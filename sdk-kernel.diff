Only in .: .git
diff -ur ./.gitignore /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/.gitignore
--- ./.gitignore	2023-04-26 12:56:03.070118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/.gitignore	2023-04-23 11:51:47.406868300 +0100
@@ -91,3 +91,4 @@
 signing_key.priv
 signing_key.x509
 x509.genkey
+kk
diff -ur ./Documentation/ABI/testing/sysfs-block-zram /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/ABI/testing/sysfs-block-zram
--- ./Documentation/ABI/testing/sysfs-block-zram	2023-04-26 12:25:47.110117359 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/ABI/testing/sysfs-block-zram	2023-04-23 11:51:54.606901100 +0100
@@ -5,20 +5,21 @@
 		The disksize file is read-write and specifies the disk size
 		which represents the limit on the *uncompressed* worth of data
 		that can be stored in this disk.
+		Unit: bytes
 
 What:		/sys/block/zram<id>/initstate
 Date:		August 2010
 Contact:	Nitin Gupta <ngupta@vflare.org>
 Description:
-		The disksize file is read-only and shows the initialization
+		The initstate file is read-only and shows the initialization
 		state of the device.
 
 What:		/sys/block/zram<id>/reset
 Date:		August 2010
 Contact:	Nitin Gupta <ngupta@vflare.org>
 Description:
-		The disksize file is write-only and allows resetting the
-		device. The reset operation frees all the memory assocaited
+		The reset file is write-only and allows resetting the
+		device. The reset operation frees all the memory associated
 		with this device.
 
 What:		/sys/block/zram<id>/num_reads
@@ -42,25 +43,46 @@
 		The invalid_io file is read-only and specifies the number of
 		non-page-size-aligned I/O requests issued to this device.
 
+What:		/sys/block/zram<id>/failed_reads
+Date:		February 2014
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		The failed_reads file is read-only and specifies the number of
+		failed reads happened on this device.
+
+What:		/sys/block/zram<id>/failed_writes
+Date:		February 2014
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		The failed_writes file is read-only and specifies the number of
+		failed writes happened on this device.
+
+What:		/sys/block/zram<id>/max_comp_streams
+Date:		February 2014
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		The max_comp_streams file is read-write and specifies the
+		number of backend's zcomp_strm compression streams (number of
+		concurrent compress operations).
+
+What:		/sys/block/zram<id>/comp_algorithm
+Date:		February 2014
+Contact:	Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
+Description:
+		The comp_algorithm file is read-write and lets to show
+		available and selected compression algorithms, change
+		compression algorithm selection.
+
 What:		/sys/block/zram<id>/notify_free
 Date:		August 2010
 Contact:	Nitin Gupta <ngupta@vflare.org>
 Description:
 		The notify_free file is read-only and specifies the number of
 		swap slot free notifications received by this device. These
-		notifications are send to a swap block device when a swap slot
+		notifications are sent to a swap block device when a swap slot
 		is freed. This statistic is applicable only when this disk is
 		being used as a swap disk.
 
-What:		/sys/block/zram<id>/discard
-Date:		August 2010
-Contact:	Nitin Gupta <ngupta@vflare.org>
-Description:
-		The discard file is read-only and specifies the number of
-		discard requests received by this device. These requests
-		provide information to block device regarding blocks which are
-		no longer used by filesystem.
-
 What:		/sys/block/zram<id>/zero_pages
 Date:		August 2010
 Contact:	Nitin Gupta <ngupta@vflare.org>
Only in ./Documentation/DocBook/media/dvb: dvbstb.pdf
Only in ./Documentation/DocBook/media/v4l: crop.pdf
Only in ./Documentation/DocBook/media/v4l: fieldseq_bt.pdf
Only in ./Documentation/DocBook/media/v4l: fieldseq_tb.pdf
Only in ./Documentation/DocBook/media/v4l: pipeline.pdf
Only in ./Documentation/DocBook/media/v4l: vbi_525.pdf
Only in ./Documentation/DocBook/media/v4l: vbi_625.pdf
Only in ./Documentation/DocBook/media/v4l: vbi_hsync.pdf
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation: android.txt
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/arm64: tagged-pointers.txt
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/blockdev: zram.txt
diff -ur ./Documentation/cgroups/cgroups.txt /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/cgroups/cgroups.txt
--- ./Documentation/cgroups/cgroups.txt	2023-04-26 12:25:47.530117362 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/cgroups/cgroups.txt	2023-04-23 11:53:11.497335300 +0100
@@ -598,6 +598,15 @@
 be called for a newly-created cgroup if an error occurs after this
 subsystem's create() method has been called for the new cgroup).
 
+int allow_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)
+(cgroup_mutex held by caller)
+
+Called prior to moving a task into a cgroup; if the subsystem
+returns an error, this will abort the attach operation.  Used
+to extend the permission checks - if all subsystems in a cgroup
+return 0, the attach will be allowed to proceed, even if the
+default permission check (root or same user) fails.
+
 int can_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)
 (cgroup_mutex held by caller)
 
diff -ur ./Documentation/cpu-freq/governors.txt /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/cpu-freq/governors.txt
--- ./Documentation/cpu-freq/governors.txt	2023-04-26 12:25:47.560117362 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/cpu-freq/governors.txt	2023-04-23 11:53:16.841118100 +0100
@@ -28,6 +28,7 @@
 2.3  Userspace
 2.4  Ondemand
 2.5  Conservative
+2.6  Interactive
 
 3.   The Governor Interface in the CPUfreq Core
 
@@ -218,6 +219,90 @@
 speed. Load for frequency increase is still evaluated every
 sampling rate.
 
+2.6 Interactive
+---------------
+
+The CPUfreq governor "interactive" is designed for latency-sensitive,
+interactive workloads. This governor sets the CPU speed depending on
+usage, similar to "ondemand" and "conservative" governors, but with a
+different set of configurable behaviors.
+
+The tuneable values for this governor are:
+
+target_loads: CPU load values used to adjust speed to influence the
+current CPU load toward that value.  In general, the lower the target
+load, the more often the governor will raise CPU speeds to bring load
+below the target.  The format is a single target load, optionally
+followed by pairs of CPU speeds and CPU loads to target at or above
+those speeds.  Colons can be used between the speeds and associated
+target loads for readability.  For example:
+
+   85 1000000:90 1700000:99
+
+targets CPU load 85% below speed 1GHz, 90% at or above 1GHz, until
+1.7GHz and above, at which load 99% is targeted.  If speeds are
+specified these must appear in ascending order.  Higher target load
+values are typically specified for higher speeds, that is, target load
+values also usually appear in an ascending order. The default is
+target load 90% for all speeds.
+
+min_sample_time: The minimum amount of time to spend at the current
+frequency before ramping down. Default is 80000 uS.
+
+hispeed_freq: An intermediate "hi speed" at which to initially ramp
+when CPU load hits the value specified in go_hispeed_load.  If load
+stays high for the amount of time specified in above_hispeed_delay,
+then speed may be bumped higher.  Default is the maximum speed
+allowed by the policy at governor initialization time.
+
+go_hispeed_load: The CPU load at which to ramp to hispeed_freq.
+Default is 99%.
+
+above_hispeed_delay: When speed is at or above hispeed_freq, wait for
+this long before raising speed in response to continued high load.
+The format is a single delay value, optionally followed by pairs of
+CPU speeds and the delay to use at or above those speeds.  Colons can
+be used between the speeds and associated delays for readability.  For
+example:
+
+   80000 1300000:200000 1500000:40000
+
+uses delay 80000 uS until CPU speed 1.3 GHz, at which speed delay
+200000 uS is used until speed 1.5 GHz, at which speed (and above)
+delay 40000 uS is used.  If speeds are specified these must appear in
+ascending order.  Default is 20000 uS.
+
+timer_rate: Sample rate for reevaluating CPU load when the CPU is not
+idle.  A deferrable timer is used, such that the CPU will not be woken
+from idle to service this timer until something else needs to run.
+(The maximum time to allow deferring this timer when not running at
+minimum speed is configurable via timer_slack.)  Default is 20000 uS.
+
+timer_slack: Maximum additional time to defer handling the governor
+sampling timer beyond timer_rate when running at speeds above the
+minimum.  For platforms that consume additional power at idle when
+CPUs are running at speeds greater than minimum, this places an upper
+bound on how long the timer will be deferred prior to re-evaluating
+load and dropping speed.  For example, if timer_rate is 20000uS and
+timer_slack is 10000uS then timers will be deferred for up to 30msec
+when not at lowest speed.  A value of -1 means defer timers
+indefinitely at all speeds.  Default is 80000 uS.
+
+boost: If non-zero, immediately boost speed of all CPUs to at least
+hispeed_freq until zero is written to this attribute.  If zero, allow
+CPU speeds to drop below hispeed_freq according to load as usual.
+Default is zero.
+
+boostpulse: On each write, immediately boost speed of all CPUs to
+hispeed_freq for at least the period of time specified by
+boostpulse_duration, after which speeds are allowed to drop below
+hispeed_freq according to load as usual.
+
+boostpulse_duration: Length of time to hold CPU speed at hispeed_freq
+on a write to boostpulse, before allowing speed to drop according to
+load as usual.  Default is 80000 uS.
+
+
 3. The Governor Interface in the CPUfreq Core
 =============================================
 
diff -ur ./Documentation/filesystems/proc.txt /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/filesystems/proc.txt
--- ./Documentation/filesystems/proc.txt	2023-04-26 12:56:03.200118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/filesystems/proc.txt	2023-04-23 11:55:11.875049500 +0100
@@ -369,6 +369,8 @@
  [stack:1001]             = the stack of the thread with tid 1001
  [vdso]                   = the "virtual dynamic shared object",
                             the kernel system call handler
+ [anon:<name>]            = an anonymous mapping that has been
+                            named by userspace
 
  or if empty, the mapping is anonymous.
 
@@ -419,6 +421,7 @@
 MMUPageSize:           4 kB
 Locked:              374 kB
 VmFlags: rd ex mr mw me de
+Name:           name from userspace
 
 the first of these lines shows the same information as is displayed for the
 mapping in /proc/PID/maps.  The remaining lines show the size of the mapping
@@ -469,6 +472,9 @@
 be present in all further kernel releases. Things get changed, the flags may
 be vanished or the reverse -- new added.
 
+The "Name" field will only be present on a mapping that has been named by
+userspace, and will show the name passed in by userspace.
+
 This file is only present if the CONFIG_MMU kernel configuration option is
 enabled.
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation: sync.txt
diff -ur ./Documentation/sysctl/vm.txt /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/sysctl/vm.txt
--- ./Documentation/sysctl/vm.txt	2023-04-26 12:56:03.270118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/sysctl/vm.txt	2023-04-23 11:55:28.198218800 +0100
@@ -29,6 +29,7 @@
 - dirty_writeback_centisecs
 - drop_caches
 - extfrag_threshold
+- extra_free_kbytes
 - hugepages_treat_as_movable
 - hugetlb_shm_group
 - laptop_mode
@@ -198,6 +199,21 @@
 
 ==============================================================
 
+extra_free_kbytes
+
+This parameter tells the VM to keep extra free memory between the threshold
+where background reclaim (kswapd) kicks in, and the threshold where direct
+reclaim (by allocating processes) kicks in.
+
+This is useful for workloads that require low latency memory allocations
+and have a bounded burstiness in memory allocations, for example a
+realtime application that receives and transmits network traffic
+(causing in-kernel memory allocations) with a maximum total message burst
+size of 200MB may need 200MB of extra free memory to avoid direct reclaim
+related latencies.
+
+==============================================================
+
 hugepages_treat_as_movable
 
 This parameter is only useful when kernelcore= is specified at boot time to
diff -ur ./Documentation/trace/ftrace.txt /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/trace/ftrace.txt
--- ./Documentation/trace/ftrace.txt	2023-04-26 12:56:03.270118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Documentation/trace/ftrace.txt	2023-04-23 11:55:28.676251200 +0100
@@ -2013,6 +2013,35 @@
  1)   1.449 us    |             }
 
 
+You can disable the hierarchical function call formatting and instead print a
+flat list of function entry and return events.  This uses the format described
+in the Output Formatting section and respects all the trace options that
+control that formatting.  Hierarchical formatting is the default.
+
+	hierachical: echo nofuncgraph-flat > trace_options
+	flat: echo funcgraph-flat > trace_options
+
+  ie:
+
+  # tracer: function_graph
+  #
+  # entries-in-buffer/entries-written: 68355/68355   #P:2
+  #
+  #                              _-----=> irqs-off
+  #                             / _----=> need-resched
+  #                            | / _---=> hardirq/softirq
+  #                            || / _--=> preempt-depth
+  #                            ||| /     delay
+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
+  #              | |       |   ||||       |         |
+                sh-1806  [001] d...   198.843443: graph_ent: func=_raw_spin_lock
+                sh-1806  [001] d...   198.843445: graph_ent: func=__raw_spin_lock
+                sh-1806  [001] d..1   198.843447: graph_ret: func=__raw_spin_lock
+                sh-1806  [001] d..1   198.843449: graph_ret: func=_raw_spin_lock
+                sh-1806  [001] d..1   198.843451: graph_ent: func=_raw_spin_unlock_irqrestore
+                sh-1806  [001] d...   198.843453: graph_ret: func=_raw_spin_unlock_irqrestore
+
+
 You might find other useful features for this tracer in the
 following "dynamic ftrace" section such as tracing only specific
 functions or tasks.
diff -ur ./Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Makefile
--- ./Makefile	2023-04-26 12:56:03.340118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/Makefile	2023-04-23 11:55:33.556823200 +0100
@@ -192,7 +192,7 @@
 # "make" in the configured kernel build directory always uses that.
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-ARCH		?= $(SUBARCH)
+ARCH		?= mips
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/: android
diff -ur ./arch/arm/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Kconfig
--- ./arch/arm/Kconfig	2023-04-26 12:56:03.370118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Kconfig	2023-04-23 11:55:41.797039000 +0100
@@ -1819,6 +1819,15 @@
 	help
 	  Say Y if you want to run Linux in a Virtual Machine on Xen on ARM.
 
+config ARM_FLUSH_CONSOLE_ON_RESTART
+	bool "Force flush the console on restart"
+	help
+	  If the console is locked while the system is rebooted, the messages
+	  in the temporary logbuffer would not have propogated to all the
+	  console drivers. This option forces the console lock to be
+	  released if it failed to be acquired, which will cause all the
+	  pending messages to be flushed.
+
 endmenu
 
 menu "Boot options"
@@ -1848,6 +1857,21 @@
 	  This was deprecated in 2001 and announced to live on for 5 years.
 	  Some old boot loaders still use this way.
 
+config BUILD_ARM_APPENDED_DTB_IMAGE
+	bool "Build a concatenated zImage/dtb by default"
+	depends on OF
+	help
+	  Enabling this option will cause a concatenated zImage and list of
+	  DTBs to be built by default (instead of a standalone zImage.)
+	  The image will built in arch/arm/boot/zImage-dtb
+
+config BUILD_ARM_APPENDED_DTB_IMAGE_NAMES
+	string "Default dtb names"
+	depends on BUILD_ARM_APPENDED_DTB_IMAGE
+	help
+	  Space separated list of names of dtbs to append when
+	  building a concatenated zImage-dtb.
+
 # Compressed boot loader in ROM.  Yes, we really want to ask about
 # TEXT and BSS so we preserve their values in the config files.
 config ZBOOT_ROM_TEXT
diff -ur ./arch/arm/Kconfig.debug /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Kconfig.debug
--- ./arch/arm/Kconfig.debug	2023-04-26 12:56:03.380118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Kconfig.debug	2023-04-23 11:55:41.795992700 +0100
@@ -63,6 +63,27 @@
 	      8 - SIGSEGV faults
 	     16 - SIGBUS faults
 
+config DEBUG_RODATA
+	bool "Write protect kernel text section"
+	default n
+	depends on DEBUG_KERNEL && MMU
+	---help---
+	  Mark the kernel text section as write-protected in the pagetables,
+	  in order to catch accidental (and incorrect) writes to such const
+	  data. This will cause the size of the kernel, plus up to 4MB, to
+	  be mapped as pages instead of sections, which will increase TLB
+	  pressure.
+	  If in doubt, say "N".
+
+config DEBUG_RODATA_TEST
+	bool "Testcase for the DEBUG_RODATA feature"
+	depends on DEBUG_RODATA
+	default n
+	---help---
+	  This option enables a testcase for the DEBUG_RODATA
+	  feature.
+	  If in doubt, say "N"
+
 # These options are only for real kernel hackers who want to get their hands dirty.
 config DEBUG_LL
 	bool "Kernel low-level debugging functions (read help!)"
@@ -669,6 +690,14 @@
 	  kernel low-level debugging functions. Add earlyprintk to your
 	  kernel parameters to enable this console.
 
+config EARLY_PRINTK_DIRECT
+	bool "Early printk direct"
+	depends on DEBUG_LL
+	help
+	  Say Y here if you want to have an early console using the
+	  kernel low-level debugging functions and EARLY_PRINTK is
+	  not early enough.
+
 config OC_ETM
 	bool "On-chip ETM and ETB"
 	depends on ARM_AMBA
diff -ur ./arch/arm/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Makefile
--- ./arch/arm/Makefile	2023-04-26 12:56:03.380118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/Makefile	2023-04-23 11:55:41.795392800 +0100
@@ -264,6 +264,8 @@
 # Default target when executing plain make
 ifeq ($(CONFIG_XIP_KERNEL),y)
 KBUILD_IMAGE := xipImage
+else ifeq ($(CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE),y)
+KBUILD_IMAGE := zImage-dtb
 else
 KBUILD_IMAGE := zImage
 endif
@@ -295,6 +297,9 @@
 dtbs: scripts
 	$(Q)$(MAKE) $(build)=$(boot)/dts MACHINE=$(MACHINE) dtbs
 
+zImage-dtb: vmlinux scripts dtbs
+	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
+
 # We use MRPROPER_FILES and CLEAN_FILES now
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
diff -ur ./arch/arm/boot/.gitignore /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/.gitignore
--- ./arch/arm/boot/.gitignore	2023-04-26 12:25:49.360117375 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/.gitignore	2023-04-23 11:55:41.873801100 +0100
@@ -4,3 +4,4 @@
 bootpImage
 uImage
 *.dtb
+zImage-dtb
\ No newline at end of file
diff -ur ./arch/arm/boot/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/Makefile
--- ./arch/arm/boot/Makefile	2023-04-26 12:25:49.360117375 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/Makefile	2023-04-23 11:55:41.873376300 +0100
@@ -14,6 +14,7 @@
 ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/Makefile.boot
 endif
+include $(srctree)/arch/arm/boot/dts/Makefile
 
 # Note: the following conditions must always be true:
 #   ZRELADDR == virt_to_phys(PAGE_OFFSET + TEXT_OFFSET)
@@ -27,6 +28,14 @@
 
 targets := Image zImage xipImage bootpImage uImage
 
+DTB_NAMES := $(subst $\",,$(CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES))
+ifneq ($(DTB_NAMES),)
+DTB_LIST := $(addsuffix .dtb,$(DTB_NAMES))
+else
+DTB_LIST := $(dtb-y)
+endif
+DTB_OBJS := $(addprefix $(obj)/dts/,$(DTB_LIST))
+
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
 $(obj)/xipImage: vmlinux FORCE
@@ -55,6 +64,10 @@
 	$(call if_changed,objcopy)
 	@$(kecho) '  Kernel: $@ is ready'
 
+$(obj)/zImage-dtb:	$(obj)/zImage $(DTB_OBJS) FORCE
+	$(call if_changed,cat)
+	@echo '  Kernel: $@ is ready'
+
 endif
 
 ifneq ($(LOADADDR),)
diff -ur ./arch/arm/boot/compressed/head.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/compressed/head.S
--- ./arch/arm/boot/compressed/head.S	2023-04-26 12:56:03.380118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/compressed/head.S	2023-04-23 11:55:42.194861500 +0100
@@ -717,6 +717,8 @@
 		bic     r6, r6, #1 << 31        @ 32-bit translation system
 		bic     r6, r6, #3 << 0         @ use only ttbr0
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
+		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+		mcr	p15, 0, r0, c7, c5, 4	@ ISB
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
 #endif
diff -ur ./arch/arm/boot/dts/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/dts/Makefile
--- ./arch/arm/boot/dts/Makefile	2023-04-26 12:56:03.380118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/dts/Makefile	2023-04-23 11:55:42.364017600 +0100
@@ -210,13 +210,20 @@
 	wm8850-w70v2.dtb
 dtb-$(CONFIG_ARCH_ZYNQ) += zynq-zc702.dtb
 
+DTB_NAMES := $(subst $\",,$(CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES))
+ifneq ($(DTB_NAMES),)
+DTB_LIST := $(addsuffix .dtb,$(DTB_NAMES))
+else
+DTB_LIST := $(dtb-y)
+endif
+
 targets += dtbs
-targets += $(dtb-y)
+targets += $(DTB_LIST)
 endif
 
 # *.dtb used to be generated in the directory above. Clean out the
 # old build results so people don't accidentally use them.
-dtbs: $(addprefix $(obj)/, $(dtb-y))
+dtbs: $(addprefix $(obj)/, $(DTB_LIST))
 	$(Q)rm -f $(obj)/../*.dtb
 
 clean-files := *.dtb
File ./arch/arm/boot/dts/include/dt-bindings is a directory while file /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/boot/dts/include/dt-bindings is a regular file
diff -ur ./arch/arm/common/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common/Kconfig
--- ./arch/arm/common/Kconfig	2023-04-26 12:56:03.430118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common/Kconfig	2023-04-23 11:55:47.715985000 +0100
@@ -17,3 +17,53 @@
 
 config SHARP_SCOOP
 	bool
+
+config FIQ_GLUE
+	bool
+	select FIQ
+
+config FIQ_DEBUGGER
+	bool "FIQ Mode Serial Debugger"
+	select FIQ
+	select FIQ_GLUE
+	default n
+	help
+	  The FIQ serial debugger can accept commands even when the
+	  kernel is unresponsive due to being stuck with interrupts
+	  disabled.
+
+
+config FIQ_DEBUGGER_NO_SLEEP
+	bool "Keep serial debugger active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables the serial debugger at boot. Passing
+	  fiq_debugger.no_sleep on the kernel commandline will
+	  override this config option.
+
+config FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON
+	bool "Don't disable wakeup IRQ when debugger is active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Don't disable the wakeup irq when enabling the uart clock.  This will
+	  cause extra interrupts, but it makes the serial debugger usable with
+	  on some MSM radio builds that ignore the uart clock request in power
+	  collapse.
+
+config FIQ_DEBUGGER_CONSOLE
+	bool "Console on FIQ Serial Debugger port"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables a console so that printk messages are displayed on
+	  the debugger serial port as the occur.
+
+config FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE
+	bool "Put the FIQ debugger into console mode by default"
+	depends on FIQ_DEBUGGER_CONSOLE
+	default n
+	help
+	  If enabled, this puts the fiq debugger into console mode by default.
+	  Otherwise, the fiq debugger will start out in debug mode.
diff -ur ./arch/arm/common/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common/Makefile
--- ./arch/arm/common/Makefile	2023-04-26 12:56:03.430118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common/Makefile	2023-04-23 11:55:47.713556300 +0100
@@ -4,6 +4,8 @@
 
 obj-y				+= firmware.o
 
+obj-$(CONFIG_FIQ_DEBUGGER)	+= fiq_debugger.o
+obj-$(CONFIG_FIQ_GLUE)		+= fiq_glue.o fiq_glue_setup.o
 obj-$(CONFIG_ICST)		+= icst.o
 obj-$(CONFIG_SA1111)		+= sa1111.o
 obj-$(CONFIG_PCI_HOST_VIA82C505) += via82c505.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common: fiq_debugger.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common: fiq_debugger_ringbuf.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common: fiq_glue.S
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/common: fiq_glue_setup.c
diff -ur ./arch/arm/include/asm/cacheflush.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/cacheflush.h
--- ./arch/arm/include/asm/cacheflush.h	2023-04-26 12:25:49.690117377 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/cacheflush.h	2023-04-23 11:55:50.198474700 +0100
@@ -16,6 +16,7 @@
 #include <asm/shmparam.h>
 #include <asm/cachetype.h>
 #include <asm/outercache.h>
+#include <asm/rodata.h>
 
 #define CACHE_COLOUR(vaddr)	((vaddr & (SHMLBA - 1)) >> PAGE_SHIFT)
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm: fiq_debugger.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm: fiq_glue.h
diff -ur ./arch/arm/include/asm/hardirq.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardirq.h
--- ./arch/arm/include/asm/hardirq.h	2023-04-26 12:25:49.710117377 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardirq.h	2023-04-23 11:55:50.834566500 +0100
@@ -5,7 +5,7 @@
 #include <linux/threads.h>
 #include <asm/irq.h>
 
-#define NR_IPI	6
+#define NR_IPI	7
 
 typedef struct {
 	unsigned int __softirq_pending;
diff -ur ./arch/arm/include/asm/hardware/cache-l2x0.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardware/cache-l2x0.h
--- ./arch/arm/include/asm/hardware/cache-l2x0.h	2023-04-26 12:25:49.710117377 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardware/cache-l2x0.h	2023-04-23 11:55:50.915322200 +0100
@@ -66,6 +66,7 @@
 #define   L2X0_STNDBY_MODE_EN		(1 << 0)
 
 /* Registers shifts and masks */
+#define L2X0_CACHE_ID_REV_MASK		(0x3f)
 #define L2X0_CACHE_ID_PART_MASK		(0xf << 6)
 #define L2X0_CACHE_ID_PART_L210		(1 << 6)
 #define L2X0_CACHE_ID_PART_L310		(3 << 6)
@@ -106,6 +107,8 @@
 
 #define L2X0_WAY_SIZE_SHIFT		3
 
+#define REV_PL310_R2P0				4
+
 #ifndef __ASSEMBLY__
 extern void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask);
 #if defined(CONFIG_CACHE_L2X0) && defined(CONFIG_OF)
diff -ur ./arch/arm/include/asm/hardware/coresight.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardware/coresight.h
--- ./arch/arm/include/asm/hardware/coresight.h	2023-04-26 12:25:49.710117377 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/hardware/coresight.h	2023-04-23 11:55:50.914275100 +0100
@@ -17,15 +17,23 @@
 #define TRACER_ACCESSED_BIT	0
 #define TRACER_RUNNING_BIT	1
 #define TRACER_CYCLE_ACC_BIT	2
+#define TRACER_TRACE_DATA_BIT	3
+#define TRACER_TIMESTAMP_BIT	4
+#define TRACER_BRANCHOUTPUT_BIT	5
+#define TRACER_RETURN_STACK_BIT	6
 #define TRACER_ACCESSED		BIT(TRACER_ACCESSED_BIT)
 #define TRACER_RUNNING		BIT(TRACER_RUNNING_BIT)
 #define TRACER_CYCLE_ACC	BIT(TRACER_CYCLE_ACC_BIT)
+#define TRACER_TRACE_DATA	BIT(TRACER_TRACE_DATA_BIT)
+#define TRACER_TIMESTAMP	BIT(TRACER_TIMESTAMP_BIT)
+#define TRACER_BRANCHOUTPUT	BIT(TRACER_BRANCHOUTPUT_BIT)
+#define TRACER_RETURN_STACK	BIT(TRACER_RETURN_STACK_BIT)
 
 #define TRACER_TIMEOUT 10000
 
-#define etm_writel(t, v, x) \
-	(__raw_writel((v), (t)->etm_regs + (x)))
-#define etm_readl(t, x) (__raw_readl((t)->etm_regs + (x)))
+#define etm_writel(t, id, v, x) \
+	(__raw_writel((v), (t)->etm_regs[(id)] + (x)))
+#define etm_readl(t, id, x) (__raw_readl((t)->etm_regs[(id)] + (x)))
 
 /* CoreSight Management Registers */
 #define CSMR_LOCKACCESS 0xfb0
@@ -43,7 +51,7 @@
 #define ETMCTRL_POWERDOWN	1
 #define ETMCTRL_PROGRAM		(1 << 10)
 #define ETMCTRL_PORTSEL		(1 << 11)
-#define ETMCTRL_DO_CONTEXTID	(3 << 14)
+#define ETMCTRL_CONTEXTIDSIZE(x) (((x) & 3) << 14)
 #define ETMCTRL_PORTMASK1	(7 << 4)
 #define ETMCTRL_PORTMASK2	(1 << 21)
 #define ETMCTRL_PORTMASK	(ETMCTRL_PORTMASK1 | ETMCTRL_PORTMASK2)
@@ -55,9 +63,12 @@
 #define ETMCTRL_DATA_DO_BOTH	(ETMCTRL_DATA_DO_DATA | ETMCTRL_DATA_DO_ADDR)
 #define ETMCTRL_BRANCH_OUTPUT	(1 << 8)
 #define ETMCTRL_CYCLEACCURATE	(1 << 12)
+#define ETMCTRL_TIMESTAMP_EN	(1 << 28)
+#define ETMCTRL_RETURN_STACK_EN	(1 << 29)
 
 /* ETM configuration code register */
 #define ETMR_CONFCODE		(0x04)
+#define ETMCCR_ETMIDR_PRESENT	BIT(31)
 
 /* ETM trace start/stop resource control register */
 #define ETMR_TRACESSCTRL	(0x18)
@@ -113,10 +124,25 @@
 #define ETMR_TRACEENCTRL	0x24
 #define ETMTE_INCLEXCL		BIT(24)
 #define ETMR_TRACEENEVT		0x20
-#define ETMCTRL_OPTS		(ETMCTRL_DO_CPRT | \
-				ETMCTRL_DATA_DO_ADDR | \
-				ETMCTRL_BRANCH_OUTPUT | \
-				ETMCTRL_DO_CONTEXTID)
+
+#define ETMR_VIEWDATAEVT	0x30
+#define ETMR_VIEWDATACTRL1	0x34
+#define ETMR_VIEWDATACTRL2	0x38
+#define ETMR_VIEWDATACTRL3	0x3c
+#define ETMVDC3_EXCLONLY	BIT(16)
+
+#define ETMCTRL_OPTS		(ETMCTRL_DO_CPRT)
+
+#define ETMR_ID			0x1e4
+#define ETMIDR_VERSION(x)	(((x) >> 4) & 0xff)
+#define ETMIDR_VERSION_3_1	0x21
+#define ETMIDR_VERSION_PFT_1_0	0x30
+
+#define ETMR_CCE		0x1e8
+#define ETMCCER_RETURN_STACK_IMPLEMENTED	BIT(23)
+#define ETMCCER_TIMESTAMPING_IMPLEMENTED	BIT(22)
+
+#define ETMR_TRACEIDR		0x200
 
 /* ETM management registers, "ETM Architecture", 3.5.24 */
 #define ETMMR_OSLAR	0x300
@@ -140,14 +166,16 @@
 #define ETBFF_TRIGIN		BIT(8)
 #define ETBFF_TRIGEVT		BIT(9)
 #define ETBFF_TRIGFL		BIT(10)
+#define ETBFF_STOPFL		BIT(12)
 
 #define etb_writel(t, v, x) \
 	(__raw_writel((v), (t)->etb_regs + (x)))
 #define etb_readl(t, x) (__raw_readl((t)->etb_regs + (x)))
 
-#define etm_lock(t) do { etm_writel((t), 0, CSMR_LOCKACCESS); } while (0)
-#define etm_unlock(t) \
-	do { etm_writel((t), CS_LAR_KEY, CSMR_LOCKACCESS); } while (0)
+#define etm_lock(t, id) \
+	do { etm_writel((t), (id), 0, CSMR_LOCKACCESS); } while (0)
+#define etm_unlock(t, id) \
+	do { etm_writel((t), (id), CS_LAR_KEY, CSMR_LOCKACCESS); } while (0)
 
 #define etb_lock(t) do { etb_writel((t), 0, CSMR_LOCKACCESS); } while (0)
 #define etb_unlock(t) \
diff -ur ./arch/arm/include/asm/irq.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/irq.h
--- ./arch/arm/include/asm/irq.h	2023-04-26 12:25:49.720117377 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/irq.h	2023-04-23 11:55:51.398136100 +0100
@@ -35,6 +35,9 @@
 extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
 #endif
 
+void arch_trigger_all_cpu_backtrace(void);
+#define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
+
 #endif
 
 #endif
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/mach: mmc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm: rodata.h
diff -ur ./arch/arm/include/asm/smp.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/smp.h
--- ./arch/arm/include/asm/smp.h	2023-04-26 12:56:03.470118965 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/include/asm/smp.h	2023-04-23 11:55:52.600682900 +0100
@@ -81,6 +81,8 @@
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 extern void arch_send_wakeup_ipi_mask(const struct cpumask *mask);
 
+extern void smp_send_all_cpu_backtrace(void);
+
 struct smp_operations {
 #ifdef CONFIG_SMP
 	/*
diff -ur ./arch/arm/kernel/etm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/etm.c
--- ./arch/arm/kernel/etm.c	2023-04-26 12:25:49.800117378 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/etm.c	2023-04-23 11:55:54.522358000 +0100
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 #include <linux/sysrq.h>
 #include <linux/device.h>
 #include <linux/clk.h>
@@ -37,26 +38,37 @@
 struct tracectx {
 	unsigned int	etb_bufsz;
 	void __iomem	*etb_regs;
-	void __iomem	*etm_regs;
+	void __iomem	**etm_regs;
+	int		etm_regs_count;
 	unsigned long	flags;
 	int		ncmppairs;
 	int		etm_portsz;
+	int		etm_contextid_size;
+	u32		etb_fc;
+	unsigned long	range_start;
+	unsigned long	range_end;
+	unsigned long	data_range_start;
+	unsigned long	data_range_end;
+	bool		dump_initial_etb;
 	struct device	*dev;
 	struct clk	*emu_clk;
 	struct mutex	mutex;
 };
 
-static struct tracectx tracer;
+static struct tracectx tracer = {
+	.range_start = (unsigned long)_stext,
+	.range_end = (unsigned long)_etext,
+};
 
 static inline bool trace_isrunning(struct tracectx *t)
 {
 	return !!(t->flags & TRACER_RUNNING);
 }
 
-static int etm_setup_address_range(struct tracectx *t, int n,
+static int etm_setup_address_range(struct tracectx *t, int id, int n,
 		unsigned long start, unsigned long end, int exclude, int data)
 {
-	u32 flags = ETMAAT_ARM | ETMAAT_IGNCONTEXTID | ETMAAT_NSONLY | \
+	u32 flags = ETMAAT_ARM | ETMAAT_IGNCONTEXTID | ETMAAT_IGNSECURITY |
 		    ETMAAT_NOVALCMP;
 
 	if (n < 1 || n > t->ncmppairs)
@@ -72,95 +84,185 @@
 		flags |= ETMAAT_IEXEC;
 
 	/* first comparator for the range */
-	etm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2));
-	etm_writel(t, start, ETMR_COMP_VAL(n * 2));
+	etm_writel(t, id, flags, ETMR_COMP_ACC_TYPE(n * 2));
+	etm_writel(t, id, start, ETMR_COMP_VAL(n * 2));
 
 	/* second comparator is right next to it */
-	etm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2 + 1));
-	etm_writel(t, end, ETMR_COMP_VAL(n * 2 + 1));
+	etm_writel(t, id, flags, ETMR_COMP_ACC_TYPE(n * 2 + 1));
+	etm_writel(t, id, end, ETMR_COMP_VAL(n * 2 + 1));
 
-	flags = exclude ? ETMTE_INCLEXCL : 0;
-	etm_writel(t, flags | (1 << n), ETMR_TRACEENCTRL);
+	if (data) {
+		flags = exclude ? ETMVDC3_EXCLONLY : 0;
+		if (exclude)
+			n += 8;
+		etm_writel(t, id, flags | BIT(n), ETMR_VIEWDATACTRL3);
+	} else {
+		flags = exclude ? ETMTE_INCLEXCL : 0;
+		etm_writel(t, id, flags | (1 << n), ETMR_TRACEENCTRL);
+	}
 
 	return 0;
 }
 
-static int trace_start(struct tracectx *t)
+static int trace_start_etm(struct tracectx *t, int id)
 {
 	u32 v;
 	unsigned long timeout = TRACER_TIMEOUT;
 
-	etb_unlock(t);
-
-	etb_writel(t, 0, ETBR_FORMATTERCTRL);
-	etb_writel(t, 1, ETBR_CTRL);
-
-	etb_lock(t);
-
-	/* configure etm */
 	v = ETMCTRL_OPTS | ETMCTRL_PROGRAM | ETMCTRL_PORTSIZE(t->etm_portsz);
+	v |= ETMCTRL_CONTEXTIDSIZE(t->etm_contextid_size);
 
 	if (t->flags & TRACER_CYCLE_ACC)
 		v |= ETMCTRL_CYCLEACCURATE;
 
-	etm_unlock(t);
+	if (t->flags & TRACER_BRANCHOUTPUT)
+		v |= ETMCTRL_BRANCH_OUTPUT;
 
-	etm_writel(t, v, ETMR_CTRL);
+	if (t->flags & TRACER_TRACE_DATA)
+		v |= ETMCTRL_DATA_DO_ADDR;
 
-	while (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
+	if (t->flags & TRACER_TIMESTAMP)
+		v |= ETMCTRL_TIMESTAMP_EN;
+
+	if (t->flags & TRACER_RETURN_STACK)
+		v |= ETMCTRL_RETURN_STACK_EN;
+
+	etm_unlock(t, id);
+
+	etm_writel(t, id, v, ETMR_CTRL);
+
+	while (!(etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
 		;
 	if (!timeout) {
 		dev_dbg(t->dev, "Waiting for progbit to assert timed out\n");
-		etm_lock(t);
+		etm_lock(t, id);
 		return -EFAULT;
 	}
 
-	etm_setup_address_range(t, 1, (unsigned long)_stext,
-			(unsigned long)_etext, 0, 0);
-	etm_writel(t, 0, ETMR_TRACEENCTRL2);
-	etm_writel(t, 0, ETMR_TRACESSCTRL);
-	etm_writel(t, 0x6f, ETMR_TRACEENEVT);
+	if (t->range_start || t->range_end)
+		etm_setup_address_range(t, id, 1,
+					t->range_start, t->range_end, 0, 0);
+	else
+		etm_writel(t, id, ETMTE_INCLEXCL, ETMR_TRACEENCTRL);
+
+	etm_writel(t, id, 0, ETMR_TRACEENCTRL2);
+	etm_writel(t, id, 0, ETMR_TRACESSCTRL);
+	etm_writel(t, id, 0x6f, ETMR_TRACEENEVT);
+
+	etm_writel(t, id, 0, ETMR_VIEWDATACTRL1);
+	etm_writel(t, id, 0, ETMR_VIEWDATACTRL2);
+
+	if (t->data_range_start || t->data_range_end)
+		etm_setup_address_range(t, id, 2, t->data_range_start,
+					t->data_range_end, 0, 1);
+	else
+		etm_writel(t, id, ETMVDC3_EXCLONLY, ETMR_VIEWDATACTRL3);
+
+	etm_writel(t, id, 0x6f, ETMR_VIEWDATAEVT);
 
 	v &= ~ETMCTRL_PROGRAM;
 	v |= ETMCTRL_PORTSEL;
 
-	etm_writel(t, v, ETMR_CTRL);
+	etm_writel(t, id, v, ETMR_CTRL);
 
 	timeout = TRACER_TIMEOUT;
-	while (etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM && --timeout)
+	while (etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM && --timeout)
 		;
 	if (!timeout) {
 		dev_dbg(t->dev, "Waiting for progbit to deassert timed out\n");
-		etm_lock(t);
+		etm_lock(t, id);
 		return -EFAULT;
 	}
 
-	etm_lock(t);
+	etm_lock(t, id);
+	return 0;
+}
+
+static int trace_start(struct tracectx *t)
+{
+	int ret;
+	int id;
+	u32 etb_fc = t->etb_fc;
+
+	etb_unlock(t);
+
+	t->dump_initial_etb = false;
+	etb_writel(t, 0, ETBR_WRITEADDR);
+	etb_writel(t, etb_fc, ETBR_FORMATTERCTRL);
+	etb_writel(t, 1, ETBR_CTRL);
+
+	etb_lock(t);
+
+	/* configure etm(s) */
+	for (id = 0; id < t->etm_regs_count; id++) {
+		ret = trace_start_etm(t, id);
+		if (ret)
+			return ret;
+	}
 
 	t->flags |= TRACER_RUNNING;
 
 	return 0;
 }
 
-static int trace_stop(struct tracectx *t)
+static int trace_stop_etm(struct tracectx *t, int id)
 {
 	unsigned long timeout = TRACER_TIMEOUT;
 
-	etm_unlock(t);
+	etm_unlock(t, id);
 
-	etm_writel(t, 0x440, ETMR_CTRL);
-	while (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
+	etm_writel(t, id, 0x440, ETMR_CTRL);
+	while (!(etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
 		;
 	if (!timeout) {
-		dev_dbg(t->dev, "Waiting for progbit to assert timed out\n");
-		etm_lock(t);
+		dev_err(t->dev,
+			"etm%d: Waiting for progbit to assert timed out\n",
+			id);
+		etm_lock(t, id);
 		return -EFAULT;
 	}
 
-	etm_lock(t);
+	etm_lock(t, id);
+	return 0;
+}
+
+static int trace_power_down_etm(struct tracectx *t, int id)
+{
+	unsigned long timeout = TRACER_TIMEOUT;
+	etm_unlock(t, id);
+	while (!(etm_readl(t, id, ETMR_STATUS) & ETMST_PROGBIT) && --timeout)
+		;
+	if (!timeout) {
+		dev_err(t->dev, "etm%d: Waiting for status progbit to assert timed out\n",
+			id);
+		etm_lock(t, id);
+		return -EFAULT;
+	}
+
+	etm_writel(t, id, 0x441, ETMR_CTRL);
+
+	etm_lock(t, id);
+	return 0;
+}
+
+static int trace_stop(struct tracectx *t)
+{
+	int id;
+	unsigned long timeout = TRACER_TIMEOUT;
+	u32 etb_fc = t->etb_fc;
+
+	for (id = 0; id < t->etm_regs_count; id++)
+		trace_stop_etm(t, id);
+
+	for (id = 0; id < t->etm_regs_count; id++)
+		trace_power_down_etm(t, id);
 
 	etb_unlock(t);
-	etb_writel(t, ETBFF_MANUAL_FLUSH, ETBR_FORMATTERCTRL);
+	if (etb_fc) {
+		etb_fc |= ETBFF_STOPFL;
+		etb_writel(t, t->etb_fc, ETBR_FORMATTERCTRL);
+	}
+	etb_writel(t, etb_fc | ETBFF_MANUAL_FLUSH, ETBR_FORMATTERCTRL);
 
 	timeout = TRACER_TIMEOUT;
 	while (etb_readl(t, ETBR_FORMATTERCTRL) &
@@ -185,24 +287,15 @@
 static int etb_getdatalen(struct tracectx *t)
 {
 	u32 v;
-	int rp, wp;
+	int wp;
 
 	v = etb_readl(t, ETBR_STATUS);
 
 	if (v & 1)
 		return t->etb_bufsz;
 
-	rp = etb_readl(t, ETBR_READADDR);
 	wp = etb_readl(t, ETBR_WRITEADDR);
-
-	if (rp > wp) {
-		etb_writel(t, 0, ETBR_READADDR);
-		etb_writel(t, 0, ETBR_WRITEADDR);
-
-		return 0;
-	}
-
-	return wp - rp;
+	return wp;
 }
 
 /* sysrq+v will always stop the running trace and leave it at that */
@@ -235,21 +328,18 @@
 		printk("%08x", cpu_to_be32(etb_readl(t, ETBR_READMEM)));
 	printk(KERN_INFO "\n--- ETB buffer end ---\n");
 
-	/* deassert the overflow bit */
-	etb_writel(t, 1, ETBR_CTRL);
-	etb_writel(t, 0, ETBR_CTRL);
-
-	etb_writel(t, 0, ETBR_TRIGGERCOUNT);
-	etb_writel(t, 0, ETBR_READADDR);
-	etb_writel(t, 0, ETBR_WRITEADDR);
-
 	etb_lock(t);
 }
 
 static void sysrq_etm_dump(int key)
 {
+	if (!mutex_trylock(&tracer.mutex)) {
+		printk(KERN_INFO "Tracing hardware busy\n");
+		return;
+	}
 	dev_dbg(tracer.dev, "Dumping ETB buffer\n");
 	etm_dump();
+	mutex_unlock(&tracer.mutex);
 }
 
 static struct sysrq_key_op sysrq_etm_op = {
@@ -276,6 +366,10 @@
 	struct tracectx *t = file->private_data;
 	u32 first = 0;
 	u32 *buf;
+	int wpos;
+	int skip;
+	long wlength;
+	loff_t pos = *ppos;
 
 	mutex_lock(&t->mutex);
 
@@ -287,31 +381,39 @@
 	etb_unlock(t);
 
 	total = etb_getdatalen(t);
+	if (total == 0 && t->dump_initial_etb)
+		total = t->etb_bufsz;
 	if (total == t->etb_bufsz)
 		first = etb_readl(t, ETBR_WRITEADDR);
 
-	etb_writel(t, first, ETBR_READADDR);
+	if (pos > total * 4) {
+		skip = 0;
+		wpos = total;
+	} else {
+		skip = (int)pos % 4;
+		wpos = (int)pos / 4;
+	}
+	total -= wpos;
+	first = (first + wpos) % t->etb_bufsz;
 
-	length = min(total * 4, (int)len);
-	buf = vmalloc(length);
+	etb_writel(t, first, ETBR_READADDR);
 
-	dev_dbg(t->dev, "ETB buffer length: %d\n", total);
+	wlength = min(total, DIV_ROUND_UP(skip + (int)len, 4));
+	length = min(total * 4 - skip, (int)len);
+	buf = vmalloc(wlength * 4);
+
+	dev_dbg(t->dev, "ETB read %ld bytes to %lld from %ld words at %d\n",
+		length, pos, wlength, first);
+	dev_dbg(t->dev, "ETB buffer length: %d\n", total + wpos);
 	dev_dbg(t->dev, "ETB status reg: %x\n", etb_readl(t, ETBR_STATUS));
-	for (i = 0; i < length / 4; i++)
+	for (i = 0; i < wlength; i++)
 		buf[i] = etb_readl(t, ETBR_READMEM);
 
-	/* the only way to deassert overflow bit in ETB status is this */
-	etb_writel(t, 1, ETBR_CTRL);
-	etb_writel(t, 0, ETBR_CTRL);
-
-	etb_writel(t, 0, ETBR_WRITEADDR);
-	etb_writel(t, 0, ETBR_READADDR);
-	etb_writel(t, 0, ETBR_TRIGGERCOUNT);
-
 	etb_lock(t);
 
-	length -= copy_to_user(data, buf, length);
+	length -= copy_to_user(data, (u8 *)buf + skip, length);
 	vfree(buf);
+	*ppos = pos + length;
 
 out:
 	mutex_unlock(&t->mutex);
@@ -348,28 +450,17 @@
 	if (ret)
 		goto out;
 
+	mutex_lock(&t->mutex);
 	t->etb_regs = ioremap_nocache(dev->res.start, resource_size(&dev->res));
 	if (!t->etb_regs) {
 		ret = -ENOMEM;
 		goto out_release;
 	}
 
+	t->dev = &dev->dev;
+	t->dump_initial_etb = true;
 	amba_set_drvdata(dev, t);
 
-	etb_miscdev.parent = &dev->dev;
-
-	ret = misc_register(&etb_miscdev);
-	if (ret)
-		goto out_unmap;
-
-	t->emu_clk = clk_get(&dev->dev, "emu_src_ck");
-	if (IS_ERR(t->emu_clk)) {
-		dev_dbg(&dev->dev, "Failed to obtain emu_src_ck.\n");
-		return -EFAULT;
-	}
-
-	clk_enable(t->emu_clk);
-
 	etb_unlock(t);
 	t->etb_bufsz = etb_readl(t, ETBR_DEPTH);
 	dev_dbg(&dev->dev, "Size: %x\n", t->etb_bufsz);
@@ -378,6 +469,20 @@
 	etb_writel(t, 0, ETBR_CTRL);
 	etb_writel(t, 0x1000, ETBR_FORMATTERCTRL);
 	etb_lock(t);
+	mutex_unlock(&t->mutex);
+
+	etb_miscdev.parent = &dev->dev;
+
+	ret = misc_register(&etb_miscdev);
+	if (ret)
+		goto out_unmap;
+
+	/* Get optional clock. Currently used to select clock source on omap3 */
+	t->emu_clk = clk_get(&dev->dev, "emu_src_ck");
+	if (IS_ERR(t->emu_clk))
+		dev_dbg(&dev->dev, "Failed to obtain emu_src_ck.\n");
+	else
+		clk_enable(t->emu_clk);
 
 	dev_dbg(&dev->dev, "ETB AMBA driver initialized.\n");
 
@@ -385,10 +490,13 @@
 	return ret;
 
 out_unmap:
+	mutex_lock(&t->mutex);
 	amba_set_drvdata(dev, NULL);
 	iounmap(t->etb_regs);
+	t->etb_regs = NULL;
 
 out_release:
+	mutex_unlock(&t->mutex);
 	amba_release_regions(dev);
 
 	return ret;
@@ -403,8 +511,10 @@
 	iounmap(t->etb_regs);
 	t->etb_regs = NULL;
 
-	clk_disable(t->emu_clk);
-	clk_put(t->emu_clk);
+	if (!IS_ERR(t->emu_clk)) {
+		clk_disable(t->emu_clk);
+		clk_put(t->emu_clk);
+	}
 
 	amba_release_regions(dev);
 
@@ -448,7 +558,10 @@
 		return -EINVAL;
 
 	mutex_lock(&tracer.mutex);
-	ret = value ? trace_start(&tracer) : trace_stop(&tracer);
+	if (!tracer.etb_regs)
+		ret = -ENODEV;
+	else
+		ret = value ? trace_start(&tracer) : trace_stop(&tracer);
 	mutex_unlock(&tracer.mutex);
 
 	return ret ? : n;
@@ -463,36 +576,50 @@
 {
 	u32 etb_wa, etb_ra, etb_st, etb_fc, etm_ctrl, etm_st;
 	int datalen;
+	int id;
+	int ret;
 
-	etb_unlock(&tracer);
-	datalen = etb_getdatalen(&tracer);
-	etb_wa = etb_readl(&tracer, ETBR_WRITEADDR);
-	etb_ra = etb_readl(&tracer, ETBR_READADDR);
-	etb_st = etb_readl(&tracer, ETBR_STATUS);
-	etb_fc = etb_readl(&tracer, ETBR_FORMATTERCTRL);
-	etb_lock(&tracer);
-
-	etm_unlock(&tracer);
-	etm_ctrl = etm_readl(&tracer, ETMR_CTRL);
-	etm_st = etm_readl(&tracer, ETMR_STATUS);
-	etm_lock(&tracer);
+	mutex_lock(&tracer.mutex);
+	if (tracer.etb_regs) {
+		etb_unlock(&tracer);
+		datalen = etb_getdatalen(&tracer);
+		etb_wa = etb_readl(&tracer, ETBR_WRITEADDR);
+		etb_ra = etb_readl(&tracer, ETBR_READADDR);
+		etb_st = etb_readl(&tracer, ETBR_STATUS);
+		etb_fc = etb_readl(&tracer, ETBR_FORMATTERCTRL);
+		etb_lock(&tracer);
+	} else {
+		etb_wa = etb_ra = etb_st = etb_fc = ~0;
+		datalen = -1;
+	}
 
-	return sprintf(buf, "Trace buffer len: %d\nComparator pairs: %d\n"
+	ret = sprintf(buf, "Trace buffer len: %d\nComparator pairs: %d\n"
 			"ETBR_WRITEADDR:\t%08x\n"
 			"ETBR_READADDR:\t%08x\n"
 			"ETBR_STATUS:\t%08x\n"
-			"ETBR_FORMATTERCTRL:\t%08x\n"
-			"ETMR_CTRL:\t%08x\n"
-			"ETMR_STATUS:\t%08x\n",
+			"ETBR_FORMATTERCTRL:\t%08x\n",
 			datalen,
 			tracer.ncmppairs,
 			etb_wa,
 			etb_ra,
 			etb_st,
-			etb_fc,
+			etb_fc
+			);
+
+	for (id = 0; id < tracer.etm_regs_count; id++) {
+		etm_unlock(&tracer, id);
+		etm_ctrl = etm_readl(&tracer, id, ETMR_CTRL);
+		etm_st = etm_readl(&tracer, id, ETMR_STATUS);
+		etm_lock(&tracer, id);
+		ret += sprintf(buf + ret, "ETMR_CTRL:\t%08x\n"
+			"ETMR_STATUS:\t%08x\n",
 			etm_ctrl,
 			etm_st
 			);
+	}
+	mutex_unlock(&tracer.mutex);
+
+	return ret;
 }
 
 static struct kobj_attribute trace_info_attr =
@@ -531,42 +658,260 @@
 static struct kobj_attribute trace_mode_attr =
 	__ATTR(trace_mode, 0644, trace_mode_show, trace_mode_store);
 
+static ssize_t trace_contextid_size_show(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 char *buf)
+{
+	/* 0: No context id tracing, 1: One byte, 2: Two bytes, 3: Four bytes */
+	return sprintf(buf, "%d\n", (1 << tracer.etm_contextid_size) >> 1);
+}
+
+static ssize_t trace_contextid_size_store(struct kobject *kobj,
+					  struct kobj_attribute *attr,
+					  const char *buf, size_t n)
+{
+	unsigned int contextid_size;
+
+	if (sscanf(buf, "%u", &contextid_size) != 1)
+		return -EINVAL;
+
+	if (contextid_size == 3 || contextid_size > 4)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	tracer.etm_contextid_size = fls(contextid_size);
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+static struct kobj_attribute trace_contextid_size_attr =
+	__ATTR(trace_contextid_size, 0644,
+		trace_contextid_size_show, trace_contextid_size_store);
+
+static ssize_t trace_branch_output_show(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	return sprintf(buf, "%d\n", !!(tracer.flags & TRACER_BRANCHOUTPUT));
+}
+
+static ssize_t trace_branch_output_store(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 const char *buf, size_t n)
+{
+	unsigned int branch_output;
+
+	if (sscanf(buf, "%u", &branch_output) != 1)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	if (branch_output) {
+		tracer.flags |= TRACER_BRANCHOUTPUT;
+		/* Branch broadcasting is incompatible with the return stack */
+		tracer.flags &= ~TRACER_RETURN_STACK;
+	} else {
+		tracer.flags &= ~TRACER_BRANCHOUTPUT;
+	}
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+static struct kobj_attribute trace_branch_output_attr =
+	__ATTR(trace_branch_output, 0644,
+		trace_branch_output_show, trace_branch_output_store);
+
+static ssize_t trace_return_stack_show(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  char *buf)
+{
+	return sprintf(buf, "%d\n", !!(tracer.flags & TRACER_RETURN_STACK));
+}
+
+static ssize_t trace_return_stack_store(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t n)
+{
+	unsigned int return_stack;
+
+	if (sscanf(buf, "%u", &return_stack) != 1)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	if (return_stack) {
+		tracer.flags |= TRACER_RETURN_STACK;
+		/* Return stack is incompatible with branch broadcasting */
+		tracer.flags &= ~TRACER_BRANCHOUTPUT;
+	} else {
+		tracer.flags &= ~TRACER_RETURN_STACK;
+	}
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+static struct kobj_attribute trace_return_stack_attr =
+	__ATTR(trace_return_stack, 0644,
+		trace_return_stack_show, trace_return_stack_store);
+
+static ssize_t trace_timestamp_show(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  char *buf)
+{
+	return sprintf(buf, "%d\n", !!(tracer.flags & TRACER_TIMESTAMP));
+}
+
+static ssize_t trace_timestamp_store(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t n)
+{
+	unsigned int timestamp;
+
+	if (sscanf(buf, "%u", &timestamp) != 1)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	if (timestamp)
+		tracer.flags |= TRACER_TIMESTAMP;
+	else
+		tracer.flags &= ~TRACER_TIMESTAMP;
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+static struct kobj_attribute trace_timestamp_attr =
+	__ATTR(trace_timestamp, 0644,
+		trace_timestamp_show, trace_timestamp_store);
+
+static ssize_t trace_range_show(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  char *buf)
+{
+	return sprintf(buf, "%08lx %08lx\n",
+			tracer.range_start, tracer.range_end);
+}
+
+static ssize_t trace_range_store(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t n)
+{
+	unsigned long range_start, range_end;
+
+	if (sscanf(buf, "%lx %lx", &range_start, &range_end) != 2)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	tracer.range_start = range_start;
+	tracer.range_end = range_end;
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+
+static struct kobj_attribute trace_range_attr =
+	__ATTR(trace_range, 0644, trace_range_show, trace_range_store);
+
+static ssize_t trace_data_range_show(struct kobject *kobj,
+				  struct kobj_attribute *attr,
+				  char *buf)
+{
+	unsigned long range_start;
+	u64 range_end;
+	mutex_lock(&tracer.mutex);
+	range_start = tracer.data_range_start;
+	range_end = tracer.data_range_end;
+	if (!range_end && (tracer.flags & TRACER_TRACE_DATA))
+		range_end = 0x100000000ULL;
+	mutex_unlock(&tracer.mutex);
+	return sprintf(buf, "%08lx %08llx\n", range_start, range_end);
+}
+
+static ssize_t trace_data_range_store(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t n)
+{
+	unsigned long range_start;
+	u64 range_end;
+
+	if (sscanf(buf, "%lx %llx", &range_start, &range_end) != 2)
+		return -EINVAL;
+
+	mutex_lock(&tracer.mutex);
+	tracer.data_range_start = range_start;
+	tracer.data_range_end = (unsigned long)range_end;
+	if (range_end)
+		tracer.flags |= TRACER_TRACE_DATA;
+	else
+		tracer.flags &= ~TRACER_TRACE_DATA;
+	mutex_unlock(&tracer.mutex);
+
+	return n;
+}
+
+
+static struct kobj_attribute trace_data_range_attr =
+	__ATTR(trace_data_range, 0644,
+		trace_data_range_show, trace_data_range_store);
+
 static int etm_probe(struct amba_device *dev, const struct amba_id *id)
 {
 	struct tracectx *t = &tracer;
 	int ret = 0;
+	void __iomem **new_regs;
+	int new_count;
+	u32 etmccr;
+	u32 etmidr;
+	u32 etmccer = 0;
+	u8 etm_version = 0;
 
-	if (t->etm_regs) {
-		dev_dbg(&dev->dev, "ETM already initialized\n");
-		ret = -EBUSY;
+	mutex_lock(&t->mutex);
+	new_count = t->etm_regs_count + 1;
+	new_regs = krealloc(t->etm_regs,
+				sizeof(t->etm_regs[0]) * new_count, GFP_KERNEL);
+
+	if (!new_regs) {
+		dev_dbg(&dev->dev, "Failed to allocate ETM register array\n");
+		ret = -ENOMEM;
 		goto out;
 	}
+	t->etm_regs = new_regs;
 
 	ret = amba_request_regions(dev, NULL);
 	if (ret)
 		goto out;
 
-	t->etm_regs = ioremap_nocache(dev->res.start, resource_size(&dev->res));
-	if (!t->etm_regs) {
+	t->etm_regs[t->etm_regs_count] =
+		ioremap_nocache(dev->res.start, resource_size(&dev->res));
+	if (!t->etm_regs[t->etm_regs_count]) {
 		ret = -ENOMEM;
 		goto out_release;
 	}
 
-	amba_set_drvdata(dev, t);
+	amba_set_drvdata(dev, t->etm_regs[t->etm_regs_count]);
 
-	mutex_init(&t->mutex);
-	t->dev = &dev->dev;
-	t->flags = TRACER_CYCLE_ACC;
+	t->flags = TRACER_CYCLE_ACC | TRACER_TRACE_DATA | TRACER_BRANCHOUTPUT;
 	t->etm_portsz = 1;
+	t->etm_contextid_size = 3;
 
-	etm_unlock(t);
-	(void)etm_readl(t, ETMMR_PDSR);
+	etm_unlock(t, t->etm_regs_count);
+	(void)etm_readl(t, t->etm_regs_count, ETMMR_PDSR);
 	/* dummy first read */
-	(void)etm_readl(&tracer, ETMMR_OSSRR);
+	(void)etm_readl(&tracer, t->etm_regs_count, ETMMR_OSSRR);
 
-	t->ncmppairs = etm_readl(t, ETMR_CONFCODE) & 0xf;
-	etm_writel(t, 0x440, ETMR_CTRL);
-	etm_lock(t);
+	etmccr = etm_readl(t, t->etm_regs_count, ETMR_CONFCODE);
+	t->ncmppairs = etmccr & 0xf;
+	if (etmccr & ETMCCR_ETMIDR_PRESENT) {
+		etmidr = etm_readl(t, t->etm_regs_count, ETMR_ID);
+		etm_version = ETMIDR_VERSION(etmidr);
+		if (etm_version >= ETMIDR_VERSION_3_1)
+			etmccer = etm_readl(t, t->etm_regs_count, ETMR_CCE);
+	}
+	etm_writel(t, t->etm_regs_count, 0x441, ETMR_CTRL);
+	etm_writel(t, t->etm_regs_count, new_count, ETMR_TRACEIDR);
+	etm_lock(t, t->etm_regs_count);
 
 	ret = sysfs_create_file(&dev->dev.kobj,
 			&trace_running_attr.attr);
@@ -582,36 +927,101 @@
 	if (ret)
 		dev_dbg(&dev->dev, "Failed to create trace_mode in sysfs\n");
 
-	dev_dbg(t->dev, "ETM AMBA driver initialized.\n");
+	ret = sysfs_create_file(&dev->dev.kobj,
+				&trace_contextid_size_attr.attr);
+	if (ret)
+		dev_dbg(&dev->dev,
+			"Failed to create trace_contextid_size in sysfs\n");
+
+	ret = sysfs_create_file(&dev->dev.kobj,
+				&trace_branch_output_attr.attr);
+	if (ret)
+		dev_dbg(&dev->dev,
+			"Failed to create trace_branch_output in sysfs\n");
+
+	if (etmccer & ETMCCER_RETURN_STACK_IMPLEMENTED) {
+		ret = sysfs_create_file(&dev->dev.kobj,
+					&trace_return_stack_attr.attr);
+		if (ret)
+			dev_dbg(&dev->dev,
+			      "Failed to create trace_return_stack in sysfs\n");
+	}
+
+	if (etmccer & ETMCCER_TIMESTAMPING_IMPLEMENTED) {
+		ret = sysfs_create_file(&dev->dev.kobj,
+					&trace_timestamp_attr.attr);
+		if (ret)
+			dev_dbg(&dev->dev,
+				"Failed to create trace_timestamp in sysfs\n");
+	}
+
+	ret = sysfs_create_file(&dev->dev.kobj, &trace_range_attr.attr);
+	if (ret)
+		dev_dbg(&dev->dev, "Failed to create trace_range in sysfs\n");
+
+	if (etm_version < ETMIDR_VERSION_PFT_1_0) {
+		ret = sysfs_create_file(&dev->dev.kobj,
+					&trace_data_range_attr.attr);
+		if (ret)
+			dev_dbg(&dev->dev,
+				"Failed to create trace_data_range in sysfs\n");
+	} else {
+		tracer.flags &= ~TRACER_TRACE_DATA;
+	}
+
+	dev_dbg(&dev->dev, "ETM AMBA driver initialized.\n");
+
+	/* Enable formatter if there are multiple trace sources */
+	if (new_count > 1)
+		t->etb_fc = ETBFF_ENFCONT | ETBFF_ENFTC;
+
+	t->etm_regs_count = new_count;
 
 out:
+	mutex_unlock(&t->mutex);
 	return ret;
 
 out_unmap:
 	amba_set_drvdata(dev, NULL);
-	iounmap(t->etm_regs);
+	iounmap(t->etm_regs[t->etm_regs_count]);
 
 out_release:
 	amba_release_regions(dev);
 
+	mutex_unlock(&t->mutex);
 	return ret;
 }
 
 static int etm_remove(struct amba_device *dev)
 {
-	struct tracectx *t = amba_get_drvdata(dev);
+	int i;
+	struct tracectx *t = &tracer;
+	void __iomem	*etm_regs = amba_get_drvdata(dev);
+
+	sysfs_remove_file(&dev->dev.kobj, &trace_running_attr.attr);
+	sysfs_remove_file(&dev->dev.kobj, &trace_info_attr.attr);
+	sysfs_remove_file(&dev->dev.kobj, &trace_mode_attr.attr);
+	sysfs_remove_file(&dev->dev.kobj, &trace_range_attr.attr);
+	sysfs_remove_file(&dev->dev.kobj, &trace_data_range_attr.attr);
 
 	amba_set_drvdata(dev, NULL);
 
-	iounmap(t->etm_regs);
-	t->etm_regs = NULL;
+	mutex_lock(&t->mutex);
+	for (i = 0; i < t->etm_regs_count; i++)
+		if (t->etm_regs[i] == etm_regs)
+			break;
+	for (; i < t->etm_regs_count - 1; i++)
+		t->etm_regs[i] = t->etm_regs[i + 1];
+	t->etm_regs_count--;
+	if (!t->etm_regs_count) {
+		kfree(t->etm_regs);
+		t->etm_regs = NULL;
+	}
+	mutex_unlock(&t->mutex);
 
+	iounmap(etm_regs);
 	amba_release_regions(dev);
 
-	sysfs_remove_file(&dev->dev.kobj, &trace_running_attr.attr);
-	sysfs_remove_file(&dev->dev.kobj, &trace_info_attr.attr);
-	sysfs_remove_file(&dev->dev.kobj, &trace_mode_attr.attr);
-
 	return 0;
 }
 
@@ -620,6 +1030,10 @@
 		.id	= 0x0003b921,
 		.mask	= 0x0007ffff,
 	},
+	{
+		.id	= 0x0003b950,
+		.mask	= 0x0007ffff,
+	},
 	{ 0, 0 },
 };
 
@@ -637,6 +1051,8 @@
 {
 	int retval;
 
+	mutex_init(&tracer.mutex);
+
 	retval = amba_driver_register(&etb_driver);
 	if (retval) {
 		printk(KERN_ERR "Failed to register etb\n");
diff -ur ./arch/arm/kernel/ftrace.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/ftrace.c
--- ./arch/arm/kernel/ftrace.c	2023-04-26 12:25:49.800117378 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/ftrace.c	2023-04-23 11:55:54.521327000 +0100
@@ -13,6 +13,7 @@
  */
 
 #include <linux/ftrace.h>
+#include <linux/module.h>
 #include <linux/uaccess.h>
 
 #include <asm/cacheflush.h>
@@ -63,6 +64,20 @@
 }
 #endif
 
+int ftrace_arch_code_modify_prepare(void)
+{
+	set_kernel_text_rw();
+	set_all_modules_text_rw();
+	return 0;
+}
+
+int ftrace_arch_code_modify_post_process(void)
+{
+	set_all_modules_text_ro();
+	set_kernel_text_ro();
+	return 0;
+}
+
 static unsigned long ftrace_call_replace(unsigned long pc, unsigned long addr)
 {
 	return arm_gen_branch_link(pc, addr);
diff -ur ./arch/arm/kernel/kgdb.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/kgdb.c
--- ./arch/arm/kernel/kgdb.c	2023-04-26 12:25:49.810117378 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/kgdb.c	2023-04-23 11:55:54.756044600 +0100
@@ -144,6 +144,8 @@
 
 static int kgdb_brk_fn(struct pt_regs *regs, unsigned int instr)
 {
+	if (user_mode(regs))
+		return -1;
 	kgdb_handle_exception(1, SIGTRAP, 0, regs);
 
 	return 0;
@@ -151,6 +153,8 @@
 
 static int kgdb_compiled_brk_fn(struct pt_regs *regs, unsigned int instr)
 {
+	if (user_mode(regs))
+		return -1;
 	compiled_break = 1;
 	kgdb_handle_exception(1, SIGTRAP, 0, regs);
 
diff -ur ./arch/arm/kernel/process.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/process.c
--- ./arch/arm/kernel/process.c	2023-04-26 12:56:03.490118964 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/process.c	2023-04-23 11:55:55.165362900 +0100
@@ -32,6 +32,7 @@
 #include <linux/hw_breakpoint.h>
 #include <linux/cpuidle.h>
 #include <linux/leds.h>
+#include <linux/console.h>
 
 #include <asm/cacheflush.h>
 #include <asm/idmap.h>
@@ -57,9 +58,46 @@
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
+#ifdef CONFIG_SMP
+void arch_trigger_all_cpu_backtrace(void)
+{
+	smp_send_all_cpu_backtrace();
+}
+#else
+void arch_trigger_all_cpu_backtrace(void)
+{
+	dump_stack();
+}
+#endif
+
 extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
 typedef void (*phys_reset_t)(unsigned long);
 
+#ifdef CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART
+void arm_machine_flush_console(void)
+{
+	printk("\n");
+	pr_emerg("Restarting %s\n", linux_banner);
+	if (console_trylock()) {
+		console_unlock();
+		return;
+	}
+
+	mdelay(50);
+
+	local_irq_disable();
+	if (!console_trylock())
+		pr_emerg("arm_restart: Console was locked! Busting\n");
+	else
+		pr_emerg("arm_restart: Console was locked!\n");
+	console_unlock();
+}
+#else
+void arm_machine_flush_console(void)
+{
+}
+#endif
+
 /*
  * A temporary stack to use for CPU reset. This is static so that we
  * don't clobber it with the identity mapping. When running with this
@@ -147,6 +185,7 @@
 
 void arch_cpu_idle_enter(void)
 {
+	idle_notifier_call_chain(IDLE_START);
 	ledtrig_cpu(CPU_LED_IDLE_START);
 #ifdef CONFIG_PL310_ERRATA_769419
 	wmb();
@@ -156,6 +195,7 @@
 void arch_cpu_idle_exit(void)
 {
 	ledtrig_cpu(CPU_LED_IDLE_END);
+	idle_notifier_call_chain(IDLE_END);
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -195,6 +235,16 @@
  */
 void machine_shutdown(void)
 {
+#ifdef CONFIG_SMP
+	/*
+	 * Disable preemption so we're guaranteed to
+	 * run to power off or reboot and prevent
+	 * the possibility of switching to another
+	 * thread that might wind up blocking on
+	 * one of the stopped CPUs.
+	 */
+	preempt_disable();
+#endif
 	disable_nonboot_cpus();
 }
 
@@ -240,6 +290,10 @@
 {
 	smp_send_stop();
 
+	/* Flush the console to make sure all the relevant messages make it
+	 * out to the console drivers */
+	arm_machine_flush_console();
+
 	arm_pm_restart(reboot_mode, cmd);
 
 	/* Give a grace period for failure to restart of 1s */
@@ -251,6 +305,77 @@
 	while (1);
 }
 
+/*
+ * dump a block of kernel memory from around the given address
+ */
+static void show_data(unsigned long addr, int nbytes, const char *name)
+{
+	int	i, j;
+	int	nlines;
+	u32	*p;
+
+	/*
+	 * don't attempt to dump non-kernel addresses or
+	 * values that are probably just small negative numbers
+	 */
+	if (addr < PAGE_OFFSET || addr > -256UL)
+		return;
+
+	printk("\n%s: %#lx:\n", name, addr);
+
+	/*
+	 * round address down to a 32 bit boundary
+	 * and always dump a multiple of 32 bytes
+	 */
+	p = (u32 *)(addr & ~(sizeof(u32) - 1));
+	nbytes += (addr & (sizeof(u32) - 1));
+	nlines = (nbytes + 31) / 32;
+
+
+	for (i = 0; i < nlines; i++) {
+		/*
+		 * just display low 16 bits of address to keep
+		 * each line of the dump < 80 characters
+		 */
+		printk("%04lx ", (unsigned long)p & 0xffff);
+		for (j = 0; j < 8; j++) {
+			u32	data;
+			if (probe_kernel_address(p, data)) {
+				printk(" ********");
+			} else {
+				printk(" %08x", data);
+			}
+			++p;
+		}
+		printk("\n");
+	}
+}
+
+static void show_extra_register_data(struct pt_regs *regs, int nbytes)
+{
+	mm_segment_t fs;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
+	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
+	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
+	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
+	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
+	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
+	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
+	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
+	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
+	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
+	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
+	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
+	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
+	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
+	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
+	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
+	set_fs(fs);
+}
+
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
@@ -307,6 +432,8 @@
 		printk("Control: %08x%s\n", ctrl, buf);
 	}
 #endif
+
+	show_extra_register_data(regs, 128);
 }
 
 void show_regs(struct pt_regs * regs)
diff -ur ./arch/arm/kernel/smp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/smp.c
--- ./arch/arm/kernel/smp.c	2023-04-26 12:56:03.500118964 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/kernel/smp.c	2023-04-23 11:55:55.315501800 +0100
@@ -66,6 +66,7 @@
 	IPI_CALL_FUNC,
 	IPI_CALL_FUNC_SINGLE,
 	IPI_CPU_STOP,
+	IPI_CPU_BACKTRACE,
 };
 
 static DECLARE_COMPLETION(cpu_running);
@@ -463,6 +464,7 @@
 	S(IPI_CALL_FUNC, "Function call interrupts"),
 	S(IPI_CALL_FUNC_SINGLE, "Single function call interrupts"),
 	S(IPI_CPU_STOP, "CPU stop interrupts"),
+	S(IPI_CPU_BACKTRACE, "CPU backtrace"),
 };
 
 void show_ipi_list(struct seq_file *p, int prec)
@@ -588,6 +590,58 @@
 		cpu_relax();
 }
 
+static cpumask_t backtrace_mask;
+static DEFINE_RAW_SPINLOCK(backtrace_lock);
+
+/* "in progress" flag of arch_trigger_all_cpu_backtrace */
+static unsigned long backtrace_flag;
+
+void smp_send_all_cpu_backtrace(void)
+{
+	unsigned int this_cpu = smp_processor_id();
+	int i;
+
+	if (test_and_set_bit(0, &backtrace_flag))
+		/*
+		 * If there is already a trigger_all_cpu_backtrace() in progress
+		 * (backtrace_flag == 1), don't output double cpu dump infos.
+		 */
+		return;
+
+	cpumask_copy(&backtrace_mask, cpu_online_mask);
+	cpu_clear(this_cpu, backtrace_mask);
+
+	pr_info("Backtrace for cpu %d (current):\n", this_cpu);
+	dump_stack();
+
+	pr_info("\nsending IPI to all other CPUs:\n");
+	smp_cross_call(&backtrace_mask, IPI_CPU_BACKTRACE);
+
+	/* Wait for up to 10 seconds for all other CPUs to do the backtrace */
+	for (i = 0; i < 10 * 1000; i++) {
+		if (cpumask_empty(&backtrace_mask))
+			break;
+		mdelay(1);
+	}
+
+	clear_bit(0, &backtrace_flag);
+	smp_mb__after_clear_bit();
+}
+
+/*
+ * ipi_cpu_backtrace - handle IPI from smp_send_all_cpu_backtrace()
+ */
+static void ipi_cpu_backtrace(unsigned int cpu, struct pt_regs *regs)
+{
+	if (cpu_isset(cpu, backtrace_mask)) {
+		raw_spin_lock(&backtrace_lock);
+		pr_warning("IPI backtrace for cpu %d\n", cpu);
+		show_regs(regs);
+		raw_spin_unlock(&backtrace_lock);
+		cpu_clear(cpu, backtrace_mask);
+	}
+}
+
 /*
  * Main handler for inter-processor interrupts
  */
@@ -638,6 +692,10 @@
 		irq_exit();
 		break;
 
+	case IPI_CPU_BACKTRACE:
+		ipi_cpu_backtrace(cpu, regs);
+		break;
+
 	default:
 		printk(KERN_CRIT "CPU%u: Unknown IPI message 0x%x\n",
 		       cpu, ipinr);
diff -ur ./arch/arm/mach-omap2/mux34xx.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mach-omap2/mux34xx.c
--- ./arch/arm/mach-omap2/mux34xx.c	2023-04-26 12:25:50.510117383 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mach-omap2/mux34xx.c	2023-04-23 11:56:20.993306800 +0100
@@ -1199,7 +1199,7 @@
 	_OMAP3_BALLENTRY(MCBSP1_DX, "w18", NULL),
 	_OMAP3_BALLENTRY(MCBSP1_FSR, "ab20", NULL),
 	_OMAP3_BALLENTRY(MCBSP1_FSX, "aa19", NULL),
-	_OMAP3_BALLENTRY(MCBSP2_CLKX, "t21", NULL),
+	_OMAP3_BALLENTRY(MCBSP2_CLKX, "t31", NULL),
 	_OMAP3_BALLENTRY(MCBSP2_DR, "v19", NULL),
 	_OMAP3_BALLENTRY(MCBSP2_DX, "r20", NULL),
 	_OMAP3_BALLENTRY(MCBSP2_FSX, "v20", NULL),
@@ -1532,7 +1532,7 @@
 	_OMAP3_BALLENTRY(MCBSP4_DR, "ad1", NULL),
 	_OMAP3_BALLENTRY(MCBSP4_DX, "ad2", NULL),
 	_OMAP3_BALLENTRY(MCBSP4_FSX, "ac1", NULL),
-	_OMAP3_BALLENTRY(MCBSP_CLKS, "t21", NULL),
+	_OMAP3_BALLENTRY(MCBSP_CLKS, "t31", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CLK, "ab3", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CS0, "ac2", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CS1, "ac3", NULL),
@@ -1960,7 +1960,7 @@
 	_OMAP3_BALLENTRY(MCBSP4_DR, "ad1", NULL),
 	_OMAP3_BALLENTRY(MCBSP4_DX, "ad2", NULL),
 	_OMAP3_BALLENTRY(MCBSP4_FSX, "ac1", NULL),
-	_OMAP3_BALLENTRY(MCBSP_CLKS, "t21", NULL),
+	_OMAP3_BALLENTRY(MCBSP_CLKS, "t31", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CLK, "ab3", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CS0, "ac2", NULL),
 	_OMAP3_BALLENTRY(MCSPI1_CS1, "ac3", NULL),
diff -ur ./arch/arm/mm/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/Makefile
--- ./arch/arm/mm/Makefile	2023-04-26 12:56:04.040118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/Makefile	2023-04-23 11:56:39.240222500 +0100
@@ -7,6 +7,7 @@
 
 obj-$(CONFIG_MMU)		+= fault-armv.o flush.o idmap.o ioremap.o \
 				   mmap.o pgd.o mmu.o
+obj-$(CONFIG_DEBUG_RODATA)	+= rodata.o
 
 ifneq ($(CONFIG_MMU),y)
 obj-y				+= nommu.o
diff -ur ./arch/arm/mm/cache-l2x0.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/cache-l2x0.c
--- ./arch/arm/mm/cache-l2x0.c	2023-04-26 12:56:04.040118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/cache-l2x0.c	2023-04-23 11:56:39.477808400 +0100
@@ -33,6 +33,9 @@
 static DEFINE_RAW_SPINLOCK(l2x0_lock);
 static u32 l2x0_way_mask;	/* Bitmask of active ways */
 static u32 l2x0_size;
+static u32 l2x0_cache_id;
+static unsigned int l2x0_sets;
+static unsigned int l2x0_ways;
 static unsigned long sync_reg_offset = L2X0_CACHE_SYNC;
 
 /* Aurora don't have the cache ID register available, so we have to
@@ -49,6 +52,13 @@
 
 static bool of_init = false;
 
+static inline bool is_pl310_rev(int rev)
+{
+	return (l2x0_cache_id &
+		(L2X0_CACHE_ID_PART_MASK | L2X0_CACHE_ID_REV_MASK)) ==
+			(L2X0_CACHE_ID_PART_L310 | rev);
+}
+
 static inline void cache_wait_way(void __iomem *reg, unsigned long mask)
 {
 	/* wait for cache operation by line or way to complete */
@@ -137,6 +147,23 @@
 	raw_spin_unlock_irqrestore(&l2x0_lock, flags);
 }
 
+#ifdef CONFIG_PL310_ERRATA_727915
+static void l2x0_for_each_set_way(void __iomem *reg)
+{
+	int set;
+	int way;
+	unsigned long flags;
+
+	for (way = 0; way < l2x0_ways; way++) {
+		raw_spin_lock_irqsave(&l2x0_lock, flags);
+		for (set = 0; set < l2x0_sets; set++)
+			writel_relaxed((way << 28) | (set << 5), reg);
+		cache_sync();
+		raw_spin_unlock_irqrestore(&l2x0_lock, flags);
+	}
+}
+#endif
+
 static void __l2x0_flush_all(void)
 {
 	debug_writel(0x03);
@@ -150,6 +177,13 @@
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PL310_ERRATA_727915
+	if (is_pl310_rev(REV_PL310_R2P0)) {
+		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_INV_LINE_IDX);
+		return;
+	}
+#endif
+
 	/* clean all ways */
 	raw_spin_lock_irqsave(&l2x0_lock, flags);
 	__l2x0_flush_all();
@@ -160,11 +194,20 @@
 {
 	unsigned long flags;
 
+#ifdef CONFIG_PL310_ERRATA_727915
+	if (is_pl310_rev(REV_PL310_R2P0)) {
+		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_LINE_IDX);
+		return;
+	}
+#endif
+
 	/* clean all ways */
 	raw_spin_lock_irqsave(&l2x0_lock, flags);
+	debug_writel(0x03);
 	writel_relaxed(l2x0_way_mask, l2x0_base + L2X0_CLEAN_WAY);
 	cache_wait_way(l2x0_base + L2X0_CLEAN_WAY, l2x0_way_mask);
 	cache_sync();
+	debug_writel(0x00);
 	raw_spin_unlock_irqrestore(&l2x0_lock, flags);
 }
 
@@ -323,65 +366,64 @@
 void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 {
 	u32 aux;
-	u32 cache_id;
 	u32 way_size = 0;
-	int ways;
 	int way_size_shift = L2X0_WAY_SIZE_SHIFT;
 	const char *type;
 
 	l2x0_base = base;
 	if (cache_id_part_number_from_dt)
-		cache_id = cache_id_part_number_from_dt;
+		l2x0_cache_id = cache_id_part_number_from_dt;
 	else
-		cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
+		l2x0_cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
 	aux = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
 
 	aux &= aux_mask;
 	aux |= aux_val;
 
 	/* Determine the number of ways */
-	switch (cache_id & L2X0_CACHE_ID_PART_MASK) {
+	switch (l2x0_cache_id & L2X0_CACHE_ID_PART_MASK) {
 	case L2X0_CACHE_ID_PART_L310:
 		if (aux & (1 << 16))
-			ways = 16;
+			l2x0_ways = 16;
 		else
-			ways = 8;
+			l2x0_ways = 8;
 		type = "L310";
 #ifdef CONFIG_PL310_ERRATA_753970
 		/* Unmapped register. */
 		sync_reg_offset = L2X0_DUMMY_REG;
 #endif
-		if ((cache_id & L2X0_CACHE_ID_RTL_MASK) <= L2X0_CACHE_ID_RTL_R3P0)
+		if ((l2x0_cache_id & L2X0_CACHE_ID_RTL_MASK) <= L2X0_CACHE_ID_RTL_R3P0)
 			outer_cache.set_debug = pl310_set_debug;
 		break;
 	case L2X0_CACHE_ID_PART_L210:
-		ways = (aux >> 13) & 0xf;
+		l2x0_ways = (aux >> 13) & 0xf;
 		type = "L210";
 		break;
 
 	case AURORA_CACHE_ID:
 		sync_reg_offset = AURORA_SYNC_REG;
-		ways = (aux >> 13) & 0xf;
-		ways = 2 << ((ways + 1) >> 2);
+		l2x0_ways = (aux >> 13) & 0xf;
+		l2x0_ways = 2 << ((l2x0_ways + 1) >> 2);
 		way_size_shift = AURORA_WAY_SIZE_SHIFT;
 		type = "Aurora";
 		break;
 	default:
 		/* Assume unknown chips have 8 ways */
-		ways = 8;
+		l2x0_ways = 8;
 		type = "L2x0 series";
 		break;
 	}
 
-	l2x0_way_mask = (1 << ways) - 1;
+	l2x0_way_mask = (1 << l2x0_ways) - 1;
 
 	/*
 	 * L2 cache Size =  Way size * Number of ways
 	 */
 	way_size = (aux & L2X0_AUX_CTRL_WAY_SIZE_MASK) >> 17;
-	way_size = 1 << (way_size + way_size_shift);
+	way_size = SZ_1K << (way_size + way_size_shift);
 
-	l2x0_size = ways * way_size * SZ_1K;
+	l2x0_size = l2x0_ways * way_size;
+	l2x0_sets = way_size / CACHE_LINE_SIZE;
 
 	/*
 	 * Check if l2x0 controller is already enabled.
@@ -390,7 +432,7 @@
 	 */
 	if (!(readl_relaxed(l2x0_base + L2X0_CTRL) & L2X0_CTRL_EN)) {
 		/* Make sure that I&D is not locked down when starting */
-		l2x0_unlock(cache_id);
+		l2x0_unlock(l2x0_cache_id);
 
 		/* l2x0 controller is disabled */
 		writel_relaxed(aux, l2x0_base + L2X0_AUX_CTRL);
@@ -419,7 +461,7 @@
 
 	printk(KERN_INFO "%s cache controller enabled\n", type);
 	printk(KERN_INFO "l2x0: %d ways, CACHE_ID 0x%08x, AUX_CTRL 0x%08x, Cache size: %d B\n",
-			ways, cache_id, aux, l2x0_size);
+			l2x0_ways, l2x0_cache_id, aux, l2x0_size);
 }
 
 #ifdef CONFIG_OF
diff -ur ./arch/arm/mm/cache-v6.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/cache-v6.S
--- ./arch/arm/mm/cache-v6.S	2023-04-26 12:25:50.940117386 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/cache-v6.S	2023-04-23 11:56:39.557357700 +0100
@@ -270,6 +270,11 @@
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_flush_range)
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	sub	r2, r1, r0
+	cmp	r2, #CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	bhi	v6_dma_flush_dcache_all
+#endif
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldrb	r2, [r0]		@ read for ownership
 	strb	r2, [r0]		@ write for ownership
@@ -292,6 +297,18 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
 
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+v6_dma_flush_dcache_all:
+	mov	r0, #0
+#ifdef HARVARD_CACHE
+	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#else
+	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	mov	pc, lr
+#endif
+
 /*
  *	dma_map_area(start, size, dir)
  *	- start	- kernel virtual start address
diff -ur ./arch/arm/mm/fault.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/fault.c
--- ./arch/arm/mm/fault.c	2023-04-26 12:56:04.040118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/fault.c	2023-04-23 11:56:39.794646200 +0100
@@ -276,10 +276,10 @@
 		local_irq_enable();
 
 	/*
-	 * If we're in an interrupt or have no user
+	 * If we're in an interrupt, or have no irqs, or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (in_atomic() || irqs_disabled() || !mm)
 		goto no_context;
 
 	/*
diff -ur ./arch/arm/mm/mmu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/mmu.c
--- ./arch/arm/mm/mmu.c	2023-04-26 12:56:04.050118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm/mmu.c	2023-04-23 11:56:40.037997700 +0100
@@ -595,11 +595,25 @@
 	return early_alloc_aligned(sz, sz);
 }
 
-static pte_t * __init early_pte_alloc(pmd_t *pmd, unsigned long addr, unsigned long prot)
+static pte_t * __init early_pte_alloc(pmd_t *pmd)
+{
+	if (pmd_none(*pmd) || pmd_bad(*pmd))
+		return early_alloc(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE);
+	return pmd_page_vaddr(*pmd);
+}
+
+static void __init early_pte_install(pmd_t *pmd, pte_t *pte, unsigned long prot)
+{
+	__pmd_populate(pmd, __pa(pte), prot);
+	BUG_ON(pmd_bad(*pmd));
+}
+
+static pte_t * __init early_pte_alloc_and_install(pmd_t *pmd,
+	unsigned long addr, unsigned long prot)
 {
 	if (pmd_none(*pmd)) {
-		pte_t *pte = early_alloc(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE);
-		__pmd_populate(pmd, __pa(pte), prot);
+		pte_t *pte = early_pte_alloc(pmd);
+		early_pte_install(pmd, pte, prot);
 	}
 	BUG_ON(pmd_bad(*pmd));
 	return pte_offset_kernel(pmd, addr);
@@ -609,11 +623,17 @@
 				  unsigned long end, unsigned long pfn,
 				  const struct mem_type *type)
 {
-	pte_t *pte = early_pte_alloc(pmd, addr, type->prot_l1);
+	pte_t *start_pte = early_pte_alloc(pmd);
+	pte_t *pte = start_pte + pte_index(addr);
+
+	/* If replacing a section mapping, the whole section must be replaced */
+	BUG_ON(!pmd_none(*pmd) && pmd_bad(*pmd) && ((addr | end) & ~PMD_MASK));
+
 	do {
 		set_pte_ext(pte, pfn_pte(pfn, __pgprot(type->prot_pte)), 0);
 		pfn++;
 	} while (pte++, addr += PAGE_SIZE, addr != end);
+	early_pte_install(pmd, start_pte, type->prot_l1);
 }
 
 static void __init __map_init_section(pmd_t *pmd, unsigned long addr,
@@ -645,7 +665,8 @@
 
 static void __init alloc_init_pmd(pud_t *pud, unsigned long addr,
 				      unsigned long end, phys_addr_t phys,
-				      const struct mem_type *type)
+				      const struct mem_type *type,
+				      bool force_pages)
 {
 	pmd_t *pmd = pmd_offset(pud, addr);
 	unsigned long next;
@@ -662,7 +683,8 @@
 		 * aligned to a section boundary.
 		 */
 		if (type->prot_sect &&
-				((addr | next | phys) & ~SECTION_MASK) == 0) {
+				((addr | next | phys) & ~SECTION_MASK) == 0 &&
+				!force_pages) {
 			__map_init_section(pmd, addr, next, phys, type);
 		} else {
 			alloc_init_pte(pmd, addr, next,
@@ -675,14 +697,15 @@
 }
 
 static void __init alloc_init_pud(pgd_t *pgd, unsigned long addr,
-	unsigned long end, unsigned long phys, const struct mem_type *type)
+	unsigned long end, unsigned long phys, const struct mem_type *type,
+	bool force_pages)
 {
 	pud_t *pud = pud_offset(pgd, addr);
 	unsigned long next;
 
 	do {
 		next = pud_addr_end(addr, end);
-		alloc_init_pmd(pud, addr, next, phys, type);
+		alloc_init_pmd(pud, addr, next, phys, type, force_pages);
 		phys += next - addr;
 	} while (pud++, addr = next, addr != end);
 }
@@ -756,7 +779,7 @@
  * offsets, and we take full advantage of sections and
  * supersections.
  */
-static void __init create_mapping(struct map_desc *md)
+static void __init create_mapping(struct map_desc *md, bool force_pages)
 {
 	unsigned long addr, length, end;
 	phys_addr_t phys;
@@ -806,7 +829,7 @@
 	do {
 		unsigned long next = pgd_addr_end(addr, end);
 
-		alloc_init_pud(pgd, addr, next, phys, type);
+		alloc_init_pud(pgd, addr, next, phys, type, force_pages);
 
 		phys += next - addr;
 		addr = next;
@@ -828,7 +851,7 @@
 	svm = early_alloc_aligned(sizeof(*svm) * nr, __alignof__(*svm));
 
 	for (md = io_desc; nr; md++, nr--) {
-		create_mapping(md);
+		create_mapping(md, false);
 
 		vm = &svm->vm;
 		vm->addr = (void *)(md->virtual & PAGE_MASK);
@@ -949,7 +972,7 @@
 	map.virtual &= PAGE_MASK;
 	map.length = PAGE_SIZE;
 	map.type = MT_DEVICE;
-	create_mapping(&map);
+	create_mapping(&map, false);
 }
 #endif
 
@@ -994,6 +1017,28 @@
 		struct membank *bank = &meminfo.bank[j];
 		*bank = meminfo.bank[i];
 
+#ifdef CONFIG_SPARSEMEM
+		if (pfn_to_section_nr(bank_pfn_start(bank)) !=
+		    pfn_to_section_nr(bank_pfn_end(bank) - 1)) {
+			phys_addr_t sz;
+			unsigned long start_pfn = bank_pfn_start(bank);
+			unsigned long end_pfn = SECTION_ALIGN_UP(start_pfn + 1);
+			sz = ((phys_addr_t)(end_pfn - start_pfn) << PAGE_SHIFT);
+
+			if (meminfo.nr_banks >= NR_BANKS) {
+				pr_crit("NR_BANKS too low, ignoring %lld bytes of memory\n",
+					(unsigned long long)(bank->size - sz));
+			} else {
+				memmove(bank + 1, bank,
+					(meminfo.nr_banks - i) * sizeof(*bank));
+				meminfo.nr_banks++;
+				bank[1].size -= sz;
+				bank[1].start = __pfn_to_phys(end_pfn);
+			}
+			bank->size = sz;
+		}
+#endif
+
 		if (bank->start > ULONG_MAX)
 			highmem = 1;
 
@@ -1191,7 +1236,7 @@
 	map.virtual = MODULES_VADDR;
 	map.length = ((unsigned long)_etext - map.virtual + ~SECTION_MASK) & SECTION_MASK;
 	map.type = MT_ROM;
-	create_mapping(&map);
+	create_mapping(&map, false);
 #endif
 
 	/*
@@ -1202,14 +1247,14 @@
 	map.virtual = FLUSH_BASE;
 	map.length = SZ_1M;
 	map.type = MT_CACHECLEAN;
-	create_mapping(&map);
+	create_mapping(&map, false);
 #endif
 #ifdef FLUSH_BASE_MINICACHE
 	map.pfn = __phys_to_pfn(FLUSH_BASE_PHYS + SZ_1M);
 	map.virtual = FLUSH_BASE_MINICACHE;
 	map.length = SZ_1M;
 	map.type = MT_MINICLEAN;
-	create_mapping(&map);
+	create_mapping(&map, false);
 #endif
 
 	/*
@@ -1225,13 +1270,13 @@
 #else
 	map.type = MT_LOW_VECTORS;
 #endif
-	create_mapping(&map);
+	create_mapping(&map, false);
 
 	if (!vectors_high()) {
 		map.virtual = 0;
 		map.length = PAGE_SIZE * 2;
 		map.type = MT_LOW_VECTORS;
-		create_mapping(&map);
+		create_mapping(&map, false);
 	}
 
 	/* Now create a kernel read-only mapping */
@@ -1239,7 +1284,7 @@
 	map.virtual = 0xffff0000 + PAGE_SIZE;
 	map.length = PAGE_SIZE;
 	map.type = MT_LOW_VECTORS;
-	create_mapping(&map);
+	create_mapping(&map, false);
 
 	/*
 	 * Ask the machine support to map in the statically mapped devices.
@@ -1264,20 +1309,23 @@
 static void __init kmap_init(void)
 {
 #ifdef CONFIG_HIGHMEM
-	pkmap_page_table = early_pte_alloc(pmd_off_k(PKMAP_BASE),
+	pkmap_page_table = early_pte_alloc_and_install(pmd_off_k(PKMAP_BASE),
 		PKMAP_BASE, _PAGE_KERNEL_TABLE);
 #endif
 }
 
+
 static void __init map_lowmem(void)
 {
 	struct memblock_region *reg;
+	phys_addr_t start;
+	phys_addr_t end;
+	struct map_desc map;
 
 	/* Map all the lowmem memory banks. */
 	for_each_memblock(memory, reg) {
-		phys_addr_t start = reg->base;
-		phys_addr_t end = start + reg->size;
-		struct map_desc map;
+		start = reg->base;
+		end = start + reg->size;
 
 		if (end > arm_lowmem_limit)
 			end = arm_lowmem_limit;
@@ -1289,8 +1337,20 @@
 		map.length = end - start;
 		map.type = MT_MEMORY;
 
-		create_mapping(&map);
+		create_mapping(&map, false);
 	}
+
+#ifdef CONFIG_DEBUG_RODATA
+	start = __pa(_stext) & PMD_MASK;
+	end = ALIGN(__pa(__end_rodata), PMD_SIZE);
+
+	map.pfn = __phys_to_pfn(start);
+	map.virtual = __phys_to_virt(start);
+	map.length = end - start;
+	map.type = MT_MEMORY;
+
+	create_mapping(&map, true);
+#endif
 }
 
 /*
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm/mm: rodata.c
diff -ur ./arch/arm64/include/asm/pgtable-hwdef.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/include/asm/pgtable-hwdef.h
--- ./arch/arm64/include/asm/pgtable-hwdef.h	2023-04-26 12:56:04.070118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/include/asm/pgtable-hwdef.h	2023-04-23 11:56:45.794079000 +0100
@@ -92,5 +92,6 @@
 #define TCR_TG1_64K		(UL(1) << 30)
 #define TCR_IPS_40BIT		(UL(2) << 32)
 #define TCR_ASID16		(UL(1) << 36)
+#define TCR_TBI0		(UL(1) << 37)
 
 #endif
diff -ur ./arch/arm64/kernel/entry.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/kernel/entry.S
--- ./arch/arm64/kernel/entry.S	2023-04-26 12:56:04.070118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/kernel/entry.S	2023-04-23 11:56:46.832675000 +0100
@@ -423,6 +423,7 @@
 	 * Data abort handling
 	 */
 	mrs	x0, far_el1
+	bic	x0, x0, #(0xff << 56)
 	disable_step x1
 	isb
 	enable_dbg
diff -ur ./arch/arm64/mm/proc.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/mm/proc.S
--- ./arch/arm64/mm/proc.S	2023-04-26 12:25:51.210117388 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/arm64/mm/proc.S	2023-04-23 11:56:48.035122600 +0100
@@ -151,7 +151,7 @@
 	 * both user and kernel.
 	 */
 	ldr	x10, =TCR_TxSZ(VA_BITS) | TCR_FLAGS | TCR_IPS_40BIT | \
-		      TCR_ASID16 | (1 << 31)
+		      TCR_ASID16 | TCR_TBI0 | (1 << 31)
 #ifdef CONFIG_ARM64_64K_PAGES
 	orr	x10, x10, TCR_TG0_64K
 	orr	x10, x10, TCR_TG1_64K
diff -ur ./arch/h8300/kernel/gpio.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/h8300/kernel/gpio.c
--- ./arch/h8300/kernel/gpio.c	2023-04-26 12:25:52.550118042 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/h8300/kernel/gpio.c	2023-04-23 11:57:28.910913100 +0100
@@ -157,6 +157,7 @@
 	return single_open(file, gpio_proc_show, PDE_DATA(inode));
 }
 
+sonil
 static const struct file_operations gpio_proc_fops = {
 	.open		= gpio_proc_open,
 	.read		= seq_read,
diff -ur ./arch/microblaze/boot/dts/system.dts /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/microblaze/boot/dts/system.dts
--- ./arch/microblaze/boot/dts/system.dts	2023-04-26 12:25:54.230119104 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/microblaze/boot/dts/system.dts	2023-04-23 11:57:58.911542400 +0100
@@ -1,367 +1 @@
-/*
- * Device Tree Generator version: 1.1
- *
- * (C) Copyright 2007-2008 Xilinx, Inc.
- * (C) Copyright 2007-2009 Michal Simek
- *
- * Michal SIMEK <monstr@monstr.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
- * CAUTION: This file is automatically generated by libgen.
- * Version: Xilinx EDK 10.1.03 EDK_K_SP3.6
- *
- * XPS project directory: Xilinx-ML505-ll_temac-sgdma-MMU-FDT-edk101
- */
-
-/dts-v1/;
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "xlnx,microblaze";
-	hard-reset-gpios = <&LEDs_8Bit 2 1>;
-	model = "testing";
-	DDR2_SDRAM: memory@90000000 {
-		device_type = "memory";
-		reg = < 0x90000000 0x10000000 >;
-	} ;
-	aliases {
-		ethernet0 = &Hard_Ethernet_MAC;
-		serial0 = &RS232_Uart_1;
-	} ;
-	chosen {
-		bootargs = "console=ttyUL0,115200 highres=on";
-		linux,stdout-path = "/plb@0/serial@84000000";
-	} ;
-	cpus {
-		#address-cells = <1>;
-		#cpus = <0x1>;
-		#size-cells = <0>;
-		microblaze_0: cpu@0 {
-			clock-frequency = <125000000>;
-			compatible = "xlnx,microblaze-7.10.d";
-			d-cache-baseaddr = <0x90000000>;
-			d-cache-highaddr = <0x9fffffff>;
-			d-cache-line-size = <0x10>;
-			d-cache-size = <0x2000>;
-			device_type = "cpu";
-			i-cache-baseaddr = <0x90000000>;
-			i-cache-highaddr = <0x9fffffff>;
-			i-cache-line-size = <0x10>;
-			i-cache-size = <0x2000>;
-			model = "microblaze,7.10.d";
-			reg = <0>;
-			timebase-frequency = <125000000>;
-			xlnx,addr-tag-bits = <0xf>;
-			xlnx,allow-dcache-wr = <0x1>;
-			xlnx,allow-icache-wr = <0x1>;
-			xlnx,area-optimized = <0x0>;
-			xlnx,cache-byte-size = <0x2000>;
-			xlnx,d-lmb = <0x1>;
-			xlnx,d-opb = <0x0>;
-			xlnx,d-plb = <0x1>;
-			xlnx,data-size = <0x20>;
-			xlnx,dcache-addr-tag = <0xf>;
-			xlnx,dcache-always-used = <0x1>;
-			xlnx,dcache-byte-size = <0x2000>;
-			xlnx,dcache-line-len = <0x4>;
-			xlnx,dcache-use-fsl = <0x1>;
-			xlnx,debug-enabled = <0x1>;
-			xlnx,div-zero-exception = <0x1>;
-			xlnx,dopb-bus-exception = <0x0>;
-			xlnx,dynamic-bus-sizing = <0x1>;
-			xlnx,edge-is-positive = <0x1>;
-			xlnx,family = "virtex5";
-			xlnx,endianness = <0x1>;
-			xlnx,fpu-exception = <0x1>;
-			xlnx,fsl-data-size = <0x20>;
-			xlnx,fsl-exception = <0x0>;
-			xlnx,fsl-links = <0x0>;
-			xlnx,i-lmb = <0x1>;
-			xlnx,i-opb = <0x0>;
-			xlnx,i-plb = <0x1>;
-			xlnx,icache-always-used = <0x1>;
-			xlnx,icache-line-len = <0x4>;
-			xlnx,icache-use-fsl = <0x1>;
-			xlnx,ill-opcode-exception = <0x1>;
-			xlnx,instance = "microblaze_0";
-			xlnx,interconnect = <0x1>;
-			xlnx,interrupt-is-edge = <0x0>;
-			xlnx,iopb-bus-exception = <0x0>;
-			xlnx,mmu-dtlb-size = <0x4>;
-			xlnx,mmu-itlb-size = <0x2>;
-			xlnx,mmu-tlb-access = <0x3>;
-			xlnx,mmu-zones = <0x10>;
-			xlnx,number-of-pc-brk = <0x1>;
-			xlnx,number-of-rd-addr-brk = <0x0>;
-			xlnx,number-of-wr-addr-brk = <0x0>;
-			xlnx,opcode-0x0-illegal = <0x1>;
-			xlnx,pvr = <0x2>;
-			xlnx,pvr-user1 = <0x0>;
-			xlnx,pvr-user2 = <0x0>;
-			xlnx,reset-msr = <0x0>;
-			xlnx,sco = <0x0>;
-			xlnx,unaligned-exceptions = <0x1>;
-			xlnx,use-barrel = <0x1>;
-			xlnx,use-dcache = <0x1>;
-			xlnx,use-div = <0x1>;
-			xlnx,use-ext-brk = <0x1>;
-			xlnx,use-ext-nm-brk = <0x1>;
-			xlnx,use-extended-fsl-instr = <0x0>;
-			xlnx,use-fpu = <0x2>;
-			xlnx,use-hw-mul = <0x2>;
-			xlnx,use-icache = <0x1>;
-			xlnx,use-interrupt = <0x1>;
-			xlnx,use-mmu = <0x3>;
-			xlnx,use-msr-instr = <0x1>;
-			xlnx,use-pcmp-instr = <0x1>;
-		} ;
-	} ;
-	mb_plb: plb@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "xlnx,plb-v46-1.03.a", "xlnx,plb-v46-1.00.a", "simple-bus";
-		ranges ;
-		FLASH: flash@a0000000 {
-			bank-width = <2>;
-			compatible = "xlnx,xps-mch-emc-2.00.a", "cfi-flash";
-			reg = < 0xa0000000 0x2000000 >;
-			xlnx,family = "virtex5";
-			xlnx,include-datawidth-matching-0 = <0x1>;
-			xlnx,include-datawidth-matching-1 = <0x0>;
-			xlnx,include-datawidth-matching-2 = <0x0>;
-			xlnx,include-datawidth-matching-3 = <0x0>;
-			xlnx,include-negedge-ioregs = <0x0>;
-			xlnx,include-plb-ipif = <0x1>;
-			xlnx,include-wrbuf = <0x1>;
-			xlnx,max-mem-width = <0x10>;
-			xlnx,mch-native-dwidth = <0x20>;
-			xlnx,mch-plb-clk-period-ps = <0x1f40>;
-			xlnx,mch-splb-awidth = <0x20>;
-			xlnx,mch0-accessbuf-depth = <0x10>;
-			xlnx,mch0-protocol = <0x0>;
-			xlnx,mch0-rddatabuf-depth = <0x10>;
-			xlnx,mch1-accessbuf-depth = <0x10>;
-			xlnx,mch1-protocol = <0x0>;
-			xlnx,mch1-rddatabuf-depth = <0x10>;
-			xlnx,mch2-accessbuf-depth = <0x10>;
-			xlnx,mch2-protocol = <0x0>;
-			xlnx,mch2-rddatabuf-depth = <0x10>;
-			xlnx,mch3-accessbuf-depth = <0x10>;
-			xlnx,mch3-protocol = <0x0>;
-			xlnx,mch3-rddatabuf-depth = <0x10>;
-			xlnx,mem0-width = <0x10>;
-			xlnx,mem1-width = <0x20>;
-			xlnx,mem2-width = <0x20>;
-			xlnx,mem3-width = <0x20>;
-			xlnx,num-banks-mem = <0x1>;
-			xlnx,num-channels = <0x0>;
-			xlnx,priority-mode = <0x0>;
-			xlnx,synch-mem-0 = <0x0>;
-			xlnx,synch-mem-1 = <0x0>;
-			xlnx,synch-mem-2 = <0x0>;
-			xlnx,synch-mem-3 = <0x0>;
-			xlnx,synch-pipedelay-0 = <0x2>;
-			xlnx,synch-pipedelay-1 = <0x2>;
-			xlnx,synch-pipedelay-2 = <0x2>;
-			xlnx,synch-pipedelay-3 = <0x2>;
-			xlnx,tavdv-ps-mem-0 = <0x1adb0>;
-			xlnx,tavdv-ps-mem-1 = <0x3a98>;
-			xlnx,tavdv-ps-mem-2 = <0x3a98>;
-			xlnx,tavdv-ps-mem-3 = <0x3a98>;
-			xlnx,tcedv-ps-mem-0 = <0x1adb0>;
-			xlnx,tcedv-ps-mem-1 = <0x3a98>;
-			xlnx,tcedv-ps-mem-2 = <0x3a98>;
-			xlnx,tcedv-ps-mem-3 = <0x3a98>;
-			xlnx,thzce-ps-mem-0 = <0x88b8>;
-			xlnx,thzce-ps-mem-1 = <0x1b58>;
-			xlnx,thzce-ps-mem-2 = <0x1b58>;
-			xlnx,thzce-ps-mem-3 = <0x1b58>;
-			xlnx,thzoe-ps-mem-0 = <0x1b58>;
-			xlnx,thzoe-ps-mem-1 = <0x1b58>;
-			xlnx,thzoe-ps-mem-2 = <0x1b58>;
-			xlnx,thzoe-ps-mem-3 = <0x1b58>;
-			xlnx,tlzwe-ps-mem-0 = <0x88b8>;
-			xlnx,tlzwe-ps-mem-1 = <0x0>;
-			xlnx,tlzwe-ps-mem-2 = <0x0>;
-			xlnx,tlzwe-ps-mem-3 = <0x0>;
-			xlnx,twc-ps-mem-0 = <0x2af8>;
-			xlnx,twc-ps-mem-1 = <0x3a98>;
-			xlnx,twc-ps-mem-2 = <0x3a98>;
-			xlnx,twc-ps-mem-3 = <0x3a98>;
-			xlnx,twp-ps-mem-0 = <0x11170>;
-			xlnx,twp-ps-mem-1 = <0x2ee0>;
-			xlnx,twp-ps-mem-2 = <0x2ee0>;
-			xlnx,twp-ps-mem-3 = <0x2ee0>;
-			xlnx,xcl0-linesize = <0x4>;
-			xlnx,xcl0-writexfer = <0x1>;
-			xlnx,xcl1-linesize = <0x4>;
-			xlnx,xcl1-writexfer = <0x1>;
-			xlnx,xcl2-linesize = <0x4>;
-			xlnx,xcl2-writexfer = <0x1>;
-			xlnx,xcl3-linesize = <0x4>;
-			xlnx,xcl3-writexfer = <0x1>;
-		} ;
-		Hard_Ethernet_MAC: xps-ll-temac@81c00000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "xlnx,compound";
-			ranges ;
-			ethernet@81c00000 {
-				compatible = "xlnx,xps-ll-temac-1.01.b", "xlnx,xps-ll-temac-1.00.a";
-				device_type = "network";
-				interrupt-parent = <&xps_intc_0>;
-				interrupts = < 5 2 >;
-				llink-connected = <&PIM3>;
-				local-mac-address = [ 00 0a 35 00 00 00 ];
-				reg = < 0x81c00000 0x40 >;
-				xlnx,bus2core-clk-ratio = <0x1>;
-				xlnx,phy-type = <0x1>;
-				xlnx,phyaddr = <0x1>;
-				xlnx,rxcsum = <0x0>;
-				xlnx,rxfifo = <0x1000>;
-				xlnx,temac-type = <0x0>;
-				xlnx,txcsum = <0x0>;
-				xlnx,txfifo = <0x1000>;
-			} ;
-		} ;
-		IIC_EEPROM: i2c@81600000 {
-			compatible = "xlnx,xps-iic-2.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 6 2 >;
-			reg = < 0x81600000 0x10000 >;
-			xlnx,clk-freq = <0x7735940>;
-			xlnx,family = "virtex5";
-			xlnx,gpo-width = <0x1>;
-			xlnx,iic-freq = <0x186a0>;
-			xlnx,scl-inertial-delay = <0x0>;
-			xlnx,sda-inertial-delay = <0x0>;
-			xlnx,ten-bit-adr = <0x0>;
-		} ;
-		LEDs_8Bit: gpio@81400000 {
-			compatible = "xlnx,xps-gpio-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 7 2 >;
-			reg = < 0x81400000 0x10000 >;
-			xlnx,all-inputs = <0x0>;
-			xlnx,all-inputs-2 = <0x0>;
-			xlnx,dout-default = <0x0>;
-			xlnx,dout-default-2 = <0x0>;
-			xlnx,family = "virtex5";
-			xlnx,gpio-width = <0x8>;
-			xlnx,interrupt-present = <0x1>;
-			xlnx,is-bidir = <0x1>;
-			xlnx,is-bidir-2 = <0x1>;
-			xlnx,is-dual = <0x0>;
-			xlnx,tri-default = <0xffffffff>;
-			xlnx,tri-default-2 = <0xffffffff>;
-			#gpio-cells = <2>;
-			gpio-controller;
-		} ;
-
-		gpio-leds {
-			compatible = "gpio-leds";
-
-			heartbeat {
-				label = "Heartbeat";
-				gpios = <&LEDs_8Bit 4 1>;
-				linux,default-trigger = "heartbeat";
-			};
-
-			yellow {
-				label = "Yellow";
-				gpios = <&LEDs_8Bit 5 1>;
-			};
-
-			red {
-				label = "Red";
-				gpios = <&LEDs_8Bit 6 1>;
-			};
-
-			green {
-				label = "Green";
-				gpios = <&LEDs_8Bit 7 1>;
-			};
-		} ;
-		RS232_Uart_1: serial@84000000 {
-			clock-frequency = <125000000>;
-			compatible = "xlnx,xps-uartlite-1.00.a";
-			current-speed = <115200>;
-			device_type = "serial";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 8 0 >;
-			port-number = <0>;
-			reg = < 0x84000000 0x10000 >;
-			xlnx,baudrate = <0x1c200>;
-			xlnx,data-bits = <0x8>;
-			xlnx,family = "virtex5";
-			xlnx,odd-parity = <0x0>;
-			xlnx,use-parity = <0x0>;
-		} ;
-		SysACE_CompactFlash: sysace@83600000 {
-			compatible = "xlnx,xps-sysace-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 4 2 >;
-			reg = < 0x83600000 0x10000 >;
-			xlnx,family = "virtex5";
-			xlnx,mem-width = <0x10>;
-		} ;
-		debug_module: debug@84400000 {
-			compatible = "xlnx,mdm-1.00.d";
-			reg = < 0x84400000 0x10000 >;
-			xlnx,family = "virtex5";
-			xlnx,interconnect = <0x1>;
-			xlnx,jtag-chain = <0x2>;
-			xlnx,mb-dbg-ports = <0x1>;
-			xlnx,uart-width = <0x8>;
-			xlnx,use-uart = <0x1>;
-			xlnx,write-fsl-ports = <0x0>;
-		} ;
-		mpmc@90000000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "xlnx,mpmc-4.02.a";
-			ranges ;
-			PIM3: sdma@84600180 {
-				compatible = "xlnx,ll-dma-1.00.a";
-				interrupt-parent = <&xps_intc_0>;
-				interrupts = < 2 2 1 2 >;
-				reg = < 0x84600180 0x80 >;
-			} ;
-		} ;
-		xps_intc_0: interrupt-controller@81800000 {
-			#interrupt-cells = <0x2>;
-			compatible = "xlnx,xps-intc-1.00.a";
-			interrupt-controller ;
-			reg = < 0x81800000 0x10000 >;
-			xlnx,kind-of-intr = <0x100>;
-			xlnx,num-intr-inputs = <0x9>;
-		} ;
-		xps_timer_1: timer@83c00000 {
-			compatible = "xlnx,xps-timer-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 3 2 >;
-			reg = < 0x83c00000 0x10000 >;
-			xlnx,count-width = <0x20>;
-			xlnx,family = "virtex5";
-			xlnx,gen0-assert = <0x1>;
-			xlnx,gen1-assert = <0x1>;
-			xlnx,one-timer-only = <0x0>;
-			xlnx,trig0-assert = <0x1>;
-			xlnx,trig1-assert = <0x1>;
-		} ;
-	} ;
-}  ;
+../../platform/generic/system.dts
\ No newline at end of file
diff -ur ./arch/mips/Kbuild.platforms /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Kbuild.platforms
--- ./arch/mips/Kbuild.platforms	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Kbuild.platforms	2023-04-23 11:58:02.670519000 +0100
@@ -11,6 +11,7 @@
 platforms += emma
 platforms += jazz
 platforms += jz4740
+platforms += xburst
 platforms += lantiq
 platforms += lasat
 platforms += loongson
diff -ur ./arch/mips/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Kconfig
--- ./arch/mips/Kconfig	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Kconfig	2023-04-23 11:58:02.754901700 +0100
@@ -115,6 +115,7 @@
 	select FW_CFE
 	select HW_HAS_PCI
 	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
 	select NO_EXCEPT_FILL
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_LITTLE_ENDIAN
@@ -231,6 +232,27 @@
 	select HAVE_CLK
 	select GENERIC_IRQ_CHIP
 
+config MACH_XBURST
+	bool "Ingenic Xburst based machines"
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select CPU_SUPPORTS_CPUFREQ
+	select MIPS_CPUFREQ
+	select MIPS_EXTERNAL_TIMER
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ARCH_REQUIRE_GPIOLIB
+	select ARCH_HAVE_CUSTOM_GPIO_H
+	select SYS_HAS_EARLY_PRINTK
+	select HAVE_PWM
+	select HAVE_CLK
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_ZBOOT
+	select JZRISC_PEP
+	select JZ_CPU_SCACHE
+
 config LANTIQ
 	bool "Lantiq based platforms"
 	select DMA_NONCOHERENT
@@ -312,6 +334,7 @@
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
 	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS32_R2_EVA
 	select SYS_HAS_CPU_MIPS64_R1
 	select SYS_HAS_CPU_MIPS64_R2
 	select SYS_HAS_CPU_NEVADA
@@ -325,6 +348,8 @@
 	select SYS_SUPPORTS_MULTITHREADING
 	select SYS_SUPPORTS_SMARTMIPS
 	select SYS_SUPPORTS_ZBOOT
+	select SYS_SUPPORTS_HIGHMEM
+	select PM_SLEEP
 	help
 	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
@@ -341,7 +366,6 @@
 	select DMA_NONCOHERENT
 	select IRQ_CPU
 	select IRQ_GIC
-	select MIPS_CPU_SCACHE
 	select MIPS_MSC
 	select SYS_HAS_CPU_MIPS32_R1
 	select SYS_HAS_CPU_MIPS32_R2
@@ -420,7 +444,6 @@
 	select CSRC_POWERTV
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
@@ -608,7 +631,6 @@
 	select BOOT_ELF32
 	select DMA_COHERENT
 	select HAVE_PATA_PLATFORM
-	select NR_CPUS_DEFAULT_2
 	select SIBYTE_SB1250
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_SB1
@@ -622,7 +644,6 @@
 	select BOOT_ELF32
 	select DMA_COHERENT
 	select HAVE_PATA_PLATFORM
-	select NR_CPUS_DEFAULT_2
 	select SIBYTE_SB1250
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_SB1
@@ -634,7 +655,6 @@
 	bool "Sibyte BCM91250E-Sentosa"
 	select BOOT_ELF32
 	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
 	select SIBYTE_SB1250
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_SB1
@@ -844,6 +864,7 @@
 source "arch/mips/bcm63xx/Kconfig"
 source "arch/mips/jazz/Kconfig"
 source "arch/mips/jz4740/Kconfig"
+source "arch/mips/xburst/Kconfig"
 source "arch/mips/lantiq/Kconfig"
 source "arch/mips/lasat/Kconfig"
 source "arch/mips/pmcs-msp71xx/Kconfig"
@@ -1495,6 +1516,47 @@
 	  Netlogic Microsystems XLP processors.
 endchoice
 
+config CPU_MIPS32_R2_EVA
+	bool "MIPS32 Release 2 with EVA support"
+	depends on SYS_HAS_CPU_MIPS32_R2_EVA
+	depends on CPU_MIPS32_R2
+	select EVA
+	help
+	  Choose this option to build a kernel for release 2 or later of the
+	  MIPS32 architecture working in EVA mode. EVA is an Extended Virtual
+	  Addressing but it actually allows extended direct physical memory
+	  addressing in kernel (more than 512MB - 2GB or 3GB). If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
+	  If unsure, select just CPU_MIPS32_R2 or even CPU_MIPS32_R1.
+
+config EVA_OLD_MALTA_MAP
+	bool "Old memory map on Malta (sys controller 1.418)"
+	depends on EVA
+	help
+	  Choose this option to build EVA kernel for old Malta memory map.
+	  All memory are located above 0x80000000 and first 256M is mirrored
+	  to first 0x80000000. IOCU doesn't work with this option.
+	  It is designed for systems with RocIt system controller 1.418/1.424
+	  and it is kept just for MTI testing purposes. (1.424 can be used
+	  with new memory map too).
+	  May or may not work with SMP - address aliasing is crazy for YAMON.
+
+config EVA_3GB
+	bool "EVA support for 3GB memory"
+	depends on EVA
+	depends on EVA_OLD_MALTA_MAP
+	help
+	  Choose this option to build a EVA kernel supporting up to 3GB of
+	  physical memory. This option shifts uncacheble IO registers from KSEG1
+	  to KSEG3 which becomes uncachable and KSEG1 (+KSEG0) can be used for
+	  additional 1GB physical memory. Actually, to minimize changes in
+	  drivers and code the same name (KSEG1) will still be used but it's
+	  address will be changed. The physical I/O address is still the same.
+	  On Malta board with old memory map it doesn't give you 3GB
+	  (because of PCI bridges loop) but it can be used as a start point
+	  for development.
+
 if CPU_LOONGSON2F
 config CPU_NOP_WORKAROUNDS
 	bool
@@ -1575,6 +1637,9 @@
 config SYS_HAS_CPU_MIPS32_R2
 	bool
 
+config SYS_HAS_CPU_MIPS32_R2_EVA
+	bool
+
 config SYS_HAS_CPU_MIPS64_R1
 	bool
 
@@ -1684,6 +1749,9 @@
 	bool
 	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_CAVIUM_OCTEON
 
+config EVA
+	bool
+
 config SYS_SUPPORTS_32BIT_KERNEL
 	bool
 config SYS_SUPPORTS_64BIT_KERNEL
@@ -1737,6 +1805,7 @@
 
 config KVM_GUEST
 	bool "KVM Guest Kernel"
+	depends on BROKEN_ON_SMP
 	help
 	  Select this option if building a guest kernel for KVM (Trap & Emulate) mode
 
@@ -1847,6 +1916,10 @@
 	bool
 	select BOARD_SCACHE
 
+config JZ_CPU_SCACHE
+	bool
+	select BOARD_SCACHE
+
 config R5000_CPU_SCACHE
 	bool
 	select BOARD_SCACHE
@@ -1882,60 +1955,49 @@
 	prompt "MIPS MT options"
 
 config MIPS_MT_DISABLED
-	bool "Disable multithreading support."
+	bool "Disable multithreading support"
 	help
-	  Use this option if your workload can't take advantage of
-	  MIPS hardware multithreading support.  On systems that don't have
-	  the option of an MT-enabled processor this option will be the only
-	  option in this menu.
+	  Use this option if your platform does not support the MT ASE
+	  which is hardware multithreading support. On systems without
+	  an MT-enabled processor, this will be the only option that is
+	  available in this menu.
 
 config MIPS_MT_SMP
 	bool "Use 1 TC on each available VPE for SMP"
 	depends on SYS_SUPPORTS_MULTITHREADING
 	select CPU_MIPSR2_IRQ_VI
 	select CPU_MIPSR2_IRQ_EI
+	select SYNC_R4K
 	select MIPS_MT
-	select NR_CPUS_DEFAULT_2
 	select SMP
-	select SYS_SUPPORTS_SCHED_SMT if SMP
-	select SYS_SUPPORTS_SMP
 	select SMP_UP
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_SCHED_SMT
 	select MIPS_PERF_SHARED_TC_COUNTERS
 	help
-	  This is a kernel model which is known a VSMP but lately has been
-	  marketesed into SMVP.
-	  Virtual SMP uses the processor's VPEs  to implement virtual
-	  processors. In currently available configuration of the 34K processor
-	  this allows for a dual processor. Both processors will share the same
-	  primary caches; each will obtain the half of the TLB for it's own
-	  exclusive use. For a layman this model can be described as similar to
-	  what Intel calls Hyperthreading.
-
-	  For further information see http://www.linux-mips.org/wiki/34K#VSMP
+	  This is a kernel model which is known as SMVP. This is supported
+	  on cores with the MT ASE and uses the available VPEs to implement
+	  virtual processors which supports SMP. This is equivalent to the
+	  Intel Hyperthreading feature. For further information go to
+	  <http://www.imgtec.com/mips/mips-multithreading.asp>.
 
 config MIPS_MT_SMTC
-	bool "SMTC: Use all TCs on all VPEs for SMP"
+	bool "Use all TCs on all VPEs for SMP (DEPRECATED)"
 	depends on CPU_MIPS32_R2
 	#depends on CPU_MIPS64_R2		# once there is hardware ...
 	depends on SYS_SUPPORTS_MULTITHREADING
 	select CPU_MIPSR2_IRQ_VI
 	select CPU_MIPSR2_IRQ_EI
 	select MIPS_MT
-	select NR_CPUS_DEFAULT_8
 	select SMP
-	select SYS_SUPPORTS_SMP
 	select SMP_UP
+	select SYS_SUPPORTS_SMP
+	select NR_CPUS_DEFAULT_8
 	help
-	  This is a kernel model which is known a SMTC or lately has been
-	  marketesed into SMVP.
-	  is presenting the available TC's of the core as processors to Linux.
-	  On currently available 34K processors this means a Linux system will
-	  see up to 5 processors. The implementation of the SMTC kernel differs
-	  significantly from VSMP and cannot efficiently coexist in the same
-	  kernel binary so the choice between VSMP and SMTC is a compile time
-	  decision.
-
-	  For further information see http://www.linux-mips.org/wiki/34K#SMTC
+	  This is a kernel model which is known as SMTC. This is
+	  supported on cores with the MT ASE and presents all TCs
+	  available on all VPEs to support SMP. For further
+	  information see <http://www.linux-mips.org/wiki/34K#SMTC>.
 
 endchoice
 
@@ -1962,9 +2024,19 @@
 	default y
 	depends on MIPS_MT_SMP || MIPS_MT_SMTC
 
+config MIPS_INCOMPATIBLE_FPU_EMULATION
+	bool "Emulation of incompatible FPU"
+	default n
+	depends on !CPU_MIPS32_R2 && !CPU_MIPS64_R1 && !CPU_MIPS64_R2
+	help
+	  Emulation of 32x32bit or 32x64bit FPU ELFs on incompatible FPU.
+	  CP0_Status.FR bit controls switch between both models but
+	  some CPU may not have this capability.
+	  If unsure, leave N here.
+
 config MIPS_VPE_LOADER
 	bool "VPE loader support."
-	depends on SYS_SUPPORTS_MULTITHREADING
+	depends on SYS_SUPPORTS_MULTITHREADING && MODULES
 	select CPU_MIPSR2_IRQ_VI
 	select CPU_MIPSR2_IRQ_EI
 	select MIPS_MT
@@ -2012,16 +2084,13 @@
 	help
 
 config MIPS_CMP
-	bool "MIPS CMP framework support"
-	depends on SYS_SUPPORTS_MIPS_CMP
+	bool "MIPS CMP support"
+	depends on SYS_SUPPORTS_MIPS_CMP && MIPS_MT_SMP
 	select SYNC_R4K
-	select SYS_SUPPORTS_SMP
-	select SYS_SUPPORTS_SCHED_SMT if SMP
 	select WEAK_ORDERING
 	default n
 	help
-	  This is a placeholder option for the GCMP work. It will need to
-	  be handled differently...
+	  Enable Coherency Manager processor (CMP) support.
 
 config SB1_PASS_1_WORKAROUNDS
 	bool
@@ -2116,6 +2185,8 @@
 config HIGHMEM
 	bool "High Memory Support"
 	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM
+	depends on ( !SMP || NR_CPUS = 1 || NR_CPUS = 2 || NR_CPUS = 3 || NR_CPUS = 4 || NR_CPUS = 5 || NR_CPUS = 6 || NR_CPUS = 7 || NR_CPUS = 8 )
+	depends on !CPU_MIPS32_R2_EVA
 
 config CPU_SUPPORTS_HIGHMEM
 	bool
@@ -2206,12 +2277,6 @@
 config SYS_SUPPORTS_SMP
 	bool
 
-config NR_CPUS_DEFAULT_1
-	bool
-
-config NR_CPUS_DEFAULT_2
-	bool
-
 config NR_CPUS_DEFAULT_4
 	bool
 
@@ -2229,10 +2294,8 @@
 
 config NR_CPUS
 	int "Maximum number of CPUs (2-64)"
-	range 1 64 if NR_CPUS_DEFAULT_1
+	range 2 64
 	depends on SMP
-	default "1" if NR_CPUS_DEFAULT_1
-	default "2" if NR_CPUS_DEFAULT_2
 	default "4" if NR_CPUS_DEFAULT_4
 	default "8" if NR_CPUS_DEFAULT_8
 	default "16" if NR_CPUS_DEFAULT_16
@@ -2507,6 +2570,7 @@
 config MIPS32_COMPAT
 	bool "Kernel support for Linux/MIPS 32-bit binary compatibility"
 	depends on 64BIT
+	default y if CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
 	help
 	  Select this option if you want Linux/MIPS 32-bit binary
 	  compatibility. Since all software available for Linux/MIPS is
@@ -2526,6 +2590,7 @@
 config MIPS32_O32
 	bool "Kernel support for o32 binaries"
 	depends on MIPS32_COMPAT
+	default y if CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
 	help
 	  Select this option if you want to run o32 binaries.  These are pure
 	  32-bit binaries as used by the 32-bit Linux/MIPS port.  Most of
@@ -2544,6 +2609,10 @@
 
 	  If unsure, say N.
 
+comment "64bit kernel, but support of 32bit applications is disabled!"
+	depends on 64BIT && !MIPS32_O32 && !MIPS32_N32
+	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
+
 config BINFMT_ELF32
 	bool
 	default y if MIPS32_O32 || MIPS32_N32
diff -ur ./arch/mips/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Makefile
--- ./arch/mips/Makefile	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/Makefile	2023-04-23 11:58:02.753945800 +0100
@@ -62,7 +62,7 @@
 vmlinux-32		= vmlinux
 vmlinux-64		= vmlinux.64
 
-cflags-y		+= -mabi=32
+cflags-y		+= -mabi=32 -mgp32 -mfp32
 endif
 
 ifdef CONFIG_64BIT
@@ -176,6 +176,8 @@
 libs-$(CONFIG_FW_CFE)		+= arch/mips/fw/cfe/
 libs-$(CONFIG_FW_SNIPROM)	+= arch/mips/fw/sni/
 libs-y				+= arch/mips/fw/lib/
+libs-$(CONFIG_NAND)		+= arch/mips/xburst/lib/nand/
+libs-$(CONFIG_NAND)		+= arch/mips/xburst/lib/ndd/
 
 #
 # Kernel compression
@@ -194,6 +196,8 @@
 ifdef CONFIG_PHYSICAL_START
 load-y					= $(CONFIG_PHYSICAL_START)
 endif
+entry-y				= 0x$(shell $(NM) vmlinux 2>/dev/null \
+					| grep "\bkernel_entry\b" | cut -f1 -d \ )
 
 cflags-y			+= -I$(srctree)/arch/mips/include/asm/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
@@ -221,10 +225,13 @@
 endif
 
 KBUILD_AFLAGS	+= $(cflags-y)
-KBUILD_CFLAGS	+= $(cflags-y)
+KBUILD_CFLAGS	+= $(cflags-y) -Wno-array-bounds
 KBUILD_CPPFLAGS += -DVMLINUX_LOAD_ADDRESS=$(load-y)
 KBUILD_CPPFLAGS += -DDATAOFFSET=$(if $(dataoffset-y),$(dataoffset-y),0)
 
+bootvars-y	= VMLINUX_LOAD_ADDRESS=$(load-y) \
+		  VMLINUX_ENTRY_ADDRESS=$(entry-y)
+
 LDFLAGS			+= -m $(ld-emul)
 
 ifdef CONFIG_MIPS
@@ -250,9 +257,26 @@
 # suspend and hibernation support
 drivers-$(CONFIG_PM)	+= arch/mips/power/
 
+# boot image targets (arch/mips/boot/)
+boot-y			:= vmlinux.bin
+boot-y			+= vmlinux.ecoff
+boot-y			+= vmlinux.srec
+ifeq ($(shell expr $(load-y) \< 0xffffffff80000000 2> /dev/null), 0)
+boot-y			+= uImage
+boot-y			+= uImage.gzip
+boot-y			+= uImage.lzma
+endif
+
+# compressed boot image targets (arch/mips/boot/compressed/)
+bootz-y			:= vmlinuz
+bootz-y			+= vmlinuz.bin
+bootz-y			+= vmlinuz.ecoff
+bootz-y			+= vmlinuz.srec
+
 ifdef CONFIG_LASAT
 rom.bin rom.sw: vmlinux
-	$(Q)$(MAKE) $(build)=arch/mips/lasat/image $@
+	$(Q)$(MAKE) $(build)=arch/mips/lasat/image \
+		$(bootvars-y) $@
 endif
 
 #
@@ -276,13 +300,20 @@
 all:	$(all-y)
 
 # boot
-vmlinux.bin vmlinux.ecoff vmlinux.srec: $(vmlinux-32) FORCE
-	$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) arch/mips/boot/$@
+$(boot-y): $(vmlinux-32) FORCE
+	$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) \
+		$(bootvars-y) arch/mips/boot/$@
+
+# zImage
+zImage: $(vmlinux-32) FORCE
+	$(Q)$(MAKE) $(build)=arch/mips/boot/zcompressed VMLINUX=$(vmlinux-32) $@
+	@cp arch/mips/boot/zcompressed/$@ arch/mips/boot/compressed/$@ 
+	@echo '  Kernel: arch/mips/boot/compressed/$@ is ready'
 
 # boot/compressed
-vmlinuz vmlinuz.bin vmlinuz.ecoff vmlinuz.srec: $(vmlinux-32) FORCE
+$(bootz-y): $(vmlinux-32) FORCE
 	$(Q)$(MAKE) $(build)=arch/mips/boot/compressed \
-	   VMLINUX_LOAD_ADDRESS=$(load-y) 32bit-bfd=$(32bit-bfd) $@
+		$(bootvars-y) 32bit-bfd=$(32bit-bfd) $@
 
 
 CLEAN_FILES += vmlinux.32 vmlinux.64
@@ -319,6 +350,8 @@
 	echo '  vmlinuz.ecoff        - ECOFF zboot image'
 	echo '  vmlinuz.bin          - Raw binary zboot image'
 	echo '  vmlinuz.srec         - SREC zboot image'
+	echo '  uImage               - U-Boot image'
+	echo '  uImage.gz            - U-Boot image (gzip)'
 	echo
 	echo '  These will be default as appropriate for a configured platform.'
 endef
diff -ur ./arch/mips/ath79/mach-ap136.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/ath79/mach-ap136.c
--- ./arch/mips/ath79/mach-ap136.c	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/ath79/mach-ap136.c	2023-04-23 11:58:04.036273900 +0100
@@ -132,7 +132,7 @@
 	ath79_register_pci();
 }
 #else
-static inline void ap136_pci_init(void) {}
+static inline void ap136_pci_init(u8 *eeprom) {}
 #endif /* CONFIG_PCI */
 
 static void __init ap136_setup(void)
diff -ur ./arch/mips/bcm47xx/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm47xx/Kconfig
--- ./arch/mips/bcm47xx/Kconfig	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm47xx/Kconfig	2023-04-23 11:58:04.273038100 +0100
@@ -2,7 +2,6 @@
 
 config BCM47XX_SSB
 	bool "SSB Support for Broadcom BCM47XX"
-	select SYS_HAS_CPU_MIPS32_R1
 	select SSB
 	select SSB_DRIVER_MIPS
 	select SSB_DRIVER_EXTIF
diff -ur ./arch/mips/bcm63xx/clk.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm63xx/clk.c
--- ./arch/mips/bcm63xx/clk.c	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm63xx/clk.c	2023-04-23 11:58:04.594147800 +0100
@@ -318,6 +318,18 @@
 
 EXPORT_SYMBOL(clk_get_rate);
 
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_round_rate);
+
 struct clk *clk_get(struct device *dev, const char *id)
 {
 	if (!strcmp(id, "enet0"))
diff -ur ./arch/mips/bcm63xx/cpu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm63xx/cpu.c
--- ./arch/mips/bcm63xx/cpu.c	2023-04-26 12:56:04.170118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/bcm63xx/cpu.c	2023-04-23 11:58:04.590470800 +0100
@@ -115,7 +115,9 @@
 
 static unsigned int detect_cpu_clock(void)
 {
-	switch (bcm63xx_get_cpu_id()) {
+	u16 cpu_id = bcm63xx_get_cpu_id();
+
+	switch (cpu_id) {
 	case BCM6328_CPU_ID:
 	{
 		unsigned int tmp, mips_pll_fcvo;
@@ -238,7 +240,7 @@
 	}
 
 	default:
-		BUG();
+		panic("Failed to detect clock for CPU with id=%04d\n", cpu_id);
 	}
 }
 
diff -ur ./arch/mips/boot/.gitignore /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/.gitignore
--- ./arch/mips/boot/.gitignore	2023-04-26 12:25:54.330119167 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/.gitignore	2023-04-23 11:58:04.991844600 +0100
@@ -4,3 +4,4 @@
 zImage
 zImage.tmp
 calc_vmlinuz_load_addr
+uImage*
diff -ur ./arch/mips/boot/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/Makefile
--- ./arch/mips/boot/Makefile	2023-04-26 12:25:54.330119167 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/Makefile	2023-04-23 11:58:04.991172000 +0100
@@ -40,3 +40,27 @@
       cmd_srec = $(OBJCOPY) -S -O srec $(strip-flags) $(VMLINUX) $@
 $(obj)/vmlinux.srec: $(VMLINUX) FORCE
 	$(call if_changed,srec)
+ifeq ($(shell uname -m), x86_64)
+UIMAGE_LOADADDR  = $(VMLINUX_LOAD_ADDRESS)
+else
+UIMAGE_LOADADDR  = $(subst ffffffff,,$(VMLINUX_LOAD_ADDRESS))
+endif
+UIMAGE_ENTRYADDR = $(VMLINUX_ENTRY_ADDRESS)
+
+ifeq ($(CONFIG_KERNEL_LZMA),y)
+  uImage_compress_type = lzma
+else
+  uImage_compress_type = gzip
+endif
+
+$(obj)/vmlinux.bin.$(uImage_compress_type): $(obj)/vmlinux.bin FORCE
+	$(call if_changed,$(uImage_compress_type))
+
+targets += uImage.$(uImage_compress_type)
+$(obj)/uImage.$(uImage_compress_type): $(obj)/vmlinux.bin.$(uImage_compress_type) FORCE
+	$(call if_changed,uimage,$(uImage_compress_type))
+
+targets += uImage
+$(obj)/uImage: $(obj)/uImage.$(uImage_compress_type) FORCE
+	@ln -sf $(notdir $<) $@
+	@echo '  Image $@ is ready'
diff -ur ./arch/mips/boot/compressed/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/compressed/Makefile
--- ./arch/mips/boot/compressed/Makefile	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot/compressed/Makefile	2023-04-23 11:58:05.076771400 +0100
@@ -18,12 +18,14 @@
 # Disable Function Tracer
 KBUILD_CFLAGS := $(shell echo $(KBUILD_CFLAGS) | sed -e "s/-pg//")
 
+KBUILD_CFLAGS := $(filter-out -fstack-protector, $(KBUILD_CFLAGS))
+
 KBUILD_CFLAGS := $(LINUXINCLUDE) $(KBUILD_CFLAGS) -D__KERNEL__ \
 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull"
 
 KBUILD_AFLAGS := $(LINUXINCLUDE) $(KBUILD_AFLAGS) -D__ASSEMBLY__ \
 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) \
-	-DKERNEL_ENTRY=0x$(shell $(NM) $(objtree)/$(KBUILD_IMAGE) 2>/dev/null | grep " kernel_entry" | cut -f1 -d \ )
+	-DKERNEL_ENTRY=$(VMLINUX_ENTRY_ADDRESS)
 
 targets := head.o decompress.o dbg.o uart-16550.o uart-alchemy.o
 
@@ -58,7 +60,7 @@
 # Calculate the load address of the compressed kernel image
 hostprogs-y := calc_vmlinuz_load_addr
 
-ifeq ($(CONFIG_MACH_JZ4740),y)
+ifeq ($(CONFIG_MACH_XBURST),y)
 VMLINUZ_LOAD_ADDRESS := 0x80600000
 else
 VMLINUZ_LOAD_ADDRESS = $(shell $(obj)/calc_vmlinuz_load_addr \
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot: dts
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/boot: zcompressed
diff -ur ./arch/mips/cavium-octeon/executive/cvmx-helper-board.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
--- ./arch/mips/cavium-octeon/executive/cvmx-helper-board.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/executive/cvmx-helper-board.c	2023-04-23 11:58:05.720513300 +0100
@@ -181,6 +181,11 @@
 			return ipd_port - 16 + 4;
 		else
 			return -1;
+	case CVMX_BOARD_TYPE_UBNT_E100:
+		if (ipd_port >= 0 && ipd_port <= 2)
+			return 7 - ipd_port;
+		else
+			return -1;
 	}
 
 	/* Some unknown board. Somebody forgot to update this function... */
@@ -706,6 +711,14 @@
 				}
 			}
 		}
+	} else if (cvmx_sysinfo_get()->board_type ==
+			CVMX_BOARD_TYPE_UBNT_E100) {
+		cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 0);
+		cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 0x10);
+		cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(1, interface), 0);
+		cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(1, interface), 0x10);
+		cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(2, interface), 0);
+		cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(2, interface), 0x10);
 	}
 	return 0;
 }
diff -ur ./arch/mips/cavium-octeon/octeon-irq.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/octeon-irq.c
--- ./arch/mips/cavium-octeon/octeon-irq.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/octeon-irq.c	2023-04-23 11:58:06.111627800 +0100
@@ -1776,7 +1776,7 @@
 
 #ifdef CONFIG_HOTPLUG_CPU
 
-void fixup_irqs(void)
+void octeon_fixup_irqs(void)
 {
 	irq_cpu_offline();
 }
diff -ur ./arch/mips/cavium-octeon/octeon-platform.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/octeon-platform.c
--- ./arch/mips/cavium-octeon/octeon-platform.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/octeon-platform.c	2023-04-23 11:58:06.110829100 +0100
@@ -334,9 +334,10 @@
 	char name_buffer[20];
 	int iface;
 	int p;
-	int count;
+	int count = 0;
 
-	count = cvmx_helper_interface_enumerate(idx);
+	if (cvmx_helper_interface_enumerate(idx) == 0)
+		count = cvmx_helper_ports_on_interface(idx);
 
 	snprintf(name_buffer, sizeof(name_buffer), "interface@%d", idx);
 	iface = fdt_subnode_offset(initial_boot_params, pip, name_buffer);
diff -ur ./arch/mips/cavium-octeon/setup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/setup.c
--- ./arch/mips/cavium-octeon/setup.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/setup.c	2023-04-23 11:58:06.203536900 +0100
@@ -8,6 +8,7 @@
  *   written by Ralf Baechle <ralf@linux-mips.org>
  */
 #include <linux/compiler.h>
+#include <linux/vmalloc.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/console.h>
@@ -1166,3 +1167,30 @@
 	return err;
 }
 device_initcall(edac_devinit);
+
+static void __initdata *octeon_dummy_iospace;
+
+static int __init octeon_no_pci_init(void)
+{
+	/*
+	 * Initially assume there is no PCI. The PCI/PCIe platform code will
+	 * later re-initialize these to correct values if they are present.
+	 */
+	octeon_dummy_iospace = vzalloc(IO_SPACE_LIMIT);
+	set_io_port_base((unsigned long)octeon_dummy_iospace);
+	ioport_resource.start = MAX_RESOURCE;
+	ioport_resource.end = 0;
+	return 0;
+}
+core_initcall(octeon_no_pci_init);
+
+static int __init octeon_no_pci_release(void)
+{
+	/*
+	 * Release the allocated memory if a real IO space is there.
+	 */
+	if ((unsigned long)octeon_dummy_iospace != mips_io_port_base)
+		vfree(octeon_dummy_iospace);
+	return 0;
+}
+late_initcall(octeon_no_pci_release);
diff -ur ./arch/mips/cavium-octeon/smp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/smp.c
--- ./arch/mips/cavium-octeon/smp.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/cavium-octeon/smp.c	2023-04-23 11:58:06.203039300 +0100
@@ -255,8 +255,6 @@
 /* State of each CPU. */
 DEFINE_PER_CPU(int, cpu_state);
 
-extern void fixup_irqs(void);
-
 static int octeon_cpu_disable(void)
 {
 	unsigned int cpu = smp_processor_id();
@@ -267,7 +265,7 @@
 	set_cpu_online(cpu, false);
 	cpu_clear(cpu, cpu_callin_map);
 	local_irq_disable();
-	fixup_irqs();
+	octeon_fixup_irqs();
 	local_irq_enable();
 
 	flush_cache_all();
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: bootes_v10_base_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: bootes_v10_sfc_nor_4M_no_wifi_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: box_v10_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v21_android_alsa_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v21_android_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v21_android_rgb_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v21_linux_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v21_module_android_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v22_android_alsa_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v22_android_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v22_android_mipi_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v22_android_modules_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v22_linux_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: dorado_v30_linux_nand_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: fpga_t15_base_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: halley_linux_debug_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: halley_linux_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: halley_linux_msc_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: hercules_v10_audio_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: hercules_v10_base_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: hercules_v10_sfc_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_bull_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_mango_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_mango_mini_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_monkey_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_swan_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_swan_uvc_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: isvp_turkey_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: malta_android_defconfig
diff -ur ./arch/mips/configs/malta_defconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/malta_defconfig
--- ./arch/mips/configs/malta_defconfig	2023-04-26 12:25:54.480119262 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/malta_defconfig	2023-04-23 11:58:07.709889100 +0100
@@ -226,6 +226,7 @@
 CONFIG_MAC80211_MESH=y
 CONFIG_RFKILL=m
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
 CONFIG_CONNECTOR=m
 CONFIG_MTD=y
 CONFIG_MTD_CHAR=y
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: malta_eva_defconfig
diff -ur ./arch/mips/configs/maltaaprp_defconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltaaprp_defconfig
--- ./arch/mips/configs/maltaaprp_defconfig	2023-04-26 12:25:54.490119268 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltaaprp_defconfig	2023-04-23 11:58:07.794100100 +0100
@@ -80,6 +80,7 @@
 CONFIG_NET_ACT_POLICE=y
 CONFIG_NET_CLS_IND=y
 # CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 CONFIG_IDE=y
diff -ur ./arch/mips/configs/maltasmtc_defconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltasmtc_defconfig
--- ./arch/mips/configs/maltasmtc_defconfig	2023-04-26 12:25:54.490119268 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltasmtc_defconfig	2023-04-23 11:58:07.793417100 +0100
@@ -81,6 +81,7 @@
 CONFIG_NET_ACT_POLICE=y
 CONFIG_NET_CLS_IND=y
 # CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 CONFIG_IDE=y
diff -ur ./arch/mips/configs/maltasmvp_defconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltasmvp_defconfig
--- ./arch/mips/configs/maltasmvp_defconfig	2023-04-26 12:25:54.490119268 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltasmvp_defconfig	2023-04-23 11:58:07.877104700 +0100
@@ -4,7 +4,7 @@
 CONFIG_MIPS_MT_SMP=y
 CONFIG_SCHED_SMT=y
 CONFIG_MIPS_CMP=y
-CONFIG_NR_CPUS=8
+CONFIG_NR_CPUS=2
 CONFIG_HZ_100=y
 CONFIG_LOCALVERSION="cmp"
 CONFIG_SYSVIPC=y
@@ -58,7 +58,6 @@
 CONFIG_DEV_APPLETALK=m
 CONFIG_IPDDP=m
 CONFIG_IPDDP_ENCAP=y
-CONFIG_IPDDP_DECAP=y
 CONFIG_NET_SCHED=y
 CONFIG_NET_SCH_CBQ=m
 CONFIG_NET_SCH_HTB=m
@@ -83,6 +82,7 @@
 CONFIG_NET_ACT_POLICE=y
 CONFIG_NET_CLS_IND=y
 # CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 CONFIG_IDE=y
diff -ur ./arch/mips/configs/maltaup_defconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltaup_defconfig
--- ./arch/mips/configs/maltaup_defconfig	2023-04-26 12:25:54.490119268 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs/maltaup_defconfig	2023-04-23 11:58:07.876453600 +0100
@@ -79,6 +79,7 @@
 CONFIG_NET_ACT_POLICE=y
 CONFIG_NET_CLS_IND=y
 # CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 CONFIG_IDE=y
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: musca_v10_base_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: newton2_v20_defconfig
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/configs: newton2_v20_linux_defconfig
diff -ur ./arch/mips/fw/cfe/cfe_api.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/fw/cfe/cfe_api.c
--- ./arch/mips/fw/cfe/cfe_api.c	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/fw/cfe/cfe_api.c	2023-04-23 11:58:09.232041400 +0100
@@ -406,12 +406,12 @@
 	return xiocb.xiocb_status;
 }
 
-int cfe_write(int handle, unsigned char *buffer, int length)
+int cfe_write(int handle, const char *buffer, int length)
 {
 	return cfe_writeblk(handle, 0, buffer, length);
 }
 
-int cfe_writeblk(int handle, s64 offset, unsigned char *buffer, int length)
+int cfe_writeblk(int handle, s64 offset, const char *buffer, int length)
 {
 	struct cfe_xiocb xiocb;
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips: halley_base_linux_defconfig
diff -ur ./arch/mips/include/asm/Kbuild /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/Kbuild
--- ./arch/mips/include/asm/Kbuild	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/Kbuild	2023-04-23 11:58:09.475070700 +0100
@@ -1,2 +1,15 @@
 # MIPS headers
+generic-y += cputime.h
+generic-y += current.h
+generic-y += emergency-restart.h
+generic-y += local64.h
+generic-y += mutex.h
+generic-y += parport.h
+generic-y += percpu.h
+generic-y += scatterlist.h
+generic-y += sections.h
+generic-y += segment.h
+generic-y += serial.h
 generic-y += trace_clock.h
+generic-y += ucontext.h
+generic-y += xor.h
diff -ur ./arch/mips/include/asm/addrspace.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/addrspace.h
--- ./arch/mips/include/asm/addrspace.h	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/addrspace.h	2023-04-23 11:58:09.565579600 +0100
@@ -94,6 +94,7 @@
  * Memory segments (32bit kernel mode addresses)
  * These are the traditional names used in the 32-bit universe.
  */
+#ifndef KSEG
 #define KUSEG			0x00000000
 #define KSEG0			0x80000000
 #define KSEG1			0xa0000000
@@ -105,6 +106,7 @@
 #define CKSEG1			0xa0000000
 #define CKSEG2			0xc0000000
 #define CKSEG3			0xe0000000
+#endif
 
 #endif
 
diff -ur ./arch/mips/include/asm/asm.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asm.h
--- ./arch/mips/include/asm/asm.h	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asm.h	2023-04-23 11:58:09.563765500 +0100
@@ -149,7 +149,16 @@
 		pref	hint, addr;			\
 		.set	pop
 
-#define PREFX(hint,addr)				\
+#ifdef CONFIG_EVA
+#define PREFE(hint,addr)                                \
+		.set	push;				\
+		.set	mips4;				\
+		.set    eva;                            \
+		prefe   hint, addr;                     \
+		.set	pop
+#endif
+
+#define PREFX(hint,addr)                                \
 		.set	push;				\
 		.set	mips4;				\
 		prefx	hint, addr;			\
@@ -158,6 +167,7 @@
 #else /* !CONFIG_CPU_HAS_PREFETCH */
 
 #define PREF(hint, addr)
+#define PREFE(hint, addr)
 #define PREFX(hint, addr)
 
 #endif /* !CONFIG_CPU_HAS_PREFETCH */
diff -ur ./arch/mips/include/asm/asmmacro-32.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asmmacro-32.h
--- ./arch/mips/include/asm/asmmacro-32.h	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asmmacro-32.h	2023-04-23 11:58:09.633214000 +0100
@@ -12,7 +12,127 @@
 #include <asm/fpregdef.h>
 #include <asm/mipsregs.h>
 
-	.macro	fpu_save_double thread status tmp1=t0
+#ifdef CONFIG_CPU_MIPS32_R2
+
+	/* copy stuff from MIPS64 */
+
+	.macro  fpu_save_16even thread tmp=t0
+	cfc1    \tmp, fcr31
+	sdc1    $f0,  THREAD_FPR0(\thread)
+	sdc1    $f2,  THREAD_FPR2(\thread)
+	sdc1    $f4,  THREAD_FPR4(\thread)
+	sdc1    $f6,  THREAD_FPR6(\thread)
+	sdc1    $f8,  THREAD_FPR8(\thread)
+	sdc1    $f10, THREAD_FPR10(\thread)
+	sdc1    $f12, THREAD_FPR12(\thread)
+	sdc1    $f14, THREAD_FPR14(\thread)
+	sdc1    $f16, THREAD_FPR16(\thread)
+	sdc1    $f18, THREAD_FPR18(\thread)
+	sdc1    $f20, THREAD_FPR20(\thread)
+	sdc1    $f22, THREAD_FPR22(\thread)
+	sdc1    $f24, THREAD_FPR24(\thread)
+	sdc1    $f26, THREAD_FPR26(\thread)
+	sdc1    $f28, THREAD_FPR28(\thread)
+	sdc1    $f30, THREAD_FPR30(\thread)
+	sw  \tmp, THREAD_FCR31(\thread)
+	.endm
+
+	.macro  fpu_save_16odd thread
+	.set    push
+	.set    mips64r2
+	sdc1    $f1,  THREAD_FPR1(\thread)
+	sdc1    $f3,  THREAD_FPR3(\thread)
+	sdc1    $f5,  THREAD_FPR5(\thread)
+	sdc1    $f7,  THREAD_FPR7(\thread)
+	sdc1    $f9,  THREAD_FPR9(\thread)
+	sdc1    $f11, THREAD_FPR11(\thread)
+	sdc1    $f13, THREAD_FPR13(\thread)
+	sdc1    $f15, THREAD_FPR15(\thread)
+	sdc1    $f17, THREAD_FPR17(\thread)
+	sdc1    $f19, THREAD_FPR19(\thread)
+	sdc1    $f21, THREAD_FPR21(\thread)
+	sdc1    $f23, THREAD_FPR23(\thread)
+	sdc1    $f25, THREAD_FPR25(\thread)
+	sdc1    $f27, THREAD_FPR27(\thread)
+	sdc1    $f29, THREAD_FPR29(\thread)
+	sdc1    $f31, THREAD_FPR31(\thread)
+	.set    pop
+	.endm
+
+	.macro  fpu_save_double thread status tmp
+	.set    push
+	.set    noreorder
+	.set	hardfloat
+	sll     \tmp, \status, 31 - _ST0_FR
+	bgez    \tmp, 2f
+	 nop
+	fpu_save_16odd \thread
+2:
+	fpu_save_16even \thread \tmp
+	.set    pop
+	.endm
+
+	.macro  fpu_restore_16even thread tmp=t0
+	lw  \tmp, THREAD_FCR31(\thread)
+	ldc1    $f0,  THREAD_FPR0(\thread)
+	ldc1    $f2,  THREAD_FPR2(\thread)
+	ldc1    $f4,  THREAD_FPR4(\thread)
+	ldc1    $f6,  THREAD_FPR6(\thread)
+	ldc1    $f8,  THREAD_FPR8(\thread)
+	ldc1    $f10, THREAD_FPR10(\thread)
+	ldc1    $f12, THREAD_FPR12(\thread)
+	ldc1    $f14, THREAD_FPR14(\thread)
+	ldc1    $f16, THREAD_FPR16(\thread)
+	ldc1    $f18, THREAD_FPR18(\thread)
+	ldc1    $f20, THREAD_FPR20(\thread)
+	ldc1    $f22, THREAD_FPR22(\thread)
+	ldc1    $f24, THREAD_FPR24(\thread)
+	ldc1    $f26, THREAD_FPR26(\thread)
+	ldc1    $f28, THREAD_FPR28(\thread)
+	ldc1    $f30, THREAD_FPR30(\thread)
+	ctc1    \tmp, fcr31
+	.endm
+
+	.macro  fpu_restore_16odd thread
+	.set    push
+	.set    mips64r2
+	ldc1    $f1,  THREAD_FPR1(\thread)
+	ldc1    $f3,  THREAD_FPR3(\thread)
+	ldc1    $f5,  THREAD_FPR5(\thread)
+	ldc1    $f7,  THREAD_FPR7(\thread)
+	ldc1    $f9,  THREAD_FPR9(\thread)
+	ldc1    $f11, THREAD_FPR11(\thread)
+	ldc1    $f13, THREAD_FPR13(\thread)
+	ldc1    $f15, THREAD_FPR15(\thread)
+	ldc1    $f17, THREAD_FPR17(\thread)
+	ldc1    $f19, THREAD_FPR19(\thread)
+	ldc1    $f21, THREAD_FPR21(\thread)
+	ldc1    $f23, THREAD_FPR23(\thread)
+	ldc1    $f25, THREAD_FPR25(\thread)
+	ldc1    $f27, THREAD_FPR27(\thread)
+	ldc1    $f29, THREAD_FPR29(\thread)
+	ldc1    $f31, THREAD_FPR31(\thread)
+	.set    pop
+	.endm
+
+	.macro  fpu_restore_double thread status tmp
+	.set    push
+	.set    noreorder
+	.set	hardfloat
+	sll     \tmp, \status, 31 - _ST0_FR
+	bgez    \tmp, 1f                # 16 register mode?
+	 nop
+
+	fpu_restore_16odd \thread
+1:      fpu_restore_16even \thread \tmp
+	.set    pop
+	.endm
+
+#else
+
+	.macro  fpu_save_double thread status tmp1=t0
+	.set	push
+	.set	hardfloat
 	cfc1	\tmp1,  fcr31
 	sdc1	$f0,  THREAD_FPR0(\thread)
 	sdc1	$f2,  THREAD_FPR2(\thread)
@@ -31,6 +151,7 @@
 	sdc1	$f28, THREAD_FPR28(\thread)
 	sdc1	$f30, THREAD_FPR30(\thread)
 	sw	\tmp1, THREAD_FCR31(\thread)
+	.set	pop
 	.endm
 
 	.macro	fpu_save_single thread tmp=t0
@@ -71,6 +192,8 @@
 	.endm
 
 	.macro	fpu_restore_double thread status tmp=t0
+	.set	push
+	.set	hardfloat
 	lw	\tmp, THREAD_FCR31(\thread)
 	ldc1	$f0,  THREAD_FPR0(\thread)
 	ldc1	$f2,  THREAD_FPR2(\thread)
@@ -89,6 +212,7 @@
 	ldc1	$f28, THREAD_FPR28(\thread)
 	ldc1	$f30, THREAD_FPR30(\thread)
 	ctc1	\tmp, fcr31
+	.set	pop
 	.endm
 
 	.macro	fpu_restore_single thread tmp=t0
@@ -128,6 +252,8 @@
 	ctc1	\tmp, fcr31
 	.endm
 
+#endif  // CONFIG_CPU_MIPS32_R2
+
 	.macro	cpu_save_nonscratch thread
 	LONG_S	s0, THREAD_REG16(\thread)
 	LONG_S	s1, THREAD_REG17(\thread)
diff -ur ./arch/mips/include/asm/asmmacro-64.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asmmacro-64.h
--- ./arch/mips/include/asm/asmmacro-64.h	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/asmmacro-64.h	2023-04-23 11:58:09.632830500 +0100
@@ -54,7 +54,7 @@
 	.endm
 
 	.macro	fpu_save_double thread status tmp
-	sll	\tmp, \status, 5
+	sll     \tmp, \status, 31 - _ST0_FR
 	bgez	\tmp, 2f
 	fpu_save_16odd \thread
 2:
@@ -102,7 +102,7 @@
 	.endm
 
 	.macro	fpu_restore_double thread status tmp
-	sll	\tmp, \status, 5
+	sll     \tmp, \status, 31 - _ST0_FR
 	bgez	\tmp, 1f				# 16 register mode?
 
 	fpu_restore_16odd \thread
diff -ur ./arch/mips/include/asm/bootinfo.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/bootinfo.h
--- ./arch/mips/include/asm/bootinfo.h	2023-04-26 12:25:54.530119294 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/bootinfo.h	2023-04-23 11:58:09.710800700 +0100
@@ -77,6 +77,8 @@
 #define  MACH_INGENIC_JZ4730	0	/* JZ4730 SOC		*/
 #define  MACH_INGENIC_JZ4740	1	/* JZ4740 SOC		*/
 
+#define  MACH_XBURST		2	/* Xburst based SOC	*/
+
 extern char *system_type;
 const char *get_system_type(void);
 
diff -ur ./arch/mips/include/asm/cacheflush.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cacheflush.h
--- ./arch/mips/include/asm/cacheflush.h	2023-04-26 12:25:54.540119300 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cacheflush.h	2023-04-23 11:58:09.790652600 +0100
@@ -66,20 +66,20 @@
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
 extern void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
-extern void (*__flush_cache_vmap)(void);
+extern void (*__flush_cache_vmap)(unsigned long start, unsigned long end);
 
 static inline void flush_cache_vmap(unsigned long start, unsigned long end)
 {
 	if (cpu_has_dc_aliases)
-		__flush_cache_vmap();
+		__flush_cache_vmap(start,end);
 }
 
-extern void (*__flush_cache_vunmap)(void);
+extern void (*__flush_cache_vunmap)(unsigned long start, unsigned long end);
 
 static inline void flush_cache_vunmap(unsigned long start, unsigned long end)
 {
 	if (cpu_has_dc_aliases)
-		__flush_cache_vunmap();
+		__flush_cache_vunmap(start,end);
 }
 
 extern void copy_to_user_page(struct vm_area_struct *vma,
@@ -94,6 +94,8 @@
 extern void (*flush_icache_all)(void);
 extern void (*local_flush_data_cache_page)(void * addr);
 extern void (*flush_data_cache_page)(unsigned long addr);
+extern void (*mips_flush_data_cache_range)(struct vm_area_struct *vma,
+	struct page *page, unsigned long addr, unsigned long size);
 
 /*
  * This flag is used to indicate that the page pointed to by a pte
@@ -117,7 +119,8 @@
 #define ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
 static inline void flush_kernel_dcache_page(struct page *page)
 {
-	BUG_ON(cpu_has_dc_aliases && PageHighMem(page));
+	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)
+		__flush_dcache_page(page);
 }
 
 /*
diff -ur ./arch/mips/include/asm/cacheops.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cacheops.h
--- ./arch/mips/include/asm/cacheops.h	2023-04-26 12:25:54.540119300 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cacheops.h	2023-04-23 11:58:09.790166000 +0100
@@ -35,6 +35,7 @@
 #define Fill			0x14
 #define Hit_Writeback_I		0x18
 #define Hit_Writeback_D		0x19
+#define Index_Prefetch_I	0x1c
 
 /*
  * R4000SC and R4400SC-specific cacheops
diff -ur ./arch/mips/include/asm/checksum.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/checksum.h
--- ./arch/mips/include/asm/checksum.h	2023-04-26 12:25:54.540119300 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/checksum.h	2023-04-23 11:58:09.874119900 +0100
@@ -31,6 +31,12 @@
 
 __wsum __csum_partial_copy_user(const void *src, void *dst,
 				int len, __wsum sum, int *err_ptr);
+#ifdef  CONFIG_EVA
+__wsum __csum_partial_copy_fromuser(const void *src, void *dst,
+				    int len, __wsum sum, int *err_ptr);
+__wsum __csum_partial_copy_touser(const void *src, void *dst,
+				  int len, __wsum sum, int *err_ptr);
+#endif
 
 /*
  * this is a new version of the above that records errors it finds in *errp,
@@ -40,9 +46,34 @@
 __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
+#ifndef CONFIG_EVA
 	might_fault();
 	return __csum_partial_copy_user((__force void *)src, dst,
-					len, sum, err_ptr);
+					    len, sum, err_ptr);
+#else
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return __csum_partial_copy_user((__force void *)src, dst,
+						len, sum, err_ptr);
+	else {
+		might_fault();
+		return __csum_partial_copy_fromuser((__force void *)src, dst,
+						    len, sum, err_ptr);
+	}
+#endif
+}
+
+#define _HAVE_ARCH_COPY_AND_CSUM_FROM_USER
+static inline
+__wsum csum_and_copy_from_user (const void __user *src, void *dst,
+				      int len, __wsum sum, int *err_ptr)
+{
+	if (access_ok(VERIFY_READ, src, len))
+		return csum_partial_copy_from_user(src, dst, len, sum, err_ptr);
+
+	if (len)
+		*err_ptr = -EFAULT;
+
+	return sum;
 }
 
 /*
@@ -53,10 +84,22 @@
 __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 			     __wsum sum, int *err_ptr)
 {
-	might_fault();
-	if (access_ok(VERIFY_WRITE, dst, len))
+	if (access_ok(VERIFY_WRITE, dst, len)) {
+#ifndef CONFIG_EVA
+		might_fault();
 		return __csum_partial_copy_user(src, (__force void *)dst,
-						len, sum, err_ptr);
+						  len, sum, err_ptr);
+#else
+		if (segment_eq(get_fs(), KERNEL_DS))
+			return __csum_partial_copy_user(src, (__force void *)dst,
+							  len, sum, err_ptr);
+		else {
+			might_fault();
+			return __csum_partial_copy_touser(src, (__force void *)dst,
+							  len, sum, err_ptr);
+		}
+#endif
+	}
 	if (len)
 		*err_ptr = -EFAULT;
 
diff -ur ./arch/mips/include/asm/compat.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/compat.h
--- ./arch/mips/include/asm/compat.h	2023-04-26 12:25:54.540119300 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/compat.h	2023-04-23 11:58:09.951979600 +0100
@@ -298,7 +298,13 @@
 
 static inline int is_compat_task(void)
 {
+#ifdef CONFIG_MIPS32_O32
+	return test_thread_flag(TIF_32BIT_REGS);
+#elif defined(CONFIG_MIPS32_N32)
 	return test_thread_flag(TIF_32BIT_ADDR);
+#else
+#error No MIPS32 compatibility mode defined
+#endif /* CONFIG_MIPS32_O32 */
 }
 
 #endif /* _ASM_COMPAT_H */
diff -ur ./arch/mips/include/asm/cop2.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cop2.h
--- ./arch/mips/include/asm/cop2.h	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cop2.h	2023-04-23 11:58:10.032295900 +0100
@@ -11,6 +11,24 @@
 
 #include <linux/notifier.h>
 
+#if defined(CONFIG_MACH_XBURST)
+
+extern void xburst_cop2_save(struct xburst_cop2_state *);
+extern void xburst_cop2_restore(struct xburst_cop2_state *);
+#define cop2_save(r)		xburst_cop2_save(r)
+#define cop2_restore(r)		xburst_cop2_restore(r)
+
+#define cop2_present		1
+#define cop2_lazy_restore	0
+
+#else
+
+#define cop2_present		0
+#define cop2_lazy_restore	0
+#define cop2_save(r)
+#define cop2_restore(r)
+#endif
+
 enum cu2_ops {
 	CU2_EXCEPTION,
 	CU2_LWC2_OP,
diff -ur ./arch/mips/include/asm/cpu-features.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu-features.h
--- ./arch/mips/include/asm/cpu-features.h	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu-features.h	2023-04-23 11:58:10.031888400 +0100
@@ -24,6 +24,9 @@
 #ifndef cpu_has_tlb
 #define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
 #endif
+#ifndef cpu_has_tlbinv
+#define cpu_has_tlbinv          (cpu_data[0].options & MIPS_CPU_TLBINV)
+#endif
 #ifndef cpu_has_4kex
 #define cpu_has_4kex		(cpu_data[0].options & MIPS_CPU_4KEX)
 #endif
@@ -99,11 +102,21 @@
 #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
 #endif
 #ifndef cpu_has_mmips
-#define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+# ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
+#  define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+# else
+#  define cpu_has_mmips		0
+# endif
 #endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif
+#ifndef cpu_has_vtag_dcache
+#define cpu_has_vtag_dcache     (cpu_data[0].dcache.flags & MIPS_CACHE_VTAG)
+#endif
+#ifndef cpu_has_ic_aliases
+#define cpu_has_ic_aliases      (cpu_data[0].icache.flags & MIPS_CACHE_ALIASES)
+#endif
 #ifndef cpu_has_dc_aliases
 #define cpu_has_dc_aliases	(cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
 #endif
@@ -116,6 +129,12 @@
 #ifndef cpu_has_local_ebase
 #define cpu_has_local_ebase	1
 #endif
+#ifndef cpu_has_cm2
+#define cpu_has_cm2             (cpu_data[0].options & MIPS_CPU_CM2)
+#endif
+#ifndef cpu_has_cm2_l2sync
+#define cpu_has_cm2_l2sync      (cpu_data[0].options & MIPS_CPU_CM2_L2SYNC)
+#endif
 
 /*
  * I-Cache snoops remote store.	 This only matters on SMP.  Some multiprocessors
@@ -178,7 +197,7 @@
 
 /*
  * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
- * pre-MIPS32/MIPS53 processors have CLO, CLZ.	The IDT RC64574 is 64-bit and
+ * pre-MIPS32/MIPS64 processors have CLO, CLZ.	The IDT RC64574 is 64-bit and
  * has CLO and CLZ but not DCLO nor DCLZ.  For 64-bit kernels
  * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
  */
@@ -198,10 +217,26 @@
 #define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
 #endif
 
+#ifndef cpu_has_mxu
+#define cpu_has_mxu		(cpu_data[0].ases & MIPS_ASE_XBURSTMXU)
+#endif
+
+#ifndef cpu_has_mxu_v2
+#define cpu_has_mxu_v2		(cpu_data[0].ases & MIPS_ASE_XBURSTMXUV2)
+#endif
+
 #ifndef cpu_has_userlocal
 #define cpu_has_userlocal	(cpu_data[0].options & MIPS_CPU_ULRI)
 #endif
 
+#ifndef cpu_has_segments
+#define cpu_has_segments	(cpu_data[0].options & MIPS_CPU_SEGMENTS)
+#endif
+
+#ifndef cpu_has_eva
+#define cpu_has_eva		(cpu_data[0].options & MIPS_CPU_EVA)
+#endif
+
 #ifdef CONFIG_32BIT
 # ifndef cpu_has_nofpuex
 # define cpu_has_nofpuex	(cpu_data[0].options & MIPS_CPU_NOFPUEX)
diff -ur ./arch/mips/include/asm/cpu-info.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu-info.h
--- ./arch/mips/include/asm/cpu-info.h	2023-04-26 12:25:54.550119306 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu-info.h	2023-04-23 11:58:10.031341700 +0100
@@ -52,11 +52,14 @@
 	unsigned int		cputype;
 	int			isa_level;
 	int			tlbsize;
-	struct cache_desc	icache; /* Primary I-cache */
-	struct cache_desc	dcache; /* Primary D or combined I/D cache */
-	struct cache_desc	scache; /* Secondary cache */
-	struct cache_desc	tcache; /* Tertiary/split secondary cache */
-	int			srsets; /* Shadow register sets */
+	int                     tlbsizevtlb;
+	int                     tlbsizeftlbsets;
+	int                     tlbsizeftlbways;
+	struct cache_desc	icache;	/* Primary I-cache */
+	struct cache_desc	dcache;	/* Primary D or combined I/D cache */
+	struct cache_desc	scache;	/* Secondary cache */
+	struct cache_desc	tcache;	/* Tertiary/split secondary cache */
+	int			srsets;	/* Shadow register sets */
 	int			core;	/* physical core number */
 #ifdef CONFIG_64BIT
 	int			vmbits; /* Virtual memory size in bits */
@@ -79,6 +82,9 @@
 #define NUM_WATCH_REGS 4
 	u16			watch_reg_masks[NUM_WATCH_REGS];
 	unsigned int		kscratch_mask; /* Usable KScratch mask. */
+	unsigned int            segctl0; /* Memory Segmentation Control 0 */
+	unsigned int            segctl1; /* Memory Segmentation Control 1 */
+	unsigned int            segctl2; /* Memory Segmentation Control 2 */
 } __attribute__((aligned(SMP_CACHE_BYTES)));
 
 extern struct cpuinfo_mips cpu_data[];
diff -ur ./arch/mips/include/asm/cpu.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu.h
--- ./arch/mips/include/asm/cpu.h	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/cpu.h	2023-04-23 11:58:10.112494700 +0100
@@ -97,6 +97,10 @@
 #define PRID_IMP_1074K		0x9a00
 #define PRID_IMP_M14KC		0x9c00
 #define PRID_IMP_M14KEC		0x9e00
+#define PRID_IMP_INTERAPTIV_UP	0xa000
+#define PRID_IMP_INTERAPTIV_MP	0xa100
+#define PRID_IMP_PROAPTIV_UP	0xa200
+#define PRID_IMP_PROAPTIV_MP	0xa300
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_SIBYTE
@@ -144,9 +148,18 @@
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_INGENIC
+ * cpu_h(12bit CPU_FEATURE),chips(8bit),cpu_l(12bit CPU_ISA_ID)
  */
+#define PRID_CPU_FEATURE_MASK       0xFFF00000
+#define PRID_CPU_CHIPS_MASK         0x000FF000
+#define PRID_CPU_ISA_MASK           0x00000FFF
+
+#define PRID_IMP_JZRISC             0x00010000
+#define PRID_IMP_JZ4775             0x2ed00000
+#define PRID_IMP_JZ4780             0x3ee00000
+#define PRID_IMP_M200               0x7ae00000
+#define PRID_IMP_ISA_R2             0x0000024f
 
-#define PRID_IMP_JZRISC	       0x0200
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_NETLOGIC
@@ -265,7 +278,7 @@
 	CPU_4KC, CPU_4KEC, CPU_4KSC, CPU_24K, CPU_34K, CPU_1004K, CPU_74K,
 	CPU_ALCHEMY, CPU_PR4450, CPU_BMIPS32, CPU_BMIPS3300, CPU_BMIPS4350,
 	CPU_BMIPS4380, CPU_BMIPS5000, CPU_JZRISC, CPU_LOONGSON1, CPU_M14KC,
-	CPU_M14KEC,
+	CPU_M14KEC, CPU_PROAPTIV, CPU_INTERAPTIV,
 
 	/*
 	 * MIPS64 class processors
@@ -277,6 +290,7 @@
 	CPU_LAST
 };
 
+#define MIPS_FTLB_CAPABLE       0x1
 
 /*
  * ISA Level encodings
@@ -325,6 +339,11 @@
 #define MIPS_CPU_PCI		0x00400000 /* CPU has Perf Ctr Int indicator */
 #define MIPS_CPU_RIXI		0x00800000 /* CPU has TLB Read/eXec Inhibit */
 #define MIPS_CPU_MICROMIPS	0x01000000 /* CPU has microMIPS capability */
+#define MIPS_CPU_SEGMENTS       0x02000000 /* CPU supports memory segmentation */
+#define MIPS_CPU_EVA            0x04000000 /* CPU supports EVA functionality */
+#define MIPS_CPU_TLBINV         0x08000000 /* CPU supports TLBINV/F */
+#define MIPS_CPU_CM2            0x10000000 /* CPU has CM2 */
+#define MIPS_CPU_CM2_L2SYNC     0x20000000 /* CPU has CM2 L2-only SYNC feature */
 
 /*
  * CPU ASE encodings
@@ -337,5 +356,7 @@
 #define MIPS_ASE_MIPSMT		0x00000020 /* CPU supports MIPS MT */
 #define MIPS_ASE_DSP2P		0x00000040 /* Signal Processing ASE Rev 2 */
 #define MIPS_ASE_VZ		0x00000080 /* Virtualization ASE */
+#define MIPS_ASE_XBURSTMXU	0x80000000 /* MIPS Xburst eXtended enhanced Unit */
+#define MIPS_ASE_XBURSTMXUV2	0x40000000 /* MIPS Xburst eXtended enhanced Unit V2 */
 
 #endif /* _ASM_CPU_H */
Only in ./arch/mips/include/asm: cputime.h
Only in ./arch/mips/include/asm: current.h
diff -ur ./arch/mips/include/asm/elf.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/elf.h
--- ./arch/mips/include/asm/elf.h	2023-04-26 12:25:54.550119306 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/elf.h	2023-04-23 11:58:10.509489100 +0100
@@ -36,6 +36,7 @@
 #define EF_MIPS_ABI2		0x00000020
 #define EF_MIPS_OPTIONS_FIRST	0x00000080
 #define EF_MIPS_32BITMODE	0x00000100
+#define EF_MIPS_32BITMODE_FP64  0x00000200
 #define EF_MIPS_ABI		0x0000f000
 #define EF_MIPS_ARCH		0xf0000000
 
@@ -228,6 +229,32 @@
 #endif /* CONFIG_64BIT */
 
 /*
+ * Ensure we don't load the incompatible architecture lib via uselib() -
+ * - verify FPU model.
+ */
+#define elf_lib_check_arch(hdr)                                         \
+({									\
+	int __res = 1;							\
+	struct elfhdr *__h = (hdr);					\
+									\
+	if (test_thread_flag(TIF_32BIT_REGS)) {                         \
+		if ((__h->e_flags & EF_MIPS_ABI2) != 0)                 \
+			__res = 0;                                      \
+		if (((__h->e_flags & EF_MIPS_ABI) != 0) &&              \
+		    ((__h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32))  \
+			__res = 0;                                      \
+		if (__h->e_flags & EF_MIPS_32BITMODE_FP64)             \
+			__res = 0;                                  \
+	} else {                                                        \
+		if (((__h->e_flags & EF_MIPS_ABI) == 0) ||              \
+		    ((__h->e_flags & EF_MIPS_ABI) == EF_MIPS_ABI_O32))  \
+			if (!(__h->e_flags & EF_MIPS_32BITMODE_FP64))  \
+				__res = 0;                          \
+	}                                                               \
+	__res;								\
+})
+
+/*
  * These are used to set parameters in the core dumps.
  */
 #ifdef __MIPSEB__
@@ -249,6 +276,11 @@
 
 #define SET_PERSONALITY(ex)						\
 do {									\
+	if ((ex).e_flags & EF_MIPS_32BITMODE_FP64)                      \
+	    clear_thread_flag(TIF_32BIT_REGS);                          \
+	else                                                            \
+	    set_thread_flag(TIF_32BIT_REGS);                            \
+									\
 	if (personality(current->personality) != PER_LINUX)		\
 		set_personality(PER_LINUX);				\
 									\
@@ -262,6 +294,7 @@
 #ifdef CONFIG_MIPS32_N32
 #define __SET_PERSONALITY32_N32()					\
 	do {								\
+		clear_thread_flag(TIF_32BIT_REGS);                      \
 		set_thread_flag(TIF_32BIT_ADDR);			\
 		current->thread.abi = &mips_abi_n32;			\
 	} while (0)
@@ -271,14 +304,18 @@
 #endif
 
 #ifdef CONFIG_MIPS32_O32
-#define __SET_PERSONALITY32_O32()					\
+#define __SET_PERSONALITY32_O32(ex)                                     \
 	do {								\
-		set_thread_flag(TIF_32BIT_REGS);			\
+		if ((ex).e_flags & EF_MIPS_32BITMODE_FP64)              \
+		    clear_thread_flag(TIF_32BIT_REGS);                  \
+		else                                                    \
+		    set_thread_flag(TIF_32BIT_REGS);                    \
+									\
 		set_thread_flag(TIF_32BIT_ADDR);			\
 		current->thread.abi = &mips_abi_32;			\
 	} while (0)
 #else
-#define __SET_PERSONALITY32_O32()					\
+#define __SET_PERSONALITY32_O32(ex)                                     \
 	do { } while (0)
 #endif
 
@@ -289,7 +326,7 @@
 	     ((ex).e_flags & EF_MIPS_ABI) == 0)				\
 		__SET_PERSONALITY32_N32();				\
 	else								\
-		__SET_PERSONALITY32_O32();				\
+		__SET_PERSONALITY32_O32(ex);                            \
 } while (0)
 #else
 #define __SET_PERSONALITY32(ex) do { } while (0)
Only in ./arch/mips/include/asm: emergency-restart.h
diff -ur ./arch/mips/include/asm/fixmap.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fixmap.h
--- ./arch/mips/include/asm/fixmap.h	2023-04-26 12:25:54.550119306 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fixmap.h	2023-04-23 11:58:10.672739100 +0100
@@ -20,6 +20,7 @@
 #include <asm/kmap_types.h>
 #endif
 
+#ifndef CONFIG_EVA_3GB
 /*
  * Here we define all the compile-time 'special' virtual
  * addresses. The point is to have a constant address at
@@ -46,7 +47,19 @@
  * fix-mapped?
  */
 enum fixed_addresses {
+
+/* must be <= 8, last_pkmap_nr_arr[] is initialized to 8 elements,
+   keep the total L1 size <= 512KB with 4 ways */
+#ifdef  CONFIG_PAGE_SIZE_64KB
+#define FIX_N_COLOURS 2
+#endif
+#ifdef  CONFIG_PAGE_SIZE_32KB
+#define FIX_N_COLOURS 4
+#endif
+#ifndef FIX_N_COLOURS
 #define FIX_N_COLOURS 8
+#endif
+
 	FIX_CMAP_BEGIN,
 #ifdef CONFIG_MIPS_MT_SMTC
 	FIX_CMAP_END = FIX_CMAP_BEGIN + (FIX_N_COLOURS * NR_CPUS * 2),
@@ -56,7 +69,7 @@
 #ifdef CONFIG_HIGHMEM
 	/* reserved pte's for temporary kernel mappings */
 	FIX_KMAP_BEGIN = FIX_CMAP_END + 1,
-	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN+(8*NR_CPUS*FIX_N_COLOURS)-1,
 #endif
 	__end_of_fixed_addresses
 };
@@ -115,3 +128,4 @@
 
 
 #endif
+#endif
diff -ur ./arch/mips/include/asm/fpu.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fpu.h
--- ./arch/mips/include/asm/fpu.h	2023-04-26 12:25:54.560119313 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fpu.h	2023-04-23 11:58:10.752168800 +0100
@@ -29,11 +29,15 @@
 struct sigcontext32;
 
 extern void fpu_emulator_init_fpu(void);
-extern void _init_fpu(void);
+extern int _init_fpu(void);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
 
-#define __enable_fpu()							\
+/*
+ * This macro is used only to obtain FIR from FPU and it seems
+ * like a BUG in 34K with single FPU affinity to VPE0.
+ */
+#define __enable_fpu()                                                  \
 do {									\
 	set_c0_status(ST0_CU1);						\
 	enable_fpu_hazard();						\
@@ -42,7 +46,7 @@
 #define __disable_fpu()							\
 do {									\
 	clear_c0_status(ST0_CU1);					\
-	disable_fpu_hazard();						\
+        disable_fpu_hazard();						\
 } while (0)
 
 #define enable_fpu()							\
@@ -70,27 +74,58 @@
 	return cpu_has_fpu && __is_fpu_owner();
 }
 
-static inline void __own_fpu(void)
+static inline int __own_fpu(void)
 {
-	__enable_fpu();
+	int ret = 0;
+
+#if defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_MIPS64)
+	if (test_thread_flag(TIF_32BIT_REGS)) {
+		change_c0_status(ST0_CU1|ST0_FR,ST0_CU1);
+		KSTK_STATUS(current) |= ST0_CU1;
+		KSTK_STATUS(current) &= ~ST0_FR;
+		enable_fpu_hazard();
+		if (read_c0_status() & ST0_FR)
+		    ret = SIGFPE;
+	} else {
+		set_c0_status(ST0_CU1|ST0_FR);
+		KSTK_STATUS(current) |= ST0_CU1|ST0_FR;
+		enable_fpu_hazard();
+		if (!(read_c0_status() & ST0_FR))
+		    ret = SIGFPE;
+	}
+#else
+	if (!test_thread_flag(TIF_32BIT_REGS))
+		return SIGFPE;  /* core has no 64bit FPU, so ... */
+
+	set_c0_status(ST0_CU1);
 	KSTK_STATUS(current) |= ST0_CU1;
+	enable_fpu_hazard();
+#endif
 	set_thread_flag(TIF_USEDFPU);
+	return ret;
 }
 
-static inline void own_fpu_inatomic(int restore)
+static inline int own_fpu_inatomic(int restore)
 {
+	int ret = 0;
+
 	if (cpu_has_fpu && !__is_fpu_owner()) {
-		__own_fpu();
-		if (restore)
+		ret =__own_fpu();
+		if (restore && !ret)
 			_restore_fp(current);
 	}
+	return ret;
 }
 
-static inline void own_fpu(int restore)
+static inline int own_fpu(int restore)
 {
+	int ret;
+
 	preempt_disable();
-	own_fpu_inatomic(restore);
+	ret = own_fpu_inatomic(restore);
 	preempt_enable();
+
+	return ret;
 }
 
 static inline void lose_fpu(int save)
@@ -101,21 +136,25 @@
 			_save_fp(current);
 		KSTK_STATUS(current) &= ~ST0_CU1;
 		clear_thread_flag(TIF_USEDFPU);
-		__disable_fpu();
+		clear_c0_status(ST0_CU1);
+		disable_fpu_hazard();
 	}
 	preempt_enable();
 }
 
-static inline void init_fpu(void)
+static inline int init_fpu(void)
 {
+	int ret = 0;
+
 	preempt_disable();
-	if (cpu_has_fpu) {
-		__own_fpu();
+	if (cpu_has_fpu && !(ret = __own_fpu()))
 		_init_fpu();
-	} else {
+	else
 		fpu_emulator_init_fpu();
-	}
+
 	preempt_enable();
+
+	return ret;
 }
 
 static inline void save_fp(struct task_struct *tsk)
diff -ur ./arch/mips/include/asm/futex.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/futex.h
--- ./arch/mips/include/asm/futex.h	2023-04-26 12:25:54.560119313 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/futex.h	2023-04-23 11:58:10.750694800 +0100
@@ -16,6 +16,7 @@
 #include <asm/errno.h>
 #include <asm/war.h>
 
+#ifndef CONFIG_EVA
 #define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
 {									\
 	if (cpu_has_llsc && R10000_LLSC_WAR) {				\
@@ -73,6 +74,69 @@
 	} else								\
 		ret = -ENOSYS;						\
 }
+#else
+#define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
+{									\
+	if (cpu_has_llsc && R10000_LLSC_WAR) {				\
+		__asm__ __volatile__(					\
+		"	.set	push				\n"	\
+		"	.set	noat				\n"	\
+		"	.set	mips3				\n"	\
+		"1:	ll	%1, %4	# __futex_atomic_op	\n"	\
+		"	.set	mips0				\n"	\
+		"	" insn	"				\n"	\
+		"	.set	mips3				\n"	\
+		"2:	sc	$1, %2				\n"	\
+		"	beqzl	$1, 1b				\n"	\
+		__WEAK_LLSC_MB						\
+		"3:						\n"	\
+		"	.insn					\n"	\
+		"	.set	pop				\n"	\
+		"	.set	mips0				\n"	\
+		"	.section .fixup,\"ax\"			\n"	\
+		"4:	li	%0, %6				\n"	\
+		"	j	3b				\n"	\
+		"	.previous				\n"	\
+		"	.section __ex_table,\"a\"		\n"	\
+		"	"__UA_ADDR "\t1b, 4b			\n"	\
+		"	"__UA_ADDR "\t2b, 4b			\n"	\
+		"	.previous				\n"	\
+		: "=r" (ret), "=&r" (oldval), "=R" (*uaddr)		\
+		: "0" (0), "R" (*uaddr), "Jr" (oparg), "i" (-EFAULT)	\
+		: "memory");						\
+	} else if (cpu_has_llsc) {					\
+		__asm__ __volatile__(					\
+		"	.set	push				\n"	\
+		"	.set	noat				\n"	\
+		"       .set    eva                             \n"     \
+		"1:     lwe     %1, %4                          \n"     \
+		"       lwe     %1, %4                          \n"     \
+		"	.set	mips0				\n"	\
+		"	" insn	"				\n"	\
+		"       .set    eva                             \n"     \
+		"2:     swe     $1, %2                          \n"     \
+		"       li      $1, 1                           \n"     \
+		"	beqz	$1, 1b				\n"	\
+		__WEAK_LLSC_MB						\
+		"3:						\n"	\
+		"	.insn					\n"	\
+		"	.set	pop				\n"	\
+		"	.set	mips0				\n"	\
+		"	.section .fixup,\"ax\"			\n"	\
+		"4:	li	%0, %6				\n"	\
+		"	j	3b				\n"	\
+		"	.previous				\n"	\
+		"	.section __ex_table,\"a\"		\n"	\
+		"	"__UA_ADDR "\t1b, 4b			\n"	\
+		"	"__UA_ADDR "\t2b, 4b			\n"	\
+		"	.previous				\n"	\
+		: "=r" (ret), "=&r" (oldval), "=R" (*uaddr)		\
+		: "0" (0), "R" (*uaddr), "Jr" (oparg), "i" (-EFAULT)	\
+		: "memory");						\
+	} else								\
+		ret = -ENOSYS;						\
+}
+#endif
 
 static inline int
 futex_atomic_op_inuser(int encoded_op, u32 __user *uaddr)
@@ -131,6 +195,7 @@
 	return ret;
 }
 
+#ifndef CONFIG_EVA
 static inline int
 futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
 			      u32 oldval, u32 newval)
@@ -201,6 +266,82 @@
 	*uval = val;
 	return ret;
 }
+#else
+static inline int
+futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
+			      u32 oldval, u32 newval)
+{
+	int ret = 0;
+	u32 val;
+
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	if (cpu_has_llsc && R10000_LLSC_WAR) {
+		__asm__ __volatile__(
+		"# futex_atomic_cmpxchg_inatomic			\n"
+		"	.set	push					\n"
+		"	.set	noat					\n"
+		"	.set	mips3					\n"
+		"1:     ll      %1, %3                                  \n"
+		"       bne     %1, %z4, 3f                             \n"
+		"	.set	mips0					\n"
+		"       move    $1, %z5                                 \n"
+		"	.set	mips3					\n"
+		"2:     sc      $1, %2                                  \n"
+		"	beqzl	$1, 1b					\n"
+		__WEAK_LLSC_MB
+		"3:							\n"
+		"	.insn						\n"
+		"	.set	pop					\n"
+		"	.section .fixup,\"ax\"				\n"
+		"4:     li      %0, %6                                  \n"
+		"	j	3b					\n"
+		"	.previous					\n"
+		"	.section __ex_table,\"a\"			\n"
+		"	"__UA_ADDR "\t1b, 4b				\n"
+		"	"__UA_ADDR "\t2b, 4b				\n"
+		"	.previous					\n"
+		: "+r" (ret), "=&r" (val), "=R" (*uaddr)
+		: "R" (*uaddr), "Jr" (oldval), "Jr" (newval), "i" (-EFAULT)
+		: "memory");
+	} else if (cpu_has_llsc) {
+		__asm__ __volatile__(
+		"# futex_atomic_cmpxchg_inatomic			\n"
+		"	.set	push					\n"
+		"	.set	noat					\n"
+		"       .set    eva                                     \n"
+		"1:     lwe     %1, %3                                  \n"
+		"       lwe     %1, %3                                  \n"
+		"       bne     %1, %z4, 3f                             \n"
+		"	.set	mips0					\n"
+		"       move    $1, %z5                                 \n"
+		"       .set    eva                                     \n"
+		"2:     swe     $1, %2                                  \n"
+		"       li      $1, 1                                   \n"
+		"	beqz	$1, 1b					\n"
+		__WEAK_LLSC_MB
+		"3:							\n"
+		"	.insn						\n"
+		"	.set	pop					\n"
+		"	.section .fixup,\"ax\"				\n"
+		"4:     li      %0, %6                                  \n"
+		"	j	3b					\n"
+		"	.previous					\n"
+		"	.section __ex_table,\"a\"			\n"
+		"	"__UA_ADDR "\t1b, 4b				\n"
+		"	"__UA_ADDR "\t2b, 4b				\n"
+		"	.previous					\n"
+		: "+r" (ret), "=&r" (val), "=R" (*uaddr)
+		: "R" (*uaddr), "Jr" (oldval), "Jr" (newval), "i" (-EFAULT)
+		: "memory");
+	} else
+		return -ENOSYS;
+
+	*uval = val;
+	return ret;
+}
+#endif
 
 #endif
 #endif /* _ASM_FUTEX_H */
diff -ur ./arch/mips/include/asm/fw/cfe/cfe_api.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fw/cfe/cfe_api.h
--- ./arch/mips/include/asm/fw/cfe/cfe_api.h	2023-04-26 12:56:04.180118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/fw/cfe/cfe_api.h	2023-04-23 11:58:10.913508300 +0100
@@ -115,8 +115,8 @@
 int cfe_readblk(int handle, int64_t offset, unsigned char *buffer,
 		int length);
 int cfe_setenv(char *name, char *val);
-int cfe_write(int handle, unsigned char *buffer, int length);
-int cfe_writeblk(int handle, int64_t offset, unsigned char *buffer,
+int cfe_write(int handle, const char *buffer, int length);
+int cfe_writeblk(int handle, int64_t offset, const char *buffer,
 		 int length);
 
 #endif				/* CFE_API_H */
diff -ur ./arch/mips/include/asm/gcmpregs.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/gcmpregs.h
--- ./arch/mips/include/asm/gcmpregs.h	2023-04-26 12:25:54.560119313 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/gcmpregs.h	2023-04-23 11:58:10.912059900 +0100
@@ -73,7 +73,10 @@
 #define GCMP_GCB_GCMEO_OFS		0x0058	/* Global CM Error Multiple */
 #define	 GCMP_GCB_GMEO_ERROR_2ND_SHF	0
 #define	 GCMP_GCB_GMEO_ERROR_2ND_MSK	GCMPGCBMSK(GMEO_ERROR_2ND, 5)
-#define GCMP_GCB_GICBA_OFS		0x0080	/* Global Interrupt Controller Base Address */
+#define GCMP_GCB_GCMCUS_OFS             0x0060  /* GCR Custom Base */
+#define GCMP_GCB_GCMCST_OFS             0x0068  /* GCR Custom Status */
+#define GCMP_GCB_GCML2S_OFS             0x0070  /* Global L2 only Sync Register */
+#define GCMP_GCB_GICBA_OFS              0x0080  /* Global Interrupt Controller Base Address */
 #define	 GCMP_GCB_GICBA_BASE_SHF	17
 #define	 GCMP_GCB_GICBA_BASE_MSK	GCMPGCBMSK(GICBA_BASE, 15)
 #define	 GCMP_GCB_GICBA_EN_SHF		0
@@ -115,6 +118,11 @@
 #define GCMP_CCB_RESETBASE_OFS		0x0020		/* Reset Exception Base */
 #define	 GCMP_CCB_RESETBASE_BEV_SHF	12
 #define	 GCMP_CCB_RESETBASE_BEV_MSK	GCMPCCBMSK(RESETBASE_BEV, 20)
+#define GCMP_CCB_RESETBASEEXT_OFS       0x0030          /* Reset Exception Base Extention */
+#define  GCMP_CCB_RESETEXTBASE_BEV_SHF      20
+#define  GCMP_CCB_RESETEXTBASE_BEV_MASK_MSK GCMPCCBMSK(RESETEXTBASE_BEV, 8)
+#define  GCMP_CCB_RESETEXTBASE_LOWBITS_SHF     0
+#define  GCMP_CCB_RESETEXTBASE_BEV_MASK_LOWBITS GCMPCCBMSK(RESETEXTBASE_LOWBITS, 20)
 #define GCMP_CCB_ID_OFS			0x0028		/* Identification */
 #define GCMP_CCB_DINTGROUP_OFS		0x0030		/* DINT Group Participate */
 #define GCMP_CCB_DBGGROUP_OFS		0x0100		/* DebugBreak Group */
@@ -122,4 +130,7 @@
 extern int __init gcmp_probe(unsigned long, unsigned long);
 extern int __init gcmp_niocu(void);
 extern void __init gcmp_setregion(int, unsigned long, unsigned long, int);
+extern unsigned long _gcmp_base;
+#define GCMP_L2SYNC_OFFSET              0x8000
+
 #endif /* _ASM_GCMPREGS_H */
diff -ur ./arch/mips/include/asm/highmem.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/highmem.h
--- ./arch/mips/include/asm/highmem.h	2023-04-26 12:25:54.560119313 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/highmem.h	2023-04-23 11:58:11.073880200 +0100
@@ -37,11 +37,38 @@
  * easily, subsequent pte tables have to be allocated in one physical
  * chunk of RAM.
  */
+
+/*  8 colors pages are here */
+#ifdef  CONFIG_PAGE_SIZE_4KB
+#define LAST_PKMAP 4096
+#endif
+#ifdef  CONFIG_PAGE_SIZE_8KB
+#define LAST_PKMAP 2048
+#endif
+#ifdef  CONFIG_PAGE_SIZE_16KB
+#define LAST_PKMAP 1024
+#endif
+
+/* 32KB and 64KB pages should have 4 and 2 colors to keep space under control */
+#ifndef LAST_PKMAP
 #define LAST_PKMAP 1024
+#endif
+
 #define LAST_PKMAP_MASK (LAST_PKMAP-1)
 #define PKMAP_NR(virt)	((virt-PKMAP_BASE) >> PAGE_SHIFT)
 #define PKMAP_ADDR(nr)	(PKMAP_BASE + ((nr) << PAGE_SHIFT))
 
+#define ARCH_PKMAP_COLORING             1
+#define     set_pkmap_color(pg,cl)      { cl = ((unsigned long)lowmem_page_address(pg) \
+					   >> PAGE_SHIFT) & (FIX_N_COLOURS-1); }
+#define     get_last_pkmap_nr(p,cl)     (last_pkmap_nr_arr[cl])
+#define     get_next_pkmap_nr(p,cl)     (last_pkmap_nr_arr[cl] = \
+					    ((p + FIX_N_COLOURS) & LAST_PKMAP_MASK))
+#define     is_no_more_pkmaps(p,cl)     (p < FIX_N_COLOURS)
+#define     get_next_pkmap_counter(c,cl)    (c - FIX_N_COLOURS)
+extern unsigned int     last_pkmap_nr_arr[];
+
+
 extern void * kmap_high(struct page *page);
 extern void kunmap_high(struct page *page);
 
Only in ./arch/mips/include/asm: kspd.h
Only in ./arch/mips/include/asm: local64.h
diff -ur ./arch/mips/include/asm/mach-ar7/spaces.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-ar7/spaces.h
--- ./arch/mips/include/asm/mach-ar7/spaces.h	2023-04-26 12:56:04.190118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-ar7/spaces.h	2023-04-23 11:58:11.876589600 +0100
@@ -14,8 +14,11 @@
  * This handles the memory map.
  * We handle pages at KSEG0 for kernels with 32 bit address space.
  */
-#define PAGE_OFFSET		0x94000000UL
-#define PHYS_OFFSET		0x14000000UL
+#define PAGE_OFFSET	_AC(0x94000000, UL)
+#define PHYS_OFFSET	_AC(0x14000000, UL)
+
+#define UNCAC_BASE	_AC(0xb4000000, UL)	/* 0xa0000000 + PHYS_OFFSET */
+#define IO_BASE		UNCAC_BASE
 
 #include <asm/mach-generic/spaces.h>
 
diff -ur ./arch/mips/include/asm/mach-generic/spaces.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-generic/spaces.h
--- ./arch/mips/include/asm/mach-generic/spaces.h	2023-04-26 12:56:04.190118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-generic/spaces.h	2023-04-23 11:58:13.633758500 +0100
@@ -25,8 +25,12 @@
 #else
 #define CAC_BASE		_AC(0x80000000, UL)
 #endif
+#ifndef IO_BASE
 #define IO_BASE			_AC(0xa0000000, UL)
+#endif
+#ifndef UNCAC_BASE
 #define UNCAC_BASE		_AC(0xa0000000, UL)
+#endif
 
 #ifndef MAP_BASE
 #ifdef CONFIG_KVM_GUEST
@@ -93,4 +97,19 @@
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
 
+#ifndef in_module
+/*
+ * If the Instruction Pointer is in module space (0xc0000000), return true;
+ * otherwise, it is in kernel space (0x80000000), return false.
+ *
+ * FIXME: This will not work when the kernel space and module space are the
+ * same. If they are the same, we need to modify scripts/recordmcount.pl,
+ * ftrace_make_nop/call() and the other related parts to ensure the
+ * enabling/disabling of the calling site to _mcount is right for both kernel
+ * and module.
+ *
+ */
+#define in_module(ip)   (((unsigned long)ip) & 0x40000000)
+#endif
+
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
diff -ur ./arch/mips/include/asm/mach-ip28/spaces.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-ip28/spaces.h
--- ./arch/mips/include/asm/mach-ip28/spaces.h	2023-04-26 12:56:04.190118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-ip28/spaces.h	2023-04-23 11:58:13.953784900 +0100
@@ -11,11 +11,14 @@
 #ifndef _ASM_MACH_IP28_SPACES_H
 #define _ASM_MACH_IP28_SPACES_H
 
-#define CAC_BASE		0xa800000000000000
+#define CAC_BASE	_AC(0xa800000000000000, UL)
 
-#define HIGHMEM_START		(~0UL)
+#define HIGHMEM_START	(~0UL)
 
-#define PHYS_OFFSET		_AC(0x20000000, UL)
+#define PHYS_OFFSET	_AC(0x20000000, UL)
+
+#define UNCAC_BASE	_AC(0xc0000000, UL)     /* 0xa0000000 + PHYS_OFFSET */
+#define IO_BASE		UNCAC_BASE
 
 #include <asm/mach-generic/spaces.h>
 
diff -ur ./arch/mips/include/asm/mach-malta/kernel-entry-init.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-malta/kernel-entry-init.h
--- ./arch/mips/include/asm/mach-malta/kernel-entry-init.h	2023-04-26 12:25:54.630119357 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-malta/kernel-entry-init.h	2023-04-23 11:58:15.474765500 +0100
@@ -4,11 +4,144 @@
  * for more details.
  *
  * Chris Dearman (chris@mips.com)
- * Copyright (C) 2007 Mips Technologies, Inc.
+ * Leonid Yegoshin (yegoshin@mips.com)
+ * Copyright (C) 2012 Mips Technologies, Inc.
  */
 #ifndef __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
 #define __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
 
+	.macro  eva_entry   t1  t2  t0
+	andi    \t1, 0x7    /* Config.K0 == CCA */
+	move    \t2, \t1
+	ins     \t2, \t1, 16, 3
+
+#ifdef CONFIG_EVA_OLD_MALTA_MAP
+
+#ifdef CONFIG_EVA_3GB
+	li      \t0, ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |            \
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |  \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |                \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	ins     \t0, \t1, 16, 3
+	mtc0    \t0, $5, 2
+#ifdef CONFIG_SMP
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#else
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(4 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#endif /* CONFIG_SMP */
+	or      \t0, \t2
+	mtc0    \t0, $5, 3
+#else /* !CONFIG_EVA_3GB */
+	li      \t0, ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |            \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |                \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	or      \t0, \t2
+	mtc0    \t0, $5, 2
+#ifdef CONFIG_SMP
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |  \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#else
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |  \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(4 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#endif /* CONFIG_SMP */
+	ins     \t0, \t1, 16, 3
+	mtc0    \t0, $5, 3
+#endif /* CONFIG_EVA_3GB */
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(6 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(4 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+
+#else /* !CONFIG_EVA_OLD_MALTA_MAP */
+
+#ifdef CONFIG_EVA_3GB
+	li      \t0, ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |            \
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |  \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |                \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	ins     \t0, \t1, 16, 3
+	mtc0    \t0, $5, 2
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |          \
+		(6 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(5 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	or      \t0, \t2
+	mtc0    \t0, $5, 3
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(3 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(1 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#else /* !CONFIG_EVA_3GB */
+	li      \t0, ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |            \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |                \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	or      \t0, \t2
+	mtc0    \t0, $5, 2
+	li      \t0, ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |            \
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |  \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |                \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+	ins     \t0, \t1, 16, 3
+	mtc0    \t0, $5, 3
+	li      \t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |         \
+		(2 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) |                              \
+		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |             \
+		(0 << MIPS_SEGCFG_PA_SHIFT) |                               \
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+#endif /* CONFIG_EVA_3GB */
+
+#endif /* CONFIG_EVA_OLD_MALTA_MAP */
+
+	or      \t0, \t2
+	mtc0    \t0, $5, 4
+	jal     mips_ihb
+
+	mfc0    \t0, $16, 5
+	li      \t2, 0x40000000      /* K bit */
+	or      \t0, \t0, \t2
+	mtc0    \t0, $16, 5
+	sync
+	jal	mips_ihb
+	.endm
+
+
 	.macro	kernel_entry_setup
 #ifdef CONFIG_MIPS_MT_SMTC
 	mfc0	t0, CP0_CONFIG
@@ -40,13 +173,65 @@
 	.asciz	"SMTC kernel requires the MT ASE to run\n"
 	__FINIT
 0:
-#endif
+#endif /* CONFIG_MIPS_MT_SMTC */
+
+#ifdef CONFIG_EVA
+	sync
+	ehb
+
+	mfc0    t1, CP0_CONFIG
+	bgez    t1, 9f
+	mfc0	t0, CP0_CONFIG, 1
+	bgez	t0, 9f
+	mfc0	t0, CP0_CONFIG, 2
+	bgez	t0, 9f
+	mfc0	t0, CP0_CONFIG, 3
+	sll     t0, t0, 6   /* SC bit */
+	bgez    t0, 9f
+
+	eva_entry t1 t2 t0
+	PTR_LA  t0, mips_cca
+	sw      t1, 0(t0)
+	b       0f
+
+9:
+	/* Assume we came from YAMON... */
+	PTR_LA	v0, 0x9fc00534	/* YAMON print */
+	lw	v0, (v0)
+	move	a0, zero
+	PTR_LA  a1, nonsc_processor
+	jal	v0
+
+	PTR_LA	v0, 0x9fc00520	/* YAMON exit */
+	lw	v0, (v0)
+	li	a0, 1
+	jal	v0
+
+1:	b	1b
+	nop
+
+	__INITDATA
+nonsc_processor:
+	.asciz  "Kernel requires the Segment/EVA to run\n"
+	__FINIT
+#endif /* CONFIG_EVA */
+
+0:
 	.endm
 
 /*
  * Do SMP slave processor setup necessary before we can safely execute C code.
  */
 	.macro	smp_slave_setup
+
+#ifdef CONFIG_EVA
+
+	sync
+	ehb
+	mfc0    t1, CP0_CONFIG
+	eva_entry   t1 t2 t0
+#endif /* CONFIG_EVA */
+
 	.endm
 
 #endif /* __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mach-malta: spaces.h
diff -ur ./arch/mips/include/asm/mips-boards/generic.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mips-boards/generic.h
--- ./arch/mips/include/asm/mips-boards/generic.h	2023-04-26 12:56:04.190118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mips-boards/generic.h	2023-04-23 11:58:17.398489500 +0100
@@ -24,12 +24,6 @@
 #define ASCII_DISPLAY_POS_BASE	   0x1f000418
 
 /*
- * Reset register.
- */
-#define SOFTRES_REG	  0x1f000500
-#define GORESET		  0x42
-
-/*
  * Revision register.
  */
 #define MIPS_REVISION_REG		   0x1fc00010
diff -ur ./arch/mips/include/asm/mipsregs.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mipsregs.h
--- ./arch/mips/include/asm/mipsregs.h	2023-04-26 12:56:04.190118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/mipsregs.h	2023-04-23 11:58:17.550782600 +0100
@@ -139,6 +139,12 @@
  * and should be written as zero.
  */
 #define FPU_CSR_RSVD	0x001c0000
+/* ... but FPU2 uses that bits */
+#define FPU_CSR_NAN2008 0x00040000
+#define FPU_CSR_ABS2008 0x00080000
+#define FPU_CSR_MAC2008 0x00100000
+
+#define FPU_CSR_DEFAULT 0x00000000
 
 /*
  * X the exception cause indicator
@@ -414,6 +420,7 @@
 #define ST0_BEV			0x00400000
 #define ST0_RE			0x02000000
 #define ST0_FR			0x04000000
+#define _ST0_FR                 (26)
 #define ST0_CU			0xf0000000
 #define ST0_CU0			0x10000000
 #define ST0_CU1			0x20000000
@@ -573,7 +580,9 @@
 #define MIPS_CONF1_IA		(_ULCAST_(7) << 16)
 #define MIPS_CONF1_IL		(_ULCAST_(7) << 19)
 #define MIPS_CONF1_IS		(_ULCAST_(7) << 22)
-#define MIPS_CONF1_TLBS		(_ULCAST_(63)<< 25)
+#define MIPS_CONF1_TLBS_SHIFT   (25)
+#define MIPS_CONF1_TLBS_SIZE    (6)
+#define MIPS_CONF1_TLBS         (_ULCAST_(63)<< MIPS_CONF1_TLBS_SHIFT)
 
 #define MIPS_CONF2_SA		(_ULCAST_(15)<<	 0)
 #define MIPS_CONF2_SL		(_ULCAST_(15)<<	 4)
@@ -587,28 +596,68 @@
 #define MIPS_CONF3_TL		(_ULCAST_(1) <<	 0)
 #define MIPS_CONF3_SM		(_ULCAST_(1) <<	 1)
 #define MIPS_CONF3_MT		(_ULCAST_(1) <<	 2)
+#define MIPS_CONF3_CDMM		(_ULCAST_(1) <<	 3)
 #define MIPS_CONF3_SP		(_ULCAST_(1) <<	 4)
 #define MIPS_CONF3_VINT		(_ULCAST_(1) <<	 5)
 #define MIPS_CONF3_VEIC		(_ULCAST_(1) <<	 6)
 #define MIPS_CONF3_LPA		(_ULCAST_(1) <<	 7)
+#define MIPS_CONF3_ITL		(_ULCAST_(1) <<	 8)
+#define MIPS_CONF3_CTXTC	(_ULCAST_(1) <<	 9)
 #define MIPS_CONF3_DSP		(_ULCAST_(1) << 10)
 #define MIPS_CONF3_DSP2P	(_ULCAST_(1) << 11)
 #define MIPS_CONF3_RXI		(_ULCAST_(1) << 12)
 #define MIPS_CONF3_ULRI		(_ULCAST_(1) << 13)
 #define MIPS_CONF3_ISA		(_ULCAST_(3) << 14)
-#define MIPS_CONF3_ISA_OE	(_ULCAST_(3) << 16)
+#define MIPS_CONF3_ISA_OE	(_ULCAST_(1) << 16)
+#define MIPS_CONF3_MCU		(_ULCAST_(1) << 17)
+#define MIPS_CONF3_MMAR		(_ULCAST_(7) << 18)
+#define MIPS_CONF3_IPLW		(_ULCAST_(3) << 21)
 #define MIPS_CONF3_VZ		(_ULCAST_(1) << 23)
+#define MIPS_CONF3_PW		(_ULCAST_(1) << 24)
+#define MIPS_CONF3_SC		(_ULCAST_(1) << 25)
+#define MIPS_CONF3_BI		(_ULCAST_(1) << 26)
+#define MIPS_CONF3_BP		(_ULCAST_(1) << 27)
+#define MIPS_CONF3_MSA		(_ULCAST_(1) << 28)
+#define MIPS_CONF3_CMGCR	(_ULCAST_(1) << 29)
+#define MIPS_CONF3_BPG		(_ULCAST_(1) << 30)
 
+#define MIPS_CONF4_MMUSIZEEXT_SHIFT	(0)
 #define MIPS_CONF4_MMUSIZEEXT	(_ULCAST_(255) << 0)
+#define MIPS_CONF4_FTLBSETS_SHIFT	(0)
+#define MIPS_CONF4_FTLBSETS	(_ULCAST_(15) << MIPS_CONF4_FTLBSETS_SHIFT)
+#define MIPS_CONF4_FTLBWAYS_SHIFT	(4)
+#define MIPS_CONF4_FTLBWAYS	(_ULCAST_(15) << MIPS_CONF4_FTLBWAYS_SHIFT)
+#define MIPS_CONF4_FTLBPAGESIZE_SHIFT	(8)
+#define MIPS_CONF4_FTLBPAGESIZE	(_ULCAST_(31) << MIPS_CONF4_FTLBPAGESIZE_SHIFT)
 #define MIPS_CONF4_MMUEXTDEF	(_ULCAST_(3) << 14)
 #define MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT (_ULCAST_(1) << 14)
 
+#define MIPS_CONF4_MMUEXTDEF_FTLBSIZEEXT	(_ULCAST_(2) << 14)
+#define MIPS_CONF4_MMUEXTDEF_VTLBSIZEEXT	(_ULCAST_(3) << 14)
+#define MIPS_CONF4_KSCREXIST	(_ULCAST_(255) << 16)
+#define MIPS_CONF4_VTLBSIZEEXT_SHIFT	(24)
+#define MIPS_CONF4_VTLBSIZEEXT	(_ULCAST_(15) << MIPS_CONF4_VTLBSIZEEXT_SHIFT)
+#define MIPS_CONF4_AE		(_ULCAST_(1) << 28)
+#define MIPS_CONF4_IE		(_ULCAST_(3) << 29)
+#define MIPS_CONF4_TLBINV	(_ULCAST_(2) << 29)
+
+#define MIPS_CONF5_EVA		(_ULCAST_(1) << 28)
+#define MIPS_CONF5_CV		(_ULCAST_(1) << 29)
+#define MIPS_CONF5_K		(_ULCAST_(1) << 30)
+
+#define MIPS_CONF6_JRCD		(_ULCAST_(1) << 0)
+#define MIPS_CONF6_JRCP		(_ULCAST_(1) << 1)
 #define MIPS_CONF6_SYND		(_ULCAST_(1) << 13)
+#define MIPS_CONF6_SPCD		(_ULCAST_(1) << 14)
+#define MIPS_CONF6_FTLBEN       (_ULCAST_(1) << 15)
 
 #define MIPS_CONF7_WII		(_ULCAST_(1) << 31)
-
+#define MIPS_CONF7_AR		(_ULCAST_(1) << 16)
+#define MIPS_CONF7_IAR		(_ULCAST_(1) << 10)
 #define MIPS_CONF7_RPS		(_ULCAST_(1) << 2)
 
+/*  EntryHI bit definition */
+#define MIPS_EHINV		(_ULCAST_(1) << 10)
 
 /*
  * Bits in the MIPS32/64 coprocessor 1 (FPU) revision register.
@@ -620,6 +669,32 @@
 #define MIPS_FPIR_W		(_ULCAST_(1) << 20)
 #define MIPS_FPIR_L		(_ULCAST_(1) << 21)
 #define MIPS_FPIR_F64		(_ULCAST_(1) << 22)
+/* additional bits in MIPS32/64 coprocessor 2 (FPU) */
+#define MIPS_FPIR_HAS2008       (_ULCAST_(1) << 23)
+#define MIPS_FPIR_FC            (_ULCAST_(1) << 24)
+
+/*
+ * Bits in the MIPS32 Memory Segmentation registers.
+ */
+#define MIPS_SEGCFG_PA_SHIFT	9
+#define MIPS_SEGCFG_PA		(_ULCAST_(127) << MIPS_SEGCFG_PA_SHIFT)
+#define MIPS_SEGCFG_AM_SHIFT	4
+#define MIPS_SEGCFG_AM		(_ULCAST_(7) << MIPS_SEGCFG_AM_SHIFT)
+#define MIPS_SEGCFG_EU_SHIFT	3
+#define MIPS_SEGCFG_EU		(_ULCAST_(1) << MIPS_SEGCFG_EU_SHIFT)
+#define MIPS_SEGCFG_C_SHIFT	0
+#define MIPS_SEGCFG_C		(_ULCAST_(7) << MIPS_SEGCFG_C_SHIFT)
+
+#define MIPS_SEGCFG_UUSK	_ULCAST_(7)
+#define MIPS_SEGCFG_USK		_ULCAST_(5)
+#define MIPS_SEGCFG_MUSUK	_ULCAST_(4)
+#define MIPS_SEGCFG_MUSK	_ULCAST_(3)
+#define MIPS_SEGCFG_MSK		_ULCAST_(2)
+#define MIPS_SEGCFG_MK		_ULCAST_(1)
+#define MIPS_SEGCFG_UK		_ULCAST_(0)
+
+/* ebase register bit definition */
+#define MIPS_EBASE_WG           _ULCAST_(11)
 
 #ifndef __ASSEMBLY__
 
@@ -930,6 +1005,7 @@
 #define write_c0_epc(val)	__write_ulong_c0_register($14, 0, val)
 
 #define read_c0_prid()		__read_32bit_c0_register($15, 0)
+#define read_c0_cmgcrbase()     __read_ulong_c0_register($15, 3)
 
 #define read_c0_config()	__read_32bit_c0_register($16, 0)
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
@@ -1095,6 +1171,15 @@
 #define read_c0_ebase()		__read_32bit_c0_register($15, 1)
 #define write_c0_ebase(val)	__write_32bit_c0_register($15, 1, val)
 
+/* MIPSR3 */
+#define read_c0_segctl0()	__read_32bit_c0_register($5, 2)
+#define write_c0_segctl0(val)	__write_32bit_c0_register($5, 2, val)
+
+#define read_c0_segctl1()	__read_32bit_c0_register($5, 3)
+#define write_c0_segctl1(val)	__write_32bit_c0_register($5, 3, val)
+
+#define read_c0_segctl2()	__read_32bit_c0_register($5, 4)
+#define write_c0_segctl2(val)	__write_32bit_c0_register($5, 4, val)
 
 /* Cavium OCTEON (cnMIPS) */
 #define read_c0_cvmcount()	__read_ulong_c0_register($9, 6)
@@ -1179,6 +1264,22 @@
 	__res;								\
 })
 
+#define write_32bit_cp1_register(dest,value)                            \
+({									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	reorder					\n"	\
+	"	# gas fails to assemble cfc1 for some archs,	\n"	\
+	"	# like Octeon.					\n"	\
+	"	.set	mips1					\n"	\
+	"       ctc1    %0,"STR(dest)"                          \n"     \
+	"	.set	pop					\n"	\
+	:: "r" (value));                                                \
+})
+
+/*
+ * Macros to access the DSP ASE registers
+ */
 #ifdef HAVE_AS_DSP
 #define rddsp(mask)							\
 ({									\
@@ -1399,6 +1500,7 @@
 									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	# rddsp $1, %x1					\n"	\
 	"	.hword	((0x0020067c | (%x1 << 14)) >> 16)	\n"	\
@@ -1414,6 +1516,7 @@
 do {									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	move	$1, %0					\n"	\
 	"	# wrdsp $1, %x1					\n"	\
@@ -1430,6 +1533,7 @@
 									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	.hword	0x0001					\n"	\
 	"	.hword	%x1					\n"	\
@@ -1444,6 +1548,7 @@
 do {									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	move	$1, %0					\n"	\
 	"	.hword	0x0001					\n"	\
@@ -1486,6 +1591,7 @@
 									\
 	__asm__ __volatile__(						\
 	"	.set	push				\n"		\
+	"	.set	dsp				\n"		\
 	"	.set	noat				\n"		\
 	"	# rddsp $1, %x1				\n"		\
 	"	.word	0x7c000cb8 | (%x1 << 16)	\n"		\
@@ -1500,6 +1606,7 @@
 do {									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	move	$1, %0					\n"	\
 	"	# wrdsp $1, %x1					\n"	\
@@ -1515,6 +1622,7 @@
 									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	.word	(0x00000810 | %1)			\n"	\
 	"	move	%0, $1					\n"	\
@@ -1528,6 +1636,7 @@
 do {									\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
+	"	.set	dsp					\n"	\
 	"	.set	noat					\n"	\
 	"	move	$1, %0					\n"	\
 	"	.word	(0x00200011 | %1)			\n"	\
@@ -1631,6 +1740,15 @@
 		".set reorder");
 }
 
+static inline void tlbinvf(void)
+{
+	__asm__ __volatile__(
+		".set push\n\t"
+		".set noreorder\n\t"
+		".word 0x42000004\n\t"
+		".set pop");
+}
+
 /*
  * Manipulate bits in a c0 register.
  */
Only in ./arch/mips/include/asm: mutex.h
diff -ur ./arch/mips/include/asm/octeon/cvmx-bootinfo.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/octeon/cvmx-bootinfo.h
--- ./arch/mips/include/asm/octeon/cvmx-bootinfo.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/octeon/cvmx-bootinfo.h	2023-04-23 11:58:18.201369000 +0100
@@ -227,6 +227,7 @@
 	 * use any numbers in this range.
 	 */
 	CVMX_BOARD_TYPE_CUST_PRIVATE_MIN = 20001,
+	CVMX_BOARD_TYPE_UBNT_E100 = 20002,
 	CVMX_BOARD_TYPE_CUST_PRIVATE_MAX = 30000,
 
 	/* The remaining range is reserved for future use. */
@@ -325,6 +326,7 @@
 
 		    /* Customer private range */
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MIN)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_UBNT_E100)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MAX)
 	}
 	return "Unsupported Board";
diff -ur ./arch/mips/include/asm/octeon/octeon.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/octeon/octeon.h
--- ./arch/mips/include/asm/octeon/octeon.h	2023-04-26 12:25:54.750119433 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/octeon/octeon.h	2023-04-23 11:58:19.632018200 +0100
@@ -251,4 +251,6 @@
 typedef void (*octeon_irq_ip4_handler_t)(void);
 void octeon_irq_set_ip4_handler(octeon_irq_ip4_handler_t);
 
+extern void octeon_fixup_irqs(void);
+
 #endif /* __ASM_OCTEON_OCTEON_H */
diff -ur ./arch/mips/include/asm/page.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/page.h
--- ./arch/mips/include/asm/page.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/page.h	2023-04-23 11:58:19.629789900 +0100
@@ -33,6 +33,9 @@
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
 #define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
 
+/* this is used for calculation of real page sizes and should be the same */
+#define BASIC_PAGE_SHIFT    12
+
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
 #define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)
@@ -70,13 +73,16 @@
 
 struct page;
 
+#include <asm/cpu-features.h>
+
 static inline void clear_user_page(void *addr, unsigned long vaddr,
 	struct page *page)
 {
 	extern void (*flush_data_cache_page)(unsigned long addr);
 
 	clear_page(addr);
-	if (pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK))
+	if (cpu_has_vtag_dcache || (cpu_has_dc_aliases &&
+	     pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK)))
 		flush_data_cache_page((unsigned long)addr);
 }
 
@@ -165,7 +171,9 @@
  * https://patchwork.linux-mips.org/patch/1541/
  */
 
-#define __pa_symbol(x)	__pa(RELOC_HIDE((unsigned long)(x), 0))
+#ifndef __pa_symbol
+#define __pa_symbol(x)  __pa(RELOC_HIDE((unsigned long)(x), 0))
+#endif
 
 #define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 
@@ -202,13 +210,13 @@
 #define virt_addr_valid(kaddr)						\
 	__virt_addr_valid((const volatile void *) (kaddr))
 
-#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_STACK_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE +	\
-								PHYS_OFFSET)
-#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET -	\
-								PHYS_OFFSET)
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
+#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>
Only in ./arch/mips/include/asm: parport.h
Only in ./arch/mips/include/asm: percpu.h
diff -ur ./arch/mips/include/asm/pgtable-32.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable-32.h
--- ./arch/mips/include/asm/pgtable-32.h	2023-04-26 12:25:54.750119433 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable-32.h	2023-04-23 11:58:19.794110700 +0100
@@ -51,11 +51,13 @@
 
 #define PKMAP_BASE		(0xfe000000UL)
 
+#ifndef VMALLOC_END
 #ifdef CONFIG_HIGHMEM
 # define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
 #else
 # define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
 #endif
+#endif
 
 #ifdef CONFIG_64BIT_PHYS_ADDR
 #define pte_ERROR(e) \
diff -ur ./arch/mips/include/asm/pgtable-bits.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable-bits.h
--- ./arch/mips/include/asm/pgtable-bits.h	2023-04-26 12:25:54.760119439 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable-bits.h	2023-04-23 11:58:19.792680400 +0100
@@ -32,7 +32,32 @@
  * unpredictable things.  The code (when it is written) to deal with
  * this problem will be in the update_mmu_cache() code for the r4k.
  */
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+
+#if defined(CONFIG_JZRISC_PEP) && defined(CONFIG_CPU_MIPS32)
+#define _PAGE_PRESENT_SHIFT	0
+#define _PAGE_PRESENT		(1 << _PAGE_PRESENT_SHIFT)
+#define _PAGE_READ_SHIFT	1
+#define _PAGE_READ 		(1 << _PAGE_READ_SHIFT)
+#define _PAGE_WRITE_SHIFT	2
+#define _PAGE_WRITE		(1 << _PAGE_WRITE_SHIFT)
+#define _PAGE_ACCESSED_SHIFT	3
+#define _PAGE_ACCESSED		(1 << _PAGE_ACCESSED_SHIFT)
+#define _PAGE_MODIFIED_SHIFT	4
+#define _PAGE_MODIFIED		(1 << _PAGE_MODIFIED_SHIFT)
+#define _PAGE_FILE		(1 << 4)
+#define _PAGE_NO_EXEC		(1 << 5)
+#define _PAGE_GLOBAL		(1 << 6)
+#define _PAGE_VALID_SHIFT	7
+#define _PAGE_VALID		(1 << _PAGE_VALID_SHIFT)
+#define _PAGE_SILENT_READ	(1 << 7)
+#define _PAGE_DIRTY_SHIFT	8
+#define _PAGE_DIRTY		(1 << _PAGE_DIRTY_SHIFT)
+#define _PAGE_SILENT_WRITE	(1 << 8)
+#define _CACHE_SHIFT		(9)
+#define _CACHE_MASK		(7 << _CACHE_SHIFT)
+#define _PFN_SHIFT		(PAGE_SHIFT - 12 + _CACHE_SHIFT + 3)
+
+#elif defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
 
 /*
  * The following bits are directly used by the TLB hardware
@@ -102,6 +127,8 @@
 #define _CACHE_MASK		(1 << _CACHE_UNCACHED_SHIFT)
 
 #else /* 'Normal' r4K case */
+
+#ifndef CONFIG_CPU_MIPSR2
 /*
  * When using the RI/XI bit support, we have 13 bits of flags below
  * the physical address. The RI/XI bits are placed such that a SRL 5
@@ -154,7 +181,150 @@
 #define _PAGE_NO_READ_SHIFT	(cpu_has_rixi ? _PAGE_NO_EXEC_SHIFT + 1 : _PAGE_NO_EXEC_SHIFT)
 #define _PAGE_NO_READ		({BUG_ON(!cpu_has_rixi); 1 << _PAGE_NO_READ_SHIFT; })
 
-#define _PAGE_GLOBAL_SHIFT	(_PAGE_NO_READ_SHIFT + 1)
+#else /* CONFIG_CPU_MIPSR2 */
+
+/* static bits allocation in MIPS R2, two variants -
+   HUGE TLB in 64BIT kernel support or not.
+   RIXI support in both */
+
+#ifdef CONFIG_64BIT
+
+/*
+ * Low bits are: CCC D V G RI XI [S H] M A W R P
+ * TLB refill will do a ROTR 7/9 (in case of cpu_has_rixi),
+ * or SRL/DSRL 7/9 to strip low bits.
+ * PFN size in high bits is 49 or 51 bit --> 512TB or 4*512TB for 4KB pages
+ */
+
+#define _PAGE_PRESENT_SHIFT     (0)
+#define _PAGE_PRESENT		(1 << _PAGE_PRESENT_SHIFT)
+/* implemented in software, should be unused if cpu_has_rixi. */
+#define _PAGE_READ_SHIFT        (_PAGE_PRESENT_SHIFT + 1)
+#define _PAGE_READ              (1 << _PAGE_READ_SHIFT)
+/* implemented in software */
+#define _PAGE_WRITE_SHIFT	(_PAGE_READ_SHIFT + 1)
+#define _PAGE_WRITE		(1 << _PAGE_WRITE_SHIFT)
+/* implemented in software */
+#define _PAGE_ACCESSED_SHIFT	(_PAGE_WRITE_SHIFT + 1)
+#define _PAGE_ACCESSED		(1 << _PAGE_ACCESSED_SHIFT)
+/* implemented in software */
+#define _PAGE_MODIFIED_SHIFT	(_PAGE_ACCESSED_SHIFT + 1)
+#define _PAGE_MODIFIED		(1 << _PAGE_MODIFIED_SHIFT)
+/* set:pagecache unset:swap */
+#define _PAGE_FILE		(_PAGE_MODIFIED)
+
+#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
+/* huge tlb page */
+#define _PAGE_HUGE_SHIFT	(_PAGE_MODIFIED_SHIFT + 1)
+#define _PAGE_HUGE		(1 << _PAGE_HUGE_SHIFT)
+#define _PAGE_SPLITTING_SHIFT	(_PAGE_HUGE_SHIFT + 1)
+#define _PAGE_SPLITTING		(1 << _PAGE_SPLITTING_SHIFT)
+#else
+#define _PAGE_HUGE_SHIFT	(_PAGE_MODIFIED_SHIFT)
+#define _PAGE_HUGE		({BUG(); 1; })	/* Dummy value */
+#define _PAGE_SPLITTING_SHIFT	(_PAGE_HUGE_SHIFT)
+#define _PAGE_SPLITTING		({BUG(); 1; })	/* Dummy value */
+#endif /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
+
+/* Page cannot be executed */
+#define _PAGE_NO_EXEC_SHIFT     (_PAGE_SPLITTING_SHIFT + 1)
+#define _PAGE_NO_EXEC           (1 << _PAGE_NO_EXEC_SHIFT)
+
+/* Page cannot be read */
+#define _PAGE_NO_READ_SHIFT     (_PAGE_NO_EXEC_SHIFT + 1)
+#define _PAGE_NO_READ           (1 << _PAGE_NO_READ_SHIFT)
+
+#else /* !CONFIG_64BIT */
+
+#ifndef CONFIG_MIPS_HUGE_TLB_SUPPORT
+
+/*
+ * No HUGE page support
+ * Low bits are: CCC D V G RI(=R) XI M A W P
+ * TLB refill will do a ROTR 6 (in case of cpu_has_rixi),
+ * or SRL 6 to strip low bits.
+ * All 20 bits PFN are preserved in high bits (4GB in 4KB pages)
+ */
+
+#define _PAGE_PRESENT_SHIFT     (0)
+#define _PAGE_PRESENT		(1 << _PAGE_PRESENT_SHIFT)
+/* implemented in software */
+#define _PAGE_WRITE_SHIFT       (_PAGE_PRESENT_SHIFT + 1)
+#define _PAGE_WRITE		(1 << _PAGE_WRITE_SHIFT)
+/* implemented in software */
+#define _PAGE_ACCESSED_SHIFT	(_PAGE_WRITE_SHIFT + 1)
+#define _PAGE_ACCESSED		(1 << _PAGE_ACCESSED_SHIFT)
+/* implemented in software */
+#define _PAGE_MODIFIED_SHIFT	(_PAGE_ACCESSED_SHIFT + 1)
+#define _PAGE_MODIFIED		(1 << _PAGE_MODIFIED_SHIFT)
+/* set:pagecache unset:swap */
+#define _PAGE_FILE		(_PAGE_MODIFIED)
+
+/* huge tlb page dummies */
+#define _PAGE_HUGE_SHIFT	(_PAGE_MODIFIED_SHIFT)
+#define _PAGE_HUGE		({BUG(); 1; })	/* Dummy value */
+#define _PAGE_SPLITTING_SHIFT	(_PAGE_HUGE_SHIFT)
+#define _PAGE_SPLITTING		({BUG(); 1; })	/* Dummy value */
+
+/* Page cannot be executed */
+#define _PAGE_NO_EXEC_SHIFT     (_PAGE_SPLITTING_SHIFT + 1)
+#define _PAGE_NO_EXEC           (1 << _PAGE_NO_EXEC_SHIFT)
+
+/* Page cannot be read */
+#define _PAGE_NO_READ_SHIFT     (_PAGE_NO_EXEC_SHIFT + 1)
+#define _PAGE_NO_READ           (1 << _PAGE_NO_READ_SHIFT)
+
+/* implemented in software, should be unused if cpu_has_rixi. */
+#define _PAGE_READ_SHIFT        (_PAGE_NO_READ_SHIFT)
+#define _PAGE_READ              (1 << _PAGE_READ_SHIFT)
+
+#else /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
+
+/*
+ * Low bits are: CCC D V G S H M A W R P
+ * No RIXI is enforced
+ * TLB refill will do a SRL 7,
+ * only 19 bits PFN are preserved in high bits (2GB in 4KB pages)
+ */
+
+#define _PAGE_PRESENT_SHIFT     (0)
+#define _PAGE_PRESENT		(1 << _PAGE_PRESENT_SHIFT)
+/* implemented in software */
+#define _PAGE_READ_SHIFT        (_PAGE_PRESENT_SHIFT + 1)
+#define _PAGE_READ              (1 << _PAGE_READ_SHIFT)
+/* implemented in software */
+#define _PAGE_WRITE_SHIFT       (_PAGE_READ_SHIFT + 1)
+#define _PAGE_WRITE		(1 << _PAGE_WRITE_SHIFT)
+/* implemented in software */
+#define _PAGE_ACCESSED_SHIFT	(_PAGE_WRITE_SHIFT + 1)
+#define _PAGE_ACCESSED		(1 << _PAGE_ACCESSED_SHIFT)
+/* implemented in software */
+#define _PAGE_MODIFIED_SHIFT	(_PAGE_ACCESSED_SHIFT + 1)
+#define _PAGE_MODIFIED		(1 << _PAGE_MODIFIED_SHIFT)
+/* set:pagecache unset:swap */
+#define _PAGE_FILE		(_PAGE_MODIFIED)
+
+/* huge tlb page... but no HUGE page support in MIPS32 yet */
+#define _PAGE_HUGE_SHIFT	(_PAGE_MODIFIED_SHIFT + 1)
+#define _PAGE_HUGE		(1 << _PAGE_HUGE_SHIFT)
+#define _PAGE_SPLITTING_SHIFT	(_PAGE_HUGE_SHIFT + 1)
+#define _PAGE_SPLITTING		(1 << _PAGE_SPLITTING_SHIFT)
+
+/* Page cannot be executed */
+#define _PAGE_NO_EXEC_SHIFT     (_PAGE_SPLITTING_SHIFT)
+#define _PAGE_NO_EXEC           ({BUG(); 1; })  /* Dummy value */
+/* Page cannot be read */
+#define _PAGE_NO_READ_SHIFT     (_PAGE_NO_EXEC_SHIFT)
+#define _PAGE_NO_READ           ({BUG(); 1; })  /* Dummy value */
+
+#endif /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
+
+#endif /* CONFIG_64BIT */
+
+#endif /* !CONFIG_CPU_MIPSR2 */
+
+
+#define _PAGE_GLOBAL_SHIFT      (_PAGE_NO_READ_SHIFT + 1)
 #define _PAGE_GLOBAL		(1 << _PAGE_GLOBAL_SHIFT)
 
 #define _PAGE_VALID_SHIFT	(_PAGE_GLOBAL_SHIFT + 1)
diff -ur ./arch/mips/include/asm/pgtable.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable.h
--- ./arch/mips/include/asm/pgtable.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/pgtable.h	2023-04-23 11:58:19.875368100 +0100
@@ -336,6 +336,15 @@
 	return __pgprot(prot);
 }
 
+static inline pgprot_t pgprot_noncached_wa(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot = (prot & ~_CACHE_MASK) | _CACHE_CACHABLE_WA;
+
+	return __pgprot(prot);
+}
+
 /*
  * Conversion functions: convert a page and protection to a page entry,
  * and a page entry and page directory to the page they refer to.
diff -ur ./arch/mips/include/asm/processor.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/processor.h
--- ./arch/mips/include/asm/processor.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/processor.h	2023-04-23 11:58:19.873960900 +0100
@@ -96,9 +96,13 @@
 
 
 #define NUM_FPU_REGS	32
+#define NUM_MXU_REGS	16
 
 typedef __u64 fpureg_t;
 
+struct xburst_mxu_struct {
+	unsigned int regs[NUM_MXU_REGS];
+};
 /*
  * It would be nice to add some more fields for emulator statistics, but there
  * are a number of fixed offsets in offset.h and elsewhere that would have to
@@ -191,6 +195,24 @@
 
 #endif
 
+#ifdef CONFIG_MACH_XBURST
+typedef union {
+	u64 val64[2];
+} vpr_t;
+
+struct xburst_cop2_state {
+	u32 mxu_csr;
+	vpr_t vr[32];
+};
+#endif
+
+#ifdef CONFIG_PMON_DEBUG
+struct xburst_perf_cnt {
+	u32 perfctrl;
+	u64 perfcnt;
+};
+#endif
+
 typedef struct {
 	unsigned long seg;
 } mm_segment_t;
@@ -223,6 +245,16 @@
 	/* Saved state of the DSP ASE, if available. */
 	struct mips_dsp_state dsp;
 
+	/* Saved registers of the MXU, if available. */
+	struct xburst_mxu_struct mxu;
+
+	/* for magicode cpuinfo */
+#define CPU_MIPS             0
+#define CPU_ARM              1
+#define CPU_ARM_NEON         2
+	unsigned int mcflags;
+
+
 	/* Saved watch register state, if available. */
 	union mips_watch_reg_state watch;
 
@@ -234,6 +266,12 @@
     struct octeon_cop2_state cp2 __attribute__ ((__aligned__(128)));
     struct octeon_cvmseg_state cvmseg __attribute__ ((__aligned__(128)));
 #endif
+#ifdef CONFIG_MACH_XBURST
+	struct xburst_cop2_state cp2;
+#endif
+#ifdef CONFIG_PMON_DEBUG
+	struct xburst_perf_cnt pfc[2];
+#endif
 	struct mips_abi *abi;
 };
 
@@ -246,12 +284,22 @@
 #endif /* CONFIG_MIPS_MT_FPAFF */
 
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
-#define OCTEON_INIT						\
+#define COP2_INIT						\
 	.cp2			= INIT_OCTEON_COP2,
+#elif defined(CONFIG_MACH_XBURST)
+#define COP2_INIT						\
+	.cp2			= {0},
 #else
-#define OCTEON_INIT
+#define COP2_INIT
 #endif /* CONFIG_CPU_CAVIUM_OCTEON */
 
+#ifdef CONFIG_PMON_DEBUG
+#define PFC_INIT						\
+	.pfc			= {{0, 0}, {0, 0}},
+#else
+#define PFC_INIT
+#endif /* CONFIG_MACH_XBURST */
+
 #define INIT_THREAD  {						\
 	/*							\
 	 * Saved main processor registers			\
@@ -302,7 +350,8 @@
 	/*							\
 	 * Cavium Octeon specifics (null if not Octeon)		\
 	 */							\
-	OCTEON_INIT						\
+	COP2_INIT						\
+	PFC_INIT						\
 }
 
 struct task_struct;
diff -ur ./arch/mips/include/asm/r4kcache.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/r4kcache.h
--- ./arch/mips/include/asm/r4kcache.h	2023-04-26 12:25:54.760119439 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/r4kcache.h	2023-04-23 11:58:19.950959600 +0100
@@ -16,7 +16,30 @@
 #include <asm/cacheops.h>
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
+#include <asm/uaccess.h>
 
+#ifdef CONFIG_JZRISC
+
+#define INVALIDATE_BTB()			\
+do {						\
+	unsigned long tmp;			\
+	__asm__ __volatile__(			\
+	"	.set mips32		\n"	\
+	"	mfc0 %0, $16, 7		\n"	\
+	"	nop			\n"	\
+	"	ori %0, 2		\n"	\
+	"	mtc0 %0, $16, 7		\n"	\
+	"	nop			\n"	\
+	: "=&r" (tmp));				\
+} while (0)
+#define SYNC_WB() __sync()
+
+#else /* CONFIG_JZRISC */
+
+#define INVALIDATE_BTB() do { } while (0)
+#define SYNC_WB() do { } while (0)
+
+#endif /* CONFIG_JZRISC */
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -28,7 +51,9 @@
  *  - We need a properly sign extended address for 64-bit code.	 To get away
  *    without ifdefs we let the compiler do it by a type cast.
  */
-#define INDEX_BASE	CKSEG0
+#ifndef INDEX_BASE
+#define INDEX_BASE      CKSEG0
+#endif
 
 #define cache_op(op,addr)						\
 	__asm__ __volatile__(						\
@@ -127,6 +152,19 @@
 
 #else /* CONFIG_MIPS_MT */
 
+#ifdef CONFIG_JZRISC
+#define __iflush_prologue
+#define __iflush_epilogue	INVALIDATE_BTB();
+#define __dflush_prologue
+#define __dflush_epilogue	SYNC_WB();
+#define __inv_dflush_prologue
+#define __inv_dflush_epilogue	SYNC_WB();
+#define __sflush_prologue {
+#define __sflush_epilogue }
+#define __inv_sflush_prologue {
+#define __inv_sflush_epilogue }
+
+#else
 #define __iflush_prologue {
 #define __iflush_epilogue }
 #define __dflush_prologue {
@@ -138,6 +176,8 @@
 #define __inv_sflush_prologue {
 #define __inv_sflush_epilogue }
 
+#endif /* !CONFIG_JZRISC */
+
 #endif /* CONFIG_MIPS_MT */
 
 static inline void flush_icache_line_indexed(unsigned long addr)
@@ -203,12 +243,34 @@
 	:							\
 	: "i" (op), "r" (addr))
 
+#ifdef CONFIG_EVA
+#define protected_cachee_op(op,addr)                            \
+	__asm__ __volatile__(					\
+	"	.set	push			\n"		\
+	"	.set	noreorder		\n"		\
+	"       .set    eva                     \n"             \
+	"1:     cachee  %0, (%1)                \n"             \
+	"2:	.set	pop			\n"		\
+	"	.section __ex_table,\"a\"	\n"		\
+	"	"STR(PTR)" 1b, 2b		\n"		\
+	"	.previous"					\
+	:							\
+	: "i" (op), "r" (addr))
+#endif
+
 /*
  * The next two are for badland addresses like signal trampolines.
  */
 static inline void protected_flush_icache_line(unsigned long addr)
 {
+#ifndef CONFIG_EVA
 	protected_cache_op(Hit_Invalidate_I, addr);
+#else
+	protected_cachee_op(Hit_Invalidate_I, addr);
+#endif
+#ifdef CONFIG_JZRISC
+	INVALIDATE_BTB();
+#endif
 }
 
 /*
@@ -219,7 +281,14 @@
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
+#ifndef CONFIG_EVA
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
+#else
+	protected_cachee_op(Hit_Writeback_Inv_D, addr);
+#endif
+#ifdef CONFIG_JZRISC
+	SYNC_WB();
+#endif
 }
 
 static inline void protected_writeback_scache_line(unsigned long addr)
@@ -339,6 +408,112 @@
 		: "r" (base),						\
 		  "i" (op));
 
+#ifdef CONFIG_EVA
+#define cache16_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x010(%0)      \n"     \
+	"       cachee %1, 0x020(%0); cachee %1, 0x030(%0)      \n"     \
+	"       cachee %1, 0x040(%0); cachee %1, 0x050(%0)      \n"     \
+	"       cachee %1, 0x060(%0); cachee %1, 0x070(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x090(%0)      \n"     \
+	"       cachee %1, 0x0a0(%0); cachee %1, 0x0b0(%0)      \n"     \
+	"       cachee %1, 0x0c0(%0); cachee %1, 0x0d0(%0)      \n"     \
+	"       cachee %1, 0x0e0(%0); cachee %1, 0x0f0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x110(%0)      \n"     \
+	"       cachee %1, 0x120(%0); cachee %1, 0x130(%0)      \n"     \
+	"       cachee %1, 0x140(%0); cachee %1, 0x150(%0)      \n"     \
+	"       cachee %1, 0x160(%0); cachee %1, 0x170(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x190(%0)      \n"     \
+	"       cachee %1, 0x1a0(%0); cachee %1, 0x1b0(%0)      \n"     \
+	"       cachee %1, 0x1c0(%0); cachee %1, 0x1d0(%0)      \n"     \
+	"       cachee %1, 0x1e0(%0); cachee %1, 0x1f0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache32_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x020(%0)      \n"     \
+	"       cachee %1, 0x040(%0); cachee %1, 0x060(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x0a0(%0)      \n"     \
+	"       cachee %1, 0x0c0(%0); cachee %1, 0x0e0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x120(%0)      \n"     \
+	"       cachee %1, 0x140(%0); cachee %1, 0x160(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x1a0(%0)      \n"     \
+	"       cachee %1, 0x1c0(%0); cachee %1, 0x1e0(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x220(%0)      \n"     \
+	"       cachee %1, 0x240(%0); cachee %1, 0x260(%0)      \n"     \
+	"       cachee %1, 0x280(%0); cachee %1, 0x2a0(%0)      \n"     \
+	"       cachee %1, 0x2c0(%0); cachee %1, 0x2e0(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x320(%0)      \n"     \
+	"       cachee %1, 0x340(%0); cachee %1, 0x360(%0)      \n"     \
+	"       cachee %1, 0x380(%0); cachee %1, 0x3a0(%0)      \n"     \
+	"       cachee %1, 0x3c0(%0); cachee %1, 0x3e0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache64_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x040(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x0c0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x140(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x1c0(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x240(%0)      \n"     \
+	"       cachee %1, 0x280(%0); cachee %1, 0x2c0(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x340(%0)      \n"     \
+	"       cachee %1, 0x380(%0); cachee %1, 0x3c0(%0)      \n"     \
+	"       cachee %1, 0x400(%0); cachee %1, 0x440(%0)      \n"     \
+	"       cachee %1, 0x480(%0); cachee %1, 0x4c0(%0)      \n"     \
+	"       cachee %1, 0x500(%0); cachee %1, 0x540(%0)      \n"     \
+	"       cachee %1, 0x580(%0); cachee %1, 0x5c0(%0)      \n"     \
+	"       cachee %1, 0x600(%0); cachee %1, 0x640(%0)      \n"     \
+	"       cachee %1, 0x680(%0); cachee %1, 0x6c0(%0)      \n"     \
+	"       cachee %1, 0x700(%0); cachee %1, 0x740(%0)      \n"     \
+	"       cachee %1, 0x780(%0); cachee %1, 0x7c0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache128_unroll32_user(base,op)                                 \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x080(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x180(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x280(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x380(%0)      \n"     \
+	"       cachee %1, 0x400(%0); cachee %1, 0x480(%0)      \n"     \
+	"       cachee %1, 0x500(%0); cachee %1, 0x580(%0)      \n"     \
+	"       cachee %1, 0x600(%0); cachee %1, 0x680(%0)      \n"     \
+	"       cachee %1, 0x700(%0); cachee %1, 0x780(%0)      \n"     \
+	"       cachee %1, 0x800(%0); cachee %1, 0x880(%0)      \n"     \
+	"       cachee %1, 0x900(%0); cachee %1, 0x980(%0)      \n"     \
+	"       cachee %1, 0xa00(%0); cachee %1, 0xa80(%0)      \n"     \
+	"       cachee %1, 0xb00(%0); cachee %1, 0xb80(%0)      \n"     \
+	"       cachee %1, 0xc00(%0); cachee %1, 0xc80(%0)      \n"     \
+	"       cachee %1, 0xd00(%0); cachee %1, 0xd80(%0)      \n"     \
+	"       cachee %1, 0xe00(%0); cachee %1, 0xe80(%0)      \n"     \
+	"       cachee %1, 0xf00(%0); cachee %1, 0xf80(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+#endif
+
 /* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
 #define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
 static inline void blast_##pfx##cache##lsize(void)			\
@@ -411,6 +586,33 @@
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
 
+#ifdef CONFIG_EVA
+
+#define __BUILD_BLAST_USER_CACHE(pfx, desc, indexop, hitop, lsize) \
+static inline void blast_##pfx##cache##lsize##_user_page(unsigned long page) \
+{									\
+	unsigned long start = page;					\
+	unsigned long end = page + PAGE_SIZE;				\
+									\
+	__##pfx##flush_prologue						\
+									\
+	do {								\
+		cache##lsize##_unroll32_user(start, hitop);             \
+		start += lsize * 32;					\
+	} while (start < end);						\
+									\
+	__##pfx##flush_epilogue						\
+}
+
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
+
+#endif
+
 /* build blast_xxx_range, protected_blast_xxx_range */
 #define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
@@ -423,7 +625,7 @@
 	__##pfx##flush_prologue						\
 									\
 	while (1) {							\
-		prot##cache_op(hitop, addr);				\
+		prot##cache_op(hitop, addr);                            \
 		if (addr == aend)					\
 			break;						\
 		addr += lsize;						\
@@ -432,10 +634,49 @@
 	__##pfx##flush_epilogue						\
 }
 
+#ifndef CONFIG_EVA
+
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
 __BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
+
+#else
+
+#define __BUILD_PROT_BLAST_CACHE_RANGE(pfx, desc, hitop)                \
+static inline void protected_blast_##pfx##cache##_range(unsigned long start, \
+						    unsigned long end)	\
+{									\
+	unsigned long lsize = cpu_##desc##_line_size();			\
+	unsigned long addr = start & ~(lsize - 1);			\
+	unsigned long aend = (end - 1) & ~(lsize - 1);			\
+									\
+	__##pfx##flush_prologue						\
+									\
+	if (segment_eq(get_fs(), USER_DS))                              \
+		while (1) {                                             \
+			protected_cachee_op(hitop, addr);               \
+			if (addr == aend)                               \
+				break;                                  \
+			addr += lsize;                                  \
+		}                                                       \
+	else                                                            \
+		while (1) {                                             \
+			protected_cache_op(hitop, addr);                \
+			if (addr == aend)                               \
+				break;                                  \
+			addr += lsize;                                  \
+		}                                                       \
+									\
+	__##pfx##flush_epilogue						\
+}
+
+__BUILD_PROT_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D)
+__BUILD_PROT_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I)
+
+#endif
+
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
+__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, )
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
 /* blast_inv_dcache_range */
 __BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
Only in ./arch/mips/include/asm: scatterlist.h
Only in ./arch/mips/include/asm: sections.h
Only in ./arch/mips/include/asm: segment.h
Only in ./arch/mips/include/asm: serial.h
diff -ur ./arch/mips/include/asm/smp.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/smp.h
--- ./arch/mips/include/asm/smp.h	2023-04-26 12:25:54.790119458 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/smp.h	2023-04-23 11:58:20.915165200 +0100
@@ -16,12 +16,14 @@
 #include <linux/smp.h>
 #include <linux/threads.h>
 #include <linux/cpumask.h>
+#include <linux/cache.h>
 
 #include <linux/atomic.h>
 #include <asm/smp-ops.h>
+#include <asm/percpu.h>
 
 extern int smp_num_siblings;
-extern cpumask_t cpu_sibling_map[];
+DECLARE_PER_CPU_SHARED_ALIGNED(cpumask_t, cpu_sibling_map);
 
 #define raw_smp_processor_id() (current_thread_info()->cpu)
 
diff -ur ./arch/mips/include/asm/switch_to.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/switch_to.h
--- ./arch/mips/include/asm/switch_to.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/switch_to.h	2023-04-23 11:58:21.551209800 +0100
@@ -15,8 +15,8 @@
 #include <asm/cpu-features.h>
 #include <asm/watch.h>
 #include <asm/dsp.h>
-
-struct task_struct;
+#include <mxu.h>
+#include <asm/cop2.h>
 
 /*
  * switch_to(n) should switch tasks to task nr n, first
@@ -24,6 +24,16 @@
  */
 extern asmlinkage void *resume(void *last, void *next, void *next_ti, u32 __usedfpu);
 
+#ifdef CONFIG_PMON_DEBUG
+extern void save_perf_event_jz(void *tskvoid);
+extern void restore_perf_event_jz(void *tskvoid);
+#else
+#define save_perf_event_jz(tskvoid)
+#define restore_perf_event_jz(tskvoid)
+#endif
+
+struct task_struct;
+
 extern unsigned int ll_bit;
 extern struct task_struct *ll_task;
 
@@ -67,9 +77,21 @@
 #define switch_to(prev, next, last)					\
 do {									\
 	u32 __usedfpu;							\
+	u32 __c0_stat;							\
 	__mips_mt_fpaff_switch_to(prev);				\
 	if (cpu_has_dsp)						\
 		__save_dsp(prev);					\
+	if (cpu_has_mxu)						\
+		__save_mxu(prev);					\
+	if (cop2_present && (KSTK_STATUS(prev) & ST0_CU2)) {		\
+		if (cop2_lazy_restore)					\
+			KSTK_STATUS(prev) &= ~ST0_CU2;			\
+		__c0_stat = read_c0_status();				\
+		write_c0_status(__c0_stat | ST0_CU2);			\
+		cop2_save(&prev->thread.cp2);				\
+		write_c0_status(__c0_stat & ~ST0_CU2);			\
+	}								\
+	save_perf_event_jz(prev);					\
 	__clear_software_ll_bit();					\
 	__usedfpu = test_and_clear_tsk_thread_flag(prev, TIF_USEDFPU);	\
 	(last) = resume(prev, next, task_thread_info(next), __usedfpu); \
@@ -77,10 +99,21 @@
 
 #define finish_arch_switch(prev)					\
 do {									\
+	u32 __c0_stat;							\
+	if (cop2_present && !cop2_lazy_restore &&			\
+			(KSTK_STATUS(current) & ST0_CU2)) {		\
+		__c0_stat = read_c0_status();				\
+		write_c0_status(__c0_stat | ST0_CU2);			\
+		cop2_restore(&current->thread.cp2);			\
+		write_c0_status(__c0_stat & ~ST0_CU2);			\
+	}								\
 	if (cpu_has_dsp)						\
 		__restore_dsp(current);					\
 	if (cpu_has_userlocal)						\
 		write_c0_userlocal(current_thread_info()->tp_value);	\
+	if (cpu_has_mxu)                                                \
+		__restore_mxu(current); 				\
+	restore_perf_event_jz(current);					\
 	__restore_watch();						\
 } while (0)
 
diff -ur ./arch/mips/include/asm/time.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/time.h
--- ./arch/mips/include/asm/time.h	2023-04-26 12:25:54.810119471 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/time.h	2023-04-23 11:58:21.633365500 +0100
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
+#include <asm/gic.h>
 
 extern spinlock_t rtc_lock;
 
@@ -75,7 +76,7 @@
 
 static inline int init_mips_clocksource(void)
 {
-#if defined(CONFIG_CSRC_R4K) && !defined(CONFIG_CSRC_GIC)
+#ifdef CONFIG_CSRC_R4K
 	return init_r4k_clocksource();
 #else
 	return 0;
diff -ur ./arch/mips/include/asm/topology.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/topology.h
--- ./arch/mips/include/asm/topology.h	2023-04-26 12:25:54.810119471 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/topology.h	2023-04-23 11:58:21.710839900 +0100
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 2007 by Ralf Baechle
+ * Copyright (C) 2012 by Leonid Yegoshin
  */
 #ifndef __ASM_TOPOLOGY_H
 #define __ASM_TOPOLOGY_H
@@ -12,6 +13,10 @@
 
 #ifdef CONFIG_SMP
 #define smt_capable()	(smp_num_siblings > 1)
+#define topology_thread_cpumask(cpu)    (&per_cpu(cpu_sibling_map, cpu))
+#define topology_core_id(cpu)           (cpu_data[cpu].core)
+#define topology_core_cpumask(cpu)      ((void)(cpu), cpu_online_mask)
+#define topology_physical_package_id(cpu)   ((void)cpu, 0)
 #endif
 
 #endif /* __ASM_TOPOLOGY_H */
diff -ur ./arch/mips/include/asm/uaccess.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/uaccess.h
--- ./arch/mips/include/asm/uaccess.h	2023-04-26 12:25:54.810119471 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/uaccess.h	2023-04-23 11:58:22.115770600 +0100
@@ -223,47 +223,96 @@
  * for 32 bit mode and old iron.
  */
 #ifdef CONFIG_32BIT
+#define __GET_KERNEL_DW(val, ptr) __get_kernel_asm_ll32(val, ptr)
 #define __GET_USER_DW(val, ptr) __get_user_asm_ll32(val, ptr)
 #endif
 #ifdef CONFIG_64BIT
-#define __GET_USER_DW(val, ptr) __get_user_asm(val, "ld", ptr)
+#define __GET_KERNEL_DW(val, ptr) __get_kernel_asm(val, "ld", ptr)
 #endif
 
+extern void __get_kernel_unknown(void);
 extern void __get_user_unknown(void);
 
-#define __get_user_common(val, size, ptr)				\
+#define __get_kernel_common(val, size, ptr)                             \
 do {									\
+	__chk_user_ptr(ptr);                                            \
+	__gu_err = 0;                                                   \
+	switch (size) {                                                 \
+	case 1: __get_kernel_asm(val, "lb", ptr);  break;               \
+	case 2: __get_kernel_asm(val, "lh", ptr);  break;               \
+	case 4: __get_kernel_asm(val, "lw", ptr);  break;               \
+	case 8: __GET_KERNEL_DW(val, ptr); break;                       \
+	default: __get_kernel_unknown(); break;                         \
+	}								\
+} while (0)
+
+#ifdef CONFIG_EVA
+#define __get_user_common(val, size, ptr)                               \
+do {									\
+	__gu_err = 0;                                                   \
 	switch (size) {							\
-	case 1: __get_user_asm(val, "lb", ptr); break;			\
-	case 2: __get_user_asm(val, "lh", ptr); break;			\
-	case 4: __get_user_asm(val, "lw", ptr); break;			\
-	case 8: __GET_USER_DW(val, ptr); break;				\
-	default: __get_user_unknown(); break;				\
+	case 1: __get_user_asm(val, "lbe", ptr); break;                 \
+	case 2: __get_user_asm(val, "lhe", ptr); break;                 \
+	case 4: __get_user_asm(val, "lwe", ptr); break;                 \
+	case 8: __GET_USER_DW(val, ptr); break;                         \
+	default: __get_user_unknown(); break;                           \
 	}								\
 } while (0)
+#endif
 
-#define __get_user_nocheck(x, ptr, size)				\
+#ifndef CONFIG_EVA
+#define __get_user_nocheck(x, ptr, size)                                \
 ({									\
-	int __gu_err;							\
+	int __gu_err;                                                   \
+	__get_kernel_common((x), size, ptr);                            \
+	__gu_err;							\
+})
+#else
+#define __get_user_nocheck(x, ptr, size)                                \
+({									\
+	int __gu_err;                                                   \
+	const __typeof__(*(ptr)) __user * __gu_ptr = (ptr);             \
 									\
-	__chk_user_ptr(ptr);						\
-	__get_user_common((x), size, ptr);				\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__get_kernel_common((x), size, __gu_ptr);               \
+	else {                                                          \
+		__chk_user_ptr(ptr);                                    \
+		__get_user_common((x), size, __gu_ptr);                 \
+	}                                                               \
 	__gu_err;							\
 })
+#endif
 
-#define __get_user_check(x, ptr, size)					\
+#ifndef CONFIG_EVA
+#define __get_user_check(x, ptr, size)                                  \
 ({									\
 	int __gu_err = -EFAULT;						\
 	const __typeof__(*(ptr)) __user * __gu_ptr = (ptr);		\
 									\
-	might_fault();							\
-	if (likely(access_ok(VERIFY_READ,  __gu_ptr, size)))		\
-		__get_user_common((x), size, __gu_ptr);			\
+	might_fault();                                                  \
+	if (likely(access_ok(VERIFY_READ,  __gu_ptr, size)))            \
+		__get_kernel_common((x), size, __gu_ptr);               \
+									\
+	__gu_err;							\
+})
+#else
+#define __get_user_check(x, ptr, size)                                  \
+({									\
+	int __gu_err = -EFAULT;						\
+	const __typeof__(*(ptr)) __user * __gu_ptr = (ptr);		\
 									\
+	if (segment_eq(get_fs(), KERNEL_DS)) {                          \
+		__get_kernel_common((x), size, __gu_ptr);               \
+	} else {                                                        \
+		might_fault();                                          \
+		if (likely(access_ok(VERIFY_READ,  __gu_ptr, size)))    \
+			__get_user_common((x), size, __gu_ptr);         \
+	}                                                               \
 	__gu_err;							\
 })
+#endif
 
-#define __get_user_asm(val, insn, addr)					\
+#define __get_kernel_asm(val, insn, addr)                               \
 {									\
 	long __gu_tmp;							\
 									\
@@ -284,10 +333,34 @@
 	(val) = (__typeof__(*(addr))) __gu_tmp;				\
 }
 
+#ifdef CONFIG_EVA
+#define __get_user_asm(val, insn, addr)                                 \
+{									\
+	long __gu_tmp;							\
+									\
+	__asm__ __volatile__(						\
+	"       .set    eva                                     \n"     \
+	"1:     " insn "        %1, 0(%3)                          \n"     \
+	"2:							\n"	\
+	"	.insn						\n"	\
+	"	.section .fixup,\"ax\"				\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section __ex_table,\"a\"			\n"	\
+	"	"__UA_ADDR "\t1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=r" (__gu_tmp)				\
+	: "0" (0), "r" (addr), "i" (-EFAULT));                     \
+									\
+	(val) = (__typeof__(*(addr))) __gu_tmp;				\
+}
+#endif
+
 /*
  * Get a long long 64 using 32 bit registers.
  */
-#define __get_user_asm_ll32(val, addr)					\
+#define __get_kernel_asm_ll32(val, addr)                                \
 {									\
 	union {								\
 		unsigned long long	l;				\
@@ -314,18 +387,113 @@
 									\
 	(val) = __gu_tmp.t;						\
 }
+#ifdef CONFIG_EVA
+#define __get_user_asm_ll32(val, addr)					\
+{									\
+	union {								\
+		unsigned long long	l;				\
+		__typeof__(*(addr))	t;				\
+	} __gu_tmp;							\
+									\
+	__asm__ __volatile__(						\
+	"       .set    eva                                     \n"     \
+	"1:     lwe     %1, (%3)                                \n"     \
+	"2:     lwe     %D1, 4(%3)                              \n"     \
+	"3:							\n"	\
+	"	.insn						\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	move	%1, $0					\n"	\
+	"	move	%D1, $0					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=&r" (__gu_tmp.l)				\
+	: "0" (0), "r" (addr), "i" (-EFAULT));                          \
+									\
+	(val) = __gu_tmp.t;						\
+}
+#endif
+
 
 /*
  * Yuck.  We need two variants, one for 64bit operation and one
  * for 32 bit mode and old iron.
  */
 #ifdef CONFIG_32BIT
+#define __PUT_KERNEL_DW(ptr) __put_kernel_asm_ll32(ptr)
 #define __PUT_USER_DW(ptr) __put_user_asm_ll32(ptr)
 #endif
 #ifdef CONFIG_64BIT
-#define __PUT_USER_DW(ptr) __put_user_asm("sd", ptr)
+#define __PUT_KERNEL_DW(ptr) __put_kernel_asm("sd", ptr)
 #endif
 
+extern void __put_kernel_unknown(void);
+
+#ifdef CONFIG_EVA
+extern void __put_user_unknown(void);
+
+#define __put_kernel_common(size, ptr)                                  \
+do {									\
+	switch (size) {                                                 \
+	case 1: __put_kernel_asm("sb", ptr);  break;                    \
+	case 2: __put_kernel_asm("sh", ptr);  break;                    \
+	case 4: __put_kernel_asm("sw", ptr);  break;                    \
+	case 8: __PUT_KERNEL_DW(ptr); break;                            \
+	default: __put_kernel_unknown(); break;                         \
+	}								\
+} while (0)
+
+#define __put_user_common(size, ptr)                                    \
+do {									\
+	switch (size) {                                                 \
+	case 1: __put_user_asm("sbe", ptr);  break;                     \
+	case 2: __put_user_asm("she", ptr);  break;                     \
+	case 4: __put_user_asm("swe", ptr);  break;                     \
+	case 8: __PUT_USER_DW(ptr); break;                              \
+	default: __put_user_unknown(); break;                           \
+	}								\
+} while (0)
+
+#define __put_user_nocheck(x, ptr, size)                                \
+({									\
+	__typeof__(*(ptr)) __pu_val;                                    \
+	int __pu_err = 0;                                               \
+	const __typeof__(*(ptr)) __user * __pu_ptr = (ptr);             \
+									\
+	if (segment_eq(get_fs(), KERNEL_DS)) {                          \
+		__chk_user_ptr(__pu_ptr);                               \
+		__pu_val = (x);                                         \
+		__put_kernel_common(size, __pu_ptr);                    \
+	} else {                                                        \
+		__chk_user_ptr(__pu_ptr);                               \
+		__pu_val = (x);                                         \
+		__put_user_common(size, __pu_ptr);                      \
+	}                                                               \
+	__pu_err;                                                       \
+})
+
+#define __put_user_check(x, ptr, size)                                  \
+({									\
+	__typeof__(*(ptr)) __pu_val = (x);                              \
+	int __pu_err = -EFAULT;                                         \
+	const __typeof__(*(ptr)) __user * __pu_ptr = (ptr);             \
+									\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__put_kernel_common(size, __pu_ptr);                    \
+	else {                                                          \
+		might_fault();                                          \
+		if (likely(access_ok(VERIFY_WRITE,  __pu_ptr, size)))   \
+			__put_user_common(size, __pu_ptr);              \
+	}                                                               \
+	__pu_err;                                                       \
+})
+
+#else
+
 #define __put_user_nocheck(x, ptr, size)				\
 ({									\
 	__typeof__(*(ptr)) __pu_val;					\
@@ -334,11 +502,11 @@
 	__chk_user_ptr(ptr);						\
 	__pu_val = (x);							\
 	switch (size) {							\
-	case 1: __put_user_asm("sb", ptr); break;			\
-	case 2: __put_user_asm("sh", ptr); break;			\
-	case 4: __put_user_asm("sw", ptr); break;			\
-	case 8: __PUT_USER_DW(ptr); break;				\
-	default: __put_user_unknown(); break;				\
+	case 1: __put_kernel_asm("sb", ptr); break;                     \
+	case 2: __put_kernel_asm("sh", ptr); break;                     \
+	case 4: __put_kernel_asm("sw", ptr); break;                     \
+	case 8: __PUT_KERNEL_DW(ptr); break;                            \
+	default: __put_kernel_unknown(); break;                         \
 	}								\
 	__pu_err;							\
 })
@@ -352,17 +520,19 @@
 	might_fault();							\
 	if (likely(access_ok(VERIFY_WRITE,  __pu_addr, size))) {	\
 		switch (size) {						\
-		case 1: __put_user_asm("sb", __pu_addr); break;		\
-		case 2: __put_user_asm("sh", __pu_addr); break;		\
-		case 4: __put_user_asm("sw", __pu_addr); break;		\
-		case 8: __PUT_USER_DW(__pu_addr); break;		\
-		default: __put_user_unknown(); break;			\
+		case 1: __put_kernel_asm("sb", __pu_addr); break;       \
+		case 2: __put_kernel_asm("sh", __pu_addr); break;       \
+		case 4: __put_kernel_asm("sw", __pu_addr); break;       \
+		case 8: __PUT_KERNEL_DW(__pu_addr); break;              \
+		default: __put_kernel_unknown(); break;                 \
 		}							\
 	}								\
 	__pu_err;							\
 })
+#endif /* CONFIG_EVA */
 
-#define __put_user_asm(insn, ptr)					\
+#ifndef CONFIG_EVA
+#define __put_kernel_asm(insn, ptr)                                     \
 {									\
 	__asm__ __volatile__(						\
 	"1:	" insn "	%z2, %3		# __put_user_asm\n"	\
@@ -379,8 +549,47 @@
 	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
 	  "i" (-EFAULT));						\
 }
+#else
+#define __put_kernel_asm(insn, ptr)                                     \
+{									\
+	__asm__ __volatile__(						\
+	"1:     " insn "        %2, %3         # __put_user_asm\n"      \
+	"2:							\n"	\
+	"	.insn						\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__pu_err)						\
+	: "0" (0), "r" (__pu_val), "o" (__m(ptr)),                      \
+	  "i" (-EFAULT));						\
+}
+
+#define __put_user_asm(insn, ptr)                                       \
+{									\
+	__asm__ __volatile__(						\
+	"       .set        eva                                 \n"     \
+	"1:     " insn "        %2, 0(%3)         # __put_user_asm\n"   \
+	"2:							\n"	\
+	"	.insn						\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__pu_err)						\
+	: "0" (0), "r" (__pu_val), "r" (ptr),                           \
+	  "i" (-EFAULT));						\
+}
+#endif
+
 
-#define __put_user_asm_ll32(ptr)					\
+#define __put_kernel_asm_ll32(ptr)                                      \
 {									\
 	__asm__ __volatile__(						\
 	"1:	sw	%2, (%3)	# __put_user_asm_ll32	\n"	\
@@ -400,8 +609,30 @@
 	  "i" (-EFAULT));						\
 }
 
-extern void __put_user_unknown(void);
+#ifdef CONFIG_EVA
+#define __put_user_asm_ll32(ptr)                                        \
+{									\
+	__asm__ __volatile__(						\
+	"       .set    eva                                     \n"     \
+	"1:     swe     %2, (%3)        # __put_user_asm_ll32   \n"     \
+	"2:     swe     %D2, 4(%3)                              \n"     \
+	"3:							\n"	\
+	"	.insn						\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	.previous"						\
+	: "=r" (__pu_err)						\
+	: "0" (0), "r" (__pu_val), "r" (ptr),				\
+	  "i" (-EFAULT));                                               \
+}
+#endif
 
+#ifndef CONFIG_EVA
 /*
  * put_user_unaligned: - Write a simple value into user space.
  * @x:	 Value to copy to user space.
@@ -670,6 +901,8 @@
 
 extern void __put_user_unaligned_unknown(void);
 
+#endif /* CONFIG_EVA */
+
 /*
  * We're generating jump to subroutines which will be outside the range of
  * jump instructions
@@ -692,8 +925,12 @@
 #endif
 
 extern size_t __copy_user(void *__to, const void *__from, size_t __n);
+#ifdef CONFIG_EVA
+extern size_t __copy_fromuser(void *__to, const void *__from, size_t __n);
+extern size_t __copy_touser(void *__to, const void *__from, size_t __n);
+#endif
 
-#define __invoke_copy_to_user(to, from, n)				\
+#define __invoke_copy_to_kernel(to, from, n)                            \
 ({									\
 	register void __user *__cu_to_r __asm__("$4");			\
 	register const void *__cu_from_r __asm__("$5");			\
@@ -703,7 +940,7 @@
 	__cu_from_r = (from);						\
 	__cu_len_r = (n);						\
 	__asm__ __volatile__(						\
-	__MODULE_JAL(__copy_user)					\
+	__MODULE_JAL(__copy_user)                                       \
 	: "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r)	\
 	:								\
 	: "$8", "$9", "$10", "$11", "$12", "$14", "$15", "$24", "$31",	\
@@ -711,6 +948,26 @@
 	__cu_len_r;							\
 })
 
+#ifdef CONFIG_EVA
+#define __invoke_copy_to_user(to, from, n)                              \
+({									\
+	register void __user *__cu_to_r __asm__("$4");			\
+	register const void *__cu_from_r __asm__("$5");			\
+	register long __cu_len_r __asm__("$6");				\
+									\
+	__cu_to_r = (to);                                               \
+	__cu_from_r = (from);						\
+	__cu_len_r = (n);						\
+	__asm__ __volatile__(						\
+	__MODULE_JAL(__copy_touser)                                     \
+	: "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r)	\
+	:								\
+	: "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31",		\
+	  DADDI_SCRATCH, "memory");					\
+	__cu_len_r;							\
+})
+#endif
+
 /*
  * __copy_to_user: - Copy a block of data into user space, with less checking.
  * @to:	  Destination address, in user space.
@@ -725,6 +982,7 @@
  * Returns number of bytes that could not be copied.
  * On success, this will be zero.
  */
+#ifndef CONFIG_EVA
 #define __copy_to_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -734,13 +992,58 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	might_fault();							\
-	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
+	might_fault();                                                  \
+	__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from, __cu_len); \
 	__cu_len;							\
 })
+#else
+#define __copy_to_user(to, from, n)					\
+({									\
+	void __user *__cu_to;						\
+	const void *__cu_from;						\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from, __cu_len); \
+	else {                                                          \
+		might_fault();                                                  \
+		__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
+	}                                                               \
+	__cu_len;							\
+})
+#endif
 
-extern size_t __copy_user_inatomic(void *__to, const void *__from, size_t __n);
+#ifndef CONFIG_EVA
+#define __copy_to_user_inatomic(to, from, n)                            \
+({                                                                      \
+	void __user *__cu_to;                                           \
+	const void *__cu_from;                                          \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from, __cu_len); \
+	__cu_len;                                                       \
+})
 
+#define __copy_from_user_inatomic(to, from, n)                          \
+({                                                                      \
+	void *__cu_to;                                                  \
+	const void __user *__cu_from;                                   \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	__cu_len = __invoke_copy_from_kernel_inatomic(__cu_to, __cu_from, \
+						    __cu_len);          \
+	__cu_len;                                                       \
+})
+#else
 #define __copy_to_user_inatomic(to, from, n)				\
 ({									\
 	void __user *__cu_to;						\
@@ -750,7 +1053,10 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from, __cu_len); \
+	else                                                            \
+		__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
 	__cu_len;							\
 })
 
@@ -763,10 +1069,15 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	__cu_len = __invoke_copy_from_user_inatomic(__cu_to, __cu_from, \
-						    __cu_len);		\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__cu_len = __invoke_copy_from_kernel_inatomic(__cu_to, __cu_from, \
+						    __cu_len);          \
+	else                                                            \
+		__cu_len = __invoke_copy_from_user_inatomic(__cu_to, __cu_from, \
+						    __cu_len);          \
 	__cu_len;							\
 })
+#endif
 
 /*
  * copy_to_user: - Copy a block of data into user space.
@@ -781,6 +1092,24 @@
  * Returns number of bytes that could not be copied.
  * On success, this will be zero.
  */
+#ifndef CONFIG_EVA
+#define copy_to_user(to, from, n)                                       \
+({                                                                      \
+	void __user *__cu_to;                                           \
+	const void *__cu_from;                                          \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) {               \
+		might_fault();                                          \
+		__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from,  \
+						 __cu_len);             \
+	}                                                               \
+	__cu_len;                                                       \
+})
+#else
 #define copy_to_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -790,15 +1119,70 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) {		\
-		might_fault();						\
-		__cu_len = __invoke_copy_to_user(__cu_to, __cu_from,	\
-						 __cu_len);		\
-	}								\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__cu_len = __invoke_copy_to_kernel(__cu_to, __cu_from,  \
+						 __cu_len);             \
+	else                                                            \
+		if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) {       \
+			might_fault();                                  \
+			__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, \
+							 __cu_len);     \
+		}                                                       \
 	__cu_len;							\
 })
+#endif
+
+#define __invoke_copy_from_kernel(to, from, n)                          \
+({									\
+	register void *__cu_to_r __asm__("$4");				\
+	register const void __user *__cu_from_r __asm__("$5");		\
+	register long __cu_len_r __asm__("$6");				\
+									\
+	__cu_to_r = (to);						\
+	__cu_from_r = (from);						\
+	__cu_len_r = (n);						\
+	__asm__ __volatile__(						\
+	".set\tnoreorder\n\t"						\
+	__MODULE_JAL(__copy_user)                                       \
+	".set\tnoat\n\t"						\
+	__UA_ADDU "\t$1, %1, %2\n\t"					\
+	".set\tat\n\t"							\
+	".set\treorder"							\
+	: "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r)	\
+	:								\
+	: "$8", "$9", "$10", "$11", "$12", "$14", "$15", "$24", "$31",	\
+	  DADDI_SCRATCH, "memory");					\
+	__cu_len_r;							\
+})
+
+#ifdef CONFIG_EVA
+#define __invoke_copy_from_user(to, from, n)                            \
+({									\
+	register void *__cu_to_r __asm__("$4");				\
+	register const void __user *__cu_from_r __asm__("$5");		\
+	register long __cu_len_r __asm__("$6");				\
+									\
+	__cu_to_r = (to);						\
+	__cu_from_r = (from);						\
+	__cu_len_r = (n);						\
+	__asm__ __volatile__(						\
+	".set\tnoreorder\n\t"						\
+	__MODULE_JAL(__copy_fromuser)                                   \
+	".set\tnoat\n\t"						\
+	__UA_ADDU "\t$1, %1, %2\n\t"					\
+	".set\tat\n\t"							\
+	".set\treorder"							\
+	: "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r)	\
+	:								\
+	: "$8", "$9", "$10", "$11", "$12", "$14", "$15", "$24", "$31",	\
+	  DADDI_SCRATCH, "memory");					\
+	__cu_len_r;							\
+})
+#endif
+
+extern size_t __copy_user_inatomic(void *__to, const void *__from, size_t __n);
 
-#define __invoke_copy_from_user(to, from, n)				\
+#define __invoke_copy_from_kernel_inatomic(to, from, n)                 \
 ({									\
 	register void *__cu_to_r __asm__("$4");				\
 	register const void __user *__cu_from_r __asm__("$5");		\
@@ -809,7 +1193,7 @@
 	__cu_len_r = (n);						\
 	__asm__ __volatile__(						\
 	".set\tnoreorder\n\t"						\
-	__MODULE_JAL(__copy_user)					\
+	__MODULE_JAL(__copy_user_inatomic)                              \
 	".set\tnoat\n\t"						\
 	__UA_ADDU "\t$1, %1, %2\n\t"					\
 	".set\tat\n\t"							\
@@ -821,6 +1205,9 @@
 	__cu_len_r;							\
 })
 
+#ifdef CONFIG_EVA
+extern size_t __copy_fromuser_inatomic(void *__to, const void *__from, size_t __n);
+
 #define __invoke_copy_from_user_inatomic(to, from, n)			\
 ({									\
 	register void *__cu_to_r __asm__("$4");				\
@@ -832,7 +1219,7 @@
 	__cu_len_r = (n);						\
 	__asm__ __volatile__(						\
 	".set\tnoreorder\n\t"						\
-	__MODULE_JAL(__copy_user_inatomic)				\
+	__MODULE_JAL(__copy_fromuser_inatomic)                              \
 	".set\tnoat\n\t"						\
 	__UA_ADDU "\t$1, %1, %2\n\t"					\
 	".set\tat\n\t"							\
@@ -844,6 +1231,32 @@
 	__cu_len_r;							\
 })
 
+extern size_t __copy_inuser(void *__to, const void *__from, size_t __n);
+
+#define __invoke_copy_in_user(to, from, n)                              \
+({									\
+	register void *__cu_to_r __asm__("$4");				\
+	register const void __user *__cu_from_r __asm__("$5");		\
+	register long __cu_len_r __asm__("$6");				\
+									\
+	__cu_to_r = (to);						\
+	__cu_from_r = (from);						\
+	__cu_len_r = (n);						\
+	__asm__ __volatile__(						\
+	".set\tnoreorder\n\t"						\
+	__MODULE_JAL(__copy_inuser)                                     \
+	".set\tnoat\n\t"						\
+	__UA_ADDU "\t$1, %1, %2\n\t"					\
+	".set\tat\n\t"							\
+	".set\treorder"							\
+	: "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r)	\
+	:								\
+	: "$8", "$9", "$10", "$11", "$12", "$14", "$15", "$24", "$31",	\
+	  DADDI_SCRATCH, "memory");					\
+	__cu_len_r;							\
+})
+#endif
+
 /*
  * __copy_from_user: - Copy a block of data from user space, with less checking.
  * @to:	  Destination address, in kernel space.
@@ -861,6 +1274,22 @@
  * If some data could not be copied, this function will pad the copied
  * data to the requested size using zero bytes.
  */
+#ifndef CONFIG_EVA
+#define __copy_from_user(to, from, n)                                   \
+({									\
+	void *__cu_to;							\
+	const void __user *__cu_from;					\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	might_fault();							\
+	__cu_len = __invoke_copy_from_kernel(__cu_to, __cu_from,        \
+					   __cu_len);                   \
+	__cu_len;							\
+})
+#else
 #define __copy_from_user(to, from, n)					\
 ({									\
 	void *__cu_to;							\
@@ -872,9 +1301,10 @@
 	__cu_len = (n);							\
 	might_fault();							\
 	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\
-					   __cu_len);			\
+					   __cu_len);                   \
 	__cu_len;							\
 })
+#endif
 
 /*
  * copy_from_user: - Copy a block of data from user space.
@@ -892,7 +1322,25 @@
  * If some data could not be copied, this function will pad the copied
  * data to the requested size using zero bytes.
  */
-#define copy_from_user(to, from, n)					\
+#ifndef CONFIG_EVA
+#define copy_from_user(to, from, n)                                     \
+({                                                                      \
+	void *__cu_to;                                                  \
+	const void __user *__cu_from;                                   \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	if (access_ok(VERIFY_READ, __cu_from, __cu_len)) {              \
+		might_fault();                                          \
+		__cu_len = __invoke_copy_from_kernel(__cu_to, __cu_from,  \
+						   __cu_len);           \
+	}                                                               \
+	__cu_len;                                                       \
+})
+#else
+#define copy_from_user(to, from, n)                                     \
 ({									\
 	void *__cu_to;							\
 	const void __user *__cu_from;					\
@@ -901,14 +1349,53 @@
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
-	if (access_ok(VERIFY_READ, __cu_from, __cu_len)) {		\
-		might_fault();						\
-		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\
-						   __cu_len);		\
-	}								\
+	if (segment_eq(get_fs(), KERNEL_DS))                            \
+		__cu_len = __invoke_copy_from_kernel(__cu_to, __cu_from,  \
+						   __cu_len);           \
+	else                                                            \
+		if (access_ok(VERIFY_READ, __cu_from, __cu_len)) {      \
+			might_fault();                                  \
+			__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,  \
+							   __cu_len);   \
+		}                                                       \
 	__cu_len;							\
 })
+#endif
 
+#ifndef CONFIG_EVA
+#define __copy_in_user(to, from, n)                                     \
+({                                                                      \
+	void __user *__cu_to;                                           \
+	const void __user *__cu_from;                                   \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	might_fault();                                                  \
+	__cu_len = __invoke_copy_from_kernel(__cu_to, __cu_from,          \
+					   __cu_len);                   \
+	__cu_len;                                                       \
+})
+
+#define copy_in_user(to, from, n)                                       \
+({                                                                      \
+	void __user *__cu_to;                                           \
+	const void __user *__cu_from;                                   \
+	long __cu_len;                                                  \
+									\
+	__cu_to = (to);                                                 \
+	__cu_from = (from);                                             \
+	__cu_len = (n);                                                 \
+	if (likely(access_ok(VERIFY_READ, __cu_from, __cu_len) &&       \
+		   access_ok(VERIFY_WRITE, __cu_to, __cu_len))) {       \
+		might_fault();                                          \
+		__cu_len = __invoke_copy_from_kernel(__cu_to, __cu_from,  \
+						   __cu_len);           \
+	}                                                               \
+	__cu_len;                                                       \
+})
+#else
 #define __copy_in_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -919,8 +1406,8 @@
 	__cu_from = (from);						\
 	__cu_len = (n);							\
 	might_fault();							\
-	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\
-					   __cu_len);			\
+	__cu_len = __invoke_copy_in_user(__cu_to, __cu_from,          \
+					 __cu_len);                   \
 	__cu_len;							\
 })
 
@@ -936,11 +1423,12 @@
 	if (likely(access_ok(VERIFY_READ, __cu_from, __cu_len) &&	\
 		   access_ok(VERIFY_WRITE, __cu_to, __cu_len))) {	\
 		might_fault();						\
-		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\
-						   __cu_len);		\
+		__cu_len = __invoke_copy_in_user(__cu_to, __cu_from,  \
+						 __cu_len);           \
 	}								\
 	__cu_len;							\
 })
+#endif
 
 /*
  * __clear_user: - Zero a block of memory in user space, with less checking.
@@ -963,7 +1451,11 @@
 		"move\t$4, %1\n\t"
 		"move\t$5, $0\n\t"
 		"move\t$6, %2\n\t"
+#ifndef CONFIG_EVA
 		__MODULE_JAL(__bzero)
+#else
+		__MODULE_JAL(__bzero_user)
+#endif
 		"move\t%0, $6"
 		: "=r" (res)
 		: "r" (addr), "r" (size)
@@ -1012,7 +1504,11 @@
 		"move\t$4, %1\n\t"
 		"move\t$5, %2\n\t"
 		"move\t$6, %3\n\t"
+#ifdef CONFIG_EVA
+		__MODULE_JAL(__strncpy_from_kernel_nocheck_asm)
+#else
 		__MODULE_JAL(__strncpy_from_user_nocheck_asm)
+#endif
 		"move\t%0, $2"
 		: "=r" (res)
 		: "r" (__to), "r" (__from), "r" (__len)
@@ -1039,6 +1535,7 @@
  * If @count is smaller than the length of the string, copies @count bytes
  * and returns @count.
  */
+#ifndef CONFIG_EVA
 static inline long
 strncpy_from_user(char *__to, const char __user *__from, long __len)
 {
@@ -1049,6 +1546,37 @@
 		"move\t$4, %1\n\t"
 		"move\t$5, %2\n\t"
 		"move\t$6, %3\n\t"
+		__MODULE_JAL(__strncpy_from_kernel_asm)
+		"move\t%0, $2"
+		: "=r" (res)
+		: "r" (__to), "r" (__from), "r" (__len)
+		: "$2", "$3", "$4", "$5", "$6", __UA_t0, "$31", "memory");
+
+	return res;
+}
+#else
+static inline long
+strncpy_from_user(char *__to, const char __user *__from, long __len)
+{
+	long res;
+
+	if (segment_eq(get_fs(), KERNEL_DS)) {
+		__asm__ __volatile__(
+			"move\t$4, %1\n\t"
+			"move\t$5, %2\n\t"
+			"move\t$6, %3\n\t"
+			__MODULE_JAL(__strncpy_from_kernel_asm)
+			"move\t%0, $2"
+			: "=r" (res)
+			: "r" (__to), "r" (__from), "r" (__len)
+			: "$2", "$3", "$4", "$5", "$6", __UA_t0, "$31", "memory");
+		return res;
+	}
+	might_fault();
+	__asm__ __volatile__(
+		"move\t$4, %1\n\t"
+		"move\t$5, %2\n\t"
+		"move\t$6, %3\n\t"
 		__MODULE_JAL(__strncpy_from_user_asm)
 		"move\t%0, $2"
 		: "=r" (res)
@@ -1057,6 +1585,7 @@
 
 	return res;
 }
+#endif
 
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
 static inline long __strlen_user(const char __user *s)
@@ -1066,7 +1595,11 @@
 	might_fault();
 	__asm__ __volatile__(
 		"move\t$4, %1\n\t"
+#ifndef CONFIG_EVA
+		__MODULE_JAL(__strlen_kernel_nocheck_asm)
+#else
 		__MODULE_JAL(__strlen_user_nocheck_asm)
+#endif
 		"move\t%0, $2"
 		: "=r" (res)
 		: "r" (s)
@@ -1096,7 +1629,11 @@
 	might_fault();
 	__asm__ __volatile__(
 		"move\t$4, %1\n\t"
+#ifndef CONFIG_EVA
+		__MODULE_JAL(__strlen_kernel_asm)
+#else
 		__MODULE_JAL(__strlen_user_asm)
+#endif
 		"move\t%0, $2"
 		: "=r" (res)
 		: "r" (s)
@@ -1114,7 +1651,11 @@
 	__asm__ __volatile__(
 		"move\t$4, %1\n\t"
 		"move\t$5, %2\n\t"
+#ifndef CONFIG_EVA
+		__MODULE_JAL(__strnlen_kernel_nocheck_asm)
+#else
 		__MODULE_JAL(__strnlen_user_nocheck_asm)
+#endif
 		"move\t%0, $2"
 		: "=r" (res)
 		: "r" (s), "r" (n)
@@ -1137,6 +1678,7 @@
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
+#ifndef CONFIG_EVA
 static inline long strnlen_user(const char __user *s, long n)
 {
 	long res;
@@ -1145,6 +1687,34 @@
 	__asm__ __volatile__(
 		"move\t$4, %1\n\t"
 		"move\t$5, %2\n\t"
+		__MODULE_JAL(__strnlen_kernel_asm)
+		"move\t%0, $2"
+		: "=r" (res)
+		: "r" (s), "r" (n)
+		: "$2", "$4", "$5", __UA_t0, "$31");
+
+	return res;
+}
+#else
+static inline long strnlen_user(const char __user *s, long n)
+{
+	long res;
+
+	if (segment_eq(get_fs(), KERNEL_DS)) {
+		__asm__ __volatile__(
+			"move\t$4, %1\n\t"
+			"move\t$5, %2\n\t"
+			__MODULE_JAL(__strnlen_kernel_asm)
+			"move\t%0, $2"
+			: "=r" (res)
+			: "r" (s), "r" (n)
+			: "$2", "$4", "$5", __UA_t0, "$31");
+		return res;
+	}
+	might_fault();
+	__asm__ __volatile__(
+		"move\t$4, %1\n\t"
+		"move\t$5, %2\n\t"
 		__MODULE_JAL(__strnlen_user_asm)
 		"move\t%0, $2"
 		: "=r" (res)
@@ -1153,6 +1723,7 @@
 
 	return res;
 }
+#endif
 
 struct exception_table_entry
 {
Only in ./arch/mips/include/asm: ucontext.h
diff -ur ./arch/mips/include/asm/vga.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/vga.h
--- ./arch/mips/include/asm/vga.h	2023-04-26 12:25:54.820119477 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/vga.h	2023-04-23 11:58:22.192781500 +0100
@@ -6,6 +6,7 @@
 #ifndef _ASM_VGA_H
 #define _ASM_VGA_H
 
+#include <asm/addrspace.h>
 #include <asm/byteorder.h>
 
 /*
@@ -13,7 +14,7 @@
  *	access the videoram directly without any black magic.
  */
 
-#define VGA_MAP_MEM(x, s)	(0xb0000000L + (unsigned long)(x))
+#define VGA_MAP_MEM(x, s)	CKSEG1ADDR(0x10000000L + (unsigned long)(x))
 
 #define vga_readb(x)	(*(x))
 #define vga_writeb(x, y)	(*(y) = (x))
diff -ur ./arch/mips/include/asm/vpe.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/vpe.h
--- ./arch/mips/include/asm/vpe.h	2023-04-26 12:25:54.820119477 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/asm/vpe.h	2023-04-23 11:58:22.192078400 +0100
@@ -26,12 +26,40 @@
 	struct list_head list;
 };
 
-
+extern unsigned long physical_memsize;
 extern int vpe_notify(int index, struct vpe_notifications *notify);
+extern void save_gp_address(unsigned int secbase, unsigned int rel);
+
+/*
+ * libc style I/O support hooks
+ */
 
 extern void *vpe_get_shared(int index);
 extern int vpe_getuid(int index);
 extern int vpe_getgid(int index);
 extern char *vpe_getcwd(int index);
 
+/*
+ * Kernel/Kernel message passing support hooks
+ */
+
+extern void *vpe_get_shared_area(int index, int type);
+
+/* "Well-Known" Area Types */
+
+#define VPE_SHARED_NULL 0
+#define VPE_SHARED_RESERVED -1
+
+struct vpe_shared_area {
+	int type;
+	void *addr;
+};
+
+/*
+ * IRQ assignment and initialization hook for RP services.
+ */
+
+int arch_get_xcpu_irq(void);
+
+int vpe_send_interrupt(int v, int i);
 #endif /* _ASM_VPE_H */
Only in ./arch/mips/include/asm: xor.h
diff -ur ./arch/mips/include/uapi/asm/Kbuild /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/uapi/asm/Kbuild
--- ./arch/mips/include/uapi/asm/Kbuild	2023-04-26 12:25:54.820119477 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/uapi/asm/Kbuild	2023-04-23 11:58:22.514653600 +0100
@@ -1,7 +1,9 @@
 # UAPI Header export list
 include include/uapi/asm-generic/Kbuild.asm
 
-header-y += auxvec.h
+generic-y += auxvec.h
+generic-y += ipcbuf.h
+
 header-y += bitsperlong.h
 header-y += break.h
 header-y += byteorder.h
@@ -11,7 +13,6 @@
 header-y += inst.h
 header-y += ioctl.h
 header-y += ioctls.h
-header-y += ipcbuf.h
 header-y += kvm_para.h
 header-y += mman.h
 header-y += msgbuf.h
Only in ./arch/mips/include/uapi/asm: auxvec.h
diff -ur ./arch/mips/include/uapi/asm/inst.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/uapi/asm/inst.h
--- ./arch/mips/include/uapi/asm/inst.h	2023-04-26 12:56:04.200118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/include/uapi/asm/inst.h	2023-04-23 11:58:22.673720400 +0100
@@ -74,8 +74,16 @@
 	ext_op, dextm_op, dextu_op, dext_op,
 	ins_op, dinsm_op, dinsu_op, dins_op,
 	lx_op = 0x0a,
-	bshfl_op = 0x20,
+	lwle_op = 0x19,
+	lwre_op = 0x1a, cachee_op = 0x1b,
+	sbe_op = 0x1c, she_op = 0x1d,
+	sce_op = 0x1e, swe_op = 0x1f,
+	bshfl_op = 0x20, swle_op = 0x21,
+	swre_op = 0x22, prefe_op = 0x23,
 	dbshfl_op = 0x24,
+	lbue_op = 0x28, lhue_op = 0x29,
+	lbe_op = 0x2c, lhe_op = 0x2d,
+	lle_op = 0x2e, lwe_op = 0x2f,
 	rdhwr_op = 0x3b
 };
 
@@ -98,8 +106,9 @@
  */
 enum cop_op {
 	mfc_op	      = 0x00, dmfc_op	    = 0x01,
-	cfc_op	      = 0x02, mtc_op	    = 0x04,
-	dmtc_op	      = 0x05, ctc_op	    = 0x06,
+	cfc_op	      = 0x02, mfhc_op	    = 0x03,
+	mtc_op        = 0x04, dmtc_op	    = 0x05,
+	ctc_op	      = 0x06, mthc_op	    = 0x07,
 	bc_op	      = 0x08, cop_op	    = 0x10,
 	copm_op	      = 0x18
 };
@@ -397,8 +406,10 @@
 	mm_movt1_op = 0xa5,
 	mm_ftruncw_op = 0xac,
 	mm_fneg1_op = 0xad,
+	mm_mfhc1_op = 0xc0,
 	mm_froundl_op = 0xcc,
 	mm_fcvtd1_op = 0xcd,
+	mm_mthc1_op = 0xe0,
 	mm_froundw_op = 0xec,
 	mm_fcvts1_op = 0xed,
 };
@@ -409,10 +420,11 @@
 enum mm_16c_minor_op {
 	mm_lwm16_op = 0x04,
 	mm_swm16_op = 0x05,
-	mm_jr16_op = 0x18,
-	mm_jrc_op = 0x1a,
-	mm_jalr16_op = 0x1c,
-	mm_jalrs16_op = 0x1e,
+	mm_jr16_op = 0x0c,
+	mm_jrc_op = 0x0d,
+	mm_jalr16_op = 0x0e,
+	mm_jalrs16_op = 0x0f,
+	mm_jraddiusp_op = 0x18,
 };
 
 /*
@@ -538,6 +550,15 @@
 	;))))))
 };
 
+struct spec3_format {   /* SPEC3 */
+	BITFIELD_FIELD(unsigned int opcode : 6,
+	BITFIELD_FIELD(unsigned int rs : 5,
+	BITFIELD_FIELD(unsigned int rt : 5,
+	BITFIELD_FIELD(signed int simmediate : 9,
+	BITFIELD_FIELD(unsigned int ls_func : 7,
+	;)))))
+};
+
 struct f_format {			/* FPU register format */
 	BITFIELD_FIELD(unsigned int opcode : 6,
 	BITFIELD_FIELD(unsigned int : 1,
@@ -854,6 +875,7 @@
 	struct c_format c_format;
 	struct r_format r_format;
 	struct p_format p_format;
+	struct spec3_format spec3_format;
 	struct f_format f_format;
 	struct ma_format ma_format;
 	struct b_format b_format;
Only in ./arch/mips/include/uapi/asm: ipcbuf.h
diff -ur ./arch/mips/kernel/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/Makefile
--- ./arch/mips/kernel/Makefile	2023-04-26 12:25:54.850119496 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/Makefile	2023-04-23 11:58:23.710808500 +0100
@@ -97,12 +97,7 @@
 obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o
 
 #
-# DSP ASE supported for MIPS32 or MIPS64 Release 2 cores only. It is not
-# safe to unconditionnaly use the assembler -mdsp / -mdspr2 switches
-# here because the compiler may use DSP ASE instructions (such as lwx) in
-# code paths where we cannot check that the CPU we are running on supports it.
-# Proper abstraction using HAVE_AS_DSP and macros is done in
-# arch/mips/include/asm/mipsregs.h.
+# DSP ASE supported for MIPS32 or MIPS64 Release 2 cores only.
 #
 ifeq ($(CONFIG_CPU_MIPSR2), y)
 CFLAGS_DSP 			= -DHAVE_AS_DSP
diff -ur ./arch/mips/kernel/cpu-probe.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/cpu-probe.c
--- ./arch/mips/kernel/cpu-probe.c	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/cpu-probe.c	2023-04-23 11:58:24.033519400 +0100
@@ -17,6 +17,7 @@
 #include <linux/smp.h>
 #include <linux/stddef.h>
 #include <linux/export.h>
+#include <linux/kallsyms.h>
 
 #include <asm/bugs.h>
 #include <asm/cpu.h>
@@ -75,6 +76,8 @@
 	check_errata();
 }
 
+#include <asm/pgtable.h>
+#include <asm/bootinfo.h>
 /*
  * Probe whether cpu has config register by trying to play with
  * alternate cache bit and see whether it matters.
@@ -118,6 +121,22 @@
 }
 
 /*
+ * Set and Get the FPU CSR31.
+ */
+static inline unsigned long cpu_test_fpu_csr31(unsigned long fcr31)
+{
+	unsigned long tmp;
+
+	tmp = read_c0_status();
+	__enable_fpu();
+	write_32bit_cp1_register(CP1_STATUS,fcr31);
+	enable_fpu_hazard();
+	fcr31 = read_32bit_cp1_register(CP1_STATUS);
+	write_c0_status(tmp);
+	return fcr31;
+}
+
+/*
  * Check the CPU has an FPU the official way.
  */
 static inline int __cpu_has_fpu(void)
@@ -174,6 +193,8 @@
 
 	if (((config0 & MIPS_CONF_MT) >> 7) == 1)
 		c->options |= MIPS_CPU_TLB;
+	if (((config0 & MIPS_CONF_MT) >> 7) == 4)
+		c->options |= MIPS_CPU_TLB;
 	isa = (config0 & MIPS_CONF_AT) >> 13;
 	switch (isa) {
 	case 0:
@@ -196,8 +217,6 @@
 		case 1:
 			set_isa(c, MIPS_CPU_ISA_M64R2);
 			break;
-		default:
-			goto unknown;
 		}
 		break;
 	default:
@@ -228,8 +247,11 @@
 		c->options |= MIPS_CPU_FPU;
 		c->options |= MIPS_CPU_32FPR;
 	}
-	if (cpu_has_tlb)
+	if (cpu_has_tlb) {
 		c->tlbsize = ((config1 & MIPS_CONF1_TLBS) >> 25) + 1;
+		c->tlbsizevtlb = c->tlbsize;
+		c->tlbsizeftlbsets = 0;
+	}
 
 	return config1 & MIPS_CONF_M;
 }
@@ -254,10 +276,14 @@
 
 	if (config3 & MIPS_CONF3_SM) {
 		c->ases |= MIPS_ASE_SMARTMIPS;
+#if defined(CONFIG_64BIT) || !defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
 		c->options |= MIPS_CPU_RIXI;
+#endif
 	}
+#if defined(CONFIG_64BIT) || !defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
 	if (config3 & MIPS_CONF3_RXI)
 		c->options |= MIPS_CPU_RIXI;
+#endif
 	if (config3 & MIPS_CONF3_DSP)
 		c->ases |= MIPS_ASE_DSP;
 	if (config3 & MIPS_CONF3_DSP2P)
@@ -272,33 +298,127 @@
 		c->options |= MIPS_CPU_ULRI;
 	if (config3 & MIPS_CONF3_ISA)
 		c->options |= MIPS_CPU_MICROMIPS;
-#ifdef CONFIG_CPU_MICROMIPS
-	write_c0_config3(read_c0_config3() | MIPS_CONF3_ISA_OE);
-#endif
 	if (config3 & MIPS_CONF3_VZ)
 		c->ases |= MIPS_ASE_VZ;
+	if (config3 & MIPS_CONF3_SC)
+		c->options |= MIPS_CPU_SEGMENTS;
 
 	return config3 & MIPS_CONF_M;
 }
 
-static inline unsigned int decode_config4(struct cpuinfo_mips *c)
+static unsigned int cpu_capability = 0;
+
+static inline unsigned int decode_config4(struct cpuinfo_mips *c, int pass,
+					  int conf6available)
 {
 	unsigned int config4;
+	unsigned int newcf4;
+	unsigned int config6;
 
 	config4 = read_c0_config4();
 
-	if ((config4 & MIPS_CONF4_MMUEXTDEF) == MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT
-	    && cpu_has_tlb)
-		c->tlbsize += (config4 & MIPS_CONF4_MMUSIZEEXT) * 0x40;
+	if (pass && cpu_has_tlb) {
+		if (config4 & MIPS_CONF4_IE) {
+			if (config4 & MIPS_CONF4_TLBINV) {
+				c->options |= MIPS_CPU_TLBINV;
+				printk("TLBINV/F supported, config4=0x%0x\n",config4);
+			}
+			/* TBW: page walker support starts here */
+		}
+		switch (config4 & MIPS_CONF4_MMUEXTDEF) {
+		case MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT:
+			c->tlbsize =
+			    ((((config4 & MIPS_CONF4_MMUSIZEEXT) >>
+			       MIPS_CONF4_MMUSIZEEXT_SHIFT) <<
+			      MIPS_CONF1_TLBS_SIZE) |
+				(c->tlbsize - 1)) + 1;
+			c->tlbsizevtlb = c->tlbsize;
+			printk("MMUSizeExt found, total TLB=%d\n",c->tlbsize);
+			break;
+		case MIPS_CONF4_MMUEXTDEF_VTLBSIZEEXT:
+			c->tlbsizevtlb = ((c->tlbsizevtlb - 1) |
+				(((config4 & MIPS_CONF4_VTLBSIZEEXT) >>
+				  MIPS_CONF4_VTLBSIZEEXT_SHIFT) <<
+				 MIPS_CONF1_TLBS_SIZE)) + 1;
+			c->tlbsize = c->tlbsizevtlb;
+			/* fall through */
+		case MIPS_CONF4_MMUEXTDEF_FTLBSIZEEXT:
+			newcf4 = (config4 & ~MIPS_CONF4_FTLBPAGESIZE) |
+				((((fls(PAGE_SIZE >> BASIC_PAGE_SHIFT)-1)/2)+1) <<
+				 MIPS_CONF4_FTLBPAGESIZE_SHIFT);
+			write_c0_config4(newcf4);
+			back_to_back_c0_hazard();
+			config4 = read_c0_config4();
+			if (config4 != newcf4) {
+				printk(KERN_ERR "PAGE_SIZE 0x%0lx is not supported by FTLB (config4=0x%0x)\n",
+					PAGE_SIZE, config4);
+				if (conf6available && (cpu_capability & MIPS_FTLB_CAPABLE)) {
+					printk("Switching FTLB OFF\n");
+					config6 = read_c0_config6();
+					write_c0_config6(config6 & ~MIPS_CONF6_FTLBEN);
+				}
+				printk("Total TLB(VTLB) inuse: %d\n",c->tlbsizevtlb);
+				break;
+			}
+			c->tlbsizeftlbsets = 1 <<
+				((config4 & MIPS_CONF4_FTLBSETS) >>
+				 MIPS_CONF4_FTLBSETS_SHIFT);
+			c->tlbsizeftlbways = ((config4 & MIPS_CONF4_FTLBWAYS) >>
+					      MIPS_CONF4_FTLBWAYS_SHIFT) + 2;
+			c->tlbsize += (c->tlbsizeftlbways *
+				       c->tlbsizeftlbsets);
+			printk("V/FTLB found: VTLB=%d, FTLB sets=%d, ways=%d total TLB=%d\n",
+				c->tlbsizevtlb, c->tlbsizeftlbsets, c->tlbsizeftlbways, c->tlbsize);
+			break;
+		}
+	}
 
 	c->kscratch_mask = (config4 >> 16) & 0xff;
 
 	return config4 & MIPS_CONF_M;
 }
 
-static void __cpuinit decode_configs(struct cpuinfo_mips *c)
+static inline unsigned int decode_config5(struct cpuinfo_mips *c)
+{
+	unsigned int config5;
+
+	config5 = read_c0_config5();
+
+	if (config5 & MIPS_CONF5_EVA)
+		c->options |= MIPS_CPU_EVA;
+
+	return config5 & MIPS_CONF_M;
+}
+
+static inline unsigned int decode_config6_ftlb(struct cpuinfo_mips *c)
+{
+	unsigned int config6;
+
+	if (cpu_capability & MIPS_FTLB_CAPABLE) {
+
+		/*
+		 * Can't rely on mips_ftlb_disabled since kernel command line
+		 * hasn't been processed yet.  Need to peek at the raw command
+		 * line for "noftlb".
+		 */
+		if (strstr(arcs_cmdline, "noftlb") == NULL) {
+			config6 = read_c0_config6();
+
+			printk("Enable FTLB attempt\n");
+			write_c0_config6(config6 | MIPS_CONF6_FTLBEN);
+			back_to_back_c0_hazard();
+
+			return(1);
+		}
+	}
+
+	return(0);
+}
+
+
+static void decode_configs(struct cpuinfo_mips *c)
 {
-	int ok;
+	int ok, ok3 = 0, ok6 = 0;
 
 	/* MIPS32 or MIPS64 compliant CPU.  */
 	c->options = MIPS_CPU_4KEX | MIPS_CPU_4K_CACHE | MIPS_CPU_COUNTER |
@@ -307,15 +427,22 @@
 	c->scache.flags = MIPS_CACHE_NOT_PRESENT;
 
 	ok = decode_config0(c);			/* Read Config registers.  */
-	BUG_ON(!ok);				/* Arch spec violation!	 */
+	BUG_ON(!ok);				/* Arch spec violation!  */
 	if (ok)
 		ok = decode_config1(c);
 	if (ok)
 		ok = decode_config2(c);
 	if (ok)
-		ok = decode_config3(c);
+		ok = ok3 = decode_config3(c);
+	if (ok)
+		ok = decode_config4(c,0,0);   /* first pass - just return Mbit */
 	if (ok)
-		ok = decode_config4(c);
+		ok = decode_config5(c);
+	if (cpu_capability & MIPS_FTLB_CAPABLE)
+		ok6 = decode_config6_ftlb(c);
+
+	if (ok3)
+		ok = decode_config4(c,1,ok6); /* real parse pass, thanks HW team :-/ */
 
 	mips_probe_watch_registers(c);
 
@@ -712,7 +839,26 @@
 		c->cputype = CPU_74K;
 		__cpu_name[cpu] = "MIPS 1074Kc";
 		break;
+	case PRID_IMP_PROAPTIV_UP:
+		c->cputype = CPU_PROAPTIV;
+		__cpu_name[cpu] = "MIPS proAptiv";
+		cpu_capability = MIPS_FTLB_CAPABLE;
+		break;
+	case PRID_IMP_PROAPTIV_MP:
+		c->cputype = CPU_PROAPTIV;
+		__cpu_name[cpu] = "MIPS proAptiv (multi)";
+		cpu_capability = MIPS_FTLB_CAPABLE;
+		break;
+	case PRID_IMP_INTERAPTIV_UP:
+		c->cputype = CPU_INTERAPTIV;
+		__cpu_name[cpu] = "MIPS interAptiv UP";
+		break;
+	case PRID_IMP_INTERAPTIV_MP:
+		c->cputype = CPU_INTERAPTIV;
+		__cpu_name[cpu] = "MIPS interAptiv";
+		break;
 	}
+	decode_configs(c);
 
 	spram_config();
 }
@@ -872,19 +1018,49 @@
 	}
 }
 
+extern int soc_support_mxuv2(void);
+
 static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
 {
+	unsigned int errorpc;
+	static unsigned int showerrorpc[NR_CPUS];
+	unsigned int config1;
+
+	if(showerrorpc[cpu] == 0) {
+		__asm__ __volatile__ (
+			"mfc0  %0, $30,  0   \n\t"
+			"nop                  \n\t"
+			:"=r"(errorpc)
+			:);
+
+		printk("CPU%d RESET ERROR PC:%08X\n", cpu,errorpc);
+		if(kernel_text_address(errorpc))
+			print_ip_sym(errorpc);
+		showerrorpc[cpu] = 1;
+	}
 	decode_configs(c);
 	/* JZRISC does not implement the CP0 counter. */
 	c->options &= ~MIPS_CPU_COUNTER;
-	switch (c->processor_id & 0xff00) {
-	case PRID_IMP_JZRISC:
-		c->cputype = CPU_JZRISC;
-		__cpu_name[cpu] = "Ingenic JZRISC";
-		break;
-	default:
-		panic("Unknown Ingenic Processor ID!");
-		break;
+
+	c->cputype = CPU_JZRISC;
+	__cpu_name[cpu] = "Ingenic Xburst";
+	c->isa_level = MIPS_CPU_ISA_M32R1;
+	c->tlbsize = 32;
+
+	config1 = read_c0_config1();
+
+	/* Xburst CU2 is MXUV2 */
+	if (config1 & MIPS_CONF1_C2) {
+		if (soc_support_mxuv2()) {
+			c->ases |= MIPS_ASE_XBURSTMXUV2;
+		} else {
+			c->ases |= MIPS_ASE_XBURSTMXU;
+		}
+	}
+
+	__write_32bit_c0_register($16, 7, 0x10);
+	if((c->processor_id & PRID_CPU_ISA_MASK) == PRID_IMP_ISA_R2) {
+		c->isa_level = MIPS_CPU_ISA_M32R2;
 	}
 }
 
@@ -969,6 +1145,8 @@
 
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
+unsigned int fpu_fcr31 __read_mostly = 0;
+unsigned int system_has_fpu __read_mostly = 0;
 
 __cpuinit void cpu_probe(void)
 {
@@ -1011,6 +1189,9 @@
 	case PRID_COMP_NETLOGIC:
 		cpu_probe_netlogic(c, cpu);
 		break;
+	default:
+		cpu_probe_ingenic(c, cpu);
+		break;
 	}
 
 	BUG_ON(!__cpu_name[cpu]);
@@ -1030,12 +1211,17 @@
 		c->ases &= ~(MIPS_ASE_DSP | MIPS_ASE_DSP2P);
 
 	if (c->options & MIPS_CPU_FPU) {
+		system_has_fpu = 1;
+		fpu_fcr31 = cpu_test_fpu_csr31(FPU_CSR_DEFAULT);
+
 		c->fpu_id = cpu_get_fpu_id();
 
 		if (c->isa_level & (MIPS_CPU_ISA_M32R1 | MIPS_CPU_ISA_M32R2 |
 				    MIPS_CPU_ISA_M64R1 | MIPS_CPU_ISA_M64R2)) {
 			if (c->fpu_id & MIPS_FPIR_3D)
 				c->ases |= MIPS_ASE_MIPS3D;
+			if (c->fpu_id & MIPS_FPIR_HAS2008)
+				fpu_fcr31 = cpu_test_fpu_csr31(FPU_CSR_DEFAULT|FPU_CSR_MAC2008|FPU_CSR_ABS2008|FPU_CSR_NAN2008);
 		}
 	}
 
@@ -1059,8 +1245,8 @@
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 
-	printk(KERN_INFO "CPU revision is: %08x (%s)\n",
-	       c->processor_id, cpu_name_string());
+	printk(KERN_INFO "CPU%d revision is: %08x (%s)\n",
+	       smp_processor_id(), c->processor_id, cpu_name_string());
 	if (c->options & MIPS_CPU_FPU)
 		printk(KERN_INFO "FPU revision is: %08x\n", c->fpu_id);
 }
diff -ur ./arch/mips/kernel/entry.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/entry.S
--- ./arch/mips/kernel/entry.S	2023-04-26 12:25:54.860119502 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/entry.S	2023-04-23 11:58:24.199519800 +0100
@@ -203,10 +203,16 @@
  *
  * For C code use the inline version named instruction_hazard().
  */
+#ifdef CONFIG_EVA
+	.align  8
+#endif
 LEAF(mips_ihb)
 	.set	mips32r2
 	jr.hb	ra
 	nop
+#ifdef CONFIG_EVA
+	.align  8
+#endif
 	END(mips_ihb)
 
 #endif /* CONFIG_CPU_MIPSR2 or CONFIG_MIPS_MT */
diff -ur ./arch/mips/kernel/ftrace.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/ftrace.c
--- ./arch/mips/kernel/ftrace.c	2023-04-26 12:25:54.860119502 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/ftrace.c	2023-04-23 11:58:24.193049300 +0100
@@ -87,6 +87,7 @@
 static int ftrace_modify_code(unsigned long ip, unsigned int new_code)
 {
 	int faulted;
+	mm_segment_t old_fs;
 
 	/* *(unsigned int *)ip = new_code; */
 	safe_store_code(new_code, ip, faulted);
@@ -94,7 +95,10 @@
 	if (unlikely(faulted))
 		return -EFAULT;
 
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
 	flush_icache_range(ip, ip + 8);
+	set_fs(old_fs);
 
 	return 0;
 }
diff -ur ./arch/mips/kernel/genex.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/genex.S
--- ./arch/mips/kernel/genex.S	2023-04-26 12:25:54.860119502 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/genex.S	2023-04-23 11:58:24.192353800 +0100
@@ -374,10 +374,26 @@
 NESTED(nmi_handler, PT_SIZE, sp)
 	.set	push
 	.set	noat
+		/* Clear ERL - restore segment mapping */
+		mfc0	k0, CP0_STATUS
+		ori     k0, k0, ST0_EXL
+		lui     k1, 0xffff & ~(ST0_BEV>>16)
+		ori     k1, k1, 0xffff & ~(ST0_ERL)
+		and     k0, k0, k1
+		mtc0    k0, CP0_STATUS
+		ehb
 	SAVE_ALL
 	move	a0, sp
 	jal	nmi_exception_handler
 	RESTORE_ALL
+		/* Set ERL and clear EXL|NMI */
+		mfc0	k0, CP0_STATUS
+		ori     k0, k0, ST0_ERL
+		lui     k1, 0xffff & ~(ST0_NMI>>16)
+		ori     k1, k1, 0xffff & ~(ST0_EXL)
+		and     k0, k0, k1
+		mtc0    k0, CP0_STATUS
+		ehb
 	.set	mips3
 	eret
 	.set	pop
@@ -468,6 +484,7 @@
 	BUILD_HANDLER ov ov sti silent			/* #12 */
 	BUILD_HANDLER tr tr sti silent			/* #13 */
 	BUILD_HANDLER fpe fpe fpe silent		/* #15 */
+	BUILD_HANDLER mfpe mfpe sti silent		/* #16 */
 	BUILD_HANDLER mdmx mdmx sti silent		/* #22 */
 #ifdef	CONFIG_HARDWARE_WATCHPOINTS
 	/*
diff -ur ./arch/mips/kernel/head.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/head.S
--- ./arch/mips/kernel/head.S	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/head.S	2023-04-23 11:58:24.276074000 +0100
@@ -142,9 +142,13 @@
 
 	__REF
 
+#ifdef CONFIG_EVA
+	.align  8
+#endif
+
 NESTED(kernel_entry, 16, sp)			# kernel entry point
 
-	kernel_entry_setup			# cpu specific setup
+	kernel_entry_setup                      # cpu specific setup
 
 	setup_c0_status_pri
 
@@ -152,6 +156,9 @@
 	   so we jump there.  */
 	PTR_LA	t0, 0f
 	jr	t0
+#ifdef CONFIG_EVA
+	.align  8
+#endif
 0:
 
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -204,7 +211,13 @@
  * SMP slave cpus entry point.	Board specific code for bootstrap calls this
  * function after setting up the stack and gp registers.
  */
+
+#ifdef CONFIG_EVA
+	.align  8
+#endif
+
 NESTED(smp_bootstrap, 16, sp)
+
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
 	 * Read-modify-writes of Status must be atomic, and this
@@ -216,8 +229,10 @@
 	DMT	10	# dmt t2 /* t0, t1 are used by CLI and setup_c0_status() */
 	jal	mips_ihb
 #endif /* CONFIG_MIPS_MT_SMTC */
-	setup_c0_status_sec
+
 	smp_slave_setup
+	setup_c0_status_sec
+
 #ifdef CONFIG_MIPS_MT_SMTC
 	andi	t2, t2, VPECONTROL_TE
 	beqz	t2, 2f
@@ -225,6 +240,9 @@
 2:
 #endif /* CONFIG_MIPS_MT_SMTC */
 	j	start_secondary
+#ifdef CONFIG_EVA
+	.align  8
+#endif
 	END(smp_bootstrap)
 #endif /* CONFIG_SMP */
 
diff -ur ./arch/mips/kernel/idle.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/idle.c
--- ./arch/mips/kernel/idle.c	2023-04-26 12:25:54.860119502 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/idle.c	2023-04-23 11:58:24.275058900 +0100
@@ -20,6 +20,7 @@
 #include <asm/cpu-info.h>
 #include <asm/idle.h>
 #include <asm/mipsregs.h>
+#include <asm/cacheops.h>
 
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
@@ -31,6 +32,48 @@
 void (*cpu_wait)(void);
 EXPORT_SYMBOL(cpu_wait);
 
+static void jz_wait_irqoff(void)
+{
+#define cache_prefetch(label)						\
+	do{								\
+		unsigned long addr,size,end;				\
+		/* Prefetch codes from label */				\
+		addr = (unsigned long)(&&label) & ~(32 - 1);		\
+		size = 32 * 6; /* load 128 cachelines */		\
+		end = addr + size;					\
+		for (; addr < end; addr += 32) {			\
+			__asm__ volatile (				\
+				".set mips32\n\t"			\
+				" cache %0, 0(%1)\n\t"			\
+				".set mips32\n\t"			\
+				:					\
+				: "I" (Index_Prefetch_I), "r"(addr));	\
+		}							\
+	}								\
+	while(0)
+
+	local_irq_disable();
+#ifdef CONFIG_SOC_4780
+	blast_dcache_jz();
+#endif
+	cache_prefetch(IDLE_PROGRAM);
+IDLE_PROGRAM:
+	if (!need_resched())
+		__asm__ __volatile__ (" .set    push            \n"
+				" .set    mips3           \n"
+				" sync                    \n"
+				" lw      $0,     0(%0)   \n"
+				" wait                    \n"
+				" nop                     \n"
+				" nop                     \n"
+				" nop                     \n"
+				" .set    pop             \n"
+				:: "r" (0xa0000000)
+				);
+	local_irq_enable();
+	return;
+}
+
 static void r3081_wait(void)
 {
 	unsigned long cfg = read_c0_conf();
@@ -167,6 +210,8 @@
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
 	case CPU_JZRISC:
+		cpu_wait = jz_wait_irqoff;
+		break;
 	case CPU_LOONGSON1:
 	case CPU_XLR:
 	case CPU_XLP:
@@ -182,6 +227,8 @@
 	case CPU_24K:
 	case CPU_34K:
 	case CPU_1004K:
+	case CPU_PROAPTIV:
+	case CPU_INTERAPTIV:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;
diff -ur ./arch/mips/kernel/irq-gic.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/irq-gic.c
--- ./arch/mips/kernel/irq-gic.c	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/irq-gic.c	2023-04-23 11:58:24.274647400 +0100
@@ -219,16 +219,15 @@
 
 	/* Assumption : cpumask refers to a single CPU */
 	spin_lock_irqsave(&gic_lock, flags);
-	for (;;) {
-		/* Re-route this IRQ */
-		GIC_SH_MAP_TO_VPE_SMASK(irq, first_cpu(tmp));
 
-		/* Update the pcpu_masks */
-		for (i = 0; i < NR_CPUS; i++)
-			clear_bit(irq, pcpu_masks[i].pcpu_mask);
-		set_bit(irq, pcpu_masks[first_cpu(tmp)].pcpu_mask);
+	/* Re-route this IRQ */
+	GIC_SH_MAP_TO_VPE_SMASK(irq, first_cpu(tmp));
+
+	/* Update the pcpu_masks */
+	for (i = 0; i < NR_CPUS; i++)
+		clear_bit(irq, pcpu_masks[i].pcpu_mask);
+	set_bit(irq, pcpu_masks[first_cpu(tmp)].pcpu_mask);
 
-	}
 	cpumask_copy(d->affinity, cpumask);
 	spin_unlock_irqrestore(&gic_lock, flags);
 
diff -ur ./arch/mips/kernel/kgdb.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/kgdb.c
--- ./arch/mips/kernel/kgdb.c	2023-04-26 12:25:54.870119508 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/kgdb.c	2023-04-23 11:58:24.432181000 +0100
@@ -32,6 +32,7 @@
 #include <asm/cacheflush.h>
 #include <asm/processor.h>
 #include <asm/sigcontext.h>
+#include <asm/uaccess.h>
 
 static struct hard_trap_info {
 	unsigned char tt;	/* Trap type code for MIPS R3xxx and R4xxx */
@@ -208,7 +209,14 @@
 
 static void kgdb_call_nmi_hook(void *ignored)
 {
+	mm_segment_t old_fs;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
 	kgdb_nmicallback(raw_smp_processor_id(), NULL);
+
+	set_fs(old_fs);
 }
 
 void kgdb_roundup_cpus(unsigned long flags)
@@ -282,6 +290,7 @@
 	struct die_args *args = (struct die_args *)ptr;
 	struct pt_regs *regs = args->regs;
 	int trap = (regs->cp0_cause & 0x7c) >> 2;
+	mm_segment_t old_fs;
 
 #ifdef CONFIG_KPROBES
 	/*
@@ -296,11 +305,16 @@
 	if (user_mode(regs))
 		return NOTIFY_DONE;
 
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
 	if (atomic_read(&kgdb_active) != -1)
 		kgdb_nmicallback(smp_processor_id(), regs);
 
-	if (kgdb_handle_exception(trap, compute_signal(trap), cmd, regs))
+	if (kgdb_handle_exception(trap, compute_signal(trap), cmd, regs)) {
+		set_fs(old_fs);
 		return NOTIFY_DONE;
+	}
 
 	if (atomic_read(&kgdb_setting_breakpoint))
 		if ((trap == 9) && (regs->cp0_epc == (unsigned long)breakinst))
@@ -310,6 +324,7 @@
 	local_irq_enable();
 	__flush_cache_all();
 
+	set_fs(old_fs);
 	return NOTIFY_STOP;
 }
 
diff -ur ./arch/mips/kernel/mcount.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/mcount.S
--- ./arch/mips/kernel/mcount.S	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/mcount.S	2023-04-23 11:58:24.430388400 +0100
@@ -168,15 +168,11 @@
 #endif
 
 	/* arg3: Get frame pointer of current stack */
-#ifdef CONFIG_FRAME_POINTER
-	move	a2, fp
-#else /* ! CONFIG_FRAME_POINTER */
 #ifdef CONFIG_64BIT
 	PTR_LA	a2, PT_SIZE(sp)
 #else
 	PTR_LA	a2, (PT_SIZE+8)(sp)
 #endif
-#endif
 
 	jal	prepare_ftrace_return
 	 nop
diff -ur ./arch/mips/kernel/mips_ksyms.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/mips_ksyms.c
--- ./arch/mips/kernel/mips_ksyms.c	2023-04-26 12:25:54.880119515 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/mips_ksyms.c	2023-04-23 11:58:24.525818900 +0100
@@ -16,14 +16,14 @@
 #include <asm/ftrace.h>
 
 extern void *__bzero(void *__s, size_t __count);
-extern long __strncpy_from_user_nocheck_asm(char *__to,
+extern long __strncpy_from_kernel_nocheck_asm(char *__to,
 					    const char *__from, long __len);
-extern long __strncpy_from_user_asm(char *__to, const char *__from,
+extern long __strncpy_from_kernel_asm(char *__to, const char *__from,
 				    long __len);
-extern long __strlen_user_nocheck_asm(const char *s);
-extern long __strlen_user_asm(const char *s);
-extern long __strnlen_user_nocheck_asm(const char *s);
-extern long __strnlen_user_asm(const char *s);
+extern long __strlen_kernel_nocheck_asm(const char *s);
+extern long __strlen_kernel_asm(const char *s);
+extern long __strnlen_kernel_nocheck_asm(const char *s);
+extern long __strnlen_kernel_asm(const char *s);
 
 /*
  * String functions
@@ -44,16 +44,44 @@
 EXPORT_SYMBOL(__copy_user);
 EXPORT_SYMBOL(__copy_user_inatomic);
 EXPORT_SYMBOL(__bzero);
-EXPORT_SYMBOL(__strncpy_from_user_nocheck_asm);
-EXPORT_SYMBOL(__strncpy_from_user_asm);
+EXPORT_SYMBOL(__strlen_kernel_nocheck_asm);
+EXPORT_SYMBOL(__strlen_kernel_asm);
+EXPORT_SYMBOL(__strnlen_kernel_nocheck_asm);
+EXPORT_SYMBOL(__strnlen_kernel_asm);
+EXPORT_SYMBOL(__strncpy_from_kernel_nocheck_asm);
+EXPORT_SYMBOL(__strncpy_from_kernel_asm);
+
+#ifdef CONFIG_EVA
+extern void *__bzero_user(void *__s, size_t __count);
+extern long __strncpy_from_user_nocheck_asm(char *__to,
+					    const char *__from, long __len);
+extern long __strncpy_from_user_asm(char *__to, const char *__from,
+				    long __len);
+extern long __strlen_user_nocheck_asm(const char *s);
+extern long __strlen_user_asm(const char *s);
+extern long __strnlen_user_nocheck_asm(const char *s);
+extern long __strnlen_user_asm(const char *s);
+
+EXPORT_SYMBOL(__copy_touser);
+EXPORT_SYMBOL(__copy_fromuser);
+EXPORT_SYMBOL(__copy_fromuser_inatomic);
+EXPORT_SYMBOL(__copy_inuser);
+EXPORT_SYMBOL(__bzero_user);
 EXPORT_SYMBOL(__strlen_user_nocheck_asm);
 EXPORT_SYMBOL(__strlen_user_asm);
 EXPORT_SYMBOL(__strnlen_user_nocheck_asm);
 EXPORT_SYMBOL(__strnlen_user_asm);
+EXPORT_SYMBOL(__strncpy_from_user_nocheck_asm);
+EXPORT_SYMBOL(__strncpy_from_user_asm);
+#endif
 
 EXPORT_SYMBOL(csum_partial);
 EXPORT_SYMBOL(csum_partial_copy_nocheck);
 EXPORT_SYMBOL(__csum_partial_copy_user);
+#ifdef CONFIG_EVA
+EXPORT_SYMBOL(__csum_partial_copy_fromuser);
+EXPORT_SYMBOL(__csum_partial_copy_touser);
+#endif
 
 EXPORT_SYMBOL(invalid_pte_table);
 #ifdef CONFIG_FUNCTION_TRACER
diff -ur ./arch/mips/kernel/perf_event_mipsxx.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/perf_event_mipsxx.c
--- ./arch/mips/kernel/perf_event_mipsxx.c	2023-04-26 12:25:54.880119515 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/perf_event_mipsxx.c	2023-04-23 11:58:24.679901300 +0100
@@ -805,7 +805,7 @@
 	}
 }
 
-/* 24K/34K/1004K cores can share the same event map. */
+/* 24K/34K/1004K/interAptiv/loongson1 cores share the same event map. */
 static const struct mips_perf_event mipsxxcore_event_map
 				[PERF_COUNT_HW_MAX] = {
 	[PERF_COUNT_HW_CPU_CYCLES] = { 0x00, CNTR_EVEN | CNTR_ODD, P },
@@ -814,8 +814,8 @@
 	[PERF_COUNT_HW_BRANCH_MISSES] = { 0x02, CNTR_ODD, T },
 };
 
-/* 74K core has different branch event code. */
-static const struct mips_perf_event mipsxx74Kcore_event_map
+/* 74K/proAptiv core has different branch event code. */
+static const struct mips_perf_event mipsxxcore_event_map2
 				[PERF_COUNT_HW_MAX] = {
 	[PERF_COUNT_HW_CPU_CYCLES] = { 0x00, CNTR_EVEN | CNTR_ODD, P },
 	[PERF_COUNT_HW_INSTRUCTIONS] = { 0x01, CNTR_EVEN | CNTR_ODD, T },
@@ -849,7 +849,7 @@
 	[PERF_COUNT_HW_BRANCH_MISSES] = { 0x1c, CNTR_ALL }, /* PAPI_BR_MSP */
 };
 
-/* 24K/34K/1004K cores can share the same cache event map. */
+/* 24K/34K/1004K/interAptiv/loongson1 cores share the same cache event map. */
 static const struct mips_perf_event mipsxxcore_cache_map
 				[PERF_COUNT_HW_CACHE_MAX]
 				[PERF_COUNT_HW_CACHE_OP_MAX]
@@ -930,8 +930,8 @@
 },
 };
 
-/* 74K core has completely different cache event map. */
-static const struct mips_perf_event mipsxx74Kcore_cache_map
+/* 74K/proAptiv core has completely different cache event map. */
+static const struct mips_perf_event mipsxxcore_cache_map2
 				[PERF_COUNT_HW_CACHE_MAX]
 				[PERF_COUNT_HW_CACHE_OP_MAX]
 				[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
@@ -971,13 +971,18 @@
 [C(LL)] = {
 	[C(OP_READ)] = {
 		[C(RESULT_ACCESS)]	= { 0x1c, CNTR_ODD, P },
-		[C(RESULT_MISS)]	= { 0x1d, CNTR_EVEN | CNTR_ODD, P },
+		[C(RESULT_MISS)]	= { 0x1d, CNTR_EVEN, P },
 	},
 	[C(OP_WRITE)] = {
 		[C(RESULT_ACCESS)]	= { 0x1c, CNTR_ODD, P },
-		[C(RESULT_MISS)]	= { 0x1d, CNTR_EVEN | CNTR_ODD, P },
+		[C(RESULT_MISS)]	= { 0x1d, CNTR_EVEN, P },
 	},
 },
+/*
+ * 74K core does not have specific DTLB events. proAptiv core has
+ * "speculative" DTLB events which are numbered 0x63 (even/odd) and
+ * not included here. One can use raw events if really needed.
+ */
 [C(ITLB)] = {
 	[C(OP_READ)] = {
 		[C(RESULT_ACCESS)]	= { 0x04, CNTR_EVEN, T },
@@ -1378,6 +1383,10 @@
 #define IS_BOTH_COUNTERS_74K_EVENT(b)					\
 	((b) == 0 || (b) == 1)
 
+/* proAptiv */
+#define IS_BOTH_COUNTERS_PROAPTIV_EVENT(b)				\
+	((b) == 0 || (b) == 1)
+
 /* 1004K */
 #define IS_BOTH_COUNTERS_1004K_EVENT(b)					\
 	((b) == 0 || (b) == 1 || (b) == 11)
@@ -1391,6 +1400,20 @@
 #define IS_RANGE_V_1004K_EVENT(r)	((r) == 47)
 #endif
 
+/* interAptiv */
+#define IS_BOTH_COUNTERS_INTERAPTIV_EVENT(b)				\
+	((b) == 0 || (b) == 1 || (b) == 11)
+#ifdef CONFIG_MIPS_MT_SMP
+/* The P/V/T info is not provided for "(b) == 38" in SUM, assume P. */
+#define IS_RANGE_P_INTERAPTIV_EVENT(r, b)				\
+	((b) == 0 || (r) == 18 || (b) == 21 || (b) == 22 ||		\
+	 (b) == 25 || (b) == 36 || (b) == 38 || (b) == 39 ||		\
+	 (r) == 44 || (r) == 174 || (r) == 176 || ((b) >= 50 &&		\
+	 (b) <= 59) || (r) == 188 || (b) == 61 || (b) == 62 ||		\
+	 ((b) >= 64 && (b) <= 67))
+#define IS_RANGE_V_INTERAPTIV_EVENT(r)	((r) == 47 || (r) == 175)
+#endif
+
 /* BMIPS5000 */
 #define IS_BOTH_COUNTERS_BMIPS5000_EVENT(b)				\
 	((b) == 0 || (b) == 1)
@@ -1451,6 +1474,16 @@
 		raw_event.range = P;
 #endif
 		break;
+	case CPU_PROAPTIV:
+		if (IS_BOTH_COUNTERS_PROAPTIV_EVENT(base_id))
+			raw_event.cntr_mask = CNTR_EVEN | CNTR_ODD;
+		else
+			raw_event.cntr_mask =
+				raw_id > 127 ? CNTR_ODD : CNTR_EVEN;
+#ifdef CONFIG_MIPS_MT_SMP
+		raw_event.range = P;
+#endif
+		break;
 	case CPU_1004K:
 		if (IS_BOTH_COUNTERS_1004K_EVENT(base_id))
 			raw_event.cntr_mask = CNTR_EVEN | CNTR_ODD;
@@ -1466,6 +1499,21 @@
 			raw_event.range = T;
 #endif
 		break;
+	case CPU_INTERAPTIV:
+		if (IS_BOTH_COUNTERS_INTERAPTIV_EVENT(base_id))
+			raw_event.cntr_mask = CNTR_EVEN | CNTR_ODD;
+		else
+			raw_event.cntr_mask =
+				raw_id > 127 ? CNTR_ODD : CNTR_EVEN;
+#ifdef CONFIG_MIPS_MT_SMP
+		if (IS_RANGE_P_INTERAPTIV_EVENT(raw_id, base_id))
+			raw_event.range = P;
+		else if (unlikely(IS_RANGE_V_INTERAPTIV_EVENT(raw_id)))
+			raw_event.range = V;
+		else
+			raw_event.range = T;
+#endif
+		break;
 	case CPU_BMIPS5000:
 		if (IS_BOTH_COUNTERS_BMIPS5000_EVENT(base_id))
 			raw_event.cntr_mask = CNTR_EVEN | CNTR_ODD;
@@ -1576,14 +1624,24 @@
 		break;
 	case CPU_74K:
 		mipspmu.name = "mips/74K";
-		mipspmu.general_event_map = &mipsxx74Kcore_event_map;
-		mipspmu.cache_event_map = &mipsxx74Kcore_cache_map;
+		mipspmu.general_event_map = &mipsxxcore_event_map2;
+		mipspmu.cache_event_map = &mipsxxcore_cache_map2;
 		break;
 	case CPU_1004K:
 		mipspmu.name = "mips/1004K";
 		mipspmu.general_event_map = &mipsxxcore_event_map;
 		mipspmu.cache_event_map = &mipsxxcore_cache_map;
 		break;
+	case CPU_INTERAPTIV:
+		mipspmu.name = "mips/interAptiv";
+		mipspmu.general_event_map = &mipsxxcore_event_map;
+		mipspmu.cache_event_map = &mipsxxcore_cache_map;
+		break;
+	case CPU_PROAPTIV:
+		mipspmu.name = "mips/proAptiv";
+		mipspmu.general_event_map = &mipsxxcore_event_map2;
+		mipspmu.cache_event_map = &mipsxxcore_cache_map2;
+		break;
 	case CPU_LOONGSON1:
 		mipspmu.name = "mips/loongson1";
 		mipspmu.general_event_map = &mipsxxcore_event_map;
diff -ur ./arch/mips/kernel/proc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/proc.c
--- ./arch/mips/kernel/proc.c	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/proc.c	2023-04-23 11:58:24.679513500 +0100
@@ -15,6 +15,7 @@
 #include <asm/processor.h>
 #include <asm/prom.h>
 
+extern const char *get_board_type(void);
 unsigned int vced_count, vcei_count;
 
 static int show_cpuinfo(struct seq_file *m, void *v)
@@ -22,6 +23,7 @@
 	unsigned long n = (unsigned long) v - 1;
 	unsigned int version = cpu_data[n].processor_id;
 	unsigned int fp_vers = cpu_data[n].fpu_id;
+	uint32_t efbuf[4] = {0};
 	char fmt [64];
 	int i;
 
@@ -98,6 +100,8 @@
 	if (cpu_has_mipsmt)	seq_printf(m, "%s", " mt");
 	if (cpu_has_mmips)	seq_printf(m, "%s", " micromips");
 	if (cpu_has_vz)		seq_printf(m, "%s", " vz");
+	if (cpu_has_eva)	seq_printf(m, "%s", " eva");
+	if (cpu_has_mxu)	seq_printf(m, "%s", " mxu");
 	seq_printf(m, "\n");
 
 	if (cpu_has_mmips) {
@@ -109,6 +113,14 @@
 	seq_printf(m, "kscratch registers\t: %d\n",
 		      hweight8(cpu_data[n].kscratch_mask));
 	seq_printf(m, "core\t\t\t: %d\n", cpu_data[n].core);
+#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
+	if (cpu_has_mipsmt) {
+		seq_printf(m, "VPE\t\t\t: %d\n", cpu_data[n].vpe_id);
+#if defined(CONFIG_MIPS_MT_SMTC)
+		seq_printf(m, "TC\t\t\t: %d\n", cpu_data[n].tc_id);
+#endif
+	}
+#endif
 
 	sprintf(fmt, "VCE%%c exceptions\t\t: %s\n",
 		      cpu_has_vce ? "%u" : "not available");
@@ -116,6 +128,10 @@
 	seq_printf(m, fmt, 'I', vcei_count);
 	seq_printf(m, "\n");
 
+	/* Android requires 'Hardware' to setup the init.%hardware%.rc */
+	seq_printf(m, "Hardware\t\t: %s\n", get_board_type());
+	seq_printf(m, "Serial\t\t\t: %08x %08x %08x %08x\n", efbuf[0], efbuf[1], efbuf[2], efbuf[3]);
+
 	return 0;
 }
 
diff -ur ./arch/mips/kernel/process.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/process.c
--- ./arch/mips/kernel/process.c	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/process.c	2023-04-23 11:58:24.679118000 +0100
@@ -42,6 +42,8 @@
 #include <asm/inst.h>
 #include <asm/stacktrace.h>
 
+#include <mxu.h>
+
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
 {
@@ -60,15 +62,14 @@
 
 	/* New thread loses kernel privileges. */
 	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
-#ifdef CONFIG_64BIT
-	status |= test_thread_flag(TIF_32BIT_REGS) ? 0 : ST0_FR;
-#endif
 	status |= KU_USER;
 	regs->cp0_status = status;
 	clear_used_math();
 	clear_fpu_owner();
 	if (cpu_has_dsp)
 		__init_dsp();
+	if (cpu_has_mxu)
+		__init_mxu();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 }
@@ -99,6 +100,9 @@
 	if (cpu_has_dsp)
 		save_dsp(p);
 
+	if (cpu_has_mxu)
+		save_mxu(p);
+
 	preempt_enable();
 
 	/* set up new TSS. */
diff -ur ./arch/mips/kernel/ptrace.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/ptrace.c
--- ./arch/mips/kernel/ptrace.c	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/ptrace.c	2023-04-23 11:58:24.678043000 +0100
@@ -222,14 +222,14 @@
 	for (i = 0; i < current_cpu_data.watch_reg_use_cnt; i++) {
 		__get_user(lt[i], &addr->WATCH_STYLE.watchlo[i]);
 #ifdef CONFIG_32BIT
-		if (lt[i] & __UA_LIMIT)
+		if (lt[i] & USER_DS.seg)
 			return -EINVAL;
 #else
 		if (test_tsk_thread_flag(child, TIF_32BIT_ADDR)) {
 			if (lt[i] & 0xffffffff80000000UL)
 				return -EINVAL;
 		} else {
-			if (lt[i] & __UA_LIMIT)
+			if (lt[i] & USER_DS.seg)
 				return -EINVAL;
 		}
 #endif
diff -ur ./arch/mips/kernel/r4k_fpu.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/r4k_fpu.S
--- ./arch/mips/kernel/r4k_fpu.S	2023-04-26 12:25:54.890119521 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/r4k_fpu.S	2023-04-23 11:58:24.750725400 +0100
@@ -22,6 +22,7 @@
 	.macro	EX insn, reg, src
 	.set	push
 	.set	nomacro
+	.set	hardfloat
 .ex\@:	\insn	\reg, \src
 	.set	pop
 	.section __ex_table,"a"
@@ -53,6 +54,36 @@
 	EX	sdc1 $f27, SC_FPREGS+216(a0)
 	EX	sdc1 $f29, SC_FPREGS+232(a0)
 	EX	sdc1 $f31, SC_FPREGS+248(a0)
+#else
+#ifdef CONFIG_MIPS32_R2
+	.set    push
+	.set    mips64r2
+	.set    noreorder
+	mfc0    t0, CP0_STATUS
+	sll     t0, t0, 31 - _ST0_FR
+	bgez    t0, 1f              # 16 / 32 register mode?
+	 nop
+
+	/* Store the 16 odd double precision registers */
+	EX      sdc1 $f1, SC_FPREGS+8(a0)
+	EX      sdc1 $f3, SC_FPREGS+24(a0)
+	EX      sdc1 $f5, SC_FPREGS+40(a0)
+	EX      sdc1 $f7, SC_FPREGS+56(a0)
+	EX      sdc1 $f9, SC_FPREGS+72(a0)
+	EX      sdc1 $f11, SC_FPREGS+88(a0)
+	EX      sdc1 $f13, SC_FPREGS+104(a0)
+	EX      sdc1 $f15, SC_FPREGS+120(a0)
+	EX      sdc1 $f17, SC_FPREGS+136(a0)
+	EX      sdc1 $f19, SC_FPREGS+152(a0)
+	EX      sdc1 $f21, SC_FPREGS+168(a0)
+	EX      sdc1 $f23, SC_FPREGS+184(a0)
+	EX      sdc1 $f25, SC_FPREGS+200(a0)
+	EX      sdc1 $f27, SC_FPREGS+216(a0)
+	EX      sdc1 $f29, SC_FPREGS+232(a0)
+	EX      sdc1 $f31, SC_FPREGS+248(a0)
+	.set    pop
+1:
+#endif
 #endif
 
 	/* Store the 16 even double precision registers */
@@ -82,6 +113,30 @@
 LEAF(_save_fp_context32)
 	cfc1	t1, fcr31
 
+	mfc0    t0, CP0_STATUS
+	sll     t0, t0, 31 - _ST0_FR
+	bgez    t0, 1f              # 16 / 32 register mode?
+	 nop
+
+	/* Store the 16 odd double precision registers */
+	EX      sdc1 $f1, SC_FPREGS+8(a0)
+	EX      sdc1 $f3, SC_FPREGS+24(a0)
+	EX      sdc1 $f5, SC_FPREGS+40(a0)
+	EX      sdc1 $f7, SC_FPREGS+56(a0)
+	EX      sdc1 $f9, SC_FPREGS+72(a0)
+	EX      sdc1 $f11, SC_FPREGS+88(a0)
+	EX      sdc1 $f13, SC_FPREGS+104(a0)
+	EX      sdc1 $f15, SC_FPREGS+120(a0)
+	EX      sdc1 $f17, SC_FPREGS+136(a0)
+	EX      sdc1 $f19, SC_FPREGS+152(a0)
+	EX      sdc1 $f21, SC_FPREGS+168(a0)
+	EX      sdc1 $f23, SC_FPREGS+184(a0)
+	EX      sdc1 $f25, SC_FPREGS+200(a0)
+	EX      sdc1 $f27, SC_FPREGS+216(a0)
+	EX      sdc1 $f29, SC_FPREGS+232(a0)
+	EX      sdc1 $f31, SC_FPREGS+248(a0)
+1:
+
 	EX	sdc1 $f0, SC32_FPREGS+0(a0)
 	EX	sdc1 $f2, SC32_FPREGS+16(a0)
 	EX	sdc1 $f4, SC32_FPREGS+32(a0)
@@ -131,6 +186,36 @@
 	EX	ldc1 $f27, SC_FPREGS+216(a0)
 	EX	ldc1 $f29, SC_FPREGS+232(a0)
 	EX	ldc1 $f31, SC_FPREGS+248(a0)
+
+#else
+#ifdef CONFIG_MIPS32_R2
+	.set    push
+	.set    mips64r2
+	.set    noreorder
+	mfc0    t1, CP0_STATUS
+	sll     t1, t1, 31 - _ST0_FR
+	bgez    t1, 1f                          # 16 / 32 register mode?
+	 nop
+
+	EX      ldc1 $f1, SC_FPREGS+8(a0)
+	EX      ldc1 $f3, SC_FPREGS+24(a0)
+	EX      ldc1 $f5, SC_FPREGS+40(a0)
+	EX      ldc1 $f7, SC_FPREGS+56(a0)
+	EX      ldc1 $f9, SC_FPREGS+72(a0)
+	EX      ldc1 $f11, SC_FPREGS+88(a0)
+	EX      ldc1 $f13, SC_FPREGS+104(a0)
+	EX      ldc1 $f15, SC_FPREGS+120(a0)
+	EX      ldc1 $f17, SC_FPREGS+136(a0)
+	EX      ldc1 $f19, SC_FPREGS+152(a0)
+	EX      ldc1 $f21, SC_FPREGS+168(a0)
+	EX      ldc1 $f23, SC_FPREGS+184(a0)
+	EX      ldc1 $f25, SC_FPREGS+200(a0)
+	EX      ldc1 $f27, SC_FPREGS+216(a0)
+	EX      ldc1 $f29, SC_FPREGS+232(a0)
+	EX      ldc1 $f31, SC_FPREGS+248(a0)
+	.set    pop
+1:
+#endif
 #endif
 	EX	ldc1 $f0, SC_FPREGS+0(a0)
 	EX	ldc1 $f2, SC_FPREGS+16(a0)
@@ -155,9 +240,37 @@
 
 #ifdef CONFIG_MIPS32_COMPAT
 LEAF(_restore_fp_context32)
+	.set    push
+	.set    mips64r2
+	.set    noreorder
+
 	/* Restore an o32 sigcontext.  */
 	EX	lw t0, SC32_FPC_CSR(a0)
-	EX	ldc1 $f0, SC32_FPREGS+0(a0)
+
+	mfc0    t1, CP0_STATUS
+	sll     t1, t1, 31 - _ST0_FR
+	bgez    t1, 1f                          # 16 / 32 register mode?
+	 nop
+
+	EX      ldc1 $f1, SC_FPREGS+8(a0)
+	EX      ldc1 $f3, SC_FPREGS+24(a0)
+	EX      ldc1 $f5, SC_FPREGS+40(a0)
+	EX      ldc1 $f7, SC_FPREGS+56(a0)
+	EX      ldc1 $f9, SC_FPREGS+72(a0)
+	EX      ldc1 $f11, SC_FPREGS+88(a0)
+	EX      ldc1 $f13, SC_FPREGS+104(a0)
+	EX      ldc1 $f15, SC_FPREGS+120(a0)
+	EX      ldc1 $f17, SC_FPREGS+136(a0)
+	EX      ldc1 $f19, SC_FPREGS+152(a0)
+	EX      ldc1 $f21, SC_FPREGS+168(a0)
+	EX      ldc1 $f23, SC_FPREGS+184(a0)
+	EX      ldc1 $f25, SC_FPREGS+200(a0)
+	EX      ldc1 $f27, SC_FPREGS+216(a0)
+	EX      ldc1 $f29, SC_FPREGS+232(a0)
+	EX      ldc1 $f31, SC_FPREGS+248(a0)
+1:
+
+	EX      ldc1 $f0, SC32_FPREGS+0(a0)
 	EX	ldc1 $f2, SC32_FPREGS+16(a0)
 	EX	ldc1 $f4, SC32_FPREGS+32(a0)
 	EX	ldc1 $f6, SC32_FPREGS+48(a0)
@@ -177,6 +290,7 @@
 	jr	ra
 	 li	v0, 0					# success
 	END(_restore_fp_context32)
+	.set    pop
 #endif
 
 	.set	reorder
diff -ur ./arch/mips/kernel/r4k_switch.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/r4k_switch.S
--- ./arch/mips/kernel/r4k_switch.S	2023-04-26 12:56:04.210118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/r4k_switch.S	2023-04-23 11:58:24.750274900 +0100
@@ -64,10 +64,45 @@
 	and	t0, t0, t1
 	LONG_S	t0, ST_OFF(t3)
 
+	/* Now copy FR from it */
+
+#if defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT)
+#ifdef CONFIG_MIPS_MT_SMTC
+
+	li      t3, ST0_FR
+	mfc0    t2, CP0_TCSTATUS
+	nor     t1, $0, t3
+	and     t0, t0, t3                      # extract FR from prev
+	and     t3, t2, t1
+	or      t0, t0, t3
+	mtc0    t0, CP0_TCSTATUS
+	enable_fpu_hazard
+
+	fpu_save_double a0 t0 t1                # c0_status passed in t0
+						# clobbers t1
+	mtc0    t2, CP0_TCSTATUS
+#else
+	li      t3, ST0_FR
+	mfc0    t2, CP0_STATUS
+	nor     t1, $0, t3
+	and     t0, t0, t3                      # extract FR from prev
+	and     t3, t2, t1
+	or      t0, t0, t3
+	mtc0    t0, CP0_STATUS
+	enable_fpu_hazard
+
+	fpu_save_double a0 t0 t1                # c0_status passed in t0
+						# clobbers t1
+	mtc0    t2, CP0_STATUS
+
+#endif /* CONFIG_MIPS_MT_SMTC */
+#else
+
 	fpu_save_double a0 t0 t1		# c0_status passed in t0
 						# clobbers t1
-1:
+#endif
 
+1:
 	/*
 	 * The order of restoring the registers takes care of the race
 	 * updating $28, $29 and kernelsp without disabling ints.
@@ -107,17 +142,21 @@
 	xori	t1, t1, TCSTATUS_IXMT
 	or	t1, t1, t2
 	mtc0	t1, CP0_TCSTATUS
-	_ehb
 #endif /* CONFIG_MIPS_MT_SMTC */
 	move	v0, a0
-	jr	ra
+#ifdef CPU_MIPSR2
+	jr.hb   ra
+#else
+	_ehb
+	jr      ra
+#endif
 	END(resume)
 
 /*
  * Save a thread's fp context.
  */
 LEAF(_save_fp)
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT)
 	mfc0	t0, CP0_STATUS
 #endif
 	fpu_save_double a0 t0 t1		# clobbers t1
@@ -128,7 +167,7 @@
  * Restore a thread's fp context.
  */
 LEAF(_restore_fp)
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT)
 	mfc0	t0, CP0_STATUS
 #endif
 	fpu_restore_double a0 t0 t1		# clobbers t1
@@ -143,8 +182,6 @@
  * We initialize fcr31 to rounding to nearest, no exceptions.
  */
 
-#define FPU_DEFAULT  0x00000000
-
 LEAF(_init_fpu)
 #ifdef CONFIG_MIPS_MT_SMTC
 	/* Rather than manipulate per-VPE Status, set per-TC bit in TCStatus */
@@ -161,15 +198,32 @@
 #endif /* CONFIG_MIPS_MT_SMTC */
 	enable_fpu_hazard
 
-	li	t1, FPU_DEFAULT
-	ctc1	t1, fcr31
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+	li      t2, MIPS_FPIR_HAS2008
+	cfc1    t1, CP1_REVISION
+	and     t2, t2, t1
+	li      t1, FPU_CSR_DEFAULT
+	beq     t2, $0, 3f
+	li      t1, FPU_CSR_DEFAULT|FPU_CSR_MAC2008|FPU_CSR_ABS2008|FPU_CSR_NAN2008
+3:
+#endif
+	ctc1    t1, fcr31
 
-	li	t1, -1				# SNaN
+	li      t1, -1                          # SNaN MIPS, DP or SP or DP+SP
 
 #ifdef CONFIG_64BIT
-	sll	t0, t0, 5
+	sll     t0, t0, 31 - _ST0_FR
 	bgez	t0, 1f				# 16 / 32 register mode?
 
+#ifdef CONFIG_CPU_MIPSR2
+	enable_fpu_hazard
+	li      t2, FPU_CSR_NAN2008
+	cfc1    t3, fcr31
+	and     t2, t2, t3
+	beq     t2, $0, 2f
+	dli     t1, 0x7ff000007fa00000          # SNaN 2008, DP + SP
+2:
+#endif
 	dmtc1	t1, $f1
 	dmtc1	t1, $f3
 	dmtc1	t1, $f5
@@ -187,9 +241,25 @@
 	dmtc1	t1, $f29
 	dmtc1	t1, $f31
 1:
-#endif
+#endif /* CONFIG_64BIT */
 
 #ifdef CONFIG_CPU_MIPS32
+#ifdef CONFIG_CPU_MIPS32_R2
+	sll     t0, t0, 31 - _ST0_FR
+	bgez    t0, 2f                          # 16 / 32 register mode?
+
+	enable_fpu_hazard
+	li      t2, FPU_CSR_NAN2008
+	cfc1    t3, fcr31
+	and     t2, t2, t3
+	move    t3, t1                          # SNaN MIPS, DP high word
+	beq     t2, $0, 2f
+	li      t1, 0x7fa00000                  # SNaN 2008, SP
+	li      t3, 0x7ff00000                  # SNaN 2008, DP high word
+2:
+#endif
+	.set	push
+	.set	hardfloat
 	mtc1	t1, $f0
 	mtc1	t1, $f1
 	mtc1	t1, $f2
@@ -222,7 +292,51 @@
 	mtc1	t1, $f29
 	mtc1	t1, $f30
 	mtc1	t1, $f31
-#else
+	.set	pop
+
+#ifdef CONFIG_CPU_MIPS32_R2
+	bgez    t0, 1f                          # 16 / 32 register mode?
+
+	move    t1, t3                          # move SNaN, DP high word
+	.set    push
+	.set    mips64r2
+	.set	hardfloat
+	mthc1   t1, $f0
+	mthc1   t1, $f1
+	mthc1   t1, $f2
+	mthc1   t1, $f3
+	mthc1   t1, $f4
+	mthc1   t1, $f5
+	mthc1   t1, $f6
+	mthc1   t1, $f7
+	mthc1   t1, $f8
+	mthc1   t1, $f9
+	mthc1   t1, $f10
+	mthc1   t1, $f11
+	mthc1   t1, $f12
+	mthc1   t1, $f13
+	mthc1   t1, $f14
+	mthc1   t1, $f15
+	mthc1   t1, $f16
+	mthc1   t1, $f17
+	mthc1   t1, $f18
+	mthc1   t1, $f19
+	mthc1   t1, $f20
+	mthc1   t1, $f21
+	mthc1   t1, $f22
+	mthc1   t1, $f23
+	mthc1   t1, $f24
+	mthc1   t1, $f25
+	mthc1   t1, $f26
+	mthc1   t1, $f27
+	mthc1   t1, $f28
+	mthc1   t1, $f29
+	mthc1   t1, $f30
+	mthc1   t1, $f31
+	.set    pop
+1:
+#endif /* CONFIG_CPU_MIPS32_R2 */
+#else  /* CONFIG_CPU_MIPS32 */
 	.set	mips3
 	dmtc1	t1, $f0
 	dmtc1	t1, $f2
@@ -240,6 +354,6 @@
 	dmtc1	t1, $f26
 	dmtc1	t1, $f28
 	dmtc1	t1, $f30
-#endif
+#endif /* CONFIG_CPU_MIPS32 */
 	jr	ra
 	END(_init_fpu)
diff -ur ./arch/mips/kernel/relocate_kernel.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/relocate_kernel.S
--- ./arch/mips/kernel/relocate_kernel.S	2023-04-26 12:25:54.890119521 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/relocate_kernel.S	2023-04-23 11:58:24.831405900 +0100
@@ -26,6 +26,12 @@
 	PTR_L		s2, (s0)
 	PTR_ADD		s0, s0, SZREG
 
+	/*
+	 * In case of a kdump/crash kernel, the indirection page is not
+	 * populated as the kernel is directly copied to a reserved location
+	 */
+	beqz		s2, done
+
 	/* destination page */
 	and		s3, s2, 0x1
 	beq		s3, zero, 1f
diff -ur ./arch/mips/kernel/rtlx.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/rtlx.c
--- ./arch/mips/kernel/rtlx.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/rtlx.c	2023-04-23 11:58:24.830512700 +0100
@@ -58,12 +58,6 @@
 
 extern void *vpe_get_shared(int index);
 
-static void rtlx_dispatch(void)
-{
-	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ);
-}
-
-
 /* Interrupt handler may be called before rtlx_init has otherwise had
    a chance to run.
 */
@@ -437,7 +431,6 @@
 			  size_t count, loff_t * ppos)
 {
 	int minor = iminor(file_inode(file));
-	struct rtlx_channel *rt = &rtlx->channel[minor];
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {
@@ -466,20 +459,13 @@
 	.llseek =  noop_llseek,
 };
 
-static struct irqaction rtlx_irq = {
-	.handler	= rtlx_interrupt,
-	.name		= "RTLX",
-};
-
-static int rtlx_irq_num = MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ;
-
 static char register_chrdev_failed[] __initdata =
 	KERN_ERR "rtlx_module_init: unable to register device\n";
 
 static int __init rtlx_module_init(void)
 {
 	struct device *dev;
-	int i, err;
+	int i, err, irq;
 
 	if (!cpu_has_mipsmt) {
 		printk("VPE loader: not a MIPS MT capable processor\n");
@@ -519,18 +505,17 @@
 	notify.start = starting;
 	notify.stop = stopping;
 	vpe_notify(tclimit, &notify);
-
-	if (cpu_has_vint)
-		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
-	else {
+	irq = arch_get_xcpu_irq();
+	if (irq < 0) {
 		pr_err("APRP RTLX init on non-vectored-interrupt processor\n");
 		err = -ENODEV;
 		goto out_chrdev;
 	}
 
-	rtlx_irq.dev_id = rtlx;
-	setup_irq(rtlx_irq_num, &rtlx_irq);
-
+	err = request_irq(irq, &rtlx_interrupt, IRQF_SHARED,
+		module_name, (void *)dev);
+	if (err)
+		goto out_chrdev;
 	return 0;
 
 out_chrdev:
diff -ur ./arch/mips/kernel/scall32-o32.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/scall32-o32.S
--- ./arch/mips/kernel/scall32-o32.S	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/scall32-o32.S	2023-04-23 11:58:24.829805100 +0100
@@ -125,17 +125,39 @@
 
 	la	t1, 5f			# load up to 3 arguments
 	subu	t1, t3
-1:	lw	t5, 16(t0)		# argument #5 from usp
-	.set	push
-	.set	noreorder
+#ifndef CONFIG_EVA
+1:      lw      t5, 16(t0)              # argument #5 from usp
+	.set    push
+	.set    noreorder
 	.set	nomacro
 	jr	t1
 	 addiu	t1, 6f - 5f
 
-2:	lw	t8, 28(t0)		# argument #8 from usp
-3:	lw	t7, 24(t0)		# argument #7 from usp
-4:	lw	t6, 20(t0)		# argument #6 from usp
-5:	jr	t1
+2:	.insn
+	lw	t8, 28(t0)		# argument #8 from usp
+3:	.insn
+	lw	t7, 24(t0)		# argument #7 from usp
+4:	.insn
+	lw	t6, 20(t0)		# argument #6 from usp
+5:	.insn
+#else
+	.set    eva
+1:      lwe      t5, 16(t0)              # argument #5 from usp
+	.set    push
+	.set    noreorder
+	.set	nomacro
+	jr	t1
+	 addiu	t1, 6f - 5f
+
+2:	.insn
+	lwe      t8, 28(t0)              # argument #8 from usp
+3:	.insn
+	lwe      t7, 24(t0)              # argument #7 from usp
+4:	.insn
+	lwe      t6, 20(t0)              # argument #6 from usp
+5:	.insn
+#endif /* CONFIG_EVA */
+	jr	t1
 	 sw	t5, 16(sp)		# argument #5 to ksp
 
 #ifdef CONFIG_CPU_MICROMIPS
@@ -150,7 +172,7 @@
 	sw	t7, 24(sp)		# argument #7 to ksp
 	sw	t6, 20(sp)		# argument #6 to ksp
 #endif
-6:	j	stack_done		# go back
+6:      j       stack_done              # go back
 	 nop
 	.set	pop
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel: segment.c
diff -ur ./arch/mips/kernel/setup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/setup.c
--- ./arch/mips/kernel/setup.c	2023-04-26 12:25:54.900119527 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/setup.c	2023-04-23 11:58:24.991704500 +0100
@@ -552,6 +552,52 @@
 	add_memory_region(mem, size, type);
 }
 
+#ifdef CONFIG_KEXEC
+static inline unsigned long long get_total_mem(void)
+{
+	unsigned long long total;
+
+	total = max_pfn - min_low_pfn;
+	return total << PAGE_SHIFT;
+}
+
+static void __init mips_parse_crashkernel(void)
+{
+	unsigned long long total_mem;
+	unsigned long long crash_size, crash_base;
+	int ret;
+
+	total_mem = get_total_mem();
+	ret = parse_crashkernel(boot_command_line, total_mem,
+				&crash_size, &crash_base);
+	if (ret != 0 || crash_size <= 0)
+		return;
+
+	crashk_res.start = crash_base;
+	crashk_res.end	 = crash_base + crash_size - 1;
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+	int ret;
+
+	ret = request_resource(res, &crashk_res);
+	if (!ret)
+		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
+			(unsigned long)((crashk_res.end -
+					 crashk_res.start + 1) >> 20),
+			(unsigned long)(crashk_res.start  >> 20));
+}
+#else /* !defined(CONFIG_KEXEC)		*/
+static void __init mips_parse_crashkernel(void)
+{
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+}
+#endif /* !defined(CONFIG_KEXEC)  */
+
 static void __init arch_mem_init(char **cmdline_p)
 {
 	extern void plat_mem_setup(void);
@@ -608,6 +654,8 @@
 				BOOTMEM_DEFAULT);
 	}
 #endif
+
+	mips_parse_crashkernel();
 #ifdef CONFIG_KEXEC
 	if (crashk_res.start != crashk_res.end)
 		reserve_bootmem(crashk_res.start,
@@ -620,52 +668,6 @@
 	paging_init();
 }
 
-#ifdef CONFIG_KEXEC
-static inline unsigned long long get_total_mem(void)
-{
-	unsigned long long total;
-
-	total = max_pfn - min_low_pfn;
-	return total << PAGE_SHIFT;
-}
-
-static void __init mips_parse_crashkernel(void)
-{
-	unsigned long long total_mem;
-	unsigned long long crash_size, crash_base;
-	int ret;
-
-	total_mem = get_total_mem();
-	ret = parse_crashkernel(boot_command_line, total_mem,
-				&crash_size, &crash_base);
-	if (ret != 0 || crash_size <= 0)
-		return;
-
-	crashk_res.start = crash_base;
-	crashk_res.end	 = crash_base + crash_size - 1;
-}
-
-static void __init request_crashkernel(struct resource *res)
-{
-	int ret;
-
-	ret = request_resource(res, &crashk_res);
-	if (!ret)
-		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
-			(unsigned long)((crashk_res.end -
-				crashk_res.start + 1) >> 20),
-			(unsigned long)(crashk_res.start  >> 20));
-}
-#else /* !defined(CONFIG_KEXEC)	 */
-static void __init mips_parse_crashkernel(void)
-{
-}
-
-static void __init request_crashkernel(struct resource *res)
-{
-}
-#endif /* !defined(CONFIG_KEXEC)  */
-
 static void __init resource_init(void)
 {
 	int i;
@@ -678,11 +680,6 @@
 	data_resource.start = __pa_symbol(&_etext);
 	data_resource.end = __pa_symbol(&_edata) - 1;
 
-	/*
-	 * Request address space for all standard RAM.
-	 */
-	mips_parse_crashkernel();
-
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		struct resource *res;
 		unsigned long start, end;
@@ -725,12 +722,13 @@
 
 void __init setup_arch(char **cmdline_p)
 {
-	cpu_probe();
-	prom_init();
-
 #ifdef CONFIG_EARLY_PRINTK
 	setup_early_printk();
 #endif
+
+	cpu_probe();
+	prom_init();
+
 	cpu_report();
 	check_bugs_early();
 
diff -ur ./arch/mips/kernel/signal.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/signal.c
--- ./arch/mips/kernel/signal.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/signal.c	2023-04-23 11:58:24.990443700 +0100
@@ -68,10 +68,12 @@
 static int protected_save_fp_context(struct sigcontext __user *sc)
 {
 	int err;
+#ifndef CONFIG_EVA
 	while (1) {
 		lock_fpu_owner();
-		own_fpu_inatomic(1);
-		err = save_fp_context(sc); /* this might fail */
+		err = own_fpu_inatomic(1);
+		if (!err)
+			err = save_fp_context(sc); /* this might fail */
 		unlock_fpu_owner();
 		if (likely(!err))
 			break;
@@ -82,16 +84,22 @@
 		if (err)
 			break;	/* really bad sigcontext */
 	}
+#else
+	lose_fpu(1);
+	err = save_fp_context(sc); /* this might fail */
+#endif  /* CONFIG_EVA */
 	return err;
 }
 
 static int protected_restore_fp_context(struct sigcontext __user *sc)
 {
 	int err, tmp __maybe_unused;
+#ifndef CONFIG_EVA
 	while (1) {
 		lock_fpu_owner();
-		own_fpu_inatomic(0);
-		err = restore_fp_context(sc); /* this might fail */
+		err = own_fpu_inatomic(0);
+		if (!err)
+			err = restore_fp_context(sc); /* this might fail */
 		unlock_fpu_owner();
 		if (likely(!err))
 			break;
@@ -102,6 +110,10 @@
 		if (err)
 			break;	/* really bad sigcontext */
 	}
+#else
+	lose_fpu(0);
+	err = restore_fp_context(sc); /* this might fail */
+#endif  /* CONFIG_EVA */
 	return err;
 }
 
@@ -584,6 +596,7 @@
 }
 
 #ifdef CONFIG_SMP
+#ifndef CONFIG_EVA
 static int smp_save_fp_context(struct sigcontext __user *sc)
 {
 	return raw_cpu_has_fpu
@@ -598,9 +611,11 @@
 	       : fpu_emulator_restore_context(sc);
 }
 #endif
+#endif
 
 static int signal_setup(void)
 {
+#ifndef CONFIG_EVA
 #ifdef CONFIG_SMP
 	/* For now just do the cpu_has_fpu check when the functions are invoked */
 	save_fp_context = smp_save_fp_context;
@@ -613,7 +628,11 @@
 		save_fp_context = fpu_emulator_save_context;
 		restore_fp_context = fpu_emulator_restore_context;
 	}
-#endif
+#endif /* CONFIG_SMP */
+#else
+	save_fp_context = fpu_emulator_save_context;
+	restore_fp_context = fpu_emulator_restore_context;
+#endif /* CONFIG_EVA */
 
 	return 0;
 }
diff -ur ./arch/mips/kernel/signal32.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/signal32.c
--- ./arch/mips/kernel/signal32.c	2023-04-26 12:25:54.900119527 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/signal32.c	2023-04-23 11:58:25.072636900 +0100
@@ -83,10 +83,12 @@
 static int protected_save_fp_context32(struct sigcontext32 __user *sc)
 {
 	int err;
+#ifndef CONFIG_EVA
 	while (1) {
 		lock_fpu_owner();
-		own_fpu_inatomic(1);
-		err = save_fp_context32(sc); /* this might fail */
+		err = own_fpu_inatomic(1);
+		if (!err)
+			err = save_fp_context32(sc); /* this might fail */
 		unlock_fpu_owner();
 		if (likely(!err))
 			break;
@@ -97,16 +99,22 @@
 		if (err)
 			break;	/* really bad sigcontext */
 	}
+#else
+	lose_fpu(1);
+	err = save_fp_context32(sc); /* this might fail */
+#endif
 	return err;
 }
 
 static int protected_restore_fp_context32(struct sigcontext32 __user *sc)
 {
 	int err, tmp __maybe_unused;
+#ifndef CONFIG_EVA
 	while (1) {
 		lock_fpu_owner();
-		own_fpu_inatomic(0);
-		err = restore_fp_context32(sc); /* this might fail */
+		err = own_fpu_inatomic(0);
+		if (!err)
+			err = restore_fp_context32(sc); /* this might fail */
 		unlock_fpu_owner();
 		if (likely(!err))
 			break;
@@ -117,6 +125,10 @@
 		if (err)
 			break;	/* really bad sigcontext */
 	}
+#else
+	lose_fpu(0);
+	err = restore_fp_context32(sc); /* this might fail */
+#endif /* CONFIG_EVA */
 	return err;
 }
 
@@ -558,8 +570,30 @@
 	.restart	= __NR_O32_restart_syscall
 };
 
+#ifdef CONFIG_SMP
+static int smp_save_fp_context32(struct sigcontext32 __user *sc)
+{
+	return raw_cpu_has_fpu
+	       ? _save_fp_context32(sc)
+	       : fpu_emulator_save_context32(sc);
+}
+
+static int smp_restore_fp_context32(struct sigcontext32 __user *sc)
+{
+	return raw_cpu_has_fpu
+	       ? _restore_fp_context32(sc)
+	       : fpu_emulator_restore_context32(sc);
+}
+#endif
+
 static int signal32_init(void)
 {
+#ifndef CONFIG_EVA
+#ifdef CONFIG_SMP
+	/* For now just do the cpu_has_fpu check when the functions are invoked */
+	save_fp_context32 = smp_save_fp_context32;
+	restore_fp_context32 = smp_restore_fp_context32;
+#else
 	if (cpu_has_fpu) {
 		save_fp_context32 = _save_fp_context32;
 		restore_fp_context32 = _restore_fp_context32;
@@ -567,6 +601,11 @@
 		save_fp_context32 = fpu_emulator_save_context32;
 		restore_fp_context32 = fpu_emulator_restore_context32;
 	}
+#endif /* CONFIG_SMP */
+#else
+	save_fp_context32 = fpu_emulator_save_context32;
+	restore_fp_context32 = fpu_emulator_restore_context32;
+#endif /* CONFIG_EVA */
 
 	return 0;
 }
diff -ur ./arch/mips/kernel/smp-cmp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp-cmp.c
--- ./arch/mips/kernel/smp-cmp.c	2023-04-26 12:25:54.910119534 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp-cmp.c	2023-04-23 11:58:25.070857700 +0100
@@ -38,6 +38,8 @@
 #include <asm/mips_mt.h>
 #include <asm/amon.h>
 #include <asm/gic.h>
+#include <asm/gcmpregs.h>
+#include <asm/bootinfo.h>
 
 static void ipi_call_function(unsigned int cpu)
 {
@@ -87,6 +89,107 @@
 		cmp_send_ipi_single(i, action);
 }
 
+#ifdef CONFIG_EVA
+extern int gcmp_present;
+extern unsigned long _gcmp_base;
+static unsigned long bev_location = -1;
+
+static int rd_bev_location(char *p)
+{
+	if ((strlen(p) > 19) && (*(p + 18) == '=')) {
+		p += 19;
+		bev_location = memparse(p, &p);
+	} else
+		bev_location = 0xbfc00000;
+	return 0;
+}
+early_param("force-bev-location", rd_bev_location);
+
+static void BEV_overlay_segment_map_check(unsigned long excBase,
+	unsigned long excMask, unsigned long excSize)
+{
+	unsigned long addr;
+
+	if ((excBase == (IO_BASE + IO_SHIFT)) && (excSize == IO_SIZE))
+		return;
+
+	printk("WARNING: BEV overlay segment doesn't fit whole I/O reg space, NMI/EJTAG/sRESET may not work\n");
+
+	if ((MAP_BASE < (excBase + excSize)) && (excBase < VMALLOC_END))
+		panic("BEV Overlay segment overlaps VMALLOC area\n");
+#ifdef CONFIG_HIGHMEM
+	if ((PKMAP_BASE < (excBase + excSize)) &&
+	    (excBase < (PKMAP_BASE + (PAGE_SIZE*(LAST_PKMAP-1)))))
+		panic("BEV Overlay segment overlaps HIGHMEM/PKMAP area\n");
+#endif
+	for (addr = excBase; addr < (excBase + excSize); addr += PAGE_SIZE) {
+		if (page_is_ram(__pa(addr>>PAGE_SHIFT)))
+			panic("BEV Overlay segment overlaps memory at %lx\n",addr);
+	}
+}
+
+void BEV_overlay_segment(void)
+{
+	unsigned long RExcBase;
+	unsigned long RExcExtBase;
+	unsigned long excBase;
+	unsigned long excMask;
+	unsigned long excSize;
+	unsigned long addr;
+	char *p;
+
+	printk("IO: BASE = 0x%lx, SHIFT = 0x%lx, SIZE = 0x%lx\n",IO_BASE, IO_SHIFT, IO_SIZE);
+	RExcBase = GCMPCLCB(RESETBASE);
+	RExcExtBase = GCMPCLCB(RESETBASEEXT);
+	printk("GCMP base addr = 0x%lx, CLB: ResetExcBase = 0x%lx, ResetExcExtBase = 0x%lx\n",
+		_gcmp_base,RExcBase,RExcExtBase);
+	if ( !(RExcExtBase & 0x1) )
+		return;
+
+	if (bev_location == -1) {
+		if ((p = strstr(arcs_cmdline, "force-bev-location")))
+			rd_bev_location(p);
+	}
+	if (bev_location != -1) {
+		addr = fls((IO_BASE + IO_SHIFT) ^ bev_location);
+nextSize:
+		if (addr > 28)
+			panic("enforced BEV location is too far from I/O reg space\n");
+
+		excMask = (0xffffffffUL >> (32 - addr));
+		excBase = bev_location & ~excMask;
+		if (((IO_BASE + IO_SHIFT + IO_SIZE - 1) & ~excMask) != excBase) {
+			addr++;
+			goto nextSize;
+		}
+		excSize = ((excBase | excMask) + 1) - excBase;
+		printk("Setting BEV = 0x%lx, Overlay segment = 0x%lx, size = 0x%lx\n",
+			bev_location, excBase, excSize);
+
+		BEV_overlay_segment_map_check(excBase, excMask, excSize);
+
+		GCMPCLCB(RESETBASEEXT) = (GCMPCLCB(RESETBASEEXT) &
+			~GCMP_CCB_RESETEXTBASE_BEV_MASK_MSK) |
+			(excMask & GCMP_CCB_RESETEXTBASE_BEV_MASK_MSK);
+		GCMPCLCB(RESETBASE) = (GCMPCLCB(RESETBASE) & ~GCMP_CCB_RESETBASE_BEV_MSK) |
+			bev_location;
+		RExcBase = GCMPCLCB(RESETBASE);
+		RExcExtBase = GCMPCLCB(RESETBASEEXT);
+
+		return;
+	}
+
+	excBase = RExcBase & GCMP_CCB_RESETBASE_BEV_MSK;
+	excMask = (RExcExtBase & GCMP_CCB_RESETEXTBASE_BEV_MASK_MSK) |
+		    GCMP_CCB_RESETEXTBASE_BEV_MASK_LOWBITS;
+	excBase &= ~excMask;
+	excSize = ((excBase | excMask) + 1) - excBase;
+	printk("BEV Overlay segment = 0x%lx, size = 0x%lx\n",excBase, excSize);
+
+	BEV_overlay_segment_map_check(excBase, excMask, excSize);
+}
+#endif
+
 static void cmp_init_secondary(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -95,15 +198,20 @@
 	change_c0_status(ST0_IM, STATUSF_IP3 | STATUSF_IP4 | STATUSF_IP6 |
 				 STATUSF_IP7);
 
-	/* Enable per-cpu interrupts: platform specific */
-
-	c->core = (read_c0_ebase() >> 1) & 0x1ff;
+	c->core = (read_c0_ebase() & 0x3ff) >> (fls(smp_num_siblings)-1);
 #if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
-	c->vpe_id = (read_c0_tcbind() >> TCBIND_CURVPE_SHIFT) & TCBIND_CURVPE;
+	if (cpu_has_mipsmt)
+		c->vpe_id = (read_c0_tcbind() >> TCBIND_CURVPE_SHIFT) &
+			TCBIND_CURVPE;
 #endif
 #ifdef CONFIG_MIPS_MT_SMTC
 	c->tc_id  = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
 #endif
+
+#ifdef CONFIG_EVA
+	if (gcmp_present)
+		BEV_overlay_segment();
+#endif
 }
 
 static void cmp_smp_finish(void)
@@ -145,7 +253,7 @@
 
 #if 0
 	/* Needed? */
-	flush_icache_range((unsigned long)gp,
+	local_flush_icache_range((unsigned long)gp,
 			   (unsigned long)(gp + sizeof(struct thread_info)));
 #endif
 
@@ -177,9 +285,16 @@
 	}
 
 	if (cpu_has_mipsmt) {
-		unsigned int nvpe, mvpconf0 = read_c0_mvpconf0();
+		unsigned int nvpe = 1;
+#ifdef CONFIG_MIPS_MT_SMP
+		unsigned int mvpconf0 = read_c0_mvpconf0();
+
+		nvpe = ((mvpconf0 & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;
+#elif defined(CONFIG_MIPS_MT_SMTC)
+		unsigned int mvpconf0 = read_c0_mvpconf0();
 
 		nvpe = ((mvpconf0 & MVPCONF0_PTC) >> MVPCONF0_PTC_SHIFT) + 1;
+#endif
 		smp_num_siblings = nvpe;
 	}
 	pr_info("Detected %i available secondary CPU(s)\n", ncpu);
diff -ur ./arch/mips/kernel/smp-mt.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp-mt.c
--- ./arch/mips/kernel/smp-mt.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp-mt.c	2023-04-23 11:58:25.070211800 +0100
@@ -71,6 +71,7 @@
 
 		/* Record this as available CPU */
 		set_cpu_possible(tc, true);
+		set_cpu_present(tc, true);
 		__cpu_number_map[tc]	= ++ncpu;
 		__cpu_logical_map[ncpu] = tc;
 	}
@@ -112,12 +113,35 @@
 	write_tc_c0_tchalt(TCHALT_H);
 }
 
+static void mp_send_ipi_single(int cpu, unsigned int action)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (action) {
+	case SMP_CALL_FUNCTION:
+		gic_send_ipi(plat_ipi_call_int_xlate(cpu));
+		break;
+
+	case SMP_RESCHEDULE_YOURSELF:
+		gic_send_ipi(plat_ipi_resched_int_xlate(cpu));
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
 static void vsmp_send_ipi_single(int cpu, unsigned int action)
 {
 	int i;
 	unsigned long flags;
 	int vpflags;
 
+	if (gic_present) {
+		mp_send_ipi_single(cpu, action);
+		return;
+	}
 	local_irq_save(flags);
 
 	vpflags = dvpe();	/* can't access the other CPU's registers whilst MVPE enabled */
@@ -164,6 +188,8 @@
 
 static void __cpuinit vsmp_smp_finish(void)
 {
+	pr_debug("SMPMT: CPU%d: vsmp_smp_finish\n", smp_processor_id());
+
 	/* CDFIXME: remove this? */
 	write_c0_compare(read_c0_count() + (8* mips_hpt_frequency/HZ));
 
@@ -178,6 +204,7 @@
 
 static void vsmp_cpus_done(void)
 {
+	pr_debug("SMPMT: CPU%d: vsmp_cpus_done\n", smp_processor_id());
 }
 
 /*
@@ -191,6 +218,8 @@
 static void __cpuinit vsmp_boot_secondary(int cpu, struct task_struct *idle)
 {
 	struct thread_info *gp = task_thread_info(idle);
+	pr_debug("SMPMT: CPU%d: vsmp_boot_secondary cpu %d\n",
+		smp_processor_id(), cpu);
 	dvpe();
 	set_c0_mvpcontrol(MVPCONTROL_VPC);
 
@@ -213,8 +242,8 @@
 	/* global pointer */
 	write_tc_gpr_gp((unsigned long)gp);
 
-	flush_icache_range((unsigned long)gp,
-			   (unsigned long)(gp + sizeof(struct thread_info)));
+	local_flush_icache_range((unsigned long)gp,
+			(unsigned long)(gp + sizeof(struct thread_info)));
 
 	/* finally out of configuration and into chaos */
 	clear_c0_mvpcontrol(MVPCONTROL_VPC);
@@ -232,6 +261,7 @@
 	unsigned int mvpconf0, ntc, tc, ncpu = 0;
 	unsigned int nvpe;
 
+	pr_debug("SMPMT: CPU%d: vsmp_smp_setup\n", smp_processor_id());
 #ifdef CONFIG_MIPS_MT_FPAFF
 	/* If we have an FPU, enroll ourselves in the FPU-full mask */
 	if (cpu_has_fpu)
@@ -272,6 +302,8 @@
 
 static void __init vsmp_prepare_cpus(unsigned int max_cpus)
 {
+	pr_debug("SMPMT: CPU%d: vsmp_prepare_cpus %d\n",
+		smp_processor_id(), max_cpus);
 	mips_mt_set_cpuoptions();
 }
 
diff -ur ./arch/mips/kernel/smp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp.c
--- ./arch/mips/kernel/smp.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/smp.c	2023-04-23 11:58:25.152350000 +0100
@@ -60,12 +60,17 @@
 EXPORT_SYMBOL(smp_num_siblings);
 
 /* representing the TCs (or siblings in Intel speak) of each logical CPU */
-cpumask_t cpu_sibling_map[NR_CPUS] __read_mostly;
-EXPORT_SYMBOL(cpu_sibling_map);
+DEFINE_PER_CPU_SHARED_ALIGNED(struct cpumask, cpu_sibling_map);
+EXPORT_PER_CPU_SYMBOL(cpu_sibling_map);
 
 /* representing cpus for which sibling maps can be computed */
 static cpumask_t cpu_sibling_setup_map;
 
+/* CPU siblings in MIPS:
+ *
+ *      SMVP kernel - VPEs on common core are siblings
+ *      SMTC kernel - TC's on common core are siblings
+ */
 static inline void set_cpu_sibling_map(int cpu)
 {
 	int i;
@@ -75,12 +80,12 @@
 	if (smp_num_siblings > 1) {
 		for_each_cpu_mask(i, cpu_sibling_setup_map) {
 			if (cpu_data[cpu].core == cpu_data[i].core) {
-				cpu_set(i, cpu_sibling_map[cpu]);
-				cpu_set(cpu, cpu_sibling_map[i]);
+				cpu_set(i, per_cpu(cpu_sibling_map, cpu));
+				cpu_set(cpu, per_cpu(cpu_sibling_map, i));
 			}
 		}
 	} else
-		cpu_set(cpu, cpu_sibling_map[cpu]);
+		cpu_set(cpu, per_cpu(cpu_sibling_map, cpu));
 }
 
 struct plat_smp_ops *mp_ops;
diff -ur ./arch/mips/kernel/spram.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/spram.c
--- ./arch/mips/kernel/spram.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/spram.c	2023-04-23 11:58:25.232566500 +0100
@@ -204,8 +204,10 @@
 	switch (c->cputype) {
 	case CPU_24K:
 	case CPU_34K:
-	case CPU_74K:
 	case CPU_1004K:
+	case CPU_74K:
+	case CPU_PROAPTIV:
+	case CPU_INTERAPTIV:
 		config0 = read_c0_config();
 		/* FIXME: addresses are Malta specific */
 		if (config0 & (1<<24)) {
diff -ur ./arch/mips/kernel/time.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/time.c
--- ./arch/mips/kernel/time.c	2023-04-26 12:25:54.910119534 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/time.c	2023-04-23 11:58:25.229055700 +0100
@@ -121,6 +121,14 @@
 {
 	plat_time_init();
 
-	if (!mips_clockevent_init() || !cpu_has_mfc0_count_bug())
+	/*
+	 * The use of the R4k timer as a clock event takes precedence;
+	 * if reading the Count register might interfere with the timer
+	 * interrupt, then we don't use the timer as a clock source.
+	 * We may still use the timer as a clock source though if the
+	 * timer interrupt isn't reliable; the interference doesn't
+	 * matter then, because we don't use the interrupt.
+	 */
+	if (mips_clockevent_init() != 0 || !cpu_has_mfc0_count_bug())
 		init_mips_clocksource();
 }
diff -ur ./arch/mips/kernel/traps.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/traps.c
--- ./arch/mips/kernel/traps.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/traps.c	2023-04-23 11:58:25.310440100 +0100
@@ -76,6 +76,7 @@
 extern asmlinkage void handle_ov(void);
 extern asmlinkage void handle_tr(void);
 extern asmlinkage void handle_fpe(void);
+extern asmlinkage void handle_mfpe(void);
 extern asmlinkage void handle_mdmx(void);
 extern asmlinkage void handle_watch(void);
 extern asmlinkage void handle_mt(void);
@@ -328,6 +329,7 @@
 void show_registers(struct pt_regs *regs)
 {
 	const int field = 2 * sizeof(unsigned long);
+	mm_segment_t old_fs = get_fs();
 
 	__show_regs(regs);
 	print_modules();
@@ -342,9 +344,12 @@
 			printk("*HwTLS: %0*lx\n", field, tls);
 	}
 
+	if (!user_mode(regs))
+		set_fs(KERNEL_DS);
 	show_stacktrace(current, regs);
 	show_code((unsigned int __user *) regs->cp0_epc);
 	printk("\n");
+	set_fs(old_fs);
 }
 
 static int regs_to_trapnr(struct pt_regs *regs)
@@ -772,6 +777,12 @@
 	force_sig_info(SIGFPE, &info, current);
 }
 
+asmlinkage void do_mfpe(struct pt_regs *regs)
+{
+	die_if_kernel("Kernel bug detected", regs);
+	force_sig(SIGKILL, current);
+}
+
 static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 	const char *str)
 {
@@ -837,6 +848,13 @@
 	unsigned int opcode, bcode;
 	unsigned long epc;
 	u16 instr[2];
+#ifdef CONFIG_EVA
+	mm_segment_t seg;
+
+	seg = get_fs();
+	if (!user_mode(regs))
+		set_fs(KERNEL_DS);
+#endif
 
 	if (get_isa16_mode(regs->cp0_epc)) {
 		/* Calculate EPC. */
@@ -852,6 +870,9 @@
 				goto out_sigsegv;
 		    bcode = (instr[0] >> 6) & 0x3f;
 		    do_trap_or_bp(regs, bcode, "Break");
+#ifdef CONFIG_EVA
+		    set_fs(seg);
+#endif
 		    return;
 		}
 	} else {
@@ -875,23 +896,35 @@
 	 */
 	switch (bcode) {
 	case BRK_KPROBE_BP:
-		if (notify_die(DIE_BREAK, "debug", regs, bcode, regs_to_trapnr(regs), SIGTRAP) == NOTIFY_STOP)
+		if (notify_die(DIE_BREAK, "debug", regs, bcode, regs_to_trapnr(regs), SIGTRAP) == NOTIFY_STOP) {
+#ifdef CONFIG_EVA
+			set_fs(seg);
+#endif
 			return;
-		else
+		} else
 			break;
 	case BRK_KPROBE_SSTEPBP:
-		if (notify_die(DIE_SSTEPBP, "single_step", regs, bcode, regs_to_trapnr(regs), SIGTRAP) == NOTIFY_STOP)
+		if (notify_die(DIE_SSTEPBP, "single_step", regs, bcode, regs_to_trapnr(regs), SIGTRAP) == NOTIFY_STOP) {
+#ifdef CONFIG_EVA
+			set_fs(seg);
+#endif
 			return;
-		else
+		} else
 			break;
 	default:
 		break;
 	}
 
 	do_trap_or_bp(regs, bcode, "Break");
+#ifdef CONFIG_EVA
+	set_fs(seg);
+#endif
 	return;
 
 out_sigsegv:
+#ifdef CONFIG_EVA
+	set_fs(seg);
+#endif
 	force_sig(SIGSEGV, current);
 }
 
@@ -900,6 +933,13 @@
 	u32 opcode, tcode = 0;
 	u16 instr[2];
 	unsigned long epc = msk_isa16_mode(exception_epc(regs));
+#ifdef CONFIG_EVA
+	mm_segment_t seg;
+
+	seg = get_fs();
+	if (!user_mode(regs))
+		set_fs(KERNEL_DS);
+#endif
 
 	if (get_isa16_mode(regs->cp0_epc)) {
 		if (__get_user(instr[0], (u16 __user *)(epc + 0)) ||
@@ -1114,20 +1154,28 @@
 		/* Fall through.  */
 
 	case 1:
-		if (used_math())	/* Using the FPU again.	 */
-			own_fpu(1);
-		else {			/* First time FPU user.	 */
-			init_fpu();
+		status = 0;
+		if (used_math())	/* Using the FPU again.  */
+			status = own_fpu(1);
+		else {			/* First time FPU user.  */
+			status = init_fpu();
+#ifndef CONFIG_MIPS_INCOMPATIBLE_FPU_EMULATION
+			if (status) {
+				force_sig(SIGFPE, current);
+				return;
+			}
+#endif
+
 			set_used_math();
 		}
 
-		if (!raw_cpu_has_fpu) {
+		if ((!raw_cpu_has_fpu) || status) {
 			int sig;
 			void __user *fault_addr = NULL;
 			sig = fpu_emulator_cop1Handler(regs,
 						       &current->thread.fpu,
 						       0, &fault_addr);
-			if (!process_fpemu_return(sig, fault_addr))
+			if ((!process_fpemu_return(sig, fault_addr)) && !status)
 				mt_ase_fp_affinity();
 		}
 
@@ -1166,6 +1214,7 @@
 	 * their values and send SIGTRAP.  Otherwise another thread
 	 * left the registers set, clear them and continue.
 	 */
+#if 0
 	if (test_tsk_thread_flag(current, TIF_LOAD_WATCH)) {
 		mips_read_watch_registers();
 		local_irq_enable();
@@ -1174,6 +1223,11 @@
 		mips_clear_watch_registers();
 		local_irq_enable();
 	}
+#else
+	/* For proc watch debug. */
+	force_sig(SIGTRAP, current);
+	local_irq_enable();
+#endif
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
@@ -1286,6 +1340,8 @@
 	case CPU_34K:
 	case CPU_74K:
 	case CPU_1004K:
+	case CPU_PROAPTIV:
+	case CPU_INTERAPTIV:
 		{
 #define ERRCTL_PE	0x80000000
 #define ERRCTL_L2P	0x00800000
@@ -1367,22 +1423,26 @@
 	unsigned int reg_val;
 
 	/* For the moment, report the problem and hang. */
-	printk("Cache error exception:\n");
+	printk("Cache error exception, cp0_ecc=0x%08x:\n",read_c0_ecc());
 	printk("cp0_errorepc == %0*lx\n", field, read_c0_errorepc());
 	reg_val = read_c0_cacheerr();
 	printk("c0_cacheerr == %08x\n", reg_val);
 
-	printk("Decoded c0_cacheerr: %s cache fault in %s reference.\n",
-	       reg_val & (1<<30) ? "secondary" : "primary",
-	       reg_val & (1<<31) ? "data" : "insn");
-	printk("Error bits: %s%s%s%s%s%s%s\n",
+	if ((reg_val & 0xc0000000) == 0xc0000000)
+		printk("Decoded c0_cacheerr: FTLB parity error\n");
+	else
+		printk("Decoded c0_cacheerr: %s cache fault in %s reference.\n",
+			reg_val & (1<<30) ? "secondary" : "primary",
+			reg_val & (1<<31) ? "data" : "insn");
+	printk("Error bits: %s%s%s%s%s%s%s%s\n",
 	       reg_val & (1<<29) ? "ED " : "",
 	       reg_val & (1<<28) ? "ET " : "",
+	       reg_val & (1<<27) ? "ES " : "",
 	       reg_val & (1<<26) ? "EE " : "",
 	       reg_val & (1<<25) ? "EB " : "",
-	       reg_val & (1<<24) ? "EI " : "",
-	       reg_val & (1<<23) ? "E1 " : "",
-	       reg_val & (1<<22) ? "E0 " : "");
+	       reg_val & (1<<24) ? "EI/EF " : "",
+	       reg_val & (1<<23) ? "E1/SP " : "",
+	       reg_val & (1<<22) ? "E0/EW " : "");
 	printk("IDX: 0x%08x\n", reg_val & ((1<<22)-1));
 
 #if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
@@ -1447,10 +1507,16 @@
 
 void __noreturn nmi_exception_handler(struct pt_regs *regs)
 {
+	unsigned long epc;
+	char str[100];
+
 	raw_notifier_call_chain(&nmi_chain, 0, regs);
 	bust_spinlocks(1);
-	printk("NMI taken!!!!\n");
-	die("NMI", regs);
+	epc = regs->cp0_epc;
+	snprintf(str, 100, "CPU%d NMI taken, CP0_EPC=%lx (before replacement by CP0_ERROREPC)\n",smp_processor_id(),regs->cp0_epc);
+	regs->cp0_epc = read_c0_errorepc();
+	die(str, regs);
+	regs->cp0_epc = epc;
 }
 
 #define VECTORSPACING 0x100	/* for EI/VI mode */
@@ -1513,7 +1579,6 @@
 	unsigned char *b;
 
 	BUG_ON(!cpu_has_veic && !cpu_has_vint);
-	BUG_ON((n < 0) && (n > 9));
 
 	if (addr == NULL) {
 		handler = (unsigned long) do_default_vi;
@@ -1687,7 +1752,7 @@
 	if (cpu_has_dsp)
 		status_set |= ST0_MX;
 
-	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
+	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
 	if (cpu_has_mips_r2)
@@ -1705,6 +1770,10 @@
 
 	if (cpu_has_veic || cpu_has_vint) {
 		unsigned long sr = set_c0_status(ST0_BEV);
+#ifdef CONFIG_EVA
+		write_c0_ebase(ebase|MIPS_EBASE_WG);
+		back_to_back_c0_hazard();
+#endif
 		write_c0_ebase(ebase);
 		write_c0_status(sr);
 		/* Setting vector spacing enables EI/VI mode  */
@@ -1770,7 +1839,7 @@
 }
 
 /* Install CPU exception handler */
-void __cpuinit set_handler(unsigned long offset, void *addr, unsigned long size)
+void set_handler(unsigned long offset, void *addr, unsigned long size)
 {
 #ifdef CONFIG_CPU_MICROMIPS
 	memcpy((void *)(ebase + offset), ((unsigned char *)addr - 1), size);
@@ -1837,6 +1906,15 @@
 			ebase += (read_c0_ebase() & 0x3ffff000);
 	}
 
+	if (cpu_has_mmips) {
+		unsigned int config3 = read_c0_config3();
+
+		if (IS_ENABLED(CONFIG_CPU_MICROMIPS))
+			write_c0_config3(config3 | MIPS_CONF3_ISA_OE);
+		else
+			write_c0_config3(config3 & ~MIPS_CONF3_ISA_OE);
+	}
+
 	if (board_ebase_setup)
 		board_ebase_setup();
 	per_cpu_trap_init(true);
@@ -1934,6 +2012,9 @@
 	if (cpu_has_fpu && !cpu_has_nofpuex)
 		set_except_vector(15, handle_fpe);
 
+	if (cpu_has_mxu_v2)
+		set_except_vector(16, handle_mfpe);
+
 	set_except_vector(22, handle_mdmx);
 
 	if (cpu_has_mcheck)
diff -ur ./arch/mips/kernel/unaligned.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/unaligned.c
--- ./arch/mips/kernel/unaligned.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/unaligned.c	2023-04-23 11:58:25.310072100 +0100
@@ -105,6 +105,255 @@
 #define unaligned_action UNALIGNED_ACTION_QUIET
 #endif
 extern void show_registers(struct pt_regs *regs);
+asmlinkage void do_cpu(struct pt_regs *regs);
+
+#ifdef CONFIG_EVA
+/* EVA variant */
+
+#ifdef __BIG_ENDIAN
+#define     LoadHW(addr, value, res)  \
+		__asm__ __volatile__ (".set\tnoat\n"        \
+			"1:\tlbe\t%0, 0(%2)\n"               \
+			"2:\tlbue\t$1, 1(%2)\n\t"            \
+			"sll\t%0, 0x8\n\t"                  \
+			"or\t%0, $1\n\t"                    \
+			"li\t%1, 0\n"                       \
+			"3:\t.set\tat\n\t"                  \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadW(addr, value, res)   \
+		__asm__ __volatile__ (                      \
+			"1:\tlwle\t%0, (%2)\n"               \
+			"2:\tlwre\t%0, 3(%2)\n\t"            \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadHWU(addr, value, res) \
+		__asm__ __volatile__ (                      \
+			".set\tnoat\n"                      \
+			"1:\tlbue\t%0, 0(%2)\n"              \
+			"2:\tlbue\t$1, 1(%2)\n\t"            \
+			"sll\t%0, 0x8\n\t"                  \
+			"or\t%0, $1\n\t"                    \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".set\tat\n\t"                      \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadWU(addr, value, res)  \
+		__asm__ __volatile__ (                      \
+			"1:\tlwle\t%0, (%2)\n"               \
+			"2:\tlwre\t%0, 3(%2)\n\t"            \
+			"dsll\t%0, %0, 32\n\t"              \
+			"dsrl\t%0, %0, 32\n\t"              \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			"\t.section\t.fixup,\"ax\"\n\t"     \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     StoreHW(addr, value, res) \
+		__asm__ __volatile__ (                      \
+			".set\tnoat\n"                      \
+			"1:\tsbe\t%1, 1(%2)\n\t"             \
+			"srl\t$1, %1, 0x8\n"                \
+			"2:\tsbe\t$1, 0(%2)\n\t"             \
+			".set\tat\n\t"                      \
+			"li\t%0, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%0, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=r" (res)                        \
+			: "r" (value), "r" (addr), "i" (-EFAULT));
+
+#define     StoreW(addr, value, res)  \
+		__asm__ __volatile__ (                      \
+			"1:\tswle\t%1,(%2)\n"                \
+			"2:\tswre\t%1, 3(%2)\n\t"            \
+			"li\t%0, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%0, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+		: "=r" (res)                                \
+		: "r" (value), "r" (addr), "i" (-EFAULT));
+#endif
+
+#ifdef __LITTLE_ENDIAN
+#define     LoadHW(addr, value, res)  \
+		__asm__ __volatile__ (".set\tnoat\n"        \
+			"1:\tlbe\t%0, 1(%2)\n"               \
+			"2:\tlbue\t$1, 0(%2)\n\t"            \
+			"sll\t%0, 0x8\n\t"                  \
+			"or\t%0, $1\n\t"                    \
+			"li\t%1, 0\n"                       \
+			"3:\t.set\tat\n\t"                  \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadW(addr, value, res)   \
+		__asm__ __volatile__ (                      \
+			"1:\tlwle\t%0, 3(%2)\n"              \
+			"2:\tlwre\t%0, (%2)\n\t"             \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadHWU(addr, value, res) \
+		__asm__ __volatile__ (                      \
+			".set\tnoat\n"                      \
+			"1:\tlbue\t%0, 1(%2)\n"              \
+			"2:\tlbue\t$1, 0(%2)\n\t"            \
+			"sll\t%0, 0x8\n\t"                  \
+			"or\t%0, $1\n\t"                    \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".set\tat\n\t"                      \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     LoadWU(addr, value, res)  \
+		__asm__ __volatile__ (                      \
+			"1:\tlwle\t%0, 3(%2)\n"              \
+			"2:\tlwre\t%0, (%2)\n\t"             \
+			"dsll\t%0, %0, 32\n\t"              \
+			"dsrl\t%0, %0, 32\n\t"              \
+			"li\t%1, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			"\t.section\t.fixup,\"ax\"\n\t"     \
+			"4:\tli\t%1, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=&r" (value), "=r" (res)         \
+			: "r" (addr), "i" (-EFAULT));
+
+#define     StoreHW(addr, value, res) \
+		__asm__ __volatile__ (                      \
+			".set\tnoat\n"                      \
+			"1:\tsbe\t%1, 0(%2)\n\t"             \
+			"srl\t$1,%1, 0x8\n"                 \
+			"2:\tsbe\t$1, 1(%2)\n\t"             \
+			".set\tat\n\t"                      \
+			"li\t%0, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%0, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+			: "=r" (res)                        \
+			: "r" (value), "r" (addr), "i" (-EFAULT));
+
+#define     StoreW(addr, value, res)  \
+		__asm__ __volatile__ (                      \
+			"1:\tswle\t%1, 3(%2)\n"              \
+			"2:\tswre\t%1, (%2)\n\t"             \
+			"li\t%0, 0\n"                       \
+			"3:\n\t"                            \
+			".insn\n\t"                         \
+			".section\t.fixup,\"ax\"\n\t"       \
+			"4:\tli\t%0, %3\n\t"                \
+			"j\t3b\n\t"                         \
+			".previous\n\t"                     \
+			".section\t__ex_table,\"a\"\n\t"    \
+			STR(PTR)"\t1b, 4b\n\t"              \
+			STR(PTR)"\t2b, 4b\n\t"              \
+			".previous"                         \
+		: "=r" (res)                                \
+		: "r" (value), "r" (addr), "i" (-EFAULT));
+#endif
+
+#else
+/* non-EVA variant */
 
 #ifdef __BIG_ENDIAN
 #define     LoadHW(addr, value, res)  \
@@ -420,6 +669,8 @@
 		: "r" (value), "r" (addr), "i" (-EFAULT));
 #endif
 
+#endif
+
 static void emulate_load_store_insn(struct pt_regs *regs,
 	void __user *addr, unsigned int __user *pc)
 {
@@ -429,6 +680,9 @@
 	unsigned long origpc;
 	unsigned long orig31;
 	void __user *fault_addr = NULL;
+#ifdef CONFIG_EVA
+	mm_segment_t seg;
+#endif
 
 	origpc = (unsigned long)pc;
 	orig31 = regs->regs[31];
@@ -474,6 +728,98 @@
 		 * The remaining opcodes are the ones that are really of
 		 * interest.
 		 */
+#ifdef CONFIG_EVA
+	case spec3_op:
+
+		/* we can land here only from kernel accessing USER,
+		   so - set user space, temporary for verification */
+		seg = get_fs();
+		set_fs(USER_DS);
+
+		switch (insn.spec3_format.ls_func) {
+
+		case lhe_op:
+			if (!access_ok(VERIFY_READ, addr, 2)) {
+				set_fs(seg);
+				goto sigbus;
+			}
+
+			LoadHW(addr, value, res);
+			if (res) {
+				set_fs(seg);
+				goto fault;
+			}
+			compute_return_epc(regs);
+			regs->regs[insn.spec3_format.rt] = value;
+			break;
+
+		case lwe_op:
+			if (!access_ok(VERIFY_READ, addr, 4)) {
+				set_fs(seg);
+				goto sigbus;
+			}
+
+			LoadW(addr, value, res);
+			if (res) {
+				set_fs(seg);
+				goto fault;
+			}
+			compute_return_epc(regs);
+			regs->regs[insn.spec3_format.rt] = value;
+			break;
+
+		case lhue_op:
+			if (!access_ok(VERIFY_READ, addr, 2)) {
+				set_fs(seg);
+				goto sigbus;
+			}
+
+			LoadHWU(addr, value, res);
+			if (res) {
+				set_fs(seg);
+				goto fault;
+			}
+			compute_return_epc(regs);
+			regs->regs[insn.spec3_format.rt] = value;
+			break;
+
+		case she_op:
+			if (!access_ok(VERIFY_WRITE, addr, 2)) {
+				set_fs(seg);
+				goto sigbus;
+			}
+
+			compute_return_epc(regs);
+			value = regs->regs[insn.spec3_format.rt];
+			StoreHW(addr, value, res);
+			if (res) {
+				set_fs(seg);
+				goto fault;
+			}
+			break;
+
+		case swe_op:
+			if (!access_ok(VERIFY_WRITE, addr, 4)) {
+				set_fs(seg);
+				goto sigbus;
+			}
+
+			compute_return_epc(regs);
+			value = regs->regs[insn.spec3_format.rt];
+			StoreW(addr, value, res);
+			if (res) {
+				set_fs(seg);
+				goto fault;
+			}
+			break;
+
+		default:
+			set_fs(seg);
+			goto sigill;
+		}
+		set_fs(seg);
+		break;
+#endif
 	case lh_op:
 		if (!access_ok(VERIFY_READ, addr, 2))
 			goto sigbus;
@@ -598,13 +944,27 @@
 		/* Cannot handle 64-bit instructions in 32-bit kernel */
 		goto sigill;
 
+	case cop1x_op:
+		if (insn.f_format.func != lwxc1_op &&
+		    insn.f_format.func != ldxc1_op &&
+		    insn.f_format.func != swxc1_op &&
+		    insn.f_format.func != sdxc1_op)
+		  goto sigill;
+
 	case lwc1_op:
 	case ldc1_op:
 	case swc1_op:
 	case sdc1_op:
+#if 0
+		/* temporary fix for mixing AdEL and CpU exceptions in Impresa */
+		if (!(regs->cp0_status & ST0_CU1)) {
+			do_cpu(regs);
+			return;
+		}
+#endif
 		die_if_kernel("Unaligned FP access in kernel code", regs);
 		BUG_ON(!used_math());
-		BUG_ON(!is_fpu_owner());
+//		BUG_ON(!is_fpu_owner());
 
 		lose_fpu(1);	/* Save FPU state for the emulator. */
 		res = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1,
@@ -684,7 +1044,8 @@
 /* Recode table from 16-bit STORE register notation to 32-bit GPR. */
 const int reg16to32st[] = { 0, 17, 2, 3, 4, 5, 6, 7 };
 
-void emulate_load_store_microMIPS(struct pt_regs *regs, void __user * addr)
+static void emulate_load_store_microMIPS(struct pt_regs *regs,
+					 void __user *addr)
 {
 	unsigned long value;
 	unsigned int res;
diff -ur ./arch/mips/kernel/vpe.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/vpe.c
--- ./arch/mips/kernel/vpe.c	2023-04-26 12:25:54.920119540 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/vpe.c	2023-04-23 11:58:25.403365200 +0100
@@ -37,6 +37,7 @@
 #include <linux/vmalloc.h>
 #include <linux/elf.h>
 #include <linux/seq_file.h>
+#include <linux/spinlock.h>
 #include <linux/syscalls.h>
 #include <linux/moduleloader.h>
 #include <linux/interrupt.h>
@@ -49,6 +50,7 @@
 #include <asm/cpu.h>
 #include <asm/mips_mt.h>
 #include <asm/processor.h>
+#include <asm/setup.h>
 #include <asm/vpe.h>
 
 typedef void *vpe_handle;
@@ -94,6 +96,16 @@
 	TC_STATE_DYNAMIC
 };
 
+enum load_state {
+	LOAD_STATE_EHDR,
+	LOAD_STATE_PHDR,
+	LOAD_STATE_SHDR,
+	LOAD_STATE_PIMAGE,
+	LOAD_STATE_TRAILER,
+	LOAD_STATE_DONE,
+	LOAD_STATE_ERROR
+};
+
 struct vpe {
 	enum vpe_state state;
 
@@ -101,10 +113,25 @@
 	int minor;
 
 	/* elfloader stuff */
+	unsigned long offset; /* File offset into input stream */
 	void *load_addr;
-	unsigned long len;
+	unsigned long copied;
 	char *pbuffer;
-	unsigned long plen;
+	unsigned long pbsize;
+	/* Program loading state */
+	enum load_state l_state;
+	Elf_Ehdr *l_ehdr;
+	struct elf_phdr *l_phdr;
+	unsigned int l_phlen;
+	Elf_Shdr *l_shdr;
+	unsigned int l_shlen;
+	int *l_phsort;  /* Sorted index list of program headers */
+	int l_segoff;   /* Offset into current program segment */
+	int l_cur_seg;  /* Indirect index of segment currently being loaded */
+	unsigned int l_progminad;
+	unsigned int l_progmaxad;
+	unsigned int l_trailer;
+
 	unsigned int uid, gid;
 	char cwd[VPE_PATH_MAX];
 
@@ -116,9 +143,12 @@
 	/* The list of vpe's */
 	struct list_head list;
 
-	/* shared symbol address */
+	/* legacy shared symbol address */
 	void *shared_ptr;
 
+	 /* shared area descriptor array address */
+	struct vpe_shared_area *shared_areas;
+
 	/* the list of who wants to know when something major happens */
 	struct list_head notify;
 
@@ -140,13 +170,24 @@
 	spinlock_t tc_list_lock;
 	struct list_head tc_list;	/* Thread contexts */
 } vpecontrol = {
-	.vpe_list_lock	= __SPIN_LOCK_UNLOCKED(vpe_list_lock),
+	.vpe_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.vpe_list_lock),
 	.vpe_list	= LIST_HEAD_INIT(vpecontrol.vpe_list),
-	.tc_list_lock	= __SPIN_LOCK_UNLOCKED(tc_list_lock),
+	.tc_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.tc_list_lock),
 	.tc_list	= LIST_HEAD_INIT(vpecontrol.tc_list)
 };
 
 static void release_progmem(void *ptr);
+/*
+ * Values and state associated with publishing shared memory areas
+ */
+
+#define N_PUB_AREAS 4
+
+static struct vpe_shared_area published_vpe_area[N_PUB_AREAS] = {
+	{VPE_SHARED_RESERVED, 0},
+	{VPE_SHARED_RESERVED, 0},
+	{VPE_SHARED_RESERVED, 0},
+	{VPE_SHARED_RESERVED, 0} };
 
 /* get the vpe associated with this minor */
 static struct vpe *get_vpe(int minor)
@@ -169,7 +210,7 @@
 	return res;
 }
 
-/* get the vpe associated with this minor */
+/* get the tc associated with this minor */
 static struct tc *get_tc(int index)
 {
 	struct tc *res, *t;
@@ -194,7 +235,8 @@
 
 	if ((v = kzalloc(sizeof(struct vpe), GFP_KERNEL)) == NULL)
 		return NULL;
-
+	printk(KERN_DEBUG "Used kzalloc to allocate %d bytes at %x\n",
+		sizeof(struct vpe), (unsigned int)v);
 	INIT_LIST_HEAD(&v->tc);
 	spin_lock(&vpecontrol.vpe_list_lock);
 	list_add_tail(&v->list, &vpecontrol.vpe_list);
@@ -213,7 +255,8 @@
 
 	if ((tc = kzalloc(sizeof(struct tc), GFP_KERNEL)) == NULL)
 		goto out;
-
+	printk(KERN_DEBUG "Used kzalloc to allocate %d bytes at %x\n",
+		sizeof(struct tc), (unsigned int)tc);
 	INIT_LIST_HEAD(&tc->tc);
 	tc->index = index;
 
@@ -231,6 +274,11 @@
 	list_del(&v->list);
 	if (v->load_addr)
 		release_progmem(v);
+	printk(KERN_DEBUG "Used kfree to free memory at %x\n",
+		(unsigned int)v->l_phsort);
+	kfree(v->l_phsort);
+	printk(KERN_DEBUG "Used kfree to free memory at %x\n",
+		(unsigned int)v);
 	kfree(v);
 }
 
@@ -254,8 +302,88 @@
 	       val & MVPCONF0_PTC, (val & MVPCONF0_M) >> MVPCONF0_M_SHIFT);
 }
 
-/* Find some VPE program space	*/
-static void *alloc_progmem(unsigned long len)
+/*
+ * The original APRP prototype assumed a single, unshared IRQ for
+ * cross-VPE interrupts, used by the RTLX code.  But M3P networking
+ * and other future functions may need to share an IRQ, particularly
+ * in 34K/Malta configurations without an external interrupt controller.
+ * All cross-VPE insterrupt users need to coordinate through shared
+ * functions here.
+ */
+
+/*
+ * It would be nice if I could just have this initialized to zero,
+ * but the patchcheck police won't hear of it...
+ */
+
+static int xvpe_vector_set;
+
+#define XVPE_INTR_OFFSET 0
+
+static int xvpe_irq = MIPS_CPU_IRQ_BASE + XVPE_INTR_OFFSET;
+
+static void xvpe_dispatch(void)
+{
+	do_IRQ(xvpe_irq);
+}
+
+/* Name here is generic, as m3pnet.c could in principle be used by non-MIPS */
+int arch_get_xcpu_irq()
+{
+	/*
+	 * Some of this will ultimately become platform code,
+	 * but for now, we're only targeting 34K/FPGA/Malta,
+	 * and there's only one generic mechanism.
+	 */
+	if (!xvpe_vector_set) {
+		/*
+		 * A more elaborate shared variable shouldn't be needed.
+		 * Two initializations back-to-back should be harmless.
+		 */
+		if (cpu_has_vint) {
+			set_vi_handler(XVPE_INTR_OFFSET, xvpe_dispatch);
+			xvpe_vector_set = 1;
+		} else {
+			printk(KERN_ERR "APRP requires vectored interrupts\n");
+			return -1;
+		}
+	}
+
+	return xvpe_irq;
+}
+EXPORT_SYMBOL(arch_get_xcpu_irq);
+
+int vpe_send_interrupt(int vpe, int inter)
+{
+	unsigned long flags;
+	unsigned int vpeflags;
+
+	local_irq_save(flags);
+	vpeflags = dvpe();
+
+	/*
+	 * Initial version makes same simple-minded assumption
+	 * as is implicit elsewhere in this module, that the
+	 * only RP of interest is using the first non-Linux TC.
+	 * We ignore the parameters provided by the caller!
+	 */
+	settc(tclimit);
+	/*
+	 * In 34K/Malta, the only cross-VPE interrupts possible
+	 * are done by setting SWINT bits in Cause, of which there
+	 * are two.  SMTC uses SW1 for a multiplexed class of IPIs,
+	 * and this mechanism should be generalized to APRP and use
+	 * the same protocol.  Until that's implemented, send only
+	 * SW0 here, regardless of requested type.
+	 */
+	write_vpe_c0_cause(read_vpe_c0_cause() | C_SW0);
+	evpe(vpeflags);
+	local_irq_restore(flags);
+	return 1;
+}
+EXPORT_SYMBOL(vpe_send_interrupt);
+/* Find some VPE program space  */
+static void *alloc_progmem(void *requested, unsigned long len)
 {
 	void *addr;
 
@@ -265,10 +393,28 @@
 	 * physically have, for example by passing a mem= boot argument.
 	 */
 	addr = pfn_to_kaddr(max_low_pfn);
-	memset(addr, 0, len);
+	if (requested != 0) {
+		if (requested >= addr)
+			addr = requested;
+		else
+			addr = 0;
+	}
+	if (addr != 0)
+		memset(addr, 0, len);
+	printk(KERN_DEBUG "pfn_to_kaddr returns %lu bytes of memory at %x\n",
+	       len, (unsigned int)addr);
 #else
-	/* simple grab some mem for now */
-	addr = kzalloc(len, GFP_KERNEL);
+	if (requested != 0) {
+		/* If we have a target in mind, grab a 2x slice and hope... */
+		addr = kzalloc(len*2, GFP_KERNEL);
+		if ((requested >= addr) && (requested < (addr + len)))
+			addr = requested;
+		else
+			addr = 0;
+	} else {
+		/* simply grab some mem for now */
+		addr = kzalloc(len, GFP_KERNEL);
+	}
 #endif
 
 	return addr;
@@ -440,6 +586,8 @@
 	 * actual relocation.
 	 */
 	n = kmalloc(sizeof *n, GFP_KERNEL);
+	printk(KERN_DEBUG "Used kmalloc to allocate %d bytes at %x\n",
+	       sizeof(struct mips_hi16), (unsigned int)n);
 	if (!n)
 		return -ENOMEM;
 
@@ -497,6 +645,8 @@
 			*l->addr = insn;
 
 			next = l->next;
+			printk(KERN_DEBUG "Used kfree to free memory at %x\n",
+			       (unsigned int)l);
 			kfree(l);
 			l = next;
 		}
@@ -590,7 +740,7 @@
 	return 0;
 }
 
-static inline void save_gp_address(unsigned int secbase, unsigned int rel)
+void save_gp_address(unsigned int secbase, unsigned int rel)
 {
 	gp_addr = secbase + rel;
 	gp_offs = gp_addr - (secbase & 0xffff0000);
@@ -697,7 +847,18 @@
 	dmt_flag = dmt();
 	vpeflags = dvpe();
 
-	if (list_empty(&v->tc)) {
+	if (!list_empty(&v->tc)) {
+		if ((t = list_entry(v->tc.next, struct tc, tc)) == NULL) {
+			evpe(vpeflags);
+			emt(dmt_flag);
+			local_irq_restore(flags);
+
+			printk(KERN_WARNING
+			       "VPE loader: TC %d is already in use.\n",
+			       t->index);
+			return -ENOEXEC;
+		}
+	} else {
 		evpe(vpeflags);
 		emt(dmt_flag);
 		local_irq_restore(flags);
@@ -709,8 +870,6 @@
 		return -ENOEXEC;
 	}
 
-	t = list_first_entry(&v->tc, struct tc, tc);
-
 	/* Put MVPE's into 'configuration state' */
 	set_c0_mvpcontrol(MVPCONTROL_VPC);
 
@@ -801,16 +960,41 @@
 				      struct module *mod)
 {
 	Elf_Sym *sym = (void *)sechdrs[symindex].sh_addr;
-	unsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
+	unsigned int i, j, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
 
 	for (i = 1; i < n; i++) {
-		if (strcmp(strtab + sym[i].st_name, "__start") == 0) {
-			v->__start = sym[i].st_value;
-		}
+	    if (strcmp(strtab + sym[i].st_name, "__start") == 0)
+		v->__start = sym[i].st_value;
 
-		if (strcmp(strtab + sym[i].st_name, "vpe_shared") == 0) {
-			v->shared_ptr = (void *)sym[i].st_value;
+	    if (strcmp(strtab + sym[i].st_name, "vpe_shared") == 0)
+		v->shared_ptr = (void *)sym[i].st_value;
+
+	    if (strcmp(strtab + sym[i].st_name, "_vpe_shared_areas") == 0) {
+		struct vpe_shared_area *psa
+		    = (struct vpe_shared_area *)sym[i].st_value;
+		struct vpe_shared_area *tpsa;
+		v->shared_areas = psa;
+		printk(KERN_INFO"_vpe_shared_areas found, 0x%x\n",
+		    (unsigned int)v->shared_areas);
+		/*
+		 * Copy any "published" areas to the descriptor
+		 */
+		for (j = 0; j < N_PUB_AREAS; j++) {
+		    if (published_vpe_area[j].type != VPE_SHARED_RESERVED) {
+			tpsa = psa;
+			while (tpsa->type != VPE_SHARED_NULL) {
+			    if ((tpsa->type == VPE_SHARED_RESERVED)
+			    || (tpsa->type == published_vpe_area[j].type)) {
+				tpsa->type = published_vpe_area[j].type;
+				tpsa->addr = published_vpe_area[j].addr;
+				break;
+			    }
+			    tpsa++;
+			}
+		    }
 		}
+	    }
+
 	}
 
 	if ( (v->__start == 0) || (v->shared_ptr == NULL))
@@ -832,17 +1016,16 @@
 	char *secstrings, *strtab = NULL;
 	unsigned int len, i, symindex = 0, strindex = 0, relocate = 0;
 	struct module mod;	// so we can re-use the relocations code
+	mm_segment_t old_fs;
 
 	memset(&mod, 0, sizeof(struct module));
 	strcpy(mod.name, "VPE loader");
-
-	hdr = (Elf_Ehdr *) v->pbuffer;
-	len = v->plen;
+	hdr = v->l_ehdr;
+	len = v->pbsize;
 
 	/* Sanity checks against insmoding binaries or wrong arch,
 	   weird elf version */
-	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0
-	    || (hdr->e_type != ET_REL && hdr->e_type != ET_EXEC)
+	if ((hdr->e_type != ET_REL && hdr->e_type != ET_EXEC)
 	    || !elf_check_arch(hdr)
 	    || hdr->e_shentsize != sizeof(*sechdrs)) {
 		printk(KERN_WARNING
@@ -854,9 +1037,8 @@
 	if (hdr->e_type == ET_REL)
 		relocate = 1;
 
-	if (len < hdr->e_shoff + hdr->e_shnum * sizeof(Elf_Shdr)) {
-		printk(KERN_ERR "VPE loader: program length %u truncated\n",
-		       len);
+	if (len < v->l_phlen + v->l_shlen) {
+		printk(KERN_ERR "VPE loader: Headers exceed %u bytes\n", len);
 
 		return -ENOEXEC;
 	}
@@ -890,9 +1072,13 @@
 			}
 		}
 		layout_sections(&mod, hdr, sechdrs, secstrings);
+		/*
+		 * Non-relocatable loads should have already done their
+		 * allocates, based on program header table.
+		 */
 	}
 
-	v->load_addr = alloc_progmem(mod.core_size);
+	memset(v->load_addr, 0, mod.core_size);
 	if (!v->load_addr)
 		return -ENOMEM;
 
@@ -958,6 +1144,9 @@
 		    phdr++;
 		}
 
+		/*
+		 * Program image is already in memory.
+		 */
 		for (i = 0; i < hdr->e_shnum; i++) {
 			/* Internal symbols and strings. */
 			if (sechdrs[i].sh_type == SHT_SYMTAB) {
@@ -973,8 +1162,12 @@
 	}
 
 	/* make sure it's physically written out */
+	/* flush the icache in correct context */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
 	flush_icache_range((unsigned long)v->load_addr,
-			   (unsigned long)v->load_addr + v->len);
+			   (unsigned long)v->load_addr + v->copied);
+	set_fs(old_fs);
 
 	if ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {
 		if (v->__start == 0) {
@@ -988,8 +1181,8 @@
 			       "program does not contain vpe_shared symbol.\n"
 			       " Unable to use AMVP (AP/SP) facilities.\n");
 	}
+	pr_info("APRP VPE loader: elf loaded\n");
 
-	printk(" elf loaded\n");
 	return 0;
 }
 
@@ -1054,6 +1247,10 @@
 
 		return -ENODEV;
 	}
+	/*
+	 * This treats the tclimit command line configuration input
+	 * as a minor device indication, which is probably unwholesome.
+	 */
 
 	if ((v = get_vpe(tclimit)) == NULL) {
 		pr_warning("VPE loader: unable to get vpe\n");
@@ -1070,18 +1267,20 @@
 		}
 
 		release_progmem(v->load_addr);
+		kfree(v->l_phsort);
 		cleanup_tc(get_tc(tclimit));
 	}
 
 	/* this of-course trashes what was there before... */
 	v->pbuffer = vmalloc(P_SIZE);
-	if (!v->pbuffer) {
-		pr_warning("VPE loader: unable to allocate memory\n");
-		return -ENOMEM;
-	}
-	v->plen = P_SIZE;
 	v->load_addr = NULL;
-	v->len = 0;
+	v->copied = 0;
+	v->offset = 0;
+	v->l_state = LOAD_STATE_EHDR;
+	v->l_ehdr = NULL;
+	v->l_phdr = NULL;
+	v->l_phsort = NULL;
+	v->l_shdr = NULL;
 
 	v->uid = filp->f_cred->fsuid;
 	v->gid = filp->f_cred->fsgid;
@@ -1092,6 +1291,7 @@
 		printk(KERN_WARNING "VPE loader: open, getcwd returned %d\n", ret);
 
 	v->shared_ptr = NULL;
+	v->shared_areas = NULL;
 	v->__start = 0;
 
 	return 0;
@@ -1100,18 +1300,30 @@
 static int vpe_release(struct inode *inode, struct file *filp)
 {
 	struct vpe *v;
-	Elf_Ehdr *hdr;
 	int ret = 0;
 
 	v = get_vpe(tclimit);
 	if (v == NULL)
 		return -ENODEV;
+	/*
+	 * If image load had no errors, massage program/section tables
+	 * to reflect movement of program/section data into VPE program
+	 * memory.
+	 */
+	if (v->l_state != LOAD_STATE_DONE) {
+		printk(KERN_WARNING "VPE Release after incomplete load\n");
+		printk(KERN_DEBUG "Used vfree to free memory at "
+				  "%x after failed load attempt\n",
+		       (unsigned int)v->pbuffer);
+		if (v->pbuffer != NULL)
+			vfree(v->pbuffer);
+		return -ENOEXEC;
+	}
 
-	hdr = (Elf_Ehdr *) v->pbuffer;
-	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) == 0) {
-		if (vpe_elfload(v) >= 0) {
+	if (memcmp(((Elf_Ehdr *)v->pbuffer)->e_ident, ELFMAG, SELFMAG) == 0) {
+		if (vpe_elfload(v) >= 0)
 			vpe_run(v);
-		} else {
+		else {
 			printk(KERN_WARNING "VPE loader: ELF load failed.\n");
 			ret = -ENOEXEC;
 		}
@@ -1120,6 +1332,7 @@
 		ret = -ENOEXEC;
 	}
 
+
 	/* It's good to be able to run the SP and if it chokes have a look at
 	   the /dev/rt?. But if we reset the pointer to the shared struct we
 	   lose what has happened. So perhaps if garbage is sent to the vpe
@@ -1128,36 +1341,427 @@
 	if (ret < 0)
 		v->shared_ptr = NULL;
 
-	vfree(v->pbuffer);
-	v->plen = 0;
-
+	// cleanup any temp buffers
+	if (v->pbuffer) {
+		printk(KERN_DEBUG "Used vfree to free memory at %x\n",
+		       (unsigned int)v->pbuffer);
+		vfree(v->pbuffer);
+	}
+	v->pbsize = 0;
 	return ret;
 }
 
+/*
+ * A sort of insertion sort to generate list of program header indices
+ * in order of their file offsets.
+ */
+
+static void indexort(struct elf_phdr *phdr, int nph, int *index)
+{
+	int i, j, t;
+	unsigned int toff;
+
+	/* Create initial mapping */
+	for (i = 0; i < nph; i++)
+		index[i] = i;
+	/* Do the indexed insert sort */
+	for (i = 1; i < nph; i++) {
+		j = i;
+		t = index[j];
+		toff = phdr[t].p_offset;
+		while ((j > 0) && (phdr[index[j-1]].p_offset > toff)) {
+			index[j] = index[j-1];
+			j--;
+		}
+		index[j] = t;
+	}
+}
+
+
+/*
+ * This function has to convert the ELF file image being sequentially
+ * streamed to the pseudo-device into the binary image, symbol, and
+ * string information, which the ELF format allows to be in some degree
+ * of disorder.
+ *
+ * The ELF header and, if present, program header table, are copied into
+ * a temporary buffer.  Loadable program segments, if present, are copied
+ * into the RP program memory at the addresses specified by the program
+ * header table.
+ *
+ * Sections not specified by the program header table are loaded into
+ * memory following the program segments if they are "allocated", or
+ * into the temporary buffer if they are not. The section header
+ * table is loaded into the temporary buffer.???
+ */
+#define CURPHDR (v->l_phdr[v->l_phsort[v->l_cur_seg]])
 static ssize_t vpe_write(struct file *file, const char __user * buffer,
 			 size_t count, loff_t * ppos)
 {
 	size_t ret = count;
 	struct vpe *v;
+	int tocopy, uncopied;
+	int i;
+	unsigned int progmemlen;
 
-	if (iminor(file_inode(file)) != minor)
+	if (iminor(file->f_path.dentry->d_inode) != minor)
 		return -ENODEV;
 
 	v = get_vpe(tclimit);
 	if (v == NULL)
 		return -ENODEV;
 
-	if ((count + v->len) > v->plen) {
-		printk(KERN_WARNING
-		       "VPE loader: elf size too big. Perhaps strip uneeded symbols\n");
+	if (v->pbuffer == NULL) {
+		printk(KERN_ERR "VPE loader: no buffer for program\n");
 		return -ENOMEM;
 	}
 
-	count -= copy_from_user(v->pbuffer + v->len, buffer, count);
-	if (!count)
-		return -EFAULT;
+	while (count) {
+		switch (v->l_state) {
+		case LOAD_STATE_EHDR:
+			/* Loading ELF Header into scratch buffer */
+			tocopy = min((unsigned long)count,
+				     sizeof(Elf_Ehdr) - v->offset);
+			uncopied = copy_from_user(v->pbuffer + v->copied,
+						  buffer, tocopy);
+			count -= tocopy - uncopied;
+			v->copied += tocopy - uncopied;
+			v->offset += tocopy - uncopied;
+			buffer += tocopy - uncopied;
+			if (v->copied == sizeof(Elf_Ehdr)) {
+			    v->l_ehdr = (Elf_Ehdr *)v->pbuffer;
+			    if (memcmp(v->l_ehdr->e_ident, ELFMAG, 4) != 0) {
+				printk(KERN_WARNING "VPE loader: %s\n",
+					"non-ELF file image");
+				ret = -ENOEXEC;
+				v->l_state = LOAD_STATE_ERROR;
+				break;
+			    }
+			    if (v->l_ehdr->e_phoff != 0) {
+				v->l_phdr = (struct elf_phdr *)
+					(v->pbuffer + v->l_ehdr->e_phoff);
+				v->l_phlen = v->l_ehdr->e_phentsize
+					* v->l_ehdr->e_phnum;
+				/* Check against buffer overflow */
+				if ((v->copied + v->l_phlen) > v->pbsize) {
+					printk(KERN_WARNING
+		       "VPE loader: elf program header table size too big\n");
+					v->l_state = LOAD_STATE_ERROR;
+					return -ENOMEM;
+				}
+				v->l_state = LOAD_STATE_PHDR;
+				/*
+				 * Program headers generally indicate
+				 * linked executable with possibly
+				 * valid entry point.
+				 */
+				v->__start = v->l_ehdr->e_entry;
+			    } else  if (v->l_ehdr->e_shoff != 0) {
+				/*
+				 * No program headers, but a section
+				 * header table.  A relocatable binary.
+				 * We need to load the works into the
+				 * kernel temp buffer to compute the
+				 * RP program image.  That limits our
+				 * binary size, but at least we're no
+				 * worse off than the original APRP
+				 * prototype.
+				 */
+				v->l_shlen = v->l_ehdr->e_shentsize
+					* v->l_ehdr->e_shnum;
+				if ((v->l_ehdr->e_shoff + v->l_shlen
+				     - v->offset) > v->pbsize) {
+					printk(KERN_WARNING
+			 "VPE loader: elf sections/section table too big.\n");
+					v->l_state = LOAD_STATE_ERROR;
+					return -ENOMEM;
+				}
+				v->l_state = LOAD_STATE_SHDR;
+			    } else {
+				/*
+				 * If neither program nor section tables,
+				 * we don't know what to do.
+				 */
+				v->l_state = LOAD_STATE_ERROR;
+				return -ENOEXEC;
+			    }
+			}
+			break;
+		case LOAD_STATE_PHDR:
+			/* Loading Program Headers into scratch */
+			tocopy = min((unsigned long)count,
+			    v->l_ehdr->e_phoff + v->l_phlen - v->copied);
+			uncopied = copy_from_user(v->pbuffer + v->copied,
+			    buffer, tocopy);
+			count -= tocopy - uncopied;
+			v->copied += tocopy - uncopied;
+			v->offset += tocopy - uncopied;
+			buffer += tocopy - uncopied;
+
+			if (v->copied == v->l_ehdr->e_phoff + v->l_phlen) {
+			    /*
+			     * It's legal for the program headers to be
+			     * out of order with respect to the file layout.
+			     * Generate a list of indices, sorted by file
+			     * offset.
+			     */
+			    v->l_phsort = kmalloc(v->l_ehdr->e_phnum
+				* sizeof(int), GFP_KERNEL);
+			    printk(KERN_DEBUG
+		   "Used kmalloc to allocate %d bytes of memory at %x\n",
+				   v->l_ehdr->e_phnum*sizeof(int),
+				   (unsigned int)v->l_phsort);
+			    if (!v->l_phsort)
+				    return -ENOMEM; /* Preposterous, but... */
+			    indexort(v->l_phdr, v->l_ehdr->e_phnum,
+				     v->l_phsort);
+
+			    v->l_progminad = (unsigned int)-1;
+			    v->l_progmaxad = 0;
+			    progmemlen = 0;
+			    for (i = 0; i < v->l_ehdr->e_phnum; i++) {
+				if (v->l_phdr[v->l_phsort[i]].p_type
+				    == PT_LOAD) {
+				    /* Unstripped .reginfo sections are bad */
+				    if (v->l_phdr[v->l_phsort[i]].p_vaddr
+					< __UA_LIMIT) {
+					printk(KERN_WARNING "%s%s%s\n",
+					    "VPE loader: ",
+					    "User-mode p_vaddr, ",
+					    "skipping program segment,");
+					printk(KERN_WARNING "%s%s%s\n",
+					    "VPE loader: ",
+					    "strip .reginfo from binary ",
+					    "if necessary.");
+					continue;
+				    }
+				    if (v->l_phdr[v->l_phsort[i]].p_vaddr
+					< v->l_progminad)
+					    v->l_progminad =
+					      v->l_phdr[v->l_phsort[i]].p_vaddr;
+				    if ((v->l_phdr[v->l_phsort[i]].p_vaddr
+					+ v->l_phdr[v->l_phsort[i]].p_memsz)
+					> v->l_progmaxad)
+					    v->l_progmaxad =
+					     v->l_phdr[v->l_phsort[i]].p_vaddr +
+					     v->l_phdr[v->l_phsort[i]].p_memsz;
+				}
+			    }
+			    printk(KERN_INFO "APRP RP program 0x%x to 0x%x\n",
+				v->l_progminad, v->l_progmaxad);
+			    /*
+			     * Do a simple sanity check of the memory being
+			     * allocated. Abort if greater than an arbitrary
+			     * value of 32MB
+			     */
+			    if (v->l_progmaxad - v->l_progminad >
+				32*1024*1024) {
+				printk(KERN_WARNING
+	      "RP program failed to allocate %d kbytes - limit is 32,768 KB\n",
+				       (v->l_progmaxad - v->l_progminad)/1024);
+				return -ENOMEM;
+			      }
+
+			    v->load_addr = alloc_progmem((void *)v->l_progminad,
+				v->l_progmaxad - v->l_progminad);
+			    if (!v->load_addr)
+				return -ENOMEM;
+			    if ((unsigned int)v->load_addr
+				> v->l_progminad) {
+				release_progmem(v->load_addr);
+				return -ENOMEM;
+			    }
+			    /* Find first segment with loadable content */
+			    for (i = 0; i < v->l_ehdr->e_phnum; i++) {
+				if (v->l_phdr[v->l_phsort[i]].p_type
+				    == PT_LOAD) {
+				    if (v->l_phdr[v->l_phsort[i]].p_vaddr
+					< __UA_LIMIT) {
+					/* Skip userspace segments */
+					continue;
+				    }
+				    v->l_cur_seg = i;
+				    break;
+				}
+			    }
+			    if (i == v->l_ehdr->e_phnum) {
+				/* No loadable program segment?  Bogus file. */
+				printk(KERN_WARNING "Bad ELF file for APRP\n");
+				return -ENOEXEC;
+			    }
+			    v->l_segoff = 0;
+			    v->l_state = LOAD_STATE_PIMAGE;
+			}
+			break;
+		case LOAD_STATE_PIMAGE:
+			/*
+			 * Skip through input stream until
+			 * first program segment. Would be
+			 * better to have loaded up to here
+			 * into the temp buffer, but for now
+			 * we simply rule out "interesting"
+			 * sections prior to the last program
+			 * segment in an executable file.
+			 */
+			if (v->offset < CURPHDR.p_offset) {
+			    uncopied = CURPHDR.p_offset - v->offset;
+			    if (uncopied > count)
+				uncopied = count;
+			    count -= uncopied;
+			    buffer += uncopied;
+			    v->offset += uncopied;
+			    /* Go back through the "while" */
+			    break;
+			}
+			/*
+			 * Having dispensed with any unlikely fluff,
+			 * copy from user I/O buffer to program segment.
+			 */
+			tocopy = min(count, CURPHDR.p_filesz - v->l_segoff);
+
+			/* Loading image into RP memory */
+			uncopied = copy_from_user((char *)CURPHDR.p_vaddr
+			    + v->l_segoff, buffer, tocopy);
+			count -= tocopy - uncopied;
+			v->offset += tocopy - uncopied;
+			v->l_segoff += tocopy - uncopied;
+			buffer += tocopy - uncopied;
+			if (v->l_segoff >= CURPHDR.p_filesz) {
+			    /* Finished current segment load */
+			    /* Zero out non-file-sourced image */
+			    uncopied = CURPHDR.p_memsz - CURPHDR.p_filesz;
+			    if (uncopied > 0)
+				memset((char *)CURPHDR.p_vaddr + v->l_segoff,
+				    0, uncopied);
+			    /* Advance to next segment */
+			    for (i = v->l_cur_seg + 1;
+				i < v->l_ehdr->e_phnum; i++) {
+				if (v->l_phdr[v->l_phsort[i]].p_type
+				    == PT_LOAD) {
+				    if (v->l_phdr[v->l_phsort[i]].p_vaddr
+					< __UA_LIMIT) {
+					/* Skip userspace segments */
+					continue;
+				    }
+				    v->l_cur_seg = i;
+				    break;
+				}
+			    }
+			    /* If none left, prepare to load section headers */
+			    if (i == v->l_ehdr->e_phnum) {
+				if (v->l_ehdr->e_shoff != 0) {
+				/* Copy to where we left off in temp buffer */
+				    v->l_shlen = v->l_ehdr->e_shentsize
+					* v->l_ehdr->e_shnum;
+				    if ((v->l_ehdr->e_shoff + v->l_shlen
+					- v->offset) > v->pbsize) {
+					printk(KERN_WARNING
+			   "VPE loader: elf sections/section table too big\n");
+					v->l_state = LOAD_STATE_ERROR;
+					return -ENOMEM;
+				    }
+				    v->l_state = LOAD_STATE_SHDR;
+				    break;
+				}
+			    } else {
+				/* reset offset for new program segment */
+				v->l_segoff = 0;
+			    }
+			}
+			break;
+		case LOAD_STATE_SHDR:
+			/*
+			 * Read stream into private buffer up
+			 * through and including the section header
+			 * table.
+			 */
 
-	v->len += count;
+			tocopy = min((unsigned long)count,
+			    v->l_ehdr->e_shoff + v->l_shlen - v->offset);
+			if (tocopy) {
+			    uncopied = copy_from_user(v->pbuffer + v->copied,
+			    buffer, tocopy);
+			    count -= tocopy - uncopied;
+			    v->copied += tocopy - uncopied;
+			    v->offset += tocopy - uncopied;
+			    buffer += tocopy - uncopied;
+			}
+			/* Finished? */
+			if (v->offset == v->l_ehdr->e_shoff + v->l_shlen) {
+			    unsigned int offset_delta = v->offset - v->copied;
+
+			    v->l_shdr = (Elf_Shdr *)(v->pbuffer
+				+ v->l_ehdr->e_shoff - offset_delta);
+			    /*
+			     * Check for sections after the section table,
+			     * which for gcc MIPS binaries includes
+			     * the symbol table. Do any other processing
+			     * that requires value within stream, and
+			     * normalize offsets to be relative to
+			     * the header-only layout of temp buffer.
+			     */
+
+			    /* Assume no trailer until we detect one */
+			    v->l_trailer = 0;
+			    v->l_state = LOAD_STATE_DONE;
+			    for (i = 0; i < v->l_ehdr->e_shnum; i++) {
+				   if (v->l_shdr[i].sh_offset
+					> v->l_ehdr->e_shoff) {
+					v->l_state = LOAD_STATE_TRAILER;
+					/* Track trailing data length */
+					if (v->l_trailer
+					    < (v->l_shdr[i].sh_offset
+					    + v->l_shdr[i].sh_size)
+					    - (v->l_ehdr->e_shoff
+					    + v->l_shlen))
+						v->l_trailer =
+						    (v->l_shdr[i].sh_offset
+						    + v->l_shdr[i].sh_size)
+						    - (v->l_ehdr->e_shoff
+						    + v->l_shlen);
+				    }
+				    /* Adjust section offset if necessary */
+				    v->l_shdr[i].sh_offset -= offset_delta;
+			    }
+			    if ((v->copied + v->l_trailer) > v->pbsize) {
+				printk(KERN_WARNING
+	      "VPE loader: elf size too big. Perhaps strip uneeded symbols\n");
+				v->l_state = LOAD_STATE_ERROR;
+				return -ENOMEM;
+			    }
+
+			    /* Fix up offsets in ELF header */
+			    v->l_ehdr->e_shoff = (unsigned int)v->l_shdr
+				- (unsigned int)v->pbuffer;
+			}
+			break;
+		case LOAD_STATE_TRAILER:
+			/*
+			 * Symbol and string tables follow section headers
+			 * in gcc binaries for MIPS. Copy into temp buffer.
+			 */
+			if (v->l_trailer) {
+			    tocopy = min(count, v->l_trailer);
+			    uncopied = copy_from_user(v->pbuffer + v->copied,
+			    buffer, tocopy);
+			    count -= tocopy - uncopied;
+			    v->l_trailer -= tocopy - uncopied;
+			    v->copied += tocopy - uncopied;
+			    v->offset += tocopy - uncopied;
+			    buffer += tocopy - uncopied;
+			}
+			if (!v->l_trailer)
+			    v->l_state = LOAD_STATE_DONE;
+			break;
+		case LOAD_STATE_DONE:
+			if (count)
+				count = 0;
+			break;
+		case LOAD_STATE_ERROR:
+		default:
+			return -EINVAL;
+		}
+	}
 	return ret;
 }
 
@@ -1193,7 +1797,9 @@
 {
 	struct vpe *v = vpe;
 
-	v->__start = start;
+	/* Null start address means use value from ELF file */
+	if (start)
+		v->__start = start;
 	return vpe_run(v);
 }
 
@@ -1318,6 +1924,106 @@
 
 EXPORT_SYMBOL(vpe_getcwd);
 
+/*
+ * RP applications may contain a _vpe_shared_area descriptor
+ * array to allow for data sharing with Linux kernel functions
+ * that's slightly more abstracted and extensible than the
+ * fixed binding used by the rtlx support.  Indeed, the rtlx
+ * support should ideally be converted to use the generic
+ * shared area descriptor scheme at some point.
+ *
+ * mips_get_vpe_shared_area() can be used by AP kernel
+ * modules to get an area pointer of a given type, if
+ * it exists.
+ *
+ * mips_publish_vpe_area() is used by AP kernel modules
+ * to share kseg0 kernel memory with the RP.  It maintains
+ * a private table, so that publishing can be done before
+ * the RP program is launched.  Making this table dynamically
+ * allocated and extensible would be good scalable OS design.
+ * however, until there's more than one user of the mechanism,
+ * it should be an acceptable simplification to allow a static
+ * maximum of 4 published areas.
+ */
+
+void *mips_get_vpe_shared_area(int index, int type)
+{
+	struct vpe *v;
+	struct vpe_shared_area *vsa;
+
+	v = get_vpe(index);
+	if (v == NULL)
+		return NULL;
+
+	if (v->shared_areas == NULL)
+		return NULL;
+
+	vsa = v->shared_areas;
+
+	while (vsa->type != VPE_SHARED_NULL) {
+		if (vsa->type == type)
+			return vsa->addr;
+		else
+			vsa++;
+	}
+	/* Fell through without finding type */
+
+	return NULL;
+}
+EXPORT_SYMBOL(mips_get_vpe_shared_area);
+
+int  mips_publish_vpe_area(int type, void *ptr)
+{
+	int i;
+	int retval = 0;
+	struct vpe *v;
+	unsigned long flags;
+	unsigned int vpflags;
+
+	printk(KERN_INFO "mips_publish_vpe_area(0x%x, 0x%x)\n", type, (int)ptr);
+	if ((unsigned int)ptr >= KSEG2) {
+	    printk(KERN_ERR "VPE area pubish of invalid address 0x%x\n",
+		(int)ptr);
+	    return 0;
+	}
+	for (i = 0; i < N_PUB_AREAS; i++) {
+	    if (published_vpe_area[i].type == VPE_SHARED_RESERVED) {
+		published_vpe_area[i].type = type;
+		published_vpe_area[i].addr = ptr;
+		retval = type;
+		break;
+	    }
+	}
+	/*
+	 * If we've already got a VPE up and running, try to
+	 * update the shared descriptor with the new data.
+	 */
+	list_for_each_entry(v, &vpecontrol.vpe_list, list) {
+	    if (v->shared_areas != NULL) {
+		local_irq_save(flags);
+		vpflags = dvpe();
+		for (i = 0; v->shared_areas[i].type != VPE_SHARED_NULL; i++) {
+		    if ((v->shared_areas[i].type == type)
+		    || (v->shared_areas[i].type == VPE_SHARED_RESERVED)) {
+			v->shared_areas[i].type = type;
+			v->shared_areas[i].addr = ptr;
+		    }
+		}
+		evpe(vpflags);
+		local_irq_restore(flags);
+	    }
+	}
+	return retval;
+}
+EXPORT_SYMBOL(mips_publish_vpe_area);
+
+#ifdef CONFIG_MIPS_APSP_KSPD
+static void kspd_sp_exit( int sp_id)
+{
+	cleanup_tc(get_tc(sp_id));
+}
+#endif
+
 static ssize_t store_kill(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t len)
 {
@@ -1329,6 +2035,7 @@
 	}
 
 	release_progmem(vpe->load_addr);
+	kfree(vpe->l_phsort);
 	cleanup_tc(get_tc(tclimit));
 	vpe_stop(vpe);
 	vpe_free(vpe);
@@ -1374,6 +2081,8 @@
 
 static void vpe_device_release(struct device *cd)
 {
+	printk(KERN_DEBUG "Using kfree to free vpe class device at %x\n",
+	       (unsigned int)cd);
 	kfree(cd);
 }
 
@@ -1400,19 +2109,24 @@
 	}
 
 	if (vpelimit == 0) {
-		printk(KERN_WARNING "No VPEs reserved for AP/SP, not "
-		       "initializing VPE loader.\nPass maxvpes=<n> argument as "
-		       "kernel argument\n");
-
+#if defined(CONFIG_MIPS_MT_SMTC) || defined(MIPS_MT_SMP)
+		printk(KERN_WARNING "No VPEs reserved for VPE loader.\n"
+			"Pass maxvpes=<n> argument as kernel argument\n");
 		return -ENODEV;
+#else
+		vpelimit = 1;
+#endif
 	}
 
 	if (tclimit == 0) {
+#if defined(CONFIG_MIPS_MT_SMTC) || defined(MIPS_MT_SMP)
 		printk(KERN_WARNING "No TCs reserved for AP/SP, not "
 		       "initializing VPE loader.\nPass maxtcs=<n> argument as "
 		       "kernel argument\n");
-
 		return -ENODEV;
+#else
+		tclimit = 1;
+#endif
 	}
 
 	major = register_chrdev(0, module_name, &vpe_fops);
@@ -1426,7 +2140,7 @@
 		printk(KERN_ERR "vpe_class registration failed\n");
 		goto out_chrdev;
 	}
-
+	xvpe_vector_set = 0;
 	device_initialize(&vpe_device);
 	vpe_device.class	= &vpe_class,
 	vpe_device.parent	= NULL,
diff -ur ./arch/mips/kernel/watch.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/watch.c
--- ./arch/mips/kernel/watch.c	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kernel/watch.c	2023-04-23 11:58:25.389103600 +0100
@@ -111,6 +111,7 @@
 	 * disable the register.
 	 */
 	write_c0_watchlo0(7);
+	back_to_back_c0_hazard();
 	t = read_c0_watchlo0();
 	write_c0_watchlo0(0);
 	c->watch_reg_masks[0] = t & 7;
@@ -121,12 +122,14 @@
 	c->watch_reg_use_cnt = 1;
 	t = read_c0_watchhi0();
 	write_c0_watchhi0(t | 0xff8);
+	back_to_back_c0_hazard();
 	t = read_c0_watchhi0();
 	c->watch_reg_masks[0] |= (t & 0xff8);
 	if ((t & 0x80000000) == 0)
 		return;
 
 	write_c0_watchlo1(7);
+	back_to_back_c0_hazard();
 	t = read_c0_watchlo1();
 	write_c0_watchlo1(0);
 	c->watch_reg_masks[1] = t & 7;
@@ -135,12 +138,14 @@
 	c->watch_reg_use_cnt = 2;
 	t = read_c0_watchhi1();
 	write_c0_watchhi1(t | 0xff8);
+	back_to_back_c0_hazard();
 	t = read_c0_watchhi1();
 	c->watch_reg_masks[1] |= (t & 0xff8);
 	if ((t & 0x80000000) == 0)
 		return;
 
 	write_c0_watchlo2(7);
+	back_to_back_c0_hazard();
 	t = read_c0_watchlo2();
 	write_c0_watchlo2(0);
 	c->watch_reg_masks[2] = t & 7;
@@ -149,12 +154,14 @@
 	c->watch_reg_use_cnt = 3;
 	t = read_c0_watchhi2();
 	write_c0_watchhi2(t | 0xff8);
+	back_to_back_c0_hazard();
 	t = read_c0_watchhi2();
 	c->watch_reg_masks[2] |= (t & 0xff8);
 	if ((t & 0x80000000) == 0)
 		return;
 
 	write_c0_watchlo3(7);
+	back_to_back_c0_hazard();
 	t = read_c0_watchlo3();
 	write_c0_watchlo3(0);
 	c->watch_reg_masks[3] = t & 7;
@@ -163,6 +170,7 @@
 	c->watch_reg_use_cnt = 4;
 	t = read_c0_watchhi3();
 	write_c0_watchhi3(t | 0xff8);
+	back_to_back_c0_hazard();
 	t = read_c0_watchhi3();
 	c->watch_reg_masks[3] |= (t & 0xff8);
 	if ((t & 0x80000000) == 0)
diff -ur ./arch/mips/kvm/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kvm/Kconfig
--- ./arch/mips/kvm/Kconfig	2023-04-26 12:56:04.220118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/kvm/Kconfig	2023-04-23 11:58:25.471663600 +0100
@@ -5,7 +5,6 @@
 
 menuconfig VIRTUALIZATION
 	bool "Virtualization"
-	depends on HAVE_KVM
 	---help---
 	  Say Y here to get to see options for using your Linux host to run
 	  other operating systems inside virtual machines (guests).
diff -ur ./arch/mips/lasat/image/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lasat/image/Makefile
--- ./arch/mips/lasat/image/Makefile	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lasat/image/Makefile	2023-04-23 11:58:26.364316800 +0100
@@ -13,13 +13,11 @@
 MKLASATIMG = mklasatimg
 MKLASATIMG_ARCH = mq2,mqpro,sp100,sp200
 KERNEL_IMAGE = vmlinux
-KERNEL_START = $(shell $(NM) $(KERNEL_IMAGE) | grep " _text" | cut -f1 -d\ )
-KERNEL_ENTRY = $(shell $(NM) $(KERNEL_IMAGE) | grep kernel_entry | cut -f1 -d\ )
 
 LDSCRIPT= -L$(srctree)/$(src) -Tromscript.normal
 
-HEAD_DEFINES := -D_kernel_start=0x$(KERNEL_START) \
-		-D_kernel_entry=0x$(KERNEL_ENTRY) \
+HEAD_DEFINES := -D_kernel_start=$(VMLINUX_LOAD_ADDRESS) \
+		-D_kernel_entry=$(VMLINUX_ENTRY_ADDRESS) \
 		-D VERSION="\"$(Version)\"" \
 		-D TIMESTAMP=$(shell date +%s)
 
diff -ur ./arch/mips/lib/csum_partial.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/csum_partial.S
--- ./arch/mips/lib/csum_partial.S	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/csum_partial.S	2023-04-23 11:58:26.672587000 +0100
@@ -9,6 +9,17 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2007  Maciej W. Rozycki
  */
+/*
+ * Hack to resolve longstanding prefetch issue
+ *
+ * Prefetching may be fatal on some systems if we're prefetching beyond the
+ * end of memory on some systems.  It's also a seriously bad idea on non
+ * dma-coherent systems.
+ */
+#if defined(CONFIG_DMA_NONCOHERENT) || defined(CONFIG_MIPS_MALTA)
+#undef CONFIG_CPU_HAS_PREFETCH
+#endif
+
 #include <linux/errno.h>
 #include <asm/asm.h>
 #include <asm/asm-offsets.h>
@@ -43,6 +54,8 @@
 #define ADD    daddu
 #define NBYTES 8
 
+#define LOADK  ld
+
 #else
 
 #define LOAD   lw
@@ -50,6 +63,8 @@
 #define ADD    addu
 #define NBYTES 4
 
+#define LOADK  lw
+
 #endif /* USE_DOUBLE */
 
 #define UNIT(unit)  ((unit)*NBYTES)
@@ -417,12 +432,18 @@
 	 *
 	 * If len < NBYTES use byte operations.
 	 */
-	sltu	t2, len, NBYTES
+	PREF(   0, 0(src) )
+	PREF(   1, 0(dst) )
+	sltu    t2, len, NBYTES
 	and	t1, dst, ADDRMASK
-	bnez	t2, .Lcopy_bytes_checklen
+	PREF(   0, 1*32(src) )
+	PREF(   1, 1*32(dst) )
+	bnez    t2, .Lcopy_bytes_checklen
 	 and	t0, src, ADDRMASK
 	andi	odd, dst, 0x1			/* odd buffer? */
-	bnez	t1, .Ldst_unaligned
+	PREF(   0, 2*32(src) )
+	PREF(   1, 2*32(dst) )
+	bnez    t1, .Ldst_unaligned
 	 nop
 	bnez	t0, .Lsrc_unaligned_dst_aligned
 	/*
@@ -434,7 +455,9 @@
 	beqz	t0, .Lcleanup_both_aligned # len < 8*NBYTES
 	 nop
 	SUB	len, 8*NBYTES		# subtract here for bgez loop
-	.align	4
+	PREF(   0, 3*32(src) )
+	PREF(   1, 3*32(dst) )
+	.align  4
 1:
 EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
 EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
@@ -462,8 +485,10 @@
 	ADDC(sum, t6)
 EXC(	STORE	t7, UNIT(7)(dst),	.Ls_exc)
 	ADDC(sum, t7)
-	.set	reorder				/* DADDI_WAR */
+	.set    reorder                         /* DADDI_WAR */
 	ADD	dst, dst, 8*NBYTES
+	PREF(   0, 8*32(src) )
+	PREF(   1, 8*32(dst) )
 	bgez	len, 1b
 	.set	noreorder
 	ADD	len, 8*NBYTES		# revert len (see above)
@@ -568,9 +593,11 @@
 	 ADD	src, src, t2
 
 .Lsrc_unaligned_dst_aligned:
-	SRL	t0, len, LOG_NBYTES+2	 # +2 for 4 units/iter
+	SRL     t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREF(   0, 3*32(src) )
 	beqz	t0, .Lcleanup_src_unaligned
-	 and	rem, len, (4*NBYTES-1)	 # rem = len % 4*NBYTES
+	 and    rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREF(   1, 3*32(dst) )
 1:
 /*
  * Avoid consecutive LD*'s to the same register since some mips
@@ -587,7 +614,8 @@
 EXC(	LDFIRST t3, FIRST(3)(src),	.Ll_exc_copy)
 EXC(	LDREST	t2, REST(2)(src),	.Ll_exc_copy)
 EXC(	LDREST	t3, REST(3)(src),	.Ll_exc_copy)
-	ADD	src, src, 4*NBYTES
+	PREF(   0, 9*32(src) )          # 0 is PREF_LOAD  (not streamed)
+	ADD     src, src, 4*NBYTES
 #ifdef CONFIG_CPU_SB1
 	nop				# improves slotting
 #endif
@@ -600,7 +628,8 @@
 EXC(	STORE	t3, UNIT(3)(dst),	.Ls_exc)
 	ADDC(sum, t3)
 	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 4*NBYTES
+	PREF(   1, 9*32(dst) )          # 1 is PREF_STORE (not streamed)
+	ADD     dst, dst, 4*NBYTES
 	bne	len, rem, 1b
 	.set	noreorder
 
@@ -700,9 +729,9 @@
 	 *
 	 * Assumes src < THREAD_BUADDR($28)
 	 */
-	LOAD	t0, TI_TASK($28)
+	LOADK   t0, TI_TASK($28)
 	 li	t2, SHIFT_START
-	LOAD	t0, THREAD_BUADDR(t0)
+	LOADK   t0, THREAD_BUADDR(t0)
 1:
 EXC(	lbu	t1, 0(src),	.Ll_exc)
 	ADD	src, src, 1
@@ -715,9 +744,9 @@
 	bne	src, t0, 1b
 	.set	noreorder
 .Ll_exc:
-	LOAD	t0, TI_TASK($28)
+	LOADK   t0, TI_TASK($28)
 	 nop
-	LOAD	t0, THREAD_BUADDR(t0)	# t0 is just past last good address
+	LOADK   t0, THREAD_BUADDR(t0)   # t0 is just past last good address
 	 nop
 	SUB	len, AT, t0		# len number of uncopied bytes
 	/*
@@ -758,3 +787,738 @@
 	 sw	v1, (errptr)
 	.set	pop
 	END(__csum_partial_copy_user)
+
+
+#ifdef CONFIG_EVA
+
+	.set    eva
+
+#undef  LOAD
+#undef  LOADL
+#undef  LOADR
+#undef  STORE
+#undef  STOREL
+#undef  STORER
+#undef  LDFIRST
+#undef  LDREST
+#undef  STFIRST
+#undef  STREST
+#undef  COPY_BYTE
+
+#define LOAD   lwe
+#define LOADL  lwle
+#define LOADR  lwre
+#define STOREL swl
+#define STORER swr
+#define STORE  sw
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define LDFIRST LOADR
+#define LDREST  LOADL
+#define STFIRST STORER
+#define STREST  STOREL
+#else
+#define LDFIRST LOADL
+#define LDREST  LOADR
+#define STFIRST STOREL
+#define STREST  STORER
+#endif
+
+LEAF(__csum_partial_copy_fromuser)
+	PTR_ADDU	AT, src, len	/* See (1) above. */
+#ifdef CONFIG_64BIT
+	move	errptr, a4
+#else
+	lw	errptr, 16(sp)
+#endif
+	move	sum, zero
+	move	odd, zero
+	/*
+	 * Note: dst & src may be unaligned, len may be 0
+	 * Temps
+	 */
+	/*
+	 * The "issue break"s below are very approximate.
+	 * Issue delays for dcache fills will perturb the schedule, as will
+	 * load queue full replay traps, etc.
+	 *
+	 * If len < NBYTES use byte operations.
+	 */
+	PREFE(  0, 0(src) )
+	PREF(   1, 0(dst) )
+	sltu    t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREFE(  0, 1*32(src) )
+	PREF(   1, 1*32(dst) )
+	bnez    t2, .LFcopy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	andi	odd, dst, 0x1			/* odd buffer? */
+	PREFE(  0, 2*32(src) )
+	PREF(   1, 2*32(dst) )
+	bnez    t1, .LFdst_unaligned
+	 nop
+	bnez    t0, .LFsrc_unaligned_dst_aligned
+	/*
+	 * use delay slot for fall-through
+	 * src and dst are aligned; need to compute rem
+	 */
+.LFboth_aligned:
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+	beqz    t0, .LFcleanup_both_aligned # len < 8*NBYTES
+	 nop
+	SUB	len, 8*NBYTES		# subtract here for bgez loop
+	PREFE(  0, 3*32(src) )
+	PREF(   1, 3*32(dst) )
+	.align  4
+1:
+EXC(    LOAD    t0, UNIT(0)(src),       .LFl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LFl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LFl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LFl_exc_copy)
+EXC(    LOAD    t4, UNIT(4)(src),       .LFl_exc_copy)
+EXC(    LOAD    t5, UNIT(5)(src),       .LFl_exc_copy)
+EXC(    LOAD    t6, UNIT(6)(src),       .LFl_exc_copy)
+EXC(    LOAD    t7, UNIT(7)(src),       .LFl_exc_copy)
+	SUB	len, len, 8*NBYTES
+	ADD	src, src, 8*NBYTES
+	STORE   t0, UNIT(0)(dst)
+	ADDC(sum, t0)
+	STORE   t1, UNIT(1)(dst)
+	ADDC(sum, t1)
+	STORE   t2, UNIT(2)(dst)
+	ADDC(sum, t2)
+	STORE   t3, UNIT(3)(dst)
+	ADDC(sum, t3)
+	STORE   t4, UNIT(4)(dst)
+	ADDC(sum, t4)
+	STORE   t5, UNIT(5)(dst)
+	ADDC(sum, t5)
+	STORE   t6, UNIT(6)(dst)
+	ADDC(sum, t6)
+	STORE   t7, UNIT(7)(dst)
+	ADDC(sum, t7)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 8*NBYTES
+	PREFE(  0, 8*32(src) )
+	PREF(   1, 8*32(dst) )
+	bgez    len, 1b
+	.set	noreorder
+	ADD	len, 8*NBYTES		# revert len (see above)
+
+	/*
+	 * len == the number of bytes left to copy < 8*NBYTES
+	 */
+.LFcleanup_both_aligned:
+	beqz    len, .LFdone
+	 sltu	t0, len, 4*NBYTES
+	bnez    t0, .LFless_than_4units
+	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	/*
+	 * len >= 4*NBYTES
+	 */
+EXC(    LOAD    t0, UNIT(0)(src),       .LFl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LFl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LFl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LFl_exc_copy)
+	SUB	len, len, 4*NBYTES
+	ADD	src, src, 4*NBYTES
+	STORE   t0, UNIT(0)(dst)
+	ADDC(sum, t0)
+	STORE   t1, UNIT(1)(dst)
+	ADDC(sum, t1)
+	STORE   t2, UNIT(2)(dst)
+	ADDC(sum, t2)
+	STORE   t3, UNIT(3)(dst)
+	ADDC(sum, t3)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	beqz    len, .LFdone
+	.set	noreorder
+.LFless_than_4units:
+	/*
+	 * rem = len % NBYTES
+	 */
+	beq     rem, len, .LFcopy_bytes
+	 nop
+1:
+EXC(    LOAD    t0, 0(src),             .LFl_exc)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+	STORE   t0, 0(dst)
+	ADDC(sum, t0)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	rem, len, 1b
+	.set	noreorder
+
+	/*
+	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * A loop would do only a byte at a time with possible branch
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
+	 * because can't assume read-access to dst.  Instead, use
+	 * STREST dst, which doesn't require read access to dst.
+	 *
+	 * This code should perform better than a simple loop on modern,
+	 * wide-issue mips processors because the code has fewer branches and
+	 * more instruction-level parallelism.
+	 */
+	beqz    len, .LFdone
+	 ADD	t1, dst, len	# t1 is just past last byte of dst
+	li	bits, 8*NBYTES
+	SLL	rem, len, 3	# rem = number of bits to keep
+EXC(    LOAD    t0, 0(src),             .LFl_exc)
+	SUB	bits, bits, rem	# bits = number of bits to discard
+	SHIFT_DISCARD t0, t0, bits
+	STREST  t0, -1(t1)
+	SHIFT_DISCARD_REVERT t0, t0, bits
+	.set reorder
+	ADDC(sum, t0)
+	b       .LFdone
+	.set noreorder
+.LFdst_unaligned:
+	/*
+	 * dst is unaligned
+	 * t0 = src & ADDRMASK
+	 * t1 = dst & ADDRMASK; T1 > 0
+	 * len >= NBYTES
+	 *
+	 * Copy enough bytes to align dst
+	 * Set match = (src and dst have same alignment)
+	 */
+EXC(    LDFIRST t3, FIRST(0)(src),      .LFl_exc)
+	ADD	t2, zero, NBYTES
+EXC(    LDREST  t3, REST(0)(src),       .LFl_exc_copy)
+	SUB	t2, t2, t1	# t2 = number of bytes copied
+	xor	match, t0, t1
+	STFIRST t3, FIRST(0)(dst)
+	SLL	t4, t1, 3		# t4 = number of bits to discard
+	SHIFT_DISCARD t3, t3, t4
+	/* no SHIFT_DISCARD_REVERT to handle odd buffer properly */
+	ADDC(sum, t3)
+	beq     len, t2, .LFdone
+	 SUB	len, len, t2
+	ADD	dst, dst, t2
+	beqz    match, .LFboth_aligned
+	 ADD	src, src, t2
+
+.LFsrc_unaligned_dst_aligned:
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREFE(  0, 3*32(src) )
+	beqz    t0, .LFcleanup_src_unaligned
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREF(   1, 3*32(dst) )
+1:
+/*
+ * Avoid consecutive LD*'s to the same register since some mips
+ * implementations can't issue them in the same cycle.
+ * It's OK to load FIRST(N+1) before REST(N) because the two addresses
+ * are to the same unit (unless src is aligned, but it's not).
+ */
+EXC(    LDFIRST t0, FIRST(0)(src),      .LFl_exc)
+EXC(    LDFIRST t1, FIRST(1)(src),      .LFl_exc_copy)
+	SUB     len, len, 4*NBYTES
+EXC(    LDREST  t0, REST(0)(src),       .LFl_exc_copy)
+EXC(    LDREST  t1, REST(1)(src),       .LFl_exc_copy)
+EXC(    LDFIRST t2, FIRST(2)(src),      .LFl_exc_copy)
+EXC(    LDFIRST t3, FIRST(3)(src),      .LFl_exc_copy)
+EXC(    LDREST  t2, REST(2)(src),       .LFl_exc_copy)
+EXC(    LDREST  t3, REST(3)(src),       .LFl_exc_copy)
+	PREFE(  0, 9*32(src) )          # 0 is PREF_LOAD  (not streamed)
+	ADD     src, src, 4*NBYTES
+#ifdef CONFIG_CPU_SB1
+	nop				# improves slotting
+#endif
+	STORE   t0, UNIT(0)(dst)
+	ADDC(sum, t0)
+	STORE   t1, UNIT(1)(dst)
+	ADDC(sum, t1)
+	STORE   t2, UNIT(2)(dst)
+	ADDC(sum, t2)
+	STORE   t3, UNIT(3)(dst)
+	ADDC(sum, t3)
+	PREF(   1, 9*32(dst) )          # 1 is PREF_STORE (not streamed)
+	.set    reorder                         /* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LFcleanup_src_unaligned:
+	beqz    len, .LFdone
+	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	beq     rem, len, .LFcopy_bytes
+	 nop
+1:
+EXC(    LDFIRST t0, FIRST(0)(src),      .LFl_exc)
+EXC(    LDREST  t0, REST(0)(src),       .LFl_exc_copy)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+	STORE   t0, 0(dst)
+	ADDC(sum, t0)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LFcopy_bytes_checklen:
+	beqz    len, .LFdone
+	 nop
+.LFcopy_bytes:
+	/* 0 < len < NBYTES  */
+	move	t2, zero	# partial word
+	li	t3, SHIFT_START	# shift
+/* use .Ll_exc_copy here to return correct sum on fault */
+#define COPY_BYTE(N)                    \
+EXC(    lbue    t0, N(src), .LFl_exc_copy);      \
+	SUB	len, len, 1;		\
+	sb      t0, N(dst);   \
+	SLLV	t0, t0, t3;		\
+	addu	t3, SHIFT_INC;		\
+	beqz    len, .LFcopy_bytes_done; \
+	 or	t2, t0
+
+	COPY_BYTE(0)
+	COPY_BYTE(1)
+#ifdef USE_DOUBLE
+	COPY_BYTE(2)
+	COPY_BYTE(3)
+	COPY_BYTE(4)
+	COPY_BYTE(5)
+#endif
+EXC(    lbue    t0, NBYTES-2(src), .LFl_exc_copy)
+	SUB	len, len, 1
+	sb      t0, NBYTES-2(dst)
+	SLLV	t0, t0, t3
+	or	t2, t0
+.LFcopy_bytes_done:
+	ADDC(sum, t2)
+.LFdone:
+	/* fold checksum */
+#ifdef USE_DOUBLE
+	dsll32	v1, sum, 0
+	daddu	sum, v1
+	sltu	v1, sum, v1
+	dsra32	sum, sum, 0
+	addu	sum, v1
+#endif
+
+#ifdef CPU_MIPSR2
+	wsbh	v1, sum
+	movn	sum, v1, odd
+#else
+	beqz	odd, 1f			/* odd buffer alignment? */
+	 lui	v1, 0x00ff
+	addu	v1, 0x00ff
+	and	t0, sum, v1
+	sll	t0, t0, 8
+	srl	sum, sum, 8
+	and	sum, sum, v1
+	or	sum, sum, t0
+1:
+#endif
+	.set reorder
+	ADDC32(sum, psum)
+	jr	ra
+	.set noreorder
+
+.LFl_exc_copy:
+	/*
+	 * Copy bytes from src until faulting load address (or until a
+	 * lb faults)
+	 *
+	 * When reached by a faulting LDFIRST/LDREST, THREAD_BUADDR($28)
+	 * may be more than a byte beyond the last address.
+	 * Hence, the lb below may get an exception.
+	 *
+	 * Assumes src < THREAD_BUADDR($28)
+	 */
+	LOADK   t0, TI_TASK($28)
+	 li	t2, SHIFT_START
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)
+1:
+EXC(    lbue     t1, 0(src),     .LFl_exc)
+	ADD	src, src, 1
+	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
+	SLLV	t1, t1, t2
+	addu	t2, SHIFT_INC
+	ADDC(sum, t1)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 1
+	bne	src, t0, 1b
+	.set	noreorder
+.LFl_exc:
+	LOADK   t0, TI_TASK($28)
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)               # t0 is just past last good address
+	SUB	len, AT, t0		# len number of uncopied bytes
+	/*
+	 * Here's where we rely on src and dst being incremented in tandem,
+	 *   See (3) above.
+	 * dst += (fault addr - src) to put dst at first byte to clear
+	 */
+	ADD	dst, t0			# compute start address in a1
+	SUB	dst, src
+	/*
+	 * Clear len bytes starting at dst.  Can't call __bzero because it
+	 * might modify len.  An inefficient loop for these rare times...
+	 */
+	.set	reorder				/* DADDI_WAR */
+	SUB	src, len, 1
+	beqz    len, .LFdone
+	.set	noreorder
+1:	sb	zero, 0(dst)
+	ADD	dst, dst, 1
+	.set	push
+	.set	noat
+#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
+	bnez	src, 1b
+	 SUB	src, src, 1
+#else
+	li	v1, 1
+	bnez	src, 1b
+	 SUB	src, src, v1
+#endif
+	li	v1, -EFAULT
+	b       .LFdone
+	 sw	v1, (errptr)
+
+	.set	pop
+	END(__csum_partial_copy_fromuser)
+
+
+
+#undef  LOAD
+#undef  LOADL
+#undef  LOADR
+#undef  STORE
+#undef  STOREL
+#undef  STORER
+#undef  LDFIRST
+#undef  LDREST
+#undef  STFIRST
+#undef  STREST
+#undef  COPY_BYTE
+
+#define LOAD   lw
+#define LOADL  lwl
+#define LOADR  lwr
+#define STOREL swle
+#define STORER swre
+#define STORE  swe
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define LDFIRST LOADR
+#define LDREST  LOADL
+#define STFIRST STORER
+#define STREST  STOREL
+#else
+#define LDFIRST LOADL
+#define LDREST  LOADR
+#define STFIRST STOREL
+#define STREST  STORER
+#endif
+
+LEAF(__csum_partial_copy_touser)
+	PTR_ADDU	AT, src, len	/* See (1) above. */
+#ifdef CONFIG_64BIT
+	move	errptr, a4
+#else
+	lw	errptr, 16(sp)
+#endif
+	move	sum, zero
+	move	odd, zero
+	/*
+	 * Note: dst & src may be unaligned, len may be 0
+	 * Temps
+	 */
+	/*
+	 * The "issue break"s below are very approximate.
+	 * Issue delays for dcache fills will perturb the schedule, as will
+	 * load queue full replay traps, etc.
+	 *
+	 * If len < NBYTES use byte operations.
+	 */
+	PREF(   0, 0(src) )
+	PREFE(  1, 0(dst) )
+	sltu    t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREF(   0, 1*32(src) )
+	PREFE(  1, 1*32(dst) )
+	bnez    t2, .LTcopy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	andi	odd, dst, 0x1			/* odd buffer? */
+	PREF(   0, 2*32(src) )
+	PREFE(  1, 2*32(dst) )
+	bnez    t1, .LTdst_unaligned
+	 nop
+	bnez    t0, .LTsrc_unaligned_dst_aligned
+	/*
+	 * use delay slot for fall-through
+	 * src and dst are aligned; need to compute rem
+	 */
+.LTboth_aligned:
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+	beqz    t0, .LTcleanup_both_aligned # len < 8*NBYTES
+	 nop
+	SUB	len, 8*NBYTES		# subtract here for bgez loop
+	PREF(   0, 3*32(src) )
+	PREFE(  1, 3*32(dst) )
+	.align  4
+1:
+	LOAD    t0, UNIT(0)(src)
+	LOAD    t1, UNIT(1)(src)
+	LOAD    t2, UNIT(2)(src)
+	LOAD    t3, UNIT(3)(src)
+	LOAD    t4, UNIT(4)(src)
+	LOAD    t5, UNIT(5)(src)
+	LOAD    t6, UNIT(6)(src)
+	LOAD    t7, UNIT(7)(src)
+	SUB	len, len, 8*NBYTES
+	ADD	src, src, 8*NBYTES
+EXC(    STORE   t0, UNIT(0)(dst),       .LTs_exc)
+	ADDC(sum, t0)
+EXC(    STORE   t1, UNIT(1)(dst),       .LTs_exc)
+	ADDC(sum, t1)
+EXC(    STORE   t2, UNIT(2)(dst),       .LTs_exc)
+	ADDC(sum, t2)
+EXC(    STORE   t3, UNIT(3)(dst),       .LTs_exc)
+	ADDC(sum, t3)
+EXC(    STORE   t4, UNIT(4)(dst),       .LTs_exc)
+	ADDC(sum, t4)
+EXC(    STORE   t5, UNIT(5)(dst),       .LTs_exc)
+	ADDC(sum, t5)
+EXC(    STORE   t6, UNIT(6)(dst),       .LTs_exc)
+	ADDC(sum, t6)
+EXC(    STORE   t7, UNIT(7)(dst),       .LTs_exc)
+	ADDC(sum, t7)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 8*NBYTES
+	PREF(   0, 8*32(src) )
+	PREFE(  1, 8*32(dst) )
+	bgez    len, 1b
+	.set	noreorder
+	ADD	len, 8*NBYTES		# revert len (see above)
+
+	/*
+	 * len == the number of bytes left to copy < 8*NBYTES
+	 */
+.LTcleanup_both_aligned:
+	beqz    len, .LTdone
+	 sltu	t0, len, 4*NBYTES
+	bnez    t0, .LTless_than_4units
+	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	/*
+	 * len >= 4*NBYTES
+	 */
+	LOAD    t0, UNIT(0)(src)
+	LOAD    t1, UNIT(1)(src)
+	LOAD    t2, UNIT(2)(src)
+	LOAD    t3, UNIT(3)(src)
+	SUB	len, len, 4*NBYTES
+	ADD	src, src, 4*NBYTES
+EXC(    STORE   t0, UNIT(0)(dst),       .LTs_exc)
+	ADDC(sum, t0)
+EXC(    STORE   t1, UNIT(1)(dst),       .LTs_exc)
+	ADDC(sum, t1)
+EXC(    STORE   t2, UNIT(2)(dst),       .LTs_exc)
+	ADDC(sum, t2)
+EXC(    STORE   t3, UNIT(3)(dst),       .LTs_exc)
+	ADDC(sum, t3)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	beqz    len, .LTdone
+	.set	noreorder
+.LTless_than_4units:
+	/*
+	 * rem = len % NBYTES
+	 */
+	beq     rem, len, .LTcopy_bytes
+	 nop
+1:
+	LOAD    t0, 0(src)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .LTs_exc)
+	ADDC(sum, t0)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	rem, len, 1b
+	.set	noreorder
+
+	/*
+	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * A loop would do only a byte at a time with possible branch
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
+	 * because can't assume read-access to dst.  Instead, use
+	 * STREST dst, which doesn't require read access to dst.
+	 *
+	 * This code should perform better than a simple loop on modern,
+	 * wide-issue mips processors because the code has fewer branches and
+	 * more instruction-level parallelism.
+	 */
+	beqz    len, .LTdone
+	 ADD	t1, dst, len	# t1 is just past last byte of dst
+	li	bits, 8*NBYTES
+	SLL	rem, len, 3	# rem = number of bits to keep
+	LOAD    t0, 0(src)
+	SUB	bits, bits, rem	# bits = number of bits to discard
+	SHIFT_DISCARD t0, t0, bits
+EXC(    STREST  t0, -1(t1),             .LTs_exc)
+	SHIFT_DISCARD_REVERT t0, t0, bits
+	.set reorder
+	ADDC(sum, t0)
+	b       .LTdone
+	.set noreorder
+.LTdst_unaligned:
+	/*
+	 * dst is unaligned
+	 * t0 = src & ADDRMASK
+	 * t1 = dst & ADDRMASK; T1 > 0
+	 * len >= NBYTES
+	 *
+	 * Copy enough bytes to align dst
+	 * Set match = (src and dst have same alignment)
+	 */
+	LDFIRST t3, FIRST(0)(src)
+	ADD     t2, zero, NBYTES
+	LDREST  t3, REST(0)(src)
+	SUB	t2, t2, t1	# t2 = number of bytes copied
+	xor	match, t0, t1
+EXC(    STFIRST t3, FIRST(0)(dst),      .LTs_exc)
+	SLL	t4, t1, 3		# t4 = number of bits to discard
+	SHIFT_DISCARD t3, t3, t4
+	/* no SHIFT_DISCARD_REVERT to handle odd buffer properly */
+	ADDC(sum, t3)
+	beq     len, t2, .LTdone
+	 SUB	len, len, t2
+	ADD	dst, dst, t2
+	beqz    match, .LTboth_aligned
+	 ADD	src, src, t2
+
+.LTsrc_unaligned_dst_aligned:
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREF(   0, 3*32(src) )
+	beqz    t0, .LTcleanup_src_unaligned
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREFE(  1, 3*32(dst) )
+1:
+/*
+ * Avoid consecutive LD*'s to the same register since some mips
+ * implementations can't issue them in the same cycle.
+ * It's OK to load FIRST(N+1) before REST(N) because the two addresses
+ * are to the same unit (unless src is aligned, but it's not).
+ */
+	LDFIRST t0, FIRST(0)(src)
+	LDFIRST t1, FIRST(1)(src)
+	SUB     len, len, 4*NBYTES
+	LDREST  t0, REST(0)(src)
+	LDREST  t1, REST(1)(src)
+	LDFIRST t2, FIRST(2)(src)
+	LDFIRST t3, FIRST(3)(src)
+	LDREST  t2, REST(2)(src)
+	LDREST  t3, REST(3)(src)
+	PREF(   0, 9*32(src) )          # 0 is PREF_LOAD  (not streamed)
+	ADD     src, src, 4*NBYTES
+#ifdef CONFIG_CPU_SB1
+	nop				# improves slotting
+#endif
+EXC(    STORE   t0, UNIT(0)(dst),       .LTs_exc)
+	ADDC(sum, t0)
+EXC(    STORE   t1, UNIT(1)(dst),       .LTs_exc)
+	ADDC(sum, t1)
+EXC(    STORE   t2, UNIT(2)(dst),       .LTs_exc)
+	ADDC(sum, t2)
+EXC(    STORE   t3, UNIT(3)(dst),       .LTs_exc)
+	ADDC(sum, t3)
+	PREFE(  1, 9*32(dst) )          # 1 is PREF_STORE (not streamed)
+	.set    reorder                         /* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LTcleanup_src_unaligned:
+	beqz    len, .LTdone
+	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	beq     rem, len, .LTcopy_bytes
+	 nop
+1:
+	LDFIRST t0, FIRST(0)(src)
+	LDREST  t0, REST(0)(src)
+	ADD     src, src, NBYTES
+	SUB     len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .LTs_exc)
+	ADDC(sum, t0)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LTcopy_bytes_checklen:
+	beqz    len, .LTdone
+	 nop
+.LTcopy_bytes:
+	/* 0 < len < NBYTES  */
+	move	t2, zero	# partial word
+	li	t3, SHIFT_START	# shift
+/* use .Ll_exc_copy here to return correct sum on fault */
+#define COPY_BYTE(N)                    \
+	lbu     t0, N(src);     \
+	SUB	len, len, 1;		\
+EXC(    sbe      t0, N(dst), .LTs_exc);   \
+	SLLV	t0, t0, t3;		\
+	addu	t3, SHIFT_INC;		\
+	beqz    len, .LTcopy_bytes_done; \
+	 or	t2, t0
+
+	COPY_BYTE(0)
+	COPY_BYTE(1)
+#ifdef USE_DOUBLE
+	COPY_BYTE(2)
+	COPY_BYTE(3)
+	COPY_BYTE(4)
+	COPY_BYTE(5)
+#endif
+	lbu     t0, NBYTES-2(src)
+	SUB	len, len, 1
+EXC(    sbe     t0, NBYTES-2(dst), .LTs_exc)
+	SLLV	t0, t0, t3
+	or	t2, t0
+.LTcopy_bytes_done:
+	ADDC(sum, t2)
+.LTdone:
+	/* fold checksum */
+#ifdef USE_DOUBLE
+	dsll32	v1, sum, 0
+	daddu	sum, v1
+	sltu	v1, sum, v1
+	dsra32	sum, sum, 0
+	addu	sum, v1
+#endif
+
+#ifdef CPU_MIPSR2
+	wsbh	v1, sum
+	movn	sum, v1, odd
+#else
+	beqz	odd, 1f			/* odd buffer alignment? */
+	 lui	v1, 0x00ff
+	addu	v1, 0x00ff
+	and	t0, sum, v1
+	sll	t0, t0, 8
+	srl	sum, sum, 8
+	and	sum, sum, v1
+	or	sum, sum, t0
+1:
+#endif
+	.set reorder
+	ADDC32(sum, psum)
+	jr	ra
+	.set noreorder
+
+.LTs_exc:
+	li	v0, -1 /* invalid checksum */
+	li	v1, -EFAULT
+	jr	ra
+	 sw	v1, (errptr)
+	END(__csum_partial_copy_touser)
+
+#endif  /* CONFIG_EVA */
diff -ur ./arch/mips/lib/dump_tlb.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/dump_tlb.c
--- ./arch/mips/lib/dump_tlb.c	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/dump_tlb.c	2023-04-23 11:58:26.671705600 +0100
@@ -1,8 +1,13 @@
 /*
- * Dump R4x00 TLB for debugging purposes.
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
  * Copyright (C) 1994, 1995 by Waldorf Electronics, written by Ralf Baechle.
  * Copyright (C) 1999 by Silicon Graphics, Inc.
+ * Copyright (C) 2011 MIPS Technologies, Inc.
+ *
+ * Dump R4x00 TLB for debugging purposes.
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
@@ -59,8 +64,10 @@
 
 	for (i = first; i <= last; i++) {
 		write_c0_index(i);
+		back_to_back_c0_hazard();
 		BARRIER();
 		tlb_read();
+		back_to_back_c0_hazard();
 		BARRIER();
 		pagemask = read_c0_pagemask();
 		entryhi	 = read_c0_entryhi();
@@ -68,8 +75,8 @@
 		entrylo1 = read_c0_entrylo1();
 
 		/* Unused entries have a virtual address of CKSEG0.  */
-		if ((entryhi & ~0x1ffffUL) != CKSEG0
-		    && (entryhi & 0xff) == asid) {
+		if (((entryhi & ~0x1ffffUL) != CKSEG0) &&
+		    !(cpu_has_tlbinv && (entryhi & MIPS_EHINV))) {
 #ifdef CONFIG_32BIT
 			int width = 8;
 #else
@@ -83,7 +90,7 @@
 			c0 = (entrylo0 >> 3) & 7;
 			c1 = (entrylo1 >> 3) & 7;
 
-			printk("va=%0*lx asid=%02lx\n",
+			printk("va=%0*lx asid=%02lx:",
 			       width, (entryhi & ~0x1fffUL),
 			       entryhi & 0xff);
 			printk("\t[pa=%0*llx c=%d d=%d v=%d g=%d] ",
@@ -105,6 +112,8 @@
 	write_c0_entryhi(s_entryhi);
 	write_c0_index(s_index);
 	write_c0_pagemask(s_pagemask);
+	BARRIER();
+	back_to_back_c0_hazard();
 }
 
 void dump_tlb_all(void)
diff -ur ./arch/mips/lib/memcpy.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/memcpy.S
--- ./arch/mips/lib/memcpy.S	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/memcpy.S	2023-04-23 11:58:26.844800600 +0100
@@ -116,6 +116,8 @@
 #define NBYTES 8
 #define LOG_NBYTES 3
 
+#define LOADK  ld
+
 /*
  * As we are sharing code base with the mips32 tree (which use the o32 ABI
  * register definitions). We need to redefine the register definitions from
@@ -152,19 +154,21 @@
 #define NBYTES 4
 #define LOG_NBYTES 2
 
+#define LOADK  lw
+
 #endif /* USE_DOUBLE */
 
 #ifdef CONFIG_CPU_LITTLE_ENDIAN
 #define LDFIRST LOADR
-#define LDREST	LOADL
+#define LDREST  LOADL
 #define STFIRST STORER
-#define STREST	STOREL
+#define STREST  STOREL
 #define SHIFT_DISCARD SLLV
 #else
 #define LDFIRST LOADL
-#define LDREST	LOADR
+#define LDREST  LOADR
 #define STFIRST STOREL
-#define STREST	STORER
+#define STREST  STORER
 #define SHIFT_DISCARD SRLV
 #endif
 
@@ -235,7 +239,7 @@
 	 * src and dst are aligned; need to compute rem
 	 */
 .Lboth_aligned:
-	 SRL	t0, len, LOG_NBYTES+3	 # +3 for 8 units/iter
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
 	beqz	t0, .Lcleanup_both_aligned # len < 8*NBYTES
 	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
 	PREF(	0, 3*32(src) )
@@ -313,7 +317,7 @@
 	/*
 	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
 	 * A loop would do only a byte at a time with possible branch
-	 * mispredicts.	 Can't do an explicit LOAD dst,mask,or,STORE
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
 	 * because can't assume read-access to dst.  Instead, use
 	 * STREST dst, which doesn't require read access to dst.
 	 *
@@ -327,7 +331,7 @@
 	li	bits, 8*NBYTES
 	SLL	rem, len, 3	# rem = number of bits to keep
 EXC(	LOAD	t0, 0(src),		.Ll_exc)
-	SUB	bits, bits, rem # bits = number of bits to discard
+	SUB	bits, bits, rem	# bits = number of bits to discard
 	SHIFT_DISCARD t0, t0, bits
 EXC(	STREST	t0, -1(t1),		.Ls_exc)
 	jr	ra
@@ -343,7 +347,7 @@
 	 * Set match = (src and dst have same alignment)
 	 */
 #define match rem
-EXC(	LDFIRST t3, FIRST(0)(src),	.Ll_exc)
+EXC(	LDFIRST	t3, FIRST(0)(src),	.Ll_exc)
 	ADD	t2, zero, NBYTES
 EXC(	LDREST	t3, REST(0)(src),	.Ll_exc_copy)
 	SUB	t2, t2, t1	# t2 = number of bytes copied
@@ -357,10 +361,10 @@
 	 ADD	src, src, t2
 
 .Lsrc_unaligned_dst_aligned:
-	SRL	t0, len, LOG_NBYTES+2	 # +2 for 4 units/iter
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
 	PREF(	0, 3*32(src) )
 	beqz	t0, .Lcleanup_src_unaligned
-	 and	rem, len, (4*NBYTES-1)	 # rem = len % 4*NBYTES
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
 	PREF(	1, 3*32(dst) )
 1:
 /*
@@ -370,13 +374,13 @@
  * are to the same unit (unless src is aligned, but it's not).
  */
 	R10KCBARRIER(0(ra))
-EXC(	LDFIRST t0, FIRST(0)(src),	.Ll_exc)
-EXC(	LDFIRST t1, FIRST(1)(src),	.Ll_exc_copy)
-	SUB	len, len, 4*NBYTES
+EXC(	LDFIRST	t0, FIRST(0)(src),	.Ll_exc)
+EXC(	LDFIRST	t1, FIRST(1)(src),	.Ll_exc_copy)
+	SUB     len, len, 4*NBYTES
 EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
 EXC(	LDREST	t1, REST(1)(src),	.Ll_exc_copy)
-EXC(	LDFIRST t2, FIRST(2)(src),	.Ll_exc_copy)
-EXC(	LDFIRST t3, FIRST(3)(src),	.Ll_exc_copy)
+EXC(	LDFIRST	t2, FIRST(2)(src),	.Ll_exc_copy)
+EXC(	LDFIRST	t3, FIRST(3)(src),	.Ll_exc_copy)
 EXC(	LDREST	t2, REST(2)(src),	.Ll_exc_copy)
 EXC(	LDREST	t3, REST(3)(src),	.Ll_exc_copy)
 	PREF(	0, 9*32(src) )		# 0 is PREF_LOAD  (not streamed)
@@ -388,7 +392,7 @@
 EXC(	STORE	t1, UNIT(1)(dst),	.Ls_exc_p3u)
 EXC(	STORE	t2, UNIT(2)(dst),	.Ls_exc_p2u)
 EXC(	STORE	t3, UNIT(3)(dst),	.Ls_exc_p1u)
-	PREF(	1, 9*32(dst) )		# 1 is PREF_STORE (not streamed)
+	PREF(	1, 9*32(dst) )     	# 1 is PREF_STORE (not streamed)
 	.set	reorder				/* DADDI_WAR */
 	ADD	dst, dst, 4*NBYTES
 	bne	len, rem, 1b
@@ -451,9 +455,9 @@
 	 *
 	 * Assumes src < THREAD_BUADDR($28)
 	 */
-	LOAD	t0, TI_TASK($28)
+	LOADK   t0, TI_TASK($28)
 	 nop
-	LOAD	t0, THREAD_BUADDR(t0)
+	LOADK   t0, THREAD_BUADDR(t0)
 1:
 EXC(	lb	t1, 0(src),	.Ll_exc)
 	ADD	src, src, 1
@@ -463,12 +467,12 @@
 	bne	src, t0, 1b
 	.set	noreorder
 .Ll_exc:
-	LOAD	t0, TI_TASK($28)
+	LOADK   t0, TI_TASK($28)
 	 nop
-	LOAD	t0, THREAD_BUADDR(t0)	# t0 is just past last good address
+	LOADK   t0, THREAD_BUADDR(t0)   # t0 is just past last good address
 	 nop
-	SUB	len, AT, t0		# len number of uncopied bytes
 	bnez	t6, .Ldone	/* Skip the zeroing part if inatomic */
+	 SUB     len, AT, t0            # len number of uncopied bytes
 	/*
 	 * Here's where we rely on src and dst being incremented in tandem,
 	 *   See (3) above.
@@ -502,7 +506,7 @@
 
 
 #define SEXC(n)							\
-	.set	reorder;			/* DADDI_WAR */ \
+	.set	reorder;			/* DADDI_WAR */	\
 .Ls_exc_p ## n ## u:						\
 	ADD	len, len, n*NBYTES;				\
 	jr	ra;						\
@@ -575,3 +579,940 @@
 	jr	ra
 	 move	a2, zero
 	END(__rmemcpy)
+
+#ifdef CONFIG_EVA
+
+	.set    eva
+
+LEAF(__copy_fromuser_inatomic)
+	b       __copy_fromuser_common
+	 li	t6, 1
+	END(__copy_fromuser_inatomic)
+
+#undef  LOAD
+#undef  LOADL
+#undef  LOADR
+#undef  STORE
+#undef  STOREL
+#undef  STORER
+#undef  LDFIRST
+#undef  LDREST
+#undef  STFIRST
+#undef  STREST
+#undef  SHIFT_DISCARD
+#undef  COPY_BYTE
+#undef  SEXC
+
+#define LOAD   lwe
+#define LOADL  lwle
+#define LOADR  lwre
+#define STOREL swl
+#define STORER swr
+#define STORE  sw
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define LDFIRST LOADR
+#define LDREST  LOADL
+#define STFIRST STORER
+#define STREST  STOREL
+#define SHIFT_DISCARD SLLV
+#else
+#define LDFIRST LOADL
+#define LDREST  LOADR
+#define STFIRST STOREL
+#define STREST  STORER
+#define SHIFT_DISCARD SRLV
+#endif
+
+LEAF(__copy_fromuser)
+	li	t6, 0	/* not inatomic */
+__copy_fromuser_common:
+	/*
+	 * Note: dst & src may be unaligned, len may be 0
+	 * Temps
+	 */
+
+	R10KCBARRIER(0(ra))
+	/*
+	 * The "issue break"s below are very approximate.
+	 * Issue delays for dcache fills will perturb the schedule, as will
+	 * load queue full replay traps, etc.
+	 *
+	 * If len < NBYTES use byte operations.
+	 */
+	PREFE(  0, 0(src) )
+	PREF(	1, 0(dst) )
+	sltu	t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREFE(  0, 1*32(src) )
+	PREF(	1, 1*32(dst) )
+	bnez    t2, .LFcopy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	PREFE(  0, 2*32(src) )
+	PREF(	1, 2*32(dst) )
+	bnez    t1, .LFdst_unaligned
+	 nop
+	bnez    t0, .LFsrc_unaligned_dst_aligned
+	/*
+	 * use delay slot for fall-through
+	 * src and dst are aligned; need to compute rem
+	 */
+.LFboth_aligned:
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+	beqz    t0, .LFcleanup_both_aligned # len < 8*NBYTES
+	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
+	PREFE(  0, 3*32(src) )
+	PREF(	1, 3*32(dst) )
+	.align	4
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LOAD    t0, UNIT(0)(src),       .LFl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LFl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LFl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LFl_exc_copy)
+	SUB	len, len, 8*NBYTES
+EXC(    LOAD    t4, UNIT(4)(src),       .LFl_exc_copy)
+EXC(    LOAD    t7, UNIT(5)(src),       .LFl_exc_copy)
+	STORE   t0, UNIT(0)(dst)
+	STORE   t1, UNIT(1)(dst)
+EXC(    LOAD    t0, UNIT(6)(src),       .LFl_exc_copy)
+EXC(    LOAD    t1, UNIT(7)(src),       .LFl_exc_copy)
+	ADD	src, src, 8*NBYTES
+	ADD	dst, dst, 8*NBYTES
+	STORE   t2, UNIT(-6)(dst)
+	STORE   t3, UNIT(-5)(dst)
+	STORE   t4, UNIT(-4)(dst)
+	STORE   t7, UNIT(-3)(dst)
+	STORE   t0, UNIT(-2)(dst)
+	STORE   t1, UNIT(-1)(dst)
+	PREFE(  0, 8*32(src) )
+	PREF(	1, 8*32(dst) )
+	bne	len, rem, 1b
+	 nop
+
+	/*
+	 * len == rem == the number of bytes left to copy < 8*NBYTES
+	 */
+.LFcleanup_both_aligned:
+	beqz	len, .Ldone
+	 sltu	t0, len, 4*NBYTES
+	bnez    t0, .LFless_than_4units
+	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	/*
+	 * len >= 4*NBYTES
+	 */
+EXC(    LOAD    t0, UNIT(0)(src),       .LFl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LFl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LFl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LFl_exc_copy)
+	SUB	len, len, 4*NBYTES
+	ADD	src, src, 4*NBYTES
+	R10KCBARRIER(0(ra))
+	STORE   t0, UNIT(0)(dst)
+	STORE   t1, UNIT(1)(dst)
+	STORE   t2, UNIT(2)(dst)
+	STORE   t3, UNIT(3)(dst)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	beqz	len, .Ldone
+	.set	noreorder
+.LFless_than_4units:
+	/*
+	 * rem = len % NBYTES
+	 */
+	beq     rem, len, .LFcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LOAD    t0, 0(src),             .LFl_exc)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+	STORE   t0, 0(dst)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	rem, len, 1b
+	.set	noreorder
+
+	/*
+	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * A loop would do only a byte at a time with possible branch
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
+	 * because can't assume read-access to dst.  Instead, use
+	 * STREST dst, which doesn't require read access to dst.
+	 *
+	 * This code should perform better than a simple loop on modern,
+	 * wide-issue mips processors because the code has fewer branches and
+	 * more instruction-level parallelism.
+	 */
+	beqz	len, .Ldone
+	 ADD	t1, dst, len	# t1 is just past last byte of dst
+	li	bits, 8*NBYTES
+	SLL	rem, len, 3	# rem = number of bits to keep
+EXC(    LOAD    t0, 0(src),             .LFl_exc)
+	SUB	bits, bits, rem	# bits = number of bits to discard
+	SHIFT_DISCARD t0, t0, bits
+	STREST  t0, -1(t1)
+	jr	ra
+	 move	len, zero
+.LFdst_unaligned:
+	/*
+	 * dst is unaligned
+	 * t0 = src & ADDRMASK
+	 * t1 = dst & ADDRMASK; T1 > 0
+	 * len >= NBYTES
+	 *
+	 * Copy enough bytes to align dst
+	 * Set match = (src and dst have same alignment)
+	 */
+#define match rem
+EXC(    LDFIRST t3, FIRST(0)(src),      .LFl_exc)
+	ADD	t2, zero, NBYTES
+EXC(    LDREST  t3, REST(0)(src),       .LFl_exc_copy)
+	SUB	t2, t2, t1	# t2 = number of bytes copied
+	xor	match, t0, t1
+	R10KCBARRIER(0(ra))
+	STFIRST t3, FIRST(0)(dst)
+	beq	len, t2, .Ldone
+	 SUB	len, len, t2
+	ADD	dst, dst, t2
+	beqz    match, .LFboth_aligned
+	 ADD	src, src, t2
+
+.LFsrc_unaligned_dst_aligned:
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREFE(  0, 3*32(src) )
+	beqz    t0, .LFcleanup_src_unaligned
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREF(	1, 3*32(dst) )
+1:
+/*
+ * Avoid consecutive LD*'s to the same register since some mips
+ * implementations can't issue them in the same cycle.
+ * It's OK to load FIRST(N+1) before REST(N) because the two addresses
+ * are to the same unit (unless src is aligned, but it's not).
+ */
+	R10KCBARRIER(0(ra))
+EXC(    LDFIRST t0, FIRST(0)(src),      .LFl_exc)
+EXC(    LDFIRST t1, FIRST(1)(src),      .LFl_exc_copy)
+	SUB     len, len, 4*NBYTES
+EXC(    LDREST  t0, REST(0)(src),       .LFl_exc_copy)
+EXC(    LDREST  t1, REST(1)(src),       .LFl_exc_copy)
+EXC(    LDFIRST t2, FIRST(2)(src),      .LFl_exc_copy)
+EXC(    LDFIRST t3, FIRST(3)(src),      .LFl_exc_copy)
+EXC(    LDREST  t2, REST(2)(src),       .LFl_exc_copy)
+EXC(    LDREST  t3, REST(3)(src),       .LFl_exc_copy)
+	PREFE(  0, 9*32(src) )          # 0 is PREF_LOAD  (not streamed)
+	ADD	src, src, 4*NBYTES
+#ifdef CONFIG_CPU_SB1
+	nop				# improves slotting
+#endif
+	STORE   t0, UNIT(0)(dst)
+	STORE   t1, UNIT(1)(dst)
+	STORE   t2, UNIT(2)(dst)
+	STORE   t3, UNIT(3)(dst)
+	PREF(	1, 9*32(dst) )     	# 1 is PREF_STORE (not streamed)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LFcleanup_src_unaligned:
+	beqz	len, .Ldone
+	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	beq     rem, len, .LFcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LDFIRST t0, FIRST(0)(src),      .LFl_exc)
+EXC(    LDREST  t0, REST(0)(src),       .LFl_exc_copy)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+	STORE   t0, 0(dst)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LFcopy_bytes_checklen:
+	beqz	len, .Ldone
+	 nop
+.LFcopy_bytes:
+	/* 0 < len < NBYTES  */
+	R10KCBARRIER(0(ra))
+#define COPY_BYTE(N)			\
+EXC(    lbe      t0, N(src), .LFl_exc);   \
+	SUB	len, len, 1;		\
+	beqz	len, .Ldone;		\
+	 sb     t0, N(dst)
+
+	COPY_BYTE(0)
+	COPY_BYTE(1)
+#ifdef USE_DOUBLE
+	COPY_BYTE(2)
+	COPY_BYTE(3)
+	COPY_BYTE(4)
+	COPY_BYTE(5)
+#endif
+EXC(    lbe     t0, NBYTES-2(src), .LFl_exc)
+	SUB	len, len, 1
+	jr	ra
+	 sb     t0, NBYTES-2(dst)
+
+.LFl_exc_copy:
+	/*
+	 * Copy bytes from src until faulting load address (or until a
+	 * lb faults)
+	 *
+	 * When reached by a faulting LDFIRST/LDREST, THREAD_BUADDR($28)
+	 * may be more than a byte beyond the last address.
+	 * Hence, the lb below may get an exception.
+	 *
+	 * Assumes src < THREAD_BUADDR($28)
+	 */
+	LOADK   t0, TI_TASK($28)
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)
+1:
+EXC(    lbe     t1, 0(src),     .LFl_exc)
+	ADD	src, src, 1
+	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 1
+	bne	src, t0, 1b
+	.set	noreorder
+.LFl_exc:
+	LOADK   t0, TI_TASK($28)
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)   # t0 is just past last good address
+	bnez	t6, .Ldone	/* Skip the zeroing part if inatomic */
+	 SUB    len, AT, t0             # len number of uncopied bytes
+	/*
+	 * Here's where we rely on src and dst being incremented in tandem,
+	 *   See (3) above.
+	 * dst += (fault addr - src) to put dst at first byte to clear
+	 */
+	ADD	dst, t0			# compute start address in a1
+	SUB	dst, src
+	/*
+	 * Clear len bytes starting at dst.  Can't call __bzero because it
+	 * might modify len.  An inefficient loop for these rare times...
+	 */
+	.set	reorder				/* DADDI_WAR */
+	SUB	src, len, 1
+	beqz	len, .Ldone
+	.set	noreorder
+1:	sb	zero, 0(dst)
+	ADD	dst, dst, 1
+#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
+	bnez	src, 1b
+	 SUB	src, src, 1
+#else
+	.set	push
+	.set	noat
+	li	v1, 1
+	bnez	src, 1b
+	 SUB	src, src, v1
+	.set	pop
+#endif
+	jr	ra
+	 nop
+	END(__copy_fromuser)
+
+
+#undef  LOAD
+#undef  LOADL
+#undef  LOADR
+#undef  STORE
+#undef  STOREL
+#undef  STORER
+#undef  LDFIRST
+#undef  LDREST
+#undef  STFIRST
+#undef  STREST
+#undef  SHIFT_DISCARD
+#undef  COPY_BYTE
+#undef  SEXC
+
+#define LOAD   lw
+#define LOADL  lwl
+#define LOADR  lwr
+#define STOREL swle
+#define STORER swre
+#define STORE  swe
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define LDFIRST LOADR
+#define LDREST  LOADL
+#define STFIRST STORER
+#define STREST  STOREL
+#define SHIFT_DISCARD SLLV
+#else
+#define LDFIRST LOADL
+#define LDREST  LOADR
+#define STFIRST STOREL
+#define STREST  STORER
+#define SHIFT_DISCARD SRLV
+#endif
+
+LEAF(__copy_touser)
+	/*
+	 * Note: dst & src may be unaligned, len may be 0
+	 * Temps
+	 */
+
+	R10KCBARRIER(0(ra))
+	/*
+	 * The "issue break"s below are very approximate.
+	 * Issue delays for dcache fills will perturb the schedule, as will
+	 * load queue full replay traps, etc.
+	 *
+	 * If len < NBYTES use byte operations.
+	 */
+	PREF(	0, 0(src) )
+	PREFE(  1, 0(dst) )
+	sltu	t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREF(	0, 1*32(src) )
+	PREFE(  1, 1*32(dst) )
+	bnez    t2, .LTcopy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	PREF(	0, 2*32(src) )
+	PREFE(  1, 2*32(dst) )
+	bnez    t1, .LTdst_unaligned
+	 nop
+	bnez    t0, .LTsrc_unaligned_dst_aligned
+	/*
+	 * use delay slot for fall-through
+	 * src and dst are aligned; need to compute rem
+	 */
+.LTboth_aligned:
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+	beqz    t0, .LTcleanup_both_aligned # len < 8*NBYTES
+	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
+	PREF(	0, 3*32(src) )
+	PREFE(  1, 3*32(dst) )
+	.align	4
+1:
+	R10KCBARRIER(0(ra))
+	LOAD    t0, UNIT(0)(src)
+	LOAD    t1, UNIT(1)(src)
+	LOAD    t2, UNIT(2)(src)
+	LOAD    t3, UNIT(3)(src)
+	SUB     len, len, 8*NBYTES
+	LOAD    t4, UNIT(4)(src)
+	LOAD    t7, UNIT(5)(src)
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p8u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p7u)
+	LOAD    t0, UNIT(6)(src)
+	LOAD    t1, UNIT(7)(src)
+	ADD     src, src, 8*NBYTES
+	ADD     dst, dst, 8*NBYTES
+EXC(    STORE   t2, UNIT(-6)(dst),      .Ls_exc_p6u)
+EXC(    STORE   t3, UNIT(-5)(dst),      .Ls_exc_p5u)
+EXC(    STORE   t4, UNIT(-4)(dst),      .Ls_exc_p4u)
+EXC(    STORE   t7, UNIT(-3)(dst),      .Ls_exc_p3u)
+EXC(    STORE   t0, UNIT(-2)(dst),      .Ls_exc_p2u)
+EXC(    STORE   t1, UNIT(-1)(dst),      .Ls_exc_p1u)
+	PREF(	0, 8*32(src) )
+	PREFE(  1, 8*32(dst) )
+	bne	len, rem, 1b
+	 nop
+
+	/*
+	 * len == rem == the number of bytes left to copy < 8*NBYTES
+	 */
+.LTcleanup_both_aligned:
+	beqz	len, .Ldone
+	 sltu	t0, len, 4*NBYTES
+	bnez    t0, .LTless_than_4units
+	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	/*
+	 * len >= 4*NBYTES
+	 */
+	LOAD    t0, UNIT(0)(src)
+	LOAD    t1, UNIT(1)(src)
+	LOAD    t2, UNIT(2)(src)
+	LOAD    t3, UNIT(3)(src)
+	SUB	len, len, 4*NBYTES
+	ADD	src, src, 4*NBYTES
+	R10KCBARRIER(0(ra))
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p4u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p3u)
+EXC(    STORE   t2, UNIT(2)(dst),       .Ls_exc_p2u)
+EXC(    STORE   t3, UNIT(3)(dst),       .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	beqz	len, .Ldone
+	.set	noreorder
+.LTless_than_4units:
+	/*
+	 * rem = len % NBYTES
+	 */
+	beq     rem, len, .LTcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+	LOAD    t0, 0(src)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	rem, len, 1b
+	.set	noreorder
+
+	/*
+	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * A loop would do only a byte at a time with possible branch
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
+	 * because can't assume read-access to dst.  Instead, use
+	 * STREST dst, which doesn't require read access to dst.
+	 *
+	 * This code should perform better than a simple loop on modern,
+	 * wide-issue mips processors because the code has fewer branches and
+	 * more instruction-level parallelism.
+	 */
+	beqz	len, .Ldone
+	 ADD	t1, dst, len	# t1 is just past last byte of dst
+	li	bits, 8*NBYTES
+	SLL	rem, len, 3	# rem = number of bits to keep
+	LOAD    t0, 0(src)
+	SUB	bits, bits, rem	# bits = number of bits to discard
+	SHIFT_DISCARD t0, t0, bits
+EXC(    STREST  t0, -1(t1),             .Ls_exc)
+	jr	ra
+	 move	len, zero
+.LTdst_unaligned:
+	/*
+	 * dst is unaligned
+	 * t0 = src & ADDRMASK
+	 * t1 = dst & ADDRMASK; T1 > 0
+	 * len >= NBYTES
+	 *
+	 * Copy enough bytes to align dst
+	 * Set match = (src and dst have same alignment)
+	 */
+	LDFIRST t3, FIRST(0)(src)
+	ADD     t2, zero, NBYTES
+	LDREST  t3, REST(0)(src)
+	SUB	t2, t2, t1	# t2 = number of bytes copied
+	xor	match, t0, t1
+	R10KCBARRIER(0(ra))
+EXC(    STFIRST t3, FIRST(0)(dst),      .Ls_exc)
+	beq	len, t2, .Ldone
+	 SUB	len, len, t2
+	ADD	dst, dst, t2
+	beqz    match, .LTboth_aligned
+	 ADD	src, src, t2
+
+.LTsrc_unaligned_dst_aligned:
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREF(	0, 3*32(src) )
+	beqz    t0, .LTcleanup_src_unaligned
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREFE(  1, 3*32(dst) )
+1:
+/*
+ * Avoid consecutive LD*'s to the same register since some mips
+ * implementations can't issue them in the same cycle.
+ * It's OK to load FIRST(N+1) before REST(N) because the two addresses
+ * are to the same unit (unless src is aligned, but it's not).
+ */
+	R10KCBARRIER(0(ra))
+	LDFIRST t0, FIRST(0)(src)
+	LDFIRST t1, FIRST(1)(src)
+	SUB     len, len, 4*NBYTES
+	LDREST  t0, REST(0)(src)
+	LDREST  t1, REST(1)(src)
+	LDFIRST t2, FIRST(2)(src)
+	LDFIRST t3, FIRST(3)(src)
+	LDREST  t2, REST(2)(src)
+	LDREST  t3, REST(3)(src)
+	PREF(	0, 9*32(src) )		# 0 is PREF_LOAD  (not streamed)
+	ADD	src, src, 4*NBYTES
+#ifdef CONFIG_CPU_SB1
+	nop				# improves slotting
+#endif
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p4u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p3u)
+EXC(    STORE   t2, UNIT(2)(dst),       .Ls_exc_p2u)
+EXC(    STORE   t3, UNIT(3)(dst),       .Ls_exc_p1u)
+	PREFE(  1, 9*32(dst) )          # 1 is PREF_STORE (not streamed)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LTcleanup_src_unaligned:
+	beqz	len, .Ldone
+	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	beq     rem, len, .LTcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+	LDFIRST t0, FIRST(0)(src)
+	LDREST  t0, REST(0)(src)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LTcopy_bytes_checklen:
+	beqz	len, .Ldone
+	 nop
+.LTcopy_bytes:
+	/* 0 < len < NBYTES  */
+	R10KCBARRIER(0(ra))
+#define COPY_BYTE(N)			\
+	lb      t0, N(src);             \
+	SUB	len, len, 1;		\
+	beqz	len, .Ldone;		\
+EXC(     sbe    t0, N(dst), .Ls_exc_p1)
+
+	COPY_BYTE(0)
+	COPY_BYTE(1)
+#ifdef USE_DOUBLE
+	COPY_BYTE(2)
+	COPY_BYTE(3)
+	COPY_BYTE(4)
+	COPY_BYTE(5)
+#endif
+	lb      t0, NBYTES-2(src)
+	SUB	len, len, 1
+	jr	ra
+EXC(     sbe    t0, NBYTES-2(dst), .Ls_exc_p1)
+	END(__copy_touser)
+
+
+#undef  LOAD
+#undef  LOADL
+#undef  LOADR
+#undef  STORE
+#undef  STOREL
+#undef  STORER
+#undef  LDFIRST
+#undef  LDREST
+#undef  STFIRST
+#undef  STREST
+#undef  SHIFT_DISCARD
+#undef  COPY_BYTE
+#undef  SEXC
+
+#define LOAD   lwe
+#define LOADL  lwle
+#define LOADR  lwre
+#define STOREL swle
+#define STORER swre
+#define STORE  swe
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define LDFIRST LOADR
+#define LDREST  LOADL
+#define STFIRST STORER
+#define STREST  STOREL
+#define SHIFT_DISCARD SLLV
+#else
+#define LDFIRST LOADL
+#define LDREST  LOADR
+#define STFIRST STOREL
+#define STREST  STORER
+#define SHIFT_DISCARD SRLV
+#endif
+
+
+LEAF(__copy_inuser)
+	/*
+	 * Note: dst & src may be unaligned, len may be 0
+	 * Temps
+	 */
+
+	R10KCBARRIER(0(ra))
+	/*
+	 * The "issue break"s below are very approximate.
+	 * Issue delays for dcache fills will perturb the schedule, as will
+	 * load queue full replay traps, etc.
+	 *
+	 * If len < NBYTES use byte operations.
+	 */
+	PREFE(  0, 0(src) )
+	PREFE(  1, 0(dst) )
+	sltu	t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREFE(  0, 1*32(src) )
+	PREFE(  1, 1*32(dst) )
+	bnez    t2, .LIcopy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	PREFE(  0, 2*32(src) )
+	PREFE(  1, 2*32(dst) )
+	bnez    t1, .LIdst_unaligned
+	 nop
+	bnez    t0, .LIsrc_unaligned_dst_aligned
+	/*
+	 * use delay slot for fall-through
+	 * src and dst are aligned; need to compute rem
+	 */
+.LIboth_aligned:
+	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+	beqz    t0, .LIcleanup_both_aligned # len < 8*NBYTES
+	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
+	PREFE(  0, 3*32(src) )
+	PREFE(  1, 3*32(dst) )
+	.align	4
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LOAD    t0, UNIT(0)(src),       .LIl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LIl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LIl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LIl_exc_copy)
+	SUB	len, len, 8*NBYTES
+EXC(    LOAD    t4, UNIT(4)(src),       .LIl_exc_copy)
+EXC(    LOAD    t7, UNIT(5)(src),       .LIl_exc_copy)
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p8u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p7u)
+EXC(    LOAD    t0, UNIT(6)(src),       .LIl_exc_copy)
+EXC(    LOAD    t1, UNIT(7)(src),       .LIl_exc_copy)
+	ADD	src, src, 8*NBYTES
+	ADD	dst, dst, 8*NBYTES
+EXC(    STORE   t2, UNIT(-6)(dst),      .Ls_exc_p6u)
+EXC(    STORE   t3, UNIT(-5)(dst),      .Ls_exc_p5u)
+EXC(    STORE   t4, UNIT(-4)(dst),      .Ls_exc_p4u)
+EXC(    STORE   t7, UNIT(-3)(dst),      .Ls_exc_p3u)
+EXC(    STORE   t0, UNIT(-2)(dst),      .Ls_exc_p2u)
+EXC(    STORE   t1, UNIT(-1)(dst),      .Ls_exc_p1u)
+	PREFE(  0, 8*32(src) )
+	PREFE(  1, 8*32(dst) )
+	bne	len, rem, 1b
+	 nop
+
+	/*
+	 * len == rem == the number of bytes left to copy < 8*NBYTES
+	 */
+.LIcleanup_both_aligned:
+	beqz	len, .Ldone
+	 sltu	t0, len, 4*NBYTES
+	bnez    t0, .LIless_than_4units
+	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	/*
+	 * len >= 4*NBYTES
+	 */
+EXC(    LOAD    t0, UNIT(0)(src),       .LIl_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .LIl_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .LIl_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .LIl_exc_copy)
+	SUB	len, len, 4*NBYTES
+	ADD	src, src, 4*NBYTES
+	R10KCBARRIER(0(ra))
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p4u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p3u)
+EXC(    STORE   t2, UNIT(2)(dst),       .Ls_exc_p2u)
+EXC(    STORE   t3, UNIT(3)(dst),       .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	beqz	len, .Ldone
+	.set	noreorder
+.LIless_than_4units:
+	/*
+	 * rem = len % NBYTES
+	 */
+	beq     rem, len, .LIcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LOAD    t0, 0(src),             .LIl_exc)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	rem, len, 1b
+	.set	noreorder
+
+	/*
+	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * A loop would do only a byte at a time with possible branch
+	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
+	 * because can't assume read-access to dst.  Instead, use
+	 * STREST dst, which doesn't require read access to dst.
+	 *
+	 * This code should perform better than a simple loop on modern,
+	 * wide-issue mips processors because the code has fewer branches and
+	 * more instruction-level parallelism.
+	 */
+	beqz	len, .Ldone
+	 ADD	t1, dst, len	# t1 is just past last byte of dst
+	li	bits, 8*NBYTES
+	SLL	rem, len, 3	# rem = number of bits to keep
+EXC(    LOAD    t0, 0(src),             .LIl_exc)
+	SUB	bits, bits, rem	# bits = number of bits to discard
+	SHIFT_DISCARD t0, t0, bits
+EXC(    STREST  t0, -1(t1),             .Ls_exc)
+	jr	ra
+	 move	len, zero
+.LIdst_unaligned:
+	/*
+	 * dst is unaligned
+	 * t0 = src & ADDRMASK
+	 * t1 = dst & ADDRMASK; T1 > 0
+	 * len >= NBYTES
+	 *
+	 * Copy enough bytes to align dst
+	 * Set match = (src and dst have same alignment)
+	 */
+EXC(    LDFIRST t3, FIRST(0)(src),      .LIl_exc)
+	ADD	t2, zero, NBYTES
+EXC(    LDREST  t3, REST(0)(src),       .LIl_exc_copy)
+	SUB	t2, t2, t1	# t2 = number of bytes copied
+	xor	match, t0, t1
+	R10KCBARRIER(0(ra))
+EXC(    STFIRST t3, FIRST(0)(dst),      .Ls_exc)
+	beq	len, t2, .Ldone
+	 SUB	len, len, t2
+	ADD	dst, dst, t2
+	beqz    match, .LIboth_aligned
+	 ADD	src, src, t2
+
+.LIsrc_unaligned_dst_aligned:
+	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
+	PREFE(  0, 3*32(src) )
+	beqz    t0, .LIcleanup_src_unaligned
+	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
+	PREFE(  1, 3*32(dst) )
+1:
+/*
+ * Avoid consecutive LD*'s to the same register since some mips
+ * implementations can't issue them in the same cycle.
+ * It's OK to load FIRST(N+1) before REST(N) because the two addresses
+ * are to the same unit (unless src is aligned, but it's not).
+ */
+	R10KCBARRIER(0(ra))
+EXC(    LDFIRST t0, FIRST(0)(src),      .LIl_exc)
+EXC(    LDFIRST t1, FIRST(1)(src),      .LIl_exc_copy)
+	SUB     len, len, 4*NBYTES
+EXC(    LDREST  t0, REST(0)(src),       .LIl_exc_copy)
+EXC(    LDREST  t1, REST(1)(src),       .LIl_exc_copy)
+EXC(    LDFIRST t2, FIRST(2)(src),      .LIl_exc_copy)
+EXC(    LDFIRST t3, FIRST(3)(src),      .LIl_exc_copy)
+EXC(    LDREST  t2, REST(2)(src),       .LIl_exc_copy)
+EXC(    LDREST  t3, REST(3)(src),       .LIl_exc_copy)
+	PREFE(  0, 9*32(src) )          # 0 is PREF_LOAD  (not streamed)
+	ADD	src, src, 4*NBYTES
+#ifdef CONFIG_CPU_SB1
+	nop				# improves slotting
+#endif
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p4u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p3u)
+EXC(    STORE   t2, UNIT(2)(dst),       .Ls_exc_p2u)
+EXC(    STORE   t3, UNIT(3)(dst),       .Ls_exc_p1u)
+	PREFE(  1, 9*32(dst) )          # 1 is PREF_STORE (not streamed)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 4*NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LIcleanup_src_unaligned:
+	beqz	len, .Ldone
+	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	beq     rem, len, .LIcopy_bytes
+	 nop
+1:
+	R10KCBARRIER(0(ra))
+EXC(    LDFIRST t0, FIRST(0)(src),      .LIl_exc)
+EXC(    LDREST  t0, REST(0)(src),       .LIl_exc_copy)
+	ADD	src, src, NBYTES
+	SUB	len, len, NBYTES
+EXC(    STORE   t0, 0(dst),             .Ls_exc_p1u)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, NBYTES
+	bne	len, rem, 1b
+	.set	noreorder
+
+.LIcopy_bytes_checklen:
+	beqz	len, .Ldone
+	 nop
+.LIcopy_bytes:
+	/* 0 < len < NBYTES  */
+	R10KCBARRIER(0(ra))
+#define COPY_BYTE(N)                    \
+EXC(    lbe     t0, N(src), .LIl_exc);  \
+	SUB	len, len, 1;		\
+	beqz	len, .Ldone;		\
+EXC(     sbe    t0, N(dst), .Ls_exc_p1)
+
+	COPY_BYTE(0)
+	COPY_BYTE(1)
+#ifdef USE_DOUBLE
+	COPY_BYTE(2)
+	COPY_BYTE(3)
+	COPY_BYTE(4)
+	COPY_BYTE(5)
+#endif
+EXC(    lbe     t0, NBYTES-2(src), .LIl_exc)
+	SUB	len, len, 1
+	jr	ra
+EXC(     sbe    t0, NBYTES-2(dst), .Ls_exc_p1)
+
+.LIl_exc_copy:
+	/*
+	 * Copy bytes from src until faulting load address (or until a
+	 * lb faults)
+	 *
+	 * When reached by a faulting LDFIRST/LDREST, THREAD_BUADDR($28)
+	 * may be more than a byte beyond the last address.
+	 * Hence, the lb below may get an exception.
+	 *
+	 * Assumes src < THREAD_BUADDR($28)
+	 */
+	LOADK   t0, TI_TASK($28)
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)
+1:
+EXC(    lbe     t1, 0(src),     .LIl_exc)
+	ADD	src, src, 1
+EXC(    sbe     t1, 0(dst),     .Ls_exc)
+	.set	reorder				/* DADDI_WAR */
+	ADD	dst, dst, 1
+	SUB     len, len, 1             # need this because of sbe above
+	bne	src, t0, 1b
+	.set	noreorder
+.LIl_exc:
+	LOADK   t0, TI_TASK($28)
+	addi    t0, t0, THREAD_BUADDR
+	LOADK   t0, 0(t0)               # t0 is just past last good address
+	SUB	len, AT, t0		# len number of uncopied bytes
+	/*
+	 * Here's where we rely on src and dst being incremented in tandem,
+	 *   See (3) above.
+	 * dst += (fault addr - src) to put dst at first byte to clear
+	 */
+	ADD	dst, t0			# compute start address in a1
+	SUB	dst, src
+	/*
+	 * Clear len bytes starting at dst.  Can't call __bzero because it
+	 * might modify len.  An inefficient loop for these rare times...
+	 */
+	.set	reorder				/* DADDI_WAR */
+	SUB	src, len, 1
+	beqz	len, .Ldone
+	.set	noreorder
+1:
+EXC(    sbe     zero, 0(dst),   .Ls_exc)
+	ADD	dst, dst, 1
+#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
+	bnez	src, 1b
+	 SUB	src, src, 1
+#else
+	.set	push
+	.set	noat
+	li	v1, 1
+	bnez	src, 1b
+	 SUB	src, src, v1
+	.set	pop
+#endif
+	jr	ra
+	 nop
+	END(__copy_inuser)
+
+#endif
diff -ur ./arch/mips/lib/memset.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/memset.S
--- ./arch/mips/lib/memset.S	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/memset.S	2023-04-23 11:58:26.844313900 +0100
@@ -40,6 +40,12 @@
 	PTR	9b, handler;				\
 	.previous
 
+#define EXE(insn,handler)                               \
+9:      .word   insn;                                   \
+	.section __ex_table,"a"; 			\
+	PTR	9b, handler; 				\
+	.previous
+
 	.macro	f_fill64 dst, offset, val, fixup
 	EX(LONG_S, \val, (\offset +  0 * STORSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset +  1 * STORSIZE)(\dst), \fixup)
@@ -63,6 +69,26 @@
 #endif
 	.endm
 
+	.macro  f_fill64eva dst, offset, val, fixup
+	.set        eva
+	EX(swe, \val, (\offset +  0 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  1 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  2 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  3 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  4 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  5 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  6 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  7 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  8 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset +  9 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 10 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 11 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 12 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 13 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 14 * STORSIZE)(\dst), \fixup)
+	EX(swe, \val, (\offset + 15 * STORSIZE)(\dst), \fixup)
+	.endm
+
 /*
  * memset(void *s, int c, size_t n)
  *
@@ -202,3 +228,142 @@
 .Llast_fixup:
 	jr		ra
 	 andi		v1, a2, STORMASK
+
+#ifdef CONFIG_EVA
+/*  ++++++++  */
+/*  EVA stuff */
+/*  ++++++++  */
+
+	.set            eva
+
+#undef  LONG_S_L
+#undef  LONG_S_R
+
+#define LONG_S_L swle
+#define LONG_S_R swre
+
+LEAF(__bzero_user)
+	sltiu		t0, a2, STORSIZE	/* very small region? */
+	bnez            t0, .LEsmall_memset
+	 andi		t0, a0, STORMASK	/* aligned? */
+
+#ifdef CONFIG_CPU_MICROMIPS
+	move		t8, a1
+	move		t9, a1
+#endif
+#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
+	beqz		t0, 1f
+	 PTR_SUBU	t0, STORSIZE		/* alignment in bytes */
+#else
+	.set		noat
+	li		AT, STORSIZE
+	beqz		t0, 1f
+	 PTR_SUBU	t0, AT			/* alignment in bytes */
+	.set		at
+#endif
+
+	R10KCBARRIER(0(ra))
+#ifdef __MIPSEB__
+	EX(LONG_S_L, a1, (a0), .LEfirst_fixup)  /* make word/dword aligned */
+#endif
+#ifdef __MIPSEL__
+	EX(LONG_S_R, a1, (a0), .LEfirst_fixup)  /* make word/dword aligned */
+#endif
+	PTR_SUBU	a0, t0			/* long align ptr */
+	PTR_ADDU	a2, t0			/* correct size */
+
+1:	ori		t1, a2, 0x3f		/* # of full blocks */
+	xori		t1, 0x3f
+	beqz            t1, .LEmemset_partial    /* no block to fill */
+	 andi		t0, a2, 0x40-STORSIZE
+
+	PTR_ADDU	t1, a0			/* end address */
+	.set		reorder
+1:	PTR_ADDIU	a0, 64
+	R10KCBARRIER(0(ra))
+	f_fill64eva a0, -64, a1, .LEfwd_fixup
+	bne		t1, a0, 1b
+	.set		noreorder
+
+.LEmemset_partial:
+	R10KCBARRIER(0(ra))
+	PTR_LA		t1, 2f			/* where to start */
+#ifdef CONFIG_CPU_MICROMIPS
+	LONG_SRL	t7, t0, 1
+#if LONGSIZE == 4
+	PTR_SUBU	t1, t7
+#else
+	.set		noat
+	LONG_SRL	AT, t7, 1
+	PTR_SUBU	t1, AT
+	.set		at
+#endif
+#else
+#if LONGSIZE == 4
+	PTR_SUBU	t1, t0
+#else
+	.set		noat
+	LONG_SRL	AT, t0, 1
+	PTR_SUBU	t1, AT
+	.set		at
+#endif
+#endif
+	jr		t1
+	 PTR_ADDU	a0, t0			/* dest ptr */
+
+	.set		push
+	.set		noreorder
+	.set		nomacro
+	f_fill64eva a0, -64, a1, .LEpartial_fixup   /* ... but first do longs ... */
+2:	.set		pop
+	andi		a2, STORMASK		/* At most one long to go */
+
+	beqz		a2, 1f
+	 PTR_ADDU	a0, a2			/* What's left */
+	R10KCBARRIER(0(ra))
+#ifdef __MIPSEB__
+	EX(LONG_S_R, a1, -1(a0), .LElast_fixup)
+#endif
+#ifdef __MIPSEL__
+	EX(LONG_S_L, a1, -1(a0), .LElast_fixup)
+#endif
+1:	jr		ra
+	 move		a2, zero
+
+.LEsmall_memset:
+	beqz		a2, 2f
+	 PTR_ADDU	t1, a0, a2
+
+1:	PTR_ADDIU	a0, 1			/* fill bytewise */
+	R10KCBARRIER(0(ra))
+	bne		t1, a0, 1b
+	 sb		a1, -1(a0)
+
+2:	jr		ra			/* done */
+	 move		a2, zero
+
+.LEfirst_fixup:
+	jr	ra
+	 nop
+
+.LEfwd_fixup:
+	PTR_L		t0, TI_TASK($28)
+	andi		a2, 0x3f
+	LONG_L		t0, THREAD_BUADDR(t0)
+	LONG_ADDU	a2, t1
+	jr		ra
+	 LONG_SUBU	a2, t0
+
+.LEpartial_fixup:
+	PTR_L		t0, TI_TASK($28)
+	andi		a2, STORMASK
+	LONG_L		t0, THREAD_BUADDR(t0)
+	LONG_ADDU	a2, t1
+	jr		ra
+	 LONG_SUBU	a2, t0
+
+.LElast_fixup:
+	jr		ra
+	 andi		v1, a2, STORMASK
+	END(__bzero_user)
+#endif
diff -ur ./arch/mips/lib/r3k_dump_tlb.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/r3k_dump_tlb.c
--- ./arch/mips/lib/r3k_dump_tlb.c	2023-04-26 12:25:54.940119553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/r3k_dump_tlb.c	2023-04-23 11:58:26.843267500 +0100
@@ -1,9 +1,14 @@
 /*
- * Dump R3000 TLB for debugging purposes.
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
  * Copyright (C) 1994, 1995 by Waldorf Electronics, written by Ralf Baechle.
  * Copyright (C) 1999 by Silicon Graphics, Inc.
  * Copyright (C) 1999 by Harald Koerfgen
+ * Copyright (C) 2011 MIPS Technologies, Inc.
+ *
+ * Dump R3000 TLB for debugging purposes.
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
diff -ur ./arch/mips/lib/strlen_user.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strlen_user.S
--- ./arch/mips/lib/strlen_user.S	2023-04-26 12:25:54.950119559 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strlen_user.S	2023-04-23 11:58:26.842626500 +0100
@@ -11,7 +11,7 @@
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
 
-#define EX(insn,reg,addr,handler)			\
+#define EX(insn,reg,addr,handler)                       \
 9:	insn	reg, addr;				\
 	.section __ex_table,"a";			\
 	PTR	9b, handler;				\
@@ -22,19 +22,38 @@
  *
  * Return 0 for error
  */
+LEAF(__strlen_kernel_asm)
+	LONG_L          v0, TI_ADDR_LIMIT($28)  # pointer ok?
+	and             v0, a0
+	bnez            v0, .Lfault
+
+FEXPORT(__strlen_kernel_nocheck_asm)
+	move            v0, a0
+1:      EX(lbu, v1, (v0), .Lfault)
+	PTR_ADDIU       v0, 1
+	bnez            v1, 1b
+	PTR_SUBU        v0, a0
+	jr              ra
+	END(__strlen_kernel_asm)
+
+.Lfault:        move            v0, zero
+	jr              ra
+
+#ifdef CONFIG_EVA
+
 LEAF(__strlen_user_asm)
-	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
-	and		v0, a0
-	bnez		v0, .Lfault
+	LONG_L          v0, TI_ADDR_LIMIT($28)  # pointer ok?
+	and             v0, a0
+	bnez            v0, .Lfault
 
 FEXPORT(__strlen_user_nocheck_asm)
-	move		v0, a0
-1:	EX(lbu, v1, (v0), .Lfault)
-	PTR_ADDIU	v0, 1
-	bnez		v1, 1b
-	PTR_SUBU	v0, a0
-	jr		ra
+	move            v0, a0
+	.set            eva
+1:      EX(lbue, v1, (v0), .Lfault)
+	PTR_ADDIU       v0, 1
+	bnez            v1, 1b
+	PTR_SUBU        v0, a0
+	jr              ra
 	END(__strlen_user_asm)
 
-.Lfault:	move		v0, zero
-	jr		ra
+#endif
diff -ur ./arch/mips/lib/strncpy_user.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strncpy_user.S
--- ./arch/mips/lib/strncpy_user.S	2023-04-26 12:25:54.950119559 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strncpy_user.S	2023-04-23 11:58:26.841938400 +0100
@@ -28,6 +28,37 @@
  * it happens at most some bytes of the exceptions handlers will be copied.
  */
 
+LEAF(__strncpy_from_kernel_asm)
+	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
+	and		v0, a1
+	bnez		v0, .Lfault
+
+FEXPORT(__strncpy_from_kernel_nocheck_asm)
+	.set		noreorder
+	move		t0, zero
+	move		v1, a1
+1:      EX(lbu, v0, (v1), .Lfault)
+	PTR_ADDIU       v1, 1
+	R10KCBARRIER(0(ra))
+	beqz		v0, 2f
+	 sb		v0, (a0)
+	PTR_ADDIU	t0, 1
+	bne		t0, a2, 1b
+	 PTR_ADDIU	a0, 1
+2:	PTR_ADDU	v0, a1, t0
+	xor		v0, a1
+	bltz		v0, .Lfault
+	 nop
+	jr		ra			# return n
+	 move           v0, t0
+	END(__strncpy_from_kernel_asm)
+
+.Lfault:
+	jr              ra
+	 li             v0, -EFAULT
+
+#ifdef CONFIG_EVA
+
 LEAF(__strncpy_from_user_asm)
 	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
 	and		v0, a1
@@ -37,8 +68,10 @@
 	.set		noreorder
 	move		t0, zero
 	move		v1, a1
-1:	EX(lbu, v0, (v1), .Lfault)
-	PTR_ADDIU	v1, 1
+1:
+	.set            eva
+	EX(lbue, v0, (v1), .Lfault)
+	PTR_ADDIU       v1, 1
 	R10KCBARRIER(0(ra))
 	beqz		v0, 2f
 	 sb		v0, (a0)
@@ -50,12 +83,7 @@
 	bltz		v0, .Lfault
 	 nop
 	jr		ra			# return n
-	 move		v0, t0
+	 move           v0, t0
 	END(__strncpy_from_user_asm)
 
-.Lfault: jr		ra
-	  li		v0, -EFAULT
-
-	.section	__ex_table,"a"
-	PTR		1b, .Lfault
-	.previous
+#endif
diff -ur ./arch/mips/lib/strnlen_user.S /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strnlen_user.S
--- ./arch/mips/lib/strnlen_user.S	2023-04-26 12:25:54.950119559 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/lib/strnlen_user.S	2023-04-23 11:58:26.915014300 +0100
@@ -25,22 +25,45 @@
  *	 bytes.	 There's nothing secret there.	On 64-bit accessing beyond
  *	 the maximum is a tad hairier ...
  */
-LEAF(__strnlen_user_asm)
+LEAF(__strnlen_kernel_asm)
 	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
 	and		v0, a0
 	bnez		v0, .Lfault
 
-FEXPORT(__strnlen_user_nocheck_asm)
-	move		v0, a0
-	PTR_ADDU	a1, a0			# stop pointer
-1:	beq		v0, a1, 1f		# limit reached?
+FEXPORT(__strnlen_kernel_nocheck_asm)
+	move            v0, a0
+	PTR_ADDU        a1, a0                  # stop pointer
+1:      beq             v0, a1, 2f              # limit reached?
 	EX(lb, t0, (v0), .Lfault)
-	PTR_ADDIU	v0, 1
-	bnez		t0, 1b
-1:	PTR_SUBU	v0, a0
-	jr		ra
-	END(__strnlen_user_asm)
+	PTR_ADDIU       v0, 1
+	bnez            t0, 1b
+2:      PTR_SUBU        v0, a0
+	jr              ra
+	END(__strnlen_kernel_asm)
+
 
 .Lfault:
 	move		v0, zero
 	jr		ra
+
+
+#ifdef CONFIG_EVA
+
+LEAF(__strnlen_user_asm)
+	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
+	and		v0, a0
+	bnez		v0, .Lfault
+
+FEXPORT(__strnlen_user_nocheck_asm)
+	move            v0, a0
+	PTR_ADDU        a1, a0                  # stop pointer
+1:      beq             v0, a1, 2f              # limit reached?
+	.set            eva
+	EX(lbe, t0, (v0), .Lfault)
+	PTR_ADDIU       v0, 1
+	bnez            t0, 1b
+2:      PTR_SUBU        v0, a0
+	jr              ra
+	END(__strnlen_user_asm)
+
+#endif
diff -ur ./arch/mips/loongson/common/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/loongson/common/Makefile
--- ./arch/mips/loongson/common/Makefile	2023-04-26 12:25:54.950119559 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/loongson/common/Makefile	2023-04-23 11:58:26.989329700 +0100
@@ -3,8 +3,9 @@
 #
 
 obj-y += setup.o init.o cmdline.o env.o time.o reset.o irq.o \
-    pci.o bonito-irq.o mem.o machtype.o platform.o
+    bonito-irq.o mem.o machtype.o platform.o
 obj-$(CONFIG_GPIOLIB) += gpio.o
+obj-$(CONFIG_PCI) += pci.o
 
 #
 # Serial port support
diff -ur ./arch/mips/math-emu/cp1emu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/cp1emu.c
--- ./arch/mips/math-emu/cp1emu.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/cp1emu.c	2023-04-23 11:58:28.112761100 +0100
@@ -417,14 +417,20 @@
 			case mm_mtc1_op:
 			case mm_cfc1_op:
 			case mm_ctc1_op:
+			case mm_mfhc1_op:
+			case mm_mthc1_op:
 				if (insn.mm_fp1_format.op == mm_mfc1_op)
 					op = mfc_op;
 				else if (insn.mm_fp1_format.op == mm_mtc1_op)
 					op = mtc_op;
 				else if (insn.mm_fp1_format.op == mm_cfc1_op)
 					op = cfc_op;
-				else
+				else if (insn.mm_fp1_format.op == mm_ctc1_op)
 					op = ctc_op;
+				else if (insn.mm_fp1_format.op == mm_mfhc1_op)
+					op = mfhc_op;
+				else
+					op = mthc_op;
 				mips32_insn.fp1_format.opcode = cop1_op;
 				mips32_insn.fp1_format.op = op;
 				mips32_insn.fp1_format.rt =
@@ -471,6 +477,9 @@
 	unsigned int fcr31;
 	unsigned int bit;
 
+	if (!cpu_has_mmips)
+		return 0;
+
 	switch (insn.mm_i_format.opcode) {
 	case mm_pool32a_op:
 		if ((insn.mm_i_format.simmediate & MM_POOL32A_MINOR_MASK) ==
@@ -859,13 +868,7 @@
  */
 static inline int cop1_64bit(struct pt_regs *xcp)
 {
-#if defined(CONFIG_64BIT) && !defined(CONFIG_MIPS32_O32)
-	return 1;
-#elif defined(CONFIG_64BIT) && defined(CONFIG_MIPS32_O32)
 	return !test_thread_flag(TIF_32BIT_REGS);
-#else
-	return 0;
-#endif
 }
 
 #define SIFROMREG(si, x) ((si) = cop1_64bit(xcp) || !(x & 1) ? \
@@ -884,6 +887,10 @@
 #define DPFROMREG(dp, x)	DIFROMREG((dp).bits, x)
 #define DPTOREG(dp, x)	DITOREG((dp).bits, x)
 
+#define SIFROMHREG(si, x)	((si) = (int)(ctx->fpr[x] >> 32))
+#define SITOHREG(si, x)		(ctx->fpr[x] = \
+				ctx->fpr[x] << 32 >> 32 | (u64)(si) << 32)
+
 /*
  * Emulate the single floating point instruction pointed at by EPC.
  * Two instructions if the instruction is in a branch delay slot.
@@ -1053,6 +1060,21 @@
 			break;
 #endif
 
+#ifdef CONFIG_CPU_MIPSR2
+		case mfhc_op:
+			/* copregister rd -> gpr[rt] */
+			if (MIPSInst_RT(ir) != 0) {
+				SIFROMHREG(xcp->regs[MIPSInst_RT(ir)],
+					MIPSInst_RD(ir));
+			}
+			break;
+
+		case mthc_op:
+			/* copregister rd <- gpr[rt] */
+			SITOHREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));
+			break;
+#endif
+
 		case mfc_op:
 			/* copregister rd -> gpr[rt] */
 			if (MIPSInst_RT(ir) != 0) {
diff -ur ./arch/mips/math-emu/ieee754.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754.h
--- ./arch/mips/math-emu/ieee754.h	2023-04-26 12:25:54.960119565 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754.h	2023-04-23 11:58:28.348733400 +0100
@@ -311,7 +311,10 @@
 	unsigned pad0:7;
 	unsigned nod:1;		/* set 1 for no denormalised numbers */
 	unsigned c:1;		/* condition */
-	unsigned pad1:5;
+	unsigned pad1a:2;
+	unsigned mac2008:1;
+	unsigned abs2008:1;
+	unsigned nan2008:1;
 	unsigned cx:6;		/* exceptions this operation */
 	unsigned mx:5;		/* exception enable  mask */
 	unsigned sx:5;		/* exceptions total */
@@ -322,7 +325,10 @@
 	unsigned sx:5;		/* exceptions total */
 	unsigned mx:5;		/* exception enable  mask */
 	unsigned cx:6;		/* exceptions this operation */
-	unsigned pad1:5;
+	unsigned nan2008:1;
+	unsigned abs2008:1;
+	unsigned mac2008:1;
+	unsigned pad1a:2;
 	unsigned c:1;		/* condition */
 	unsigned nod:1;		/* set 1 for no denormalised numbers */
 	unsigned pad0:7;
diff -ur ./arch/mips/math-emu/ieee754dp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754dp.c
--- ./arch/mips/math-emu/ieee754dp.c	2023-04-26 12:25:54.960119565 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754dp.c	2023-04-23 11:58:28.433323700 +0100
@@ -41,7 +41,9 @@
 int ieee754dp_issnan(ieee754dp x)
 {
 	assert(ieee754dp_isnan(x));
-	return ((DPMANT(x) & DP_MBIT(DP_MBITS-1)) == DP_MBIT(DP_MBITS-1));
+	if (ieee754_csr.nan2008)
+		return !(DPMANT(x) & DP_MBIT(DP_MBITS-1));
+	return (DPMANT(x) & DP_MBIT(DP_MBITS-1));
 }
 
 
diff -ur ./arch/mips/math-emu/ieee754int.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754int.h
--- ./arch/mips/math-emu/ieee754int.h	2023-04-26 12:25:54.960119565 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754int.h	2023-04-23 11:58:28.432043800 +0100
@@ -83,10 +83,17 @@
     if(ve == SP_EMAX+1+SP_EBIAS){\
 	if(vm == 0)\
 	  vc = IEEE754_CLASS_INF;\
-	else if(vm & SP_MBIT(SP_MBITS-1)) \
-	  vc = IEEE754_CLASS_SNAN;\
-	else \
-	  vc = IEEE754_CLASS_QNAN;\
+	else if (ieee754_csr.nan2008) { \
+	  if(vm & SP_MBIT(SP_MBITS-1)) \
+	    vc = IEEE754_CLASS_QNAN;\
+	  else \
+	    vc = IEEE754_CLASS_SNAN;\
+	} else { \
+	  if(vm & SP_MBIT(SP_MBITS-1)) \
+	    vc = IEEE754_CLASS_SNAN;\
+	  else \
+	    vc = IEEE754_CLASS_QNAN;\
+	} \
     } else if(ve == SP_EMIN-1+SP_EBIAS) {\
 	if(vm) {\
 	    ve = SP_EMIN;\
@@ -117,10 +124,17 @@
     if(ve == DP_EMAX+1+DP_EBIAS){\
 	if(vm == 0)\
 	  vc = IEEE754_CLASS_INF;\
-	else if(vm & DP_MBIT(DP_MBITS-1)) \
-	  vc = IEEE754_CLASS_SNAN;\
-	else \
-	  vc = IEEE754_CLASS_QNAN;\
+	else if (ieee754_csr.nan2008) { \
+	  if(vm & DP_MBIT(DP_MBITS-1)) \
+	    vc = IEEE754_CLASS_QNAN;\
+	  else \
+	    vc = IEEE754_CLASS_SNAN;\
+	} else { \
+	  if(vm & DP_MBIT(DP_MBITS-1)) \
+	    vc = IEEE754_CLASS_SNAN;\
+	  else \
+	    vc = IEEE754_CLASS_QNAN;\
+	} \
     } else if(ve == DP_EMIN-1+DP_EBIAS) {\
 	if(vm) {\
 	    ve = DP_EMIN;\
diff -ur ./arch/mips/math-emu/ieee754sp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754sp.c
--- ./arch/mips/math-emu/ieee754sp.c	2023-04-26 12:25:54.960119565 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/ieee754sp.c	2023-04-23 11:58:28.430880600 +0100
@@ -41,6 +41,8 @@
 int ieee754sp_issnan(ieee754sp x)
 {
 	assert(ieee754sp_isnan(x));
+	if (ieee754_csr.nan2008)
+		return !(SPMANT(x) & SP_MBIT(SP_MBITS-1));
 	return (SPMANT(x) & SP_MBIT(SP_MBITS-1));
 }
 
diff -ur ./arch/mips/math-emu/kernel_linkage.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/kernel_linkage.c
--- ./arch/mips/math-emu/kernel_linkage.c	2023-04-26 12:25:54.970119572 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/math-emu/kernel_linkage.c	2023-04-23 11:58:28.510107000 +0100
@@ -27,7 +27,21 @@
 #include <asm/fpu.h>
 #include <asm/fpu_emulator.h>
 
-#define SIGNALLING_NAN 0x7ff800007ff80000LL
+#define SIGNALLING_NAN      0x7ff800007ff80000LL
+#define SIGNALLING_NAN2008  0x7ff000007fa00000LL
+
+extern unsigned int fpu_fcr31 __read_mostly;
+extern unsigned int system_has_fpu __read_mostly;
+static int nan2008 __read_mostly = -1;
+
+static int __init setup_nan2008(char *str)
+{
+	get_option (&str, &nan2008);
+
+	return 1;
+}
+
+__setup("nan2008=", setup_nan2008);
 
 void fpu_emulator_init_fpu(void)
 {
@@ -39,10 +53,28 @@
 		printk("Algorithmics/MIPS FPU Emulator v1.5\n");
 	}
 
-	current->thread.fpu.fcr31 = 0;
-	for (i = 0; i < 32; i++) {
-		current->thread.fpu.fpr[i] = SIGNALLING_NAN;
+	if (system_has_fpu)
+		current->thread.fpu.fcr31 = fpu_fcr31;
+	else if (nan2008 < 0) {
+		if (!test_thread_flag(TIF_32BIT_REGS))
+			current->thread.fpu.fcr31 = FPU_CSR_DEFAULT|FPU_CSR_MAC2008|FPU_CSR_ABS2008|FPU_CSR_NAN2008;
+		else
+			current->thread.fpu.fcr31 = FPU_CSR_DEFAULT;
+	} else {
+		if (nan2008)
+			current->thread.fpu.fcr31 = FPU_CSR_DEFAULT|FPU_CSR_MAC2008|FPU_CSR_ABS2008|FPU_CSR_NAN2008;
+		else
+			current->thread.fpu.fcr31 = FPU_CSR_DEFAULT;
 	}
+
+	if (current->thread.fpu.fcr31 & FPU_CSR_NAN2008)
+		for (i = 0; i < 32; i++) {
+			current->thread.fpu.fpr[i] = SIGNALLING_NAN2008;
+		}
+	else
+		for (i = 0; i < 32; i++) {
+			current->thread.fpu.fpr[i] = SIGNALLING_NAN;
+		}
 }
 
 
@@ -90,6 +122,17 @@
 	int i;
 	int err = 0;
 
+	if (!test_thread_flag(TIF_32BIT_REGS)) {
+		for (i = 0; i < 32; i++) {
+			err |=
+			    __put_user(current->thread.fpu.fpr[i], &sc->sc_fpregs[i]);
+		}
+		err |= __put_user(current->thread.fpu.fcr31, &sc->sc_fpc_csr);
+
+		return err;
+
+	}
+
 	for (i = 0; i < 32; i+=2) {
 		err |=
 		    __put_user(current->thread.fpu.fpr[i], &sc->sc_fpregs[i]);
@@ -104,6 +147,16 @@
 	int i;
 	int err = 0;
 
+	if (!test_thread_flag(TIF_32BIT_REGS)) {
+		for (i = 0; i < 32; i++) {
+			err |=
+			    __get_user(current->thread.fpu.fpr[i], &sc->sc_fpregs[i]);
+		}
+		err |= __get_user(current->thread.fpu.fcr31, &sc->sc_fpc_csr);
+
+		return err;
+	}
+
 	for (i = 0; i < 32; i+=2) {
 		err |=
 		    __get_user(current->thread.fpu.fpr[i], &sc->sc_fpregs[i]);
diff -ur ./arch/mips/mm/c-octeon.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-octeon.c
--- ./arch/mips/mm/c-octeon.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-octeon.c	2023-04-23 11:58:28.833015900 +0100
@@ -176,6 +176,13 @@
 	BUG();
 }
 
+static void octeon_flush_data_cache_range(struct vm_area_struct *vma,
+	struct page *page, unsigned long addr, unsigned long size)
+{
+	octeon_flush_cache_page(vma, addr, page_to_pfn(page));
+}
+
+
 /**
  * Probe Octeon's caches
  *
@@ -275,6 +282,7 @@
 	flush_cache_sigtramp		= octeon_flush_cache_sigtramp;
 	flush_icache_all		= octeon_flush_icache_all;
 	flush_data_cache_page		= octeon_flush_data_cache_page;
+	mips_flush_data_cache_range     = octeon_flush_data_cache_range;
 	flush_icache_range		= octeon_flush_icache_range;
 	local_flush_icache_range	= local_octeon_flush_icache_range;
 
diff -ur ./arch/mips/mm/c-r3k.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-r3k.c
--- ./arch/mips/mm/c-r3k.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-r3k.c	2023-04-23 11:58:28.832250200 +0100
@@ -274,6 +274,12 @@
 {
 }
 
+static void r3_mips_flush_data_cache_range(struct vm_area_struct *vma,
+	struct page *page, unsigned long addr, unsigned long size)
+{
+	r3k_flush_cache_page(vma, addr, page_to_pfn(page));
+}
+
 static void r3k_flush_cache_sigtramp(unsigned long addr)
 {
 	unsigned long flags;
@@ -322,7 +328,7 @@
 	flush_cache_all = r3k_flush_cache_all;
 	__flush_cache_all = r3k___flush_cache_all;
 	flush_cache_mm = r3k_flush_cache_mm;
-	flush_cache_range = r3k_flush_cache_range;
+	mips_flush_cache_range = r3k_mips_flush_cache_range;
 	flush_cache_page = r3k_flush_cache_page;
 	flush_icache_range = r3k_flush_icache_range;
 	local_flush_icache_range = r3k_flush_icache_range;
@@ -332,6 +338,7 @@
 	flush_cache_sigtramp = r3k_flush_cache_sigtramp;
 	local_flush_data_cache_page = local_r3k_flush_data_cache_page;
 	flush_data_cache_page = r3k_flush_data_cache_page;
+	flush_data_cache_range = r3_flush_data_cache_range;
 
 	_dma_cache_wback_inv = r3k_dma_cache_wback_inv;
 	_dma_cache_wback = r3k_dma_cache_wback_inv;
diff -ur ./arch/mips/mm/c-r4k.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-r4k.c
--- ./arch/mips/mm/c-r4k.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-r4k.c	2023-04-23 11:58:28.829302700 +0100
@@ -6,12 +6,14 @@
  * Copyright (C) 1996 David S. Miller (davem@davemloft.net)
  * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Ralf Baechle (ralf@gnu.org)
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2012, MIPS Technology, Leonid Yegoshin (yegoshin@mips.com)
  */
 #include <linux/hardirq.h>
 #include <linux/init.h>
 #include <linux/highmem.h>
 #include <linux/kernel.h>
 #include <linux/linkage.h>
+#include <linux/preempt.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/mm.h>
@@ -43,6 +45,13 @@
  *  o collapses to normal function call on systems with a single shared
  *    primary cache.
  *  o doesn't disable interrupts on the local CPU
+ *
+ *  Note: this function is used now for address cacheops only
+ *
+ *  Note2: It is unsafe to use address cacheops via SMP call, other CPU may not
+ *         have this process address map (ASID) loaded into EntryHI and
+ *         it usualy requires some tricks, which are absent from this file.
+ *         Cross-CPU address cacheops are much easy and safely.
  */
 static inline void r4k_on_each_cpu(void (*func) (void *info), void *info)
 {
@@ -55,13 +64,67 @@
 	preempt_enable();
 }
 
-#if defined(CONFIG_MIPS_CMP)
+#if defined(CONFIG_MIPS_CMP) && defined(CONFIG_SMP)
 #define cpu_has_safe_index_cacheops 0
 #else
 #define cpu_has_safe_index_cacheops 1
 #endif
 
 /*
+ * This variant of smp_call_function is used for index cacheops only.
+ */
+static inline void r4k_indexop_on_each_cpu(void (*func) (void *info), void *info)
+{
+	preempt_disable();
+
+#ifdef CONFIG_SMP
+	if (!cpu_has_safe_index_cacheops) {
+
+		if (smp_num_siblings > 1) {
+			cpumask_t tmp_mask = INIT_CPUMASK;
+			int cpu, this_cpu, n = 0;
+
+			/* If processor hasn't safe index cachops (likely)
+			   then run cache flush on other CPUs.
+			   But I assume that siblings have common L1 cache, so -
+			   - run cache flush only once per sibling group. LY22 */
+
+			this_cpu = smp_processor_id();
+			for_each_online_cpu(cpu) {
+
+				if (cpumask_test_cpu(cpu, (&per_cpu(cpu_sibling_map, this_cpu))))
+					continue;
+
+				if (cpumask_intersects(&tmp_mask, (&per_cpu(cpu_sibling_map, cpu))))
+					continue;
+				cpu_set(cpu, tmp_mask);
+				n++;
+			}
+			if (n)
+				smp_call_function_many(&tmp_mask, func, info, 1);
+		} else
+			smp_call_function(func, info, 1);
+	}
+#endif
+	func(info);
+	preempt_enable();
+}
+
+/*  Define a rough size where address cacheops are still more optimal than
+ *  index cacheops on whole cache (in D/I-cache size terms).
+ *  Value "2" reflects an expense of smp_call_function() on top of
+ *  whole cache flush via index cacheops.
+ */
+#ifndef CACHE_CPU_LATENCY
+#ifdef CONFIG_SMP
+#define CACHE_CPU_LATENCY   (2)
+#else
+#define CACHE_CPU_LATENCY   (1)
+#endif
+#endif
+
+
+/*
  * Must die.
  */
 static unsigned long icache_size __read_mostly;
@@ -121,6 +184,28 @@
 		r4k_blast_dcache_page = r4k_blast_dcache_page_dc64;
 }
 
+#ifndef CONFIG_EVA
+#define r4k_blast_dcache_user_page  r4k_blast_dcache_page
+#else
+
+static void (*r4k_blast_dcache_user_page)(unsigned long addr);
+
+static void __cpuinit r4k_blast_dcache_user_page_setup(void)
+{
+	unsigned long  dc_lsize = cpu_dcache_line_size();
+
+	if (dc_lsize == 0)
+		r4k_blast_dcache_user_page = (void *)cache_noop;
+	else if (dc_lsize == 16)
+		r4k_blast_dcache_user_page = blast_dcache16_user_page;
+	else if (dc_lsize == 32)
+		r4k_blast_dcache_user_page = blast_dcache32_user_page;
+	else if (dc_lsize == 64)
+		r4k_blast_dcache_user_page = blast_dcache64_user_page;
+}
+
+#endif
+
 static void (* r4k_blast_dcache_page_indexed)(unsigned long addr);
 
 static void __cpuinit r4k_blast_dcache_page_indexed_setup(void)
@@ -241,6 +326,27 @@
 		r4k_blast_icache_page = blast_icache64_page;
 }
 
+#ifndef CONFIG_EVA
+#define r4k_blast_icache_user_page  r4k_blast_icache_page
+#else
+
+static void (* r4k_blast_icache_user_page)(unsigned long addr);
+
+static void __cpuinit r4k_blast_icache_user_page_setup(void)
+{
+	unsigned long ic_lsize = cpu_icache_line_size();
+
+	if (ic_lsize == 0)
+		r4k_blast_icache_user_page = (void *)cache_noop;
+	else if (ic_lsize == 16)
+		r4k_blast_icache_user_page = blast_icache16_user_page;
+	else if (ic_lsize == 32)
+		r4k_blast_icache_user_page = blast_icache32_user_page;
+	else if (ic_lsize == 64)
+		r4k_blast_icache_user_page = blast_icache64_user_page;
+}
+
+#endif
 
 static void (* r4k_blast_icache_page_indexed)(unsigned long addr);
 
@@ -365,7 +471,7 @@
 
 static void r4k___flush_cache_all(void)
 {
-	r4k_on_each_cpu(local_r4k___flush_cache_all, NULL);
+	r4k_indexop_on_each_cpu(local_r4k___flush_cache_all, NULL);
 }
 
 static inline int has_valid_asid(const struct mm_struct *mm)
@@ -383,16 +489,73 @@
 #endif
 }
 
-static void r4k__flush_cache_vmap(void)
+
+static inline void local_r4__flush_dcache(void *args)
 {
 	r4k_blast_dcache();
 }
 
-static void r4k__flush_cache_vunmap(void)
+struct vmap_args {
+	unsigned long start;
+	unsigned long end;
+};
+
+static inline void local_r4__flush_cache_vmap(void *args)
 {
-	r4k_blast_dcache();
+	blast_dcache_range(((struct vmap_args *)args)->start,((struct vmap_args *)args)->end);
+}
+
+static void r4k__flush_cache_vmap(unsigned long start, unsigned long end)
+{
+	unsigned long size = end - start;
+
+	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
+		r4k_blast_dcache();
+	} else {
+/* Commented out until bug in free_unmap_vmap_area() is fixed - it calls
+   with unmapped page and address cache op does TLB refill exception
+		if (size >= (dcache_size * CACHE_CPU_LATENCY))
+ */
+			r4k_indexop_on_each_cpu(local_r4__flush_dcache, NULL);
+/* Commented out until bug in free_unmap_vmap_area() is fixed - it calls
+   with unmapped page and address cache op does TLB refill exception
+		else {
+			struct vmap_args args;
+
+			args.start = start;
+			args.end = end;
+			r4k_on_each_cpu(local_r4__flush_cache_vmap, (void *)&args);
+		}
+ */
+	}
+}
+
+static void r4k__flush_cache_vunmap(unsigned long start, unsigned long end)
+{
+	unsigned long size = end - start;
+
+	if (cpu_has_safe_index_cacheops && size >= dcache_size)
+		r4k_blast_dcache();
+	else {
+/* Commented out until bug in free_unmap_vmap_area() is fixed - it calls
+   with unmapped page and address cache op does TLB refill exception
+		if (size >= (dcache_size * CACHE_CPU_LATENCY))
+ */
+			r4k_indexop_on_each_cpu(local_r4__flush_dcache, NULL);
+/* Commented out until bug in free_unmap_vmap_area() is fixed - it calls
+   with unmapped page and address cache op does TLB refill exception
+		else {
+			struct vmap_args args;
+
+			args.start = start;
+			args.end = end;
+			r4k_on_each_cpu(local_r4__flush_cache_vmap, (void *)&args);
+		}
+ */
+	}
 }
 
+
 static inline void local_r4k_flush_cache_range(void * args)
 {
 	struct vm_area_struct *vma = args;
@@ -402,8 +565,11 @@
 		return;
 
 	r4k_blast_dcache();
-	if (exec)
+	if (exec) {
+		if (!cpu_has_ic_fills_f_dc)
+			wmb();
 		r4k_blast_icache();
+	}
 }
 
 static void r4k_flush_cache_range(struct vm_area_struct *vma,
@@ -412,7 +578,7 @@
 	int exec = vma->vm_flags & VM_EXEC;
 
 	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc))
-		r4k_on_each_cpu(local_r4k_flush_cache_range, vma);
+		r4k_indexop_on_each_cpu(local_r4k_flush_cache_range, vma);
 }
 
 static inline void local_r4k_flush_cache_mm(void * args)
@@ -444,7 +610,7 @@
 	if (!cpu_has_dc_aliases)
 		return;
 
-	r4k_on_each_cpu(local_r4k_flush_cache_mm, mm);
+	r4k_indexop_on_each_cpu(local_r4k_flush_cache_mm, mm);
 }
 
 struct flush_cache_page_args {
@@ -467,6 +633,7 @@
 	pmd_t *pmdp;
 	pte_t *ptep;
 	void *vaddr;
+	int dontflash = 0;
 
 	/*
 	 * If ownes no valid ASID yet, cannot possibly have gotten
@@ -488,9 +655,21 @@
 	if (!(pte_present(*ptep)))
 		return;
 
-	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID))
-		vaddr = NULL;
-	else {
+	/*  accelerate it! See below, just skipping kmap_*()/kunmap_*() */
+	if ((!exec) && !cpu_has_dc_aliases)
+		return;
+
+	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
+		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
+			r4k_blast_dcache_user_page(addr);
+			if (exec && (!cpu_has_cm2) && !cpu_has_ic_fills_f_dc)
+				wmb();
+			if (exec && !cpu_icache_snoops_remote_store)
+				r4k_blast_scache_page(addr);
+		}
+		if (exec)
+			r4k_blast_icache_user_page(addr);
+	} else {
 		/*
 		 * Use kmap_coherent or kmap_atomic to do flushes for
 		 * another ASID than the current one.
@@ -502,28 +681,37 @@
 		else
 			vaddr = kmap_atomic(page);
 		addr = (unsigned long)vaddr;
-	}
-
-	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
-		r4k_blast_dcache_page(addr);
-		if (exec && !cpu_icache_snoops_remote_store)
-			r4k_blast_scache_page(addr);
-	}
-	if (exec) {
-		if (vaddr && cpu_has_vtag_icache && mm == current->active_mm) {
-			int cpu = smp_processor_id();
 
-			if (cpu_context(cpu, mm) != 0)
-				drop_mmu_context(mm, cpu);
-		} else
-			r4k_blast_icache_page(addr);
-	}
+		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
+			r4k_blast_dcache_page(addr);
+			if (exec && (!cpu_has_cm2) && !cpu_has_ic_fills_f_dc)
+				wmb();
+			if (exec && !cpu_icache_snoops_remote_store)
+				r4k_blast_scache_page(addr);
+		}
+		if (exec) {
+			if (cpu_has_vtag_icache && mm == current->active_mm) {
+				int cpu = smp_processor_id();
+
+				if (cpu_context(cpu, mm) != 0)
+					drop_mmu_context(mm, cpu);
+				dontflash = 1;
+			} else
+				if (map_coherent || !cpu_has_ic_aliases)
+					r4k_blast_icache_page(addr);
+		}
 
-	if (vaddr) {
 		if (map_coherent)
 			kunmap_coherent();
 		else
 			kunmap_atomic(vaddr);
+
+		/*  in case of I-cache aliasing - blast it via coherent page */
+		if (exec && cpu_has_ic_aliases && (!dontflash) && !map_coherent) {
+			vaddr = kmap_coherent(page, addr);
+			r4k_blast_icache_page((unsigned long)vaddr);
+			kunmap_coherent();
+		}
 	}
 }
 
@@ -537,6 +725,8 @@
 	args.pfn = pfn;
 
 	r4k_on_each_cpu(local_r4k_flush_cache_page, &args);
+	if (cpu_has_dc_aliases)
+		ClearPageDcacheDirty(pfn_to_page(pfn));
 }
 
 static inline void local_r4k_flush_data_cache_page(void * addr)
@@ -552,11 +742,82 @@
 		r4k_on_each_cpu(local_r4k_flush_data_cache_page, (void *) addr);
 }
 
+
+struct mips_flush_data_cache_range_args {
+	struct vm_area_struct *vma;
+	unsigned long start;
+	unsigned long end;
+};
+
+static inline void local_r4k_mips_flush_data_cache_range(void *args)
+{
+	struct mips_flush_data_cache_range_args *f_args = args;
+	unsigned long start = f_args->start;
+	unsigned long end = f_args->end;
+	struct vm_area_struct * vma = f_args->vma;
+
+	blast_dcache_range(start, end);
+
+	if ((vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc) {
+		if (!cpu_has_cm2)
+			wmb();
+
+		/* vma is given for exec check only, mmap is current,
+		   so - no non-current vma page flush, just user or kernel */
+		protected_blast_icache_range(start, end);
+	}
+}
+
+/* flush dirty kernel data and a corresponding user instructions (if needed).
+   used in copy_to_user_page() */
+static void r4k_mips_flush_data_cache_range(struct vm_area_struct *vma,
+	struct page *page, unsigned long start, unsigned long len)
+{
+	struct mips_flush_data_cache_range_args args;
+
+	args.vma = vma;
+	args.start = start;
+	args.end = start + len;
+
+	r4k_on_each_cpu(local_r4k_mips_flush_data_cache_range, (void *)&args);
+}
+
+
 struct flush_icache_range_args {
 	unsigned long start;
 	unsigned long end;
 };
 
+static inline void local_r4k_flush_icache(void *args)
+{
+	if (!cpu_has_ic_fills_f_dc) {
+		r4k_blast_dcache();
+
+		wmb();
+	}
+
+	r4k_blast_icache();
+}
+
+static inline void local_r4k_flush_icache_range_ipi(void *args)
+{
+	struct flush_icache_range_args *fir_args = args;
+	unsigned long start = fir_args->start;
+	unsigned long end = fir_args->end;
+
+	if (!cpu_has_ic_fills_f_dc) {
+		R4600_HIT_CACHEOP_WAR_IMPL;
+		protected_blast_dcache_range(start, end);
+
+		if (!cpu_has_cm2)
+			wmb();
+	}
+
+	protected_blast_icache_range(start, end);
+
+}
+
+/* This function is used only for local CPU only while boot etc */
 static inline void local_r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
 	if (!cpu_has_ic_fills_f_dc) {
@@ -564,36 +825,53 @@
 			r4k_blast_dcache();
 		} else {
 			R4600_HIT_CACHEOP_WAR_IMPL;
-			protected_blast_dcache_range(start, end);
+			blast_dcache_range(start, end);
 		}
+
+		wmb();
 	}
 
 	if (end - start > icache_size)
 		r4k_blast_icache();
 	else
-		protected_blast_icache_range(start, end);
-}
-
-static inline void local_r4k_flush_icache_range_ipi(void *args)
-{
-	struct flush_icache_range_args *fir_args = args;
-	unsigned long start = fir_args->start;
-	unsigned long end = fir_args->end;
-
-	local_r4k_flush_icache_range(start, end);
+		blast_icache_range(start, end);
+#ifdef CONFIG_EVA
+	/* This is here to smooth effect of any kind of address aliasing.
+	   It is used only during boot, so - it doesn't create an impact on
+	   performance. LY22 */
+	bc_wback_inv(start, (end - start));
+	__sync();
+#endif
 }
 
+/* this function can be called for kernel OR user addresses,
+ * kernel is for module, *gdb*. User is for binfmt_a.out/flat
+ * So - take care, check get_fs() */
 static void r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
 	struct flush_icache_range_args args;
+	unsigned long size = end - start;
 
 	args.start = start;
 	args.end = end;
 
-	r4k_on_each_cpu(local_r4k_flush_icache_range_ipi, &args);
+	if (cpu_has_safe_index_cacheops &&
+	    (((size >= icache_size) && !cpu_has_ic_fills_f_dc) ||
+	     (size >= dcache_size)))
+		local_r4k_flush_icache((void *)&args);
+	else if (((size < (icache_size * CACHE_CPU_LATENCY)) && !cpu_has_ic_fills_f_dc) ||
+		 (size < (dcache_size * CACHE_CPU_LATENCY))) {
+		struct flush_icache_range_args args;
+
+		args.start = start;
+		args.end = end;
+		r4k_on_each_cpu(local_r4k_flush_icache_range_ipi, (void *)&args);
+	} else
+		r4k_indexop_on_each_cpu(local_r4k_flush_icache, NULL);
 	instruction_hazard();
 }
 
+
 #ifdef CONFIG_DMA_NONCOHERENT
 
 static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
@@ -601,11 +879,13 @@
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
 
+	preempt_disable();
 	if (cpu_has_inclusive_pcaches) {
 		if (size >= scache_size)
 			r4k_blast_scache();
 		else
 			blast_scache_range(addr, addr + size);
+		preempt_enable();
 		__sync();
 		return;
 	}
@@ -621,9 +901,11 @@
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
 	}
+	preempt_enable();
 
 	bc_wback_inv(addr, size);
-	__sync();
+	if (!cpu_has_cm2_l2sync)
+		__sync();
 }
 
 static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
@@ -631,6 +913,7 @@
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
 
+	preempt_disable();
 	if (cpu_has_inclusive_pcaches) {
 		if (size >= scache_size)
 			r4k_blast_scache();
@@ -645,6 +928,7 @@
 			 */
 			blast_inv_scache_range(addr, addr + size);
 		}
+		preempt_enable();
 		__sync();
 		return;
 	}
@@ -652,9 +936,14 @@
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
+		unsigned long lsize = cpu_dcache_line_size();
+		unsigned long almask = ~(lsize - 1);
 		R4600_HIT_CACHEOP_WAR_IMPL;
+		cache_op(Hit_Writeback_Inv_D, addr & almask);
+		cache_op(Hit_Writeback_Inv_D, (addr + size - 1)  & almask);
 		blast_inv_dcache_range(addr, addr + size);
 	}
+	preempt_enable();
 
 	bc_inv(addr, size);
 	__sync();
@@ -743,7 +1032,10 @@
 	args.vaddr = (unsigned long) vaddr;
 	args.size = size;
 
-	r4k_on_each_cpu(local_r4k_flush_kernel_vmap_range, &args);
+	if (cpu_has_safe_index_cacheops && size >= dcache_size)
+		r4k_indexop_on_each_cpu(local_r4k_flush_kernel_vmap_range, &args);
+	else
+		r4k_on_each_cpu(local_r4k_flush_kernel_vmap_range, &args);
 }
 
 static inline void rm7k_erratum31(void)
@@ -780,20 +1072,30 @@
 
 static inline void alias_74k_erratum(struct cpuinfo_mips *c)
 {
+	unsigned int imp = c->processor_id & 0xff00;
+	unsigned int rev = c->processor_id & PRID_REV_MASK;
+
 	/*
 	 * Early versions of the 74K do not update the cache tags on a
 	 * vtag miss/ptag hit which can occur in the case of KSEG0/KUSEG
 	 * aliases. In this case it is better to treat the cache as always
 	 * having aliases.
 	 */
-	if ((c->processor_id & 0xff) <= PRID_REV_ENCODE_332(2, 4, 0))
-		c->dcache.flags |= MIPS_CACHE_VTAG;
-	if ((c->processor_id & 0xff) == PRID_REV_ENCODE_332(2, 4, 0))
-		write_c0_config6(read_c0_config6() | MIPS_CONF6_SYND);
-	if (((c->processor_id & 0xff00) == PRID_IMP_1074K) &&
-	    ((c->processor_id & 0xff) <= PRID_REV_ENCODE_332(1, 1, 0))) {
-		c->dcache.flags |= MIPS_CACHE_VTAG;
-		write_c0_config6(read_c0_config6() | MIPS_CONF6_SYND);
+	switch (imp) {
+	case PRID_IMP_74K:
+		if (rev <= PRID_REV_ENCODE_332(2, 4, 0))
+			c->dcache.flags |= MIPS_CACHE_VTAG;
+		if (rev == PRID_REV_ENCODE_332(2, 4, 0))
+			write_c0_config6(read_c0_config6() | MIPS_CONF6_SYND);
+		break;
+	case PRID_IMP_1074K:
+		if (rev <= PRID_REV_ENCODE_332(1, 1, 0)) {
+			c->dcache.flags |= MIPS_CACHE_VTAG;
+			write_c0_config6(read_c0_config6() | MIPS_CONF6_SYND);
+		}
+		break;
+	default:
+		BUG();
 	}
 }
 
@@ -1065,9 +1367,15 @@
 	case CPU_34K:
 	case CPU_74K:
 	case CPU_1004K:
+	case CPU_PROAPTIV:
+	case CPU_INTERAPTIV:
 		if (c->cputype == CPU_74K)
 			alias_74k_erratum(c);
-		if ((read_c0_config7() & (1 << 16))) {
+		if (!(read_c0_config7() & MIPS_CONF7_IAR)) {
+			if (c->icache.waysize > PAGE_SIZE)
+				c->icache.flags |= MIPS_CACHE_ALIASES;
+		}
+		if (read_c0_config7() & MIPS_CONF7_AR) {
 			/* effectively physically indexed dcache,
 			   thus no virtual aliases. */
 			c->dcache.flags |= MIPS_CACHE_PINDEX;
@@ -1078,6 +1386,14 @@
 			c->dcache.flags |= MIPS_CACHE_ALIASES;
 	}
 
+#ifdef  CONFIG_HIGHMEM
+	if (((c->dcache.flags & MIPS_CACHE_ALIASES) &&
+	     ((c->dcache.waysize / PAGE_SIZE) > FIX_N_COLOURS)) ||
+	     ((c->icache.flags & MIPS_CACHE_ALIASES) &&
+	     ((c->icache.waysize / PAGE_SIZE) > FIX_N_COLOURS)))
+		panic("PAGE_SIZE*WAYS too small for L1 size, too many colors");
+#endif
+
 	switch (c->cputype) {
 	case CPU_20KC:
 		/*
@@ -1100,10 +1416,12 @@
 	c->icache.ways = 1;
 #endif
 
-	printk("Primary instruction cache %ldkB, %s, %s, linesize %d bytes.\n",
-	       icache_size >> 10,
+	printk("Primary instruction cache %ldkB, %s, %s, %slinesize %d bytes.\n",
+	       icache_size >> 10, way_string[c->icache.ways],
 	       c->icache.flags & MIPS_CACHE_VTAG ? "VIVT" : "VIPT",
-	       way_string[c->icache.ways], c->icache.linesz);
+	       (c->icache.flags & MIPS_CACHE_ALIASES) ?
+			"I-cache aliases, " : "",
+	       c->icache.linesz);
 
 	printk("Primary data cache %ldkB, %s, %s, %s, linesize %d bytes\n",
 	       dcache_size >> 10, way_string[c->dcache.ways],
@@ -1252,7 +1570,7 @@
 	default:
 		if (c->isa_level & (MIPS_CPU_ISA_M32R1 | MIPS_CPU_ISA_M32R2 |
 				    MIPS_CPU_ISA_M64R1 | MIPS_CPU_ISA_M64R2)) {
-#ifdef CONFIG_MIPS_CPU_SCACHE
+#ifdef CONFIG_BOARD_SCACHE
 			if (mips_sc_init ()) {
 				scache_size = c->scache.ways * c->scache.sets * c->scache.linesz;
 				printk("MIPS secondary cache %ldkB, %s, linesize %d bytes.\n",
@@ -1329,11 +1647,11 @@
 	NXP_BARRIER();
 }
 
-static int __cpuinitdata cca = -1;
+unsigned int mips_cca = -1;
 
 static int __init cca_setup(char *str)
 {
-	get_option(&str, &cca);
+	get_option(&str, &mips_cca);
 
 	return 0;
 }
@@ -1342,12 +1660,12 @@
 
 static void __cpuinit coherency_setup(void)
 {
-	if (cca < 0 || cca > 7)
-		cca = read_c0_config() & CONF_CM_CMASK;
-	_page_cachable_default = cca << _CACHE_SHIFT;
+	if (mips_cca < 0 || mips_cca > 7)
+		mips_cca = read_c0_config() & CONF_CM_CMASK;
+	_page_cachable_default = mips_cca << _CACHE_SHIFT;
 
-	pr_debug("Using cache attribute %d\n", cca);
-	change_c0_config(CONF_CM_CMASK, cca);
+	pr_debug("Using cache attribute %d\n", mips_cca);
+	change_c0_config(CONF_CM_CMASK, mips_cca);
 
 	/*
 	 * c0_status.cu=0 specifies that updates by the sc instruction use
@@ -1416,6 +1734,10 @@
 	r4k_blast_scache_page_setup();
 	r4k_blast_scache_page_indexed_setup();
 	r4k_blast_scache_setup();
+#ifdef CONFIG_EVA
+	r4k_blast_dcache_user_page_setup();
+	r4k_blast_icache_user_page_setup();
+#endif
 
 	/*
 	 * Some MIPS32 and MIPS64 processors have physically indexed caches.
@@ -1444,6 +1766,7 @@
 	flush_icache_all	= r4k_flush_icache_all;
 	local_flush_data_cache_page	= local_r4k_flush_data_cache_page;
 	flush_data_cache_page	= r4k_flush_data_cache_page;
+	mips_flush_data_cache_range = r4k_mips_flush_data_cache_range;
 	flush_icache_range	= r4k_flush_icache_range;
 	local_flush_icache_range	= local_r4k_flush_icache_range;
 
@@ -1468,6 +1791,13 @@
 	 * or not to flush caches.
 	 */
 	local_r4k___flush_cache_all(NULL);
+#ifdef CONFIG_EVA
+	/* this is done just in case if some address aliasing does exist in
+	   board like old Malta memory map. Doesn't hurt anyway. LY22 */
+	smp_wmb();
+	r4k_blast_scache();
+	smp_wmb();
+#endif
 
 	coherency_setup();
 	board_cache_error_setup = r4k_cache_error_setup;
diff -ur ./arch/mips/mm/c-tx39.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-tx39.c
--- ./arch/mips/mm/c-tx39.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/c-tx39.c	2023-04-23 11:58:28.915284800 +0100
@@ -122,12 +122,12 @@
 	local_irq_restore(flags);
 }
 
-static void tx39__flush_cache_vmap(void)
+static void tx39__flush_cache_vmap(unsigned long start, unsigned long end)
 {
 	tx39_blast_dcache();
 }
 
-static void tx39__flush_cache_vunmap(void)
+static void tx39__flush_cache_vunmap(unsigned long start, unsigned long end)
 {
 	tx39_blast_dcache();
 }
@@ -230,6 +230,12 @@
 	tx39_blast_dcache_page(addr);
 }
 
+static void local_flush_data_cache_range(struct vm_area_struct *vma,
+	struct page *page, unsigned long addr, unsigned long size)
+{
+	flush_cache_page(vma, addr, page_to_pfn(page));
+}
+
 static void tx39_flush_icache_range(unsigned long start, unsigned long end)
 {
 	if (end - start > dcache_size)
@@ -371,6 +377,7 @@
 
 		flush_cache_sigtramp	= (void *) tx39h_flush_icache_all;
 		local_flush_data_cache_page	= (void *) tx39h_flush_icache_all;
+		mips_flush_data_cache_range     = (void *) local_flush_data_cache_range;
 		flush_data_cache_page	= (void *) tx39h_flush_icache_all;
 
 		_dma_cache_wback_inv	= tx39h_dma_cache_wback_inv;
@@ -402,6 +409,7 @@
 
 		flush_cache_sigtramp = tx39_flush_cache_sigtramp;
 		local_flush_data_cache_page = local_tx39_flush_data_cache_page;
+		mips_flush_data_cache_range     = (void *) local_flush_data_cache_range;
 		flush_data_cache_page = tx39_flush_data_cache_page;
 
 		_dma_cache_wback_inv = tx39_dma_cache_wback_inv;
diff -ur ./arch/mips/mm/cache.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/cache.c
--- ./arch/mips/mm/cache.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/cache.c	2023-04-23 11:58:28.914527000 +0100
@@ -20,6 +20,7 @@
 #include <asm/processor.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
+#include <linux/highmem.h>
 
 /* Cache operations. */
 void (*flush_cache_all)(void);
@@ -32,8 +33,8 @@
 void (*flush_icache_range)(unsigned long start, unsigned long end);
 void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
-void (*__flush_cache_vmap)(void);
-void (*__flush_cache_vunmap)(void);
+void (*__flush_cache_vmap)(unsigned long start, unsigned long end);
+void (*__flush_cache_vunmap)(unsigned long start, unsigned long end);
 
 void (*__flush_kernel_vmap_range)(unsigned long vaddr, int size);
 void (*__invalidate_kernel_vmap_range)(unsigned long vaddr, int size);
@@ -44,10 +45,13 @@
 void (*flush_cache_sigtramp)(unsigned long addr);
 void (*local_flush_data_cache_page)(void * addr);
 void (*flush_data_cache_page)(unsigned long addr);
+void (*mips_flush_data_cache_range)(struct vm_area_struct *vma,
+      struct page *page, unsigned long addr, unsigned long size);
 void (*flush_icache_all)(void);
 
 EXPORT_SYMBOL_GPL(local_flush_data_cache_page);
 EXPORT_SYMBOL(flush_data_cache_page);
+EXPORT_SYMBOL(mips_flush_data_cache_range);
 EXPORT_SYMBOL(flush_icache_all);
 
 #ifdef CONFIG_DMA_NONCOHERENT
@@ -80,12 +84,9 @@
 
 void __flush_dcache_page(struct page *page)
 {
-	struct address_space *mapping = page_mapping(page);
-	unsigned long addr;
+	void *addr;
 
-	if (PageHighMem(page))
-		return;
-	if (mapping && !mapping_mapped(mapping)) {
+	if (page_mapping(page) && !page_mapped(page)) {
 		SetPageDcacheDirty(page);
 		return;
 	}
@@ -95,25 +96,55 @@
 	 * case is for exec env/arg pages and those are %99 certainly going to
 	 * get faulted into the tlb (and thus flushed) anyways.
 	 */
-	addr = (unsigned long) page_address(page);
-	flush_data_cache_page(addr);
+	if (PageHighMem(page)) {
+		addr = kmap_atomic(page);
+		flush_data_cache_page((unsigned long)addr);
+		kunmap_atomic(addr);
+	} else {
+		addr = (void *) page_address(page);
+		flush_data_cache_page((unsigned long)addr);
+	}
+	ClearPageDcacheDirty(page);
 }
 
 EXPORT_SYMBOL(__flush_dcache_page);
 
 void __flush_anon_page(struct page *page, unsigned long vmaddr)
 {
-	unsigned long addr = (unsigned long) page_address(page);
+	if (!PageHighMem(page)) {
+		unsigned long addr = (unsigned long) page_address(page);
 
-	if (pages_do_alias(addr, vmaddr)) {
-		if (page_mapped(page) && !Page_dcache_dirty(page)) {
-			void *kaddr;
-
-			kaddr = kmap_coherent(page, vmaddr);
-			flush_data_cache_page((unsigned long)kaddr);
-			kunmap_coherent();
-		} else
-			flush_data_cache_page(addr);
+		if (pages_do_alias(addr, vmaddr & PAGE_MASK)) {
+			if (page_mapped(page) && !Page_dcache_dirty(page)) {
+				void *kaddr;
+
+				kaddr = kmap_coherent(page, vmaddr);
+				flush_data_cache_page((unsigned long)kaddr);
+				kunmap_coherent();
+			} else {
+				flush_data_cache_page(addr);
+				ClearPageDcacheDirty(page);
+			}
+		}
+	} else {
+		void *laddr = lowmem_page_address(page);
+
+		if (pages_do_alias((unsigned long)laddr, vmaddr & PAGE_MASK)) {
+			if (page_mapped(page) && !Page_dcache_dirty(page)) {
+				void *kaddr;
+
+				kaddr = kmap_coherent(page, vmaddr);
+				flush_data_cache_page((unsigned long)kaddr);
+				kunmap_coherent();
+			} else {
+				void *kaddr;
+
+				kaddr = kmap_atomic(page);
+				flush_data_cache_page((unsigned long)kaddr);
+				kunmap_atomic(kaddr);
+				ClearPageDcacheDirty(page);
+			}
+		}
 	}
 }
 
@@ -127,15 +158,28 @@
 	int exec = (vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc;
 
 	pfn = pte_pfn(pte);
-	if (unlikely(!pfn_valid(pfn)))
+	if (unlikely(!pfn_valid(pfn))) {
+		wmb();
 		return;
+	}
 	page = pfn_to_page(pfn);
-	if (page_mapping(page) && Page_dcache_dirty(page)) {
-		addr = (unsigned long) page_address(page);
-		if (exec || pages_do_alias(addr, address & PAGE_MASK))
+	if (page_mapped(page) && Page_dcache_dirty(page)) {
+		void *kaddr = NULL;
+		if (PageHighMem(page)) {
+			addr = (unsigned long)kmap_atomic(page);
+			kaddr = (void *)addr;
+		} else
+			addr = (unsigned long) page_address(page);
+		if (exec || (cpu_has_dc_aliases &&
+		    pages_do_alias(addr, address & PAGE_MASK))) {
 			flush_data_cache_page(addr);
-		ClearPageDcacheDirty(page);
+			ClearPageDcacheDirty(page);
+		}
+
+		if (kaddr)
+			kunmap_atomic((void *)kaddr);
 	}
+	wmb();  /* finish any outstanding arch cache flushes before ret to user */
 }
 
 unsigned long _page_cachable_default;
diff -ur ./arch/mips/mm/cerr-sb1.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/cerr-sb1.c
--- ./arch/mips/mm/cerr-sb1.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/cerr-sb1.c	2023-04-23 11:58:28.913815700 +0100
@@ -182,11 +182,7 @@
 
 #ifdef CONFIG_SIBYTE_BW_TRACE
 	/* Freeze the trace buffer now */
-#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
-	csr_out32(M_BCM1480_SCD_TRACE_CFG_FREEZE, IOADDR(A_SCD_TRACE_CFG));
-#else
 	csr_out32(M_SCD_TRACE_CFG_FREEZE, IOADDR(A_SCD_TRACE_CFG));
-#endif
 	printk("Trace buffer frozen\n");
 #endif
 
diff -ur ./arch/mips/mm/fault.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/fault.c
--- ./arch/mips/mm/fault.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/fault.c	2023-04-23 11:58:28.992611500 +0100
@@ -198,7 +198,7 @@
 	if (user_mode(regs)) {
 		tsk->thread.cp0_badvaddr = address;
 		tsk->thread.error_code = write;
-#if 0
+#if 1
 		printk("do_page_fault() #2: sending SIGSEGV to %s for "
 		       "invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n",
 		       tsk->comm,
@@ -254,7 +254,7 @@
 	 * Send a sigbus, regardless of whether we were in kernel
 	 * or user mode.
 	 */
-#if 0
+#if 1
 		printk("do_page_fault() #3: sending SIGBUS to %s for "
 		       "invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n",
 		       tsk->comm,
diff -ur ./arch/mips/mm/highmem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/highmem.c
--- ./arch/mips/mm/highmem.c	2023-04-26 12:25:54.980119578 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/highmem.c	2023-04-23 11:58:28.991167900 +0100
@@ -9,6 +9,7 @@
 static pte_t *kmap_pte;
 
 unsigned long highstart_pfn, highend_pfn;
+unsigned int  last_pkmap_nr_arr[FIX_N_COLOURS] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 
 void *kmap(struct page *page)
 {
@@ -53,8 +54,12 @@
 		return page_address(page);
 
 	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+
+	idx = (((unsigned long)lowmem_page_address(page)) >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
+	idx = (FIX_N_COLOURS - idx);
+	idx = idx + FIX_N_COLOURS * (smp_processor_id() + NR_CPUS * type);
+	vaddr = __fix_to_virt(FIX_KMAP_BEGIN - 1 + idx);    /* actually - FIX_CMAP_END */
+
 #ifdef CONFIG_DEBUG_HIGHMEM
 	BUG_ON(!pte_none(*(kmap_pte - idx)));
 #endif
@@ -75,12 +80,16 @@
 		return;
 	}
 
-	type = kmap_atomic_idx();
 #ifdef CONFIG_DEBUG_HIGHMEM
 	{
-		int idx = type + KM_TYPE_NR * smp_processor_id();
+		int idx;
+		type = kmap_atomic_idx();
 
-		BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN + idx));
+		idx = ((unsigned long)kvaddr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
+		idx = (FIX_N_COLOURS - idx);
+		idx = idx + FIX_N_COLOURS * (smp_processor_id() + NR_CPUS * type);
+
+		BUG_ON(vaddr != __fix_to_virt(FIX_KMAP_BEGIN -1 + idx));
 
 		/*
 		 * force other mappings to Oops if they'll try to access
@@ -95,26 +104,6 @@
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
-/*
- * This is the same as kmap_atomic() but can map memory that doesn't
- * have a struct page associated with it.
- */
-void *kmap_atomic_pfn(unsigned long pfn)
-{
-	unsigned long vaddr;
-	int idx, type;
-
-	pagefault_disable();
-
-	type = kmap_atomic_idx_push();
-	idx = type + KM_TYPE_NR*smp_processor_id();
-	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
-	set_pte(kmap_pte-idx, pfn_pte(pfn, PAGE_KERNEL));
-	flush_tlb_one(vaddr);
-
-	return (void*) vaddr;
-}
-
 struct page *kmap_atomic_to_page(void *ptr)
 {
 	unsigned long idx, vaddr = (unsigned long)ptr;
@@ -124,7 +113,7 @@
 		return virt_to_page(ptr);
 
 	idx = virt_to_fix(vaddr);
-	pte = kmap_pte - (idx - FIX_KMAP_BEGIN);
+	pte = kmap_pte - (idx - FIX_KMAP_BEGIN + 1);
 	return pte_page(*pte);
 }
 
@@ -133,6 +122,6 @@
 	unsigned long kmap_vstart;
 
 	/* cache the first kmap pte */
-	kmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN);
+	kmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN - 1); /* actually - FIX_CMAP_END */
 	kmap_pte = kmap_get_fixmap_pte(kmap_vstart);
 }
diff -ur ./arch/mips/mm/init.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/init.c
--- ./arch/mips/mm/init.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/init.c	2023-04-23 11:58:29.080732700 +0100
@@ -116,14 +116,18 @@
 
 void *kmap_coherent(struct page *page, unsigned long addr)
 {
+#ifdef CONFIG_EVA
+	dump_stack();
+	panic("kmap_coherent");
+#else
+
 	enum fixed_addresses idx;
 	unsigned long vaddr, flags, entrylo;
 	unsigned long old_ctx;
 	pte_t pte;
 	int tlbidx;
 
-	BUG_ON(Page_dcache_dirty(page));
-
+	/* BUG_ON(Page_dcache_dirty(page)); - removed for I-cache flush */
 	inc_preempt_count();
 	idx = (addr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -169,9 +173,11 @@
 	EXIT_CRITICAL(flags);
 
 	return (void*) vaddr;
+#endif /* CONFIG_EVA */
 }
 
-#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+#define UNIQUE_ENTRYHI(idx) (cpu_has_tlbinv ? ((CKSEG0 + ((idx) << (PAGE_SHIFT + 1))) | MIPS_EHINV) : \
+			     (CKSEG0 + ((idx) << (PAGE_SHIFT + 1))))
 
 void kunmap_coherent(void)
 {
@@ -213,9 +219,15 @@
 		copy_page(vto, vfrom);
 		kunmap_atomic(vfrom);
 	}
-	if ((!cpu_has_ic_fills_f_dc) ||
-	    pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK))
+	if (cpu_has_dc_aliases)
+		SetPageDcacheDirty(to);
+	if (((vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc) ||
+	    cpu_has_vtag_dcache || (cpu_has_dc_aliases &&
+	     pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK))) {
 		flush_data_cache_page((unsigned long)vto);
+		if (cpu_has_dc_aliases)
+			ClearPageDcacheDirty(to);
+	}
 	kunmap_atomic(vto);
 	/* Make sure this page is cleared on other CPU's too before using it */
 	smp_wmb();
@@ -225,18 +237,33 @@
 	struct page *page, unsigned long vaddr, void *dst, const void *src,
 	unsigned long len)
 {
+	void *vto = NULL;
+
 	if (cpu_has_dc_aliases &&
 	    page_mapped(page) && !Page_dcache_dirty(page)) {
-		void *vto = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
+		vto = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
 		memcpy(vto, src, len);
-		kunmap_coherent();
 	} else {
 		memcpy(dst, src, len);
 		if (cpu_has_dc_aliases)
 			SetPageDcacheDirty(page);
 	}
-	if ((vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc)
-		flush_cache_page(vma, vaddr, page_to_pfn(page));
+	if (((vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc) ||
+	    (Page_dcache_dirty(page) &&
+	     pages_do_alias((unsigned long)dst & PAGE_MASK,
+			    vaddr & PAGE_MASK))) {
+		if (vto)
+			mips_flush_data_cache_range(vma, page,
+						    (unsigned long)vto, len);
+		else
+			mips_flush_data_cache_range(vma, page,
+						    (unsigned long)dst, len);
+
+		if (cpu_has_dc_aliases)
+			ClearPageDcacheDirty(page);
+	}
+	if (vto)
+		kunmap_coherent();
 }
 
 void copy_from_user_page(struct vm_area_struct *vma,
@@ -248,12 +275,10 @@
 		void *vfrom = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
 		memcpy(dst, vfrom, len);
 		kunmap_coherent();
-	} else {
+	} else
 		memcpy(dst, src, len);
-		if (cpu_has_dc_aliases)
-			SetPageDcacheDirty(page);
-	}
 }
+EXPORT_SYMBOL_GPL(copy_from_user_page);
 
 void __init fixrange_init(unsigned long start, unsigned long end,
 	pgd_t *pgd_base)
@@ -272,11 +297,11 @@
 	k = __pmd_offset(vaddr);
 	pgd = pgd_base + i;
 
-	for ( ; (i < PTRS_PER_PGD) && (vaddr < end); pgd++, i++) {
+	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
 		pud = (pud_t *)pgd;
-		for ( ; (j < PTRS_PER_PUD) && (vaddr < end); pud++, j++) {
+		for ( ; (j < PTRS_PER_PUD) && (vaddr != end); pud++, j++) {
 			pmd = (pmd_t *)pud;
-			for (; (k < PTRS_PER_PMD) && (vaddr < end); pmd++, k++) {
+			for (; (k < PTRS_PER_PMD) && (vaddr != end); pmd++, k++) {
 				if (pmd_none(*pmd)) {
 					pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
 					set_pmd(pmd, __pmd((unsigned long)pte));
@@ -322,7 +347,7 @@
 void __init paging_init(void)
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
-	unsigned long lastpfn __maybe_unused;
+	unsigned long lastpfn;
 
 	pagetable_init();
 
@@ -342,14 +367,6 @@
 #ifdef CONFIG_HIGHMEM
 	max_zone_pfns[ZONE_HIGHMEM] = highend_pfn;
 	lastpfn = highend_pfn;
-
-	if (cpu_has_dc_aliases && max_low_pfn != highend_pfn) {
-		printk(KERN_WARNING "This processor doesn't support highmem."
-		       " %ldk highmem ignored\n",
-		       (highend_pfn - max_low_pfn) << (PAGE_SHIFT - 10));
-		max_zone_pfns[ZONE_HIGHMEM] = max_low_pfn;
-		lastpfn = max_low_pfn;
-	}
 #endif
 
 	free_area_init_nodes(max_zone_pfns);
@@ -447,7 +464,12 @@
 void __init_refok free_initmem(void)
 {
 	prom_free_prom_memory();
+#ifdef CONFIG_EVA
+	free_init_pages("unused memory", __pa_symbol(&__init_begin),
+		__pa_symbol(&__init_end));
+#else
 	free_initmem_default(POISON_FREE_INITMEM);
+#endif
 }
 
 #ifndef CONFIG_MIPS_PGD_C0_CONTEXT
diff -ur ./arch/mips/mm/pgtable-32.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/pgtable-32.c
--- ./arch/mips/mm/pgtable-32.c	2023-04-26 12:25:54.980119578 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/pgtable-32.c	2023-04-23 11:58:29.151596400 +0100
@@ -32,8 +32,11 @@
 
 void __init pagetable_init(void)
 {
+#if defined(CONFIG_HIGHMEM) || defined(FIXADDR_START)
 	unsigned long vaddr;
+	unsigned long vend;
 	pgd_t *pgd_base;
+#endif
 #ifdef CONFIG_HIGHMEM
 	pgd_t *pgd;
 	pud_t *pud;
@@ -46,13 +49,18 @@
 	pgd_init((unsigned long)swapper_pg_dir
 		 + sizeof(pgd_t) * USER_PTRS_PER_PGD);
 
+#ifdef FIXADDR_START
 	pgd_base = swapper_pg_dir;
 
 	/*
 	 * Fixed mappings:
 	 */
-	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
-	fixrange_init(vaddr, vaddr + FIXADDR_SIZE, pgd_base);
+	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1);
+	/* Calculate real end before alignment. */
+	vend = vaddr + FIXADDR_SIZE;
+	vaddr = vaddr & PMD_MASK;
+	fixrange_init(vaddr, vend, pgd_base);
+#endif
 
 #ifdef CONFIG_HIGHMEM
 	/*
diff -ur ./arch/mips/mm/pgtable-64.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/pgtable-64.c
--- ./arch/mips/mm/pgtable-64.c	2023-04-26 12:25:54.980119578 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/pgtable-64.c	2023-04-23 11:58:29.151189300 +0100
@@ -107,5 +107,5 @@
 	 * Fixed mappings:
 	 */
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
-	fixrange_init(vaddr, vaddr + FIXADDR_SIZE, pgd_base);
+	fixrange_init(vaddr, 0, pgd_base);
 }
diff -ur ./arch/mips/mm/sc-mips.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/sc-mips.c
--- ./arch/mips/mm/sc-mips.c	2023-04-26 12:56:04.230118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/sc-mips.c	2023-04-23 11:58:29.150332100 +0100
@@ -7,6 +7,7 @@
 #include <linux/mm.h>
 
 #include <asm/mipsregs.h>
+#include <asm/gcmpregs.h>
 #include <asm/bcache.h>
 #include <asm/cacheops.h>
 #include <asm/page.h>
@@ -23,7 +24,11 @@
  */
 static void mips_sc_wback_inv(unsigned long addr, unsigned long size)
 {
+	if (!cpu_has_cm2)
+		__sync();
 	blast_scache_range(addr, addr + size);
+	if (cpu_has_cm2_l2sync)
+		*(unsigned long *)(_gcmp_base + GCMP_L2SYNC_OFFSET) = 0;
 }
 
 /*
@@ -73,8 +78,10 @@
 	/* Check the bypass bit (L2B) */
 	switch (c->cputype) {
 	case CPU_34K:
-	case CPU_74K:
 	case CPU_1004K:
+	case CPU_74K:
+	case CPU_PROAPTIV:	/* proAptiv havn't L2B capability but ... */
+	case CPU_INTERAPTIV:
 	case CPU_BMIPS5000:
 		if (config2 & (1 << 12))
 			return 0;
@@ -138,6 +145,7 @@
 	if (found) {
 		mips_sc_enable();
 		bcops = &mips_sc_ops;
-	}
+	} else
+		cpu_data[0].options &= ~MIPS_CPU_CM2_L2SYNC;
 	return found;
 }
diff -ur ./arch/mips/mm/tlb-r4k.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/tlb-r4k.c
--- ./arch/mips/mm/tlb-r4k.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/tlb-r4k.c	2023-04-23 11:58:29.232433100 +0100
@@ -27,7 +27,8 @@
  * Make sure all entries differ.  If they're not different
  * MIPS32 will take revenge ...
  */
-#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+#define UNIQUE_ENTRYHI(idx) (cpu_has_tlbinv ? ((CKSEG0 + ((idx) << (PAGE_SHIFT + 1))) | MIPS_EHINV) : \
+			     (CKSEG0 + ((idx) << (PAGE_SHIFT + 1))))
 
 /* Atomicity and interruptability */
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -72,6 +73,7 @@
 	unsigned long flags;
 	unsigned long old_ctx;
 	int entry;
+	int ftlbhighset;
 
 	ENTER_CRITICAL(flags);
 	/* Save old context and create impossible VPN2 value */
@@ -82,14 +84,29 @@
 	entry = read_c0_wired();
 
 	/* Blast 'em all away. */
-	while (entry < current_cpu_data.tlbsize) {
-		/* Make sure all entries differ. */
-		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
-		write_c0_index(entry);
-		mtc0_tlbw_hazard();
-		tlb_write_indexed();
-		entry++;
-	}
+	if (cpu_has_tlbinv) {
+		if (current_cpu_data.tlbsizevtlb) {
+			write_c0_index(0);
+			mtc0_tlbw_hazard();
+			tlbinvf();  /* invalide VTLB */
+		}
+		ftlbhighset = current_cpu_data.tlbsizevtlb + current_cpu_data.tlbsizeftlbsets;
+		for (entry=current_cpu_data.tlbsizevtlb;
+		     entry < ftlbhighset;
+		     entry++) {
+			write_c0_index(entry);
+			mtc0_tlbw_hazard();
+			tlbinvf();  /* invalide one FTLB set */
+		}
+	} else
+		while (entry < current_cpu_data.tlbsize) {
+			/* Make sure all entries differ. */
+			write_c0_entryhi(UNIQUE_ENTRYHI(entry));
+			write_c0_index(entry);
+			mtc0_tlbw_hazard();
+			tlb_write_indexed();
+			entry++;
+		}
 	tlbw_use_hazard();
 	write_c0_entryhi(old_ctx);
 	FLUSH_ITLB;
@@ -127,7 +144,8 @@
 		start = round_down(start, PAGE_SIZE << 1);
 		end = round_up(end, PAGE_SIZE << 1);
 		size = (end - start) >> (PAGE_SHIFT + 1);
-		if (size <= current_cpu_data.tlbsize/2) {
+		if ((current_cpu_data.tlbsizeftlbsets && (size <= current_cpu_data.tlbsize/8)) ||
+		    ((!current_cpu_data.tlbsizeftlbsets) && (size <= current_cpu_data.tlbsize/2))) {
 			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
 
@@ -166,7 +184,8 @@
 	ENTER_CRITICAL(flags);
 	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	size = (size + 1) >> 1;
-	if (size <= current_cpu_data.tlbsize / 2) {
+	if ((current_cpu_data.tlbsizeftlbsets && (size <= current_cpu_data.tlbsize/8)) ||
+	    ((!current_cpu_data.tlbsizeftlbsets) && (size <= current_cpu_data.tlbsize/2))) {
 		int pid = read_c0_entryhi();
 
 		start &= (PAGE_MASK << 1);
diff -ur ./arch/mips/mm/tlbex.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/tlbex.c
--- ./arch/mips/mm/tlbex.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mm/tlbex.c	2023-04-23 11:58:29.313250500 +0100
@@ -520,6 +520,7 @@
 		switch (current_cpu_type()) {
 		case CPU_M14KC:
 		case CPU_74K:
+		case CPU_PROAPTIV:
 			break;
 
 		default:
@@ -973,9 +974,17 @@
 #endif
 	uasm_i_mfc0(p, tmp, C0_BADVADDR); /* get faulting address */
 	uasm_i_lw(p, ptr, uasm_rel_lo(pgdc), ptr);
+
+	if (cpu_has_mips32r2) {
+		uasm_i_ext(p, tmp, tmp, PGDIR_SHIFT, (32 - PGDIR_SHIFT));
+		uasm_i_ins(p, ptr, tmp, PGD_T_LOG2, (32 - PGDIR_SHIFT));
+		return;
+	}
+
 	uasm_i_srl(p, tmp, tmp, PGDIR_SHIFT); /* get pgd only bits */
 	uasm_i_sll(p, tmp, tmp, PGD_T_LOG2);
 	uasm_i_addu(p, ptr, ptr, tmp); /* add in pgd offset */
+
 }
 
 #endif /* !CONFIG_64BIT */
@@ -1008,6 +1017,17 @@
 
 static void __cpuinit build_get_ptep(u32 **p, unsigned int tmp, unsigned int ptr)
 {
+#ifndef CONFIG_64BIT
+	if (cpu_has_mips_r2) {
+		/* For MIPS32R2, PTE ptr offset is obtained from BadVAddr */
+		UASM_i_MFC0(p, tmp, C0_BADVADDR);
+		UASM_i_LW(p, ptr, 0, ptr);
+		uasm_i_ext(p, tmp, tmp, PAGE_SHIFT+1, PGDIR_SHIFT-PAGE_SHIFT-1);
+		uasm_i_ins(p, ptr, tmp, PTE_T_LOG2+1, PGDIR_SHIFT-PAGE_SHIFT-1);
+		return;
+	}
+#endif /* CONFIG_64BIT */
+
 	/*
 	 * Bug workaround for the Nevada. It seems as if under certain
 	 * circumstances the move from cp0_context might produce a
@@ -1935,6 +1955,19 @@
 		uasm_i_nop(&p);
 
 		uasm_i_tlbr(&p);
+
+		switch (current_cpu_type()) {
+		default:
+			if (cpu_has_mips_r2) {
+				uasm_i_ehb(&p);
+
+		case CPU_CAVIUM_OCTEON:
+		case CPU_CAVIUM_OCTEON_PLUS:
+		case CPU_CAVIUM_OCTEON2:
+				break;
+			}
+		}
+
 		/* Examine  entrylo 0 or 1 based on ptr. */
 		if (use_bbit_insns()) {
 			uasm_i_bbit0(&p, wr.r2, ilog2(sizeof(pte_t)), 8);
@@ -1989,6 +2022,19 @@
 		uasm_i_nop(&p);
 
 		uasm_i_tlbr(&p);
+
+		switch (current_cpu_type()) {
+		default:
+			if (cpu_has_mips_r2) {
+				uasm_i_ehb(&p);
+
+		case CPU_CAVIUM_OCTEON:
+		case CPU_CAVIUM_OCTEON_PLUS:
+		case CPU_CAVIUM_OCTEON2:
+				break;
+			}
+		}
+
 		/* Examine  entrylo 0 or 1 based on ptr. */
 		if (use_bbit_insns()) {
 			uasm_i_bbit0(&p, wr.r2, ilog2(sizeof(pte_t)), 8);
diff -ur ./arch/mips/mti-malta/malta-init.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-init.c
--- ./arch/mips/mti-malta/malta-init.c	2023-04-26 12:25:54.990119584 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-init.c	2023-04-23 11:58:29.472462200 +0100
@@ -84,10 +84,15 @@
 	extern char except_vec_nmi;
 
 	base = cpu_has_veic ?
+#ifndef CONFIG_EVA
 		(void *)(CAC_BASE + 0xa80) :
 		(void *)(CAC_BASE + 0x380);
+#else
+		(void *)(YAMON_BASE + 0xa80) :
+		(void *)(YAMON_BASE + 0x380);
+#endif
 	memcpy(base, &except_vec_nmi, 0x80);
-	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+	local_flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
 }
 
 static void __init mips_ejtag_setup(void)
@@ -96,12 +101,18 @@
 	extern char except_vec_ejtag_debug;
 
 	base = cpu_has_veic ?
+#ifndef CONFIG_EVA
 		(void *)(CAC_BASE + 0xa00) :
 		(void *)(CAC_BASE + 0x300);
+#else
+		(void *)(YAMON_BASE + 0xa00) :
+		(void *)(YAMON_BASE + 0x300);
+#endif
 	memcpy(base, &except_vec_ejtag_debug, 0x80);
-	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+	local_flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
 }
 
+void __init prom_mem_check(int niocu);
 extern struct plat_smp_ops msmtc_smp_ops;
 
 void __init prom_init(void)
@@ -230,9 +241,39 @@
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_MEM_SHF |
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_BAR0_SHF);
 #endif
-		/* Fix up target memory mapping.  */
+		/* Fix up target memory mapping. */
+#ifndef CONFIG_EVA
 		MSC_READ(MSC01_PCI_BAR0, mask);
 		MSC_WRITE(MSC01_PCI_P2SCMSKL, mask & MSC01_PCI_BAR0_SIZE_MSK);
+#else
+#ifdef CONFIG_EVA_OLD_MALTA_MAP
+		/* Classic (old) Malta memory map:
+		   Setup the Malta max (2GB) memory for PCI DMA in host bridge
+		   in transparent addressing mode, starting from 80000000.
+		   Don't believe in registers content */
+		mask = 0x80000008;
+		MSC_WRITE(MSC01_PCI_BAR0, mask);
+
+		mask = 0x80000000;
+		MSC_WRITE(MSC01_PCI_HEAD4, mask);
+		MSC_WRITE(MSC01_PCI_P2SCMSKL, mask);
+		MSC_WRITE(MSC01_PCI_P2SCMAPL, mask);
+#else
+		/* New Malta memory map:
+		   Setup the Malta max memory (2G) for PCI DMA in host bridge
+		   in transparent addressing mode, starting from 00000000.
+		   Don't believe in registers content */
+		mask = 0x80000008;
+		MSC_WRITE(MSC01_PCI_BAR0, mask);
+
+		mask = 0x00000000;
+		MSC_WRITE(MSC01_PCI_HEAD4, mask);
+		mask = 0x80000000;
+		MSC_WRITE(MSC01_PCI_P2SCMSKL, mask);
+		mask = 0x00000000;
+		MSC_WRITE(MSC01_PCI_P2SCMAPL, mask);
+#endif
+#endif
 
 		/* Don't handle target retries indefinitely.  */
 		if ((data & MSC01_PCI_CFG_MAXRTRY_MSK) ==
@@ -268,9 +309,13 @@
 	console_config();
 #endif
 	/* Early detection of CMP support */
-	if (gcmp_probe(GCMP_BASE_ADDR, GCMP_ADDRSPACE_SZ))
+	if (gcmp_probe(GCMP_BASE_ADDR, GCMP_ADDRSPACE_SZ)) {
+#if defined(CONFIG_EVA) && !defined(CONFIG_EVA_OLD_MALTA_MAP)
+		prom_mem_check(gcmp_niocu());
+#endif
 		if (!register_cmp_smp_ops())
 			return;
+	}
 
 	if (!register_vsmp_smp_ops())
 		return;
diff -ur ./arch/mips/mti-malta/malta-int.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-int.c
--- ./arch/mips/mti-malta/malta-int.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-int.c	2023-04-23 11:58:29.468871600 +0100
@@ -48,7 +48,7 @@
 
 int gcmp_present = -1;
 static unsigned long _msc01_biu_base;
-static unsigned long _gcmp_base;
+unsigned long _gcmp_base;
 static unsigned int ipi_map[NR_CPUS];
 
 static DEFINE_RAW_SPINLOCK(mips_irq_lock);
@@ -422,20 +422,62 @@
  */
 int __init gcmp_probe(unsigned long addr, unsigned long size)
 {
-	if (mips_revision_sconid != MIPS_REVISION_SCON_ROCIT) {
+	unsigned long confaddr = 0;
+
+	if ((mips_revision_sconid != MIPS_REVISION_SCON_ROCIT) &&
+	    (mips_revision_sconid != MIPS_REVISION_SCON_GT64120)) {
 		gcmp_present = 0;
+		pr_debug("GCMP NOT present\n");
 		return gcmp_present;
 	}
 
 	if (gcmp_present >= 0)
 		return gcmp_present;
 
-	_gcmp_base = (unsigned long) ioremap_nocache(GCMP_BASE_ADDR, GCMP_ADDRSPACE_SZ);
-	_msc01_biu_base = (unsigned long) ioremap_nocache(MSC01_BIU_REG_BASE, MSC01_BIU_ADDRSPACE_SZ);
-	gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == GCMP_BASE_ADDR;
+	if (cpu_has_mips_r2 && (read_c0_config3() & MIPS_CONF3_CMGCR)) {
+		/* try CMGCRBase */
+		confaddr = read_c0_cmgcrbase() << 4;
+		_gcmp_base = (unsigned long) ioremap_nocache(confaddr, GCMP_ADDRSPACE_SZ);
+		gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == confaddr;
+		if (gcmp_present) {
+			/* reassign it to 'addr' */
+			if (addr != confaddr)
+				GCMPGCB(GCMPB) = (GCMPGCB(GCMPB) & ~GCMP_GCB_GCMPB_GCMPBASE_MSK) | addr;
+			_gcmp_base = (unsigned long) ioremap_nocache(addr , GCMP_ADDRSPACE_SZ);
+			gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == confaddr;
+			confaddr = addr;
+			if (!gcmp_present) {
+				/* reassignment failed, try CMGCRBase again */
+				confaddr = read_c0_cmgcrbase() << 4;
+				_gcmp_base = (unsigned long) ioremap_nocache(confaddr, GCMP_ADDRSPACE_SZ);
+				gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == confaddr;
+			}
+		}
+	}
+	if (gcmp_present <= 0) {
+		/* try addr */
+		_gcmp_base = (unsigned long) ioremap_nocache(addr, GCMP_ADDRSPACE_SZ);
+		gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == addr;
+		confaddr = addr;
+	}
+	if (gcmp_present <= 0) {
+		/* try GCMP_BASE_ADDR */
+		_gcmp_base = (unsigned long) ioremap_nocache(GCMP_BASE_ADDR, GCMP_ADDRSPACE_SZ);
+		gcmp_present = (GCMPGCB(GCMPB) & GCMP_GCB_GCMPB_GCMPBASE_MSK) == GCMP_BASE_ADDR;
+		confaddr = GCMP_BASE_ADDR;
+	}
+//        _msc01_biu_base = (unsigned long) ioremap_nocache(MSC01_BIU_REG_BASE, MSC01_BIU_ADDRSPACE_SZ);
 
-	if (gcmp_present)
-		pr_debug("GCMP present\n");
+	if (gcmp_present) {
+		printk("GCMP present\n");
+		if (GCMPGCB(GCMPREV) >= 6)
+			cpu_data[0].options |= MIPS_CPU_CM2;
+		if (cpu_has_cm2 && (size > 0x8000)) {
+			GCMPGCB(GCML2S) = (confaddr + 0x8000) | 1;
+			cpu_data[0].options |= MIPS_CPU_CM2_L2SYNC;
+			printk("L2-only SYNC available\n");
+		}
+	}
 	return gcmp_present;
 }
 
@@ -471,7 +513,7 @@
 {
 	int cpu;
 
-	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+	for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
 		fill_ipi_map1(gic_resched_int_base, cpu, GIC_CPU_INT1);
 		fill_ipi_map1(gic_call_int_base, cpu, GIC_CPU_INT2);
 	}
@@ -572,12 +614,11 @@
 		/* FIXME */
 		int i;
 #if defined(CONFIG_MIPS_MT_SMP)
-		gic_call_int_base = GIC_NUM_INTRS - NR_CPUS;
-		gic_resched_int_base = gic_call_int_base - NR_CPUS;
+		gic_call_int_base = GIC_NUM_INTRS -
+			(NR_CPUS - nr_cpu_ids) * 2 - nr_cpu_ids;
+		gic_resched_int_base = gic_call_int_base - nr_cpu_ids;
 		fill_ipi_map();
 #endif
-		gic_init(GIC_BASE_ADDR, GIC_ADDRSPACE_SZ, gic_intr_map,
-				ARRAY_SIZE(gic_intr_map), MIPS_GIC_IRQ_BASE);
 		if (!gcmp_present) {
 			/* Enable the GIC */
 			i = REG(_msc01_biu_base, MSC01_SC_CFG);
@@ -585,6 +626,8 @@
 				(i | (0x1 << MSC01_SC_CFG_GICENA_SHF));
 			pr_debug("GIC Enabled\n");
 		}
+		gic_init(GIC_BASE_ADDR, GIC_ADDRSPACE_SZ, gic_intr_map,
+				ARRAY_SIZE(gic_intr_map), MIPS_GIC_IRQ_BASE);
 #if defined(CONFIG_MIPS_MT_SMP)
 		/* set up ipi interrupts */
 		if (cpu_has_vint) {
@@ -597,7 +640,7 @@
 		printk("CPU%d: status register now %08x\n", smp_processor_id(), read_c0_status());
 		write_c0_status(0x1100dc00);
 		printk("CPU%d: status register frc %08x\n", smp_processor_id(), read_c0_status());
-		for (i = 0; i < NR_CPUS; i++) {
+		for (i = 0; i < nr_cpu_ids; i++) {
 			arch_init_ipiirq(MIPS_GIC_IRQ_BASE +
 					 GIC_RESCHED_INT(i), &irq_resched);
 			arch_init_ipiirq(MIPS_GIC_IRQ_BASE +
diff -ur ./arch/mips/mti-malta/malta-memory.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-memory.c
--- ./arch/mips/mti-malta/malta-memory.c	2023-04-26 12:25:54.990119584 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-memory.c	2023-04-23 11:58:29.555114800 +0100
@@ -21,10 +21,19 @@
 
 static fw_memblock_t mdesc[FW_MAX_MEMBLOCKS];
 
-/* determined physical memory size, not overridden by command line args	 */
+#ifdef DEBUG
+static char *mtypes[3] = {
+	"Dont use memory",
+	"YAMON PROM memory",
+	"Free memmory",
+};
+#endif
+
+/* determined physical memory size, not overridden by command line args  */
 unsigned long physical_memsize = 0L;
 
-fw_memblock_t * __init fw_getmdesc(void)
+#ifndef CONFIG_EVA
+static inline fw_memblock_t * __init prom_getmdesc(void)
 {
 	char *memsize_str, *ptr;
 	unsigned int memsize;
@@ -93,6 +102,153 @@
 	return &mdesc[0];
 }
 
+#else
+
+static unsigned newMapType;
+
+static inline fw_memblock_t * __init prom_getevamdesc(void)
+{
+	char *memsize_str;
+	char *ememsize_str;
+	unsigned long memsize = 0;
+	unsigned long ememsize = 0;
+	char *ptr;
+	static char cmdline[COMMAND_LINE_SIZE] __initdata;
+
+	/* otherwise look in the environment */
+	memsize_str = fw_getenv("memsize");
+#ifdef DEBUG
+	pr_debug("prom_memsize = %s\n", memsize_str);
+#endif
+	if (memsize_str)
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	ememsize_str = fw_getenv("ememsize");
+#ifdef DEBUG
+	pr_debug("fw_ememsize = %s\n", ememsize_str);
+#endif
+	if (ememsize_str)
+		ememsize = simple_strtol(ememsize_str, NULL, 0);
+
+	if ((!memsize) && !ememsize) {
+		printk(KERN_WARNING
+		       "memsize not set in boot prom, set to default (32Mb)\n");
+		physical_memsize = 0x02000000;
+	} else {
+		physical_memsize = ememsize;
+		if (!physical_memsize)
+			physical_memsize = memsize;
+	}
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	/* SOC-it swaps, or perhaps doesn't swap, when DMA'ing the last
+	   word of physical memory */
+	physical_memsize -= PAGE_SIZE;
+#endif
+
+	memsize = 0;
+	/* Check the command line for a memsize directive that overrides
+	   the physical/default amount */
+	strcpy(cmdline, arcs_cmdline);
+	ptr = strstr(cmdline, " memsize=");
+	if (ptr && (ptr != cmdline))
+		memsize = memparse(ptr + 9, &ptr);
+	ptr = strstr(cmdline, " ememsize=");
+	if (ptr && (ptr != cmdline))
+		memsize = memparse(ptr + 10, &ptr);
+	if (!memsize) {
+		ptr = strstr(cmdline, "memsize=");
+		if (ptr && (ptr != cmdline))
+			memsize = memparse(ptr + 8, &ptr);
+		ptr = strstr(cmdline, "ememsize=");
+		if (ptr && (ptr != cmdline))
+			memsize = memparse(ptr + 9, &ptr);
+	}
+	if (!memsize)
+		memsize = physical_memsize;
+
+	if ((memsize == 0x10000000) && !ememsize)
+		if ((!ptr) || (ptr == cmdline)) {
+			printk("YAMON reports memsize=256M but doesn't report ememsize option\n");
+			printk("If you install > 256MB memory, upgrade YAMON or use boot option memsize=XXXM\n");
+		}
+	newMapType = *((unsigned int *)CKSEG1ADDR(0xbf403004));
+	printk("System Controller register = %0x\n",newMapType);
+	newMapType &= 0x100;    /* extract map type bit */
+#ifdef CONFIG_EVA_OLD_MALTA_MAP
+	if (newMapType)
+		panic("Malta board has new memory map layout but kernel is configured for legacy map\n");
+	/* Don't use last 64KB - it is just for macros arithmetics overflow */
+	if (memsize > 0x7fff0000)
+		memsize = 0x7fff0000;
+#endif
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = fw_dontuse;
+	mdesc[0].base = PHYS_OFFSET;
+	mdesc[0].size = 0x00001000;
+
+	mdesc[1].type = fw_code;
+	mdesc[1].base = mdesc[0].base + 0x00001000UL;
+	mdesc[1].size = 0x000ef000;
+
+	/*
+	 * The area 0x000f0000-0x000fffff is allocated for BIOS memory by the
+	 * south bridge and PCI access always forwarded to the ISA Bus and
+	 * BIOSCS# is always generated.
+	 * This mean that this area can't be used as DMA memory for PCI
+	 * devices.
+	 */
+	mdesc[2].type = fw_dontuse;
+	mdesc[2].base = mdesc[0].base + 0x000f0000UL;
+	mdesc[2].size = 0x00010000;
+
+	mdesc[3].type = fw_dontuse;
+	mdesc[3].base = mdesc[0].base + 0x00100000UL;
+	mdesc[3].size = CPHYSADDR(PFN_ALIGN((unsigned long)&_end)) - 0x00100000UL;
+
+#ifndef CONFIG_EVA_OLD_MALTA_MAP
+	if (memsize > 0x20000000) {
+		/* first 256MB */
+		mdesc[4].type = fw_free;
+		mdesc[4].base = mdesc[0].base + CPHYSADDR(PFN_ALIGN(&_end));
+		mdesc[4].size = mdesc[0].base + 0x10000000 - CPHYSADDR(mdesc[4].base);
+
+		/* I/O hole ... */
+
+		/* the rest of memory (256MB behind hole is lost) */
+		mdesc[5].type = fw_free;
+		mdesc[5].base = mdesc[0].base + 0x20000000;
+		mdesc[5].size = memsize - 0x20000000;
+	} else {
+		/* limit to 256MB, exclude I/O hole */
+		memsize = (memsize > 0x10000000)? 0x10000000 : memsize;
+
+		mdesc[4].type = fw_free;
+		mdesc[4].base = mdesc[0].base + CPHYSADDR(PFN_ALIGN(&_end));
+		mdesc[4].size = memsize - CPHYSADDR(mdesc[4].base);
+	}
+#else
+	mdesc[4].type = fw_free;
+	mdesc[4].base = mdesc[0].base + CPHYSADDR(PFN_ALIGN(&_end));
+	mdesc[4].size = memsize - CPHYSADDR(mdesc[4].base);
+#endif
+	return &mdesc[0];
+}
+
+#ifndef CONFIG_EVA_OLD_MALTA_MAP
+void __init prom_mem_check(int niocu)
+{
+	if (!newMapType) {
+		if (niocu && mdesc[5].size) {
+			printk(KERN_WARNING "Malta board has legacy memory map + IOCU, but kernel is configured for new map layout, restrict memsize to 256MB\n");
+			boot_mem_map.nr_map--;
+		}
+	}
+}
+#endif /* !CONFIG_EVA_OLD_MALTA_MAP */
+#endif /* CONFIG_EVA */
+
 static int __init fw_memtype_classify(unsigned int type)
 {
 	switch (type) {
@@ -105,10 +261,34 @@
 	}
 }
 
+fw_memblock_t __init *fw_getmdesc(void)
+{
+	fw_memblock_t *p;
+
+#ifndef CONFIG_EVA
+	p = prom_getmdesc();
+#else
+	p = prom_getevamdesc();
+#endif
+	return p;
+}
+
 void __init fw_meminit(void)
 {
 	fw_memblock_t *p;
 
+#ifdef DEBUG
+	pr_debug("YAMON MEMORY DESCRIPTOR dump:\n");
+	p = fw_getmdesc();
+
+	while (p->size) {
+		int i = 0;
+		pr_debug("[%d,%p]: base<%08lx> size<%x> type<%s>\n",
+			 i, p, p->base, p->size, mtypes[p->type]);
+		p++;
+		i++;
+	}
+#endif
 	p = fw_getmdesc();
 
 	while (p->size) {
diff -ur ./arch/mips/mti-malta/malta-pci.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-pci.c
--- ./arch/mips/mti-malta/malta-pci.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-pci.c	2023-04-23 11:58:29.554716100 +0100
@@ -198,6 +198,12 @@
 		MSC_READ(MSC01_PCI_SC2PMBASL, start);
 		MSC_READ(MSC01_PCI_SC2PMMSKL, mask);
 		MSC_READ(MSC01_PCI_SC2PMMAPL, map);
+#if defined(CONFIG_EVA) && !defined(CONFIG_EVA_OLD_MALTA_MAP)
+		/* shift PCI devices to upper 2GB, to prevent PCI bridges loop */
+		map |= 0xa0000000;
+		MSC_WRITE(MSC01_PCI_SC2PMMAPL, map);
+		MSC_READ(MSC01_PCI_SC2PMMAPL, map);
+#endif
 		msc_mem_resource.start = start & mask;
 		msc_mem_resource.end = (start & mask) | ~mask;
 		msc_controller.mem_offset = (start & mask) - (map & mask);
diff -ur ./arch/mips/mti-malta/malta-platform.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-platform.c
--- ./arch/mips/mti-malta/malta-platform.c	2023-04-26 12:25:54.990119584 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-platform.c	2023-04-23 11:58:29.554319900 +0100
@@ -47,6 +47,7 @@
 static struct plat_serial8250_port uart8250_data[] = {
 	SMC_PORT(0x3F8, 4),
 	SMC_PORT(0x2F8, 3),
+#ifndef CONFIG_MIPS_CMP
 	{
 		.mapbase	= 0x1f000900,	/* The CBUS UART */
 		.irq		= MIPS_CPU_IRQ_BASE + MIPSCPU_INT_MB2,
@@ -55,6 +56,7 @@
 		.flags		= CBUS_UART_FLAGS,
 		.regshift	= 3,
 	},
+#endif
 	{ },
 };
 
diff -ur ./arch/mips/mti-malta/malta-reset.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-reset.c
--- ./arch/mips/mti-malta/malta-reset.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-reset.c	2023-04-23 11:58:29.553917900 +0100
@@ -1,33 +1,18 @@
 /*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
  * Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
- *
- * ########################################################################
- *
- *  This program is free software; you can distribute it and/or modify it
- *  under the terms of the GNU General Public License (Version 2) as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
- *
- * ########################################################################
- *
- * Reset the MIPS boards.
- *
  */
-#include <linux/init.h>
+#include <linux/io.h>
 #include <linux/pm.h>
 
-#include <asm/io.h>
 #include <asm/reboot.h>
-#include <asm/mips-boards/generic.h>
+
+#define SOFTRES_REG	0x1f000500
+#define GORESET		0x42
 
 static void mips_machine_restart(char *command)
 {
@@ -45,7 +30,6 @@
 	__raw_writel(GORESET, softres_reg);
 }
 
-
 static int __init mips_reboot_setup(void)
 {
 	_machine_restart = mips_machine_restart;
@@ -54,5 +38,4 @@
 
 	return 0;
 }
-
 arch_initcall(mips_reboot_setup);
diff -ur ./arch/mips/mti-malta/malta-setup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-setup.c
--- ./arch/mips/mti-malta/malta-setup.c	2023-04-26 12:25:55.000119591 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-malta/malta-setup.c	2023-04-23 11:58:29.553441800 +0100
@@ -130,8 +130,9 @@
 	} else if (gcmp_niocu() != 0) {
 		/* Nothing special needs to be done to enable coherency */
 		pr_info("CMP IOCU detected\n");
-		if ((*(unsigned int *)0xbf403000 & 0x81) != 0x81) {
-			pr_crit("IOCU OPERATION DISABLED BY SWITCH - DEFAULTING TO SW IO COHERENCY\n");
+		if ((*(unsigned int *)CKSEG1ADDR(0xbf403000) & 0x81) != 0x81) {
+			pr_crit("IOCU OPERATION DISABLED BY SWITCH"
+				" - DEFAULTING TO SW IO COHERENCY\n");
 			return 0;
 		}
 		supported = 1;
@@ -243,10 +244,143 @@
 #endif
 }
 
+#ifdef CONFIG_EVA
+extern unsigned int mips_cca;
+
+void __init plat_eva_setup(void)
+{
+	unsigned int val;
+
+#ifdef CONFIG_EVA_OLD_MALTA_MAP
+
+#ifdef CONFIG_EVA_3GB
+	val = ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl0(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+#else /* !CONFIG_EVA_3G */
+	val = ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl0(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+#endif /* CONFIG_EVA_3G */
+#ifdef CONFIG_SMP
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+#else
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(4 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+#endif
+	write_c0_segctl1(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(6 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(4 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+
+#else /* !CONFIG_EVA_OLD_MALTA_MAP */
+
+#ifdef CONFIG_EVA_3GB
+	val = ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl0(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(6 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(5 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl1(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(3 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(1 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+#else /* !CONFIG_EVA_3G */
+	val = ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl0(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (2 << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+	write_c0_segctl1(val);
+
+	val = ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(2 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT));
+	val |= (((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |
+		(0 << MIPS_SEGCFG_PA_SHIFT) | (mips_cca << MIPS_SEGCFG_C_SHIFT) |
+		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16);
+#endif /* CONFIG_EVA_3G */
+
+#endif /* CONFIG_EVA_OLD_MALTA_MAP */
+
+	write_c0_segctl2(val);
+	back_to_back_c0_hazard();
+
+	val = read_c0_config5();
+	write_c0_config5(val|MIPS_CONF5_K|MIPS_CONF5_CV);
+	back_to_back_c0_hazard();
+
+	printk("Enhanced Virtual Addressing (EVA) active\n");
+}
+
+extern int gcmp_present;
+void BEV_overlay_segment(void);
+#endif
+
 void __init plat_mem_setup(void)
 {
 	unsigned int i;
 
+#ifdef CONFIG_EVA
+#ifdef CONFIG_MIPS_CMP
+	if (gcmp_present)
+		BEV_overlay_segment();
+#endif
+
+	if ((cpu_has_segments) && (cpu_has_eva))
+		plat_eva_setup();
+	else {
+	    printk("cpu_has_segments=%ld cpu_has_eva=%ld\n",cpu_has_segments,cpu_has_eva);
+	    printk("Kernel is built for EVA support but EVA or segment control registers are not found\n");
+	    panic("EVA absent");
+	}
+#endif
+
 	mips_pcibios_init();
 
 	/* Request I/O space for devices used on the Malta board. */
diff -ur ./arch/mips/mti-sead3/sead3-reset.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-sead3/sead3-reset.c
--- ./arch/mips/mti-sead3/sead3-reset.c	2023-04-26 12:56:04.240118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/mti-sead3/sead3-reset.c	2023-04-23 11:58:29.868946700 +0100
@@ -9,7 +9,9 @@
 #include <linux/pm.h>
 
 #include <asm/reboot.h>
-#include <asm/mips-boards/generic.h>
+
+#define SOFTRES_REG	0x1f000050
+#define GORESET		0x4d
 
 static void mips_machine_restart(char *command)
 {
@@ -35,5 +37,4 @@
 
 	return 0;
 }
-
 arch_initcall(mips_reboot_setup);
diff -ur ./arch/mips/oprofile/common.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/oprofile/common.c
--- ./arch/mips/oprofile/common.c	2023-04-26 12:25:55.010119597 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/oprofile/common.c	2023-04-23 11:58:30.515188400 +0100
@@ -86,6 +86,7 @@
 	case CPU_1004K:
 	case CPU_74K:
 	case CPU_LOONGSON1:
+	case CPU_INTERAPTIV:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_R10000:
diff -ur ./arch/mips/oprofile/op_model_mipsxx.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/oprofile/op_model_mipsxx.c
--- ./arch/mips/oprofile/op_model_mipsxx.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/oprofile/op_model_mipsxx.c	2023-04-23 11:58:30.513910000 +0100
@@ -376,6 +376,14 @@
 		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;
 
+	case CPU_PROAPTIV:
+		op_model_mipsxx_ops.cpu_type = "mips/proAptiv";
+		break;
+
+	case CPU_INTERAPTIV:
+		op_model_mipsxx_ops.cpu_type = "mips/interAptiv";
+		break;
+
 	case CPU_5KC:
 		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;
diff -ur ./arch/mips/pci/pci-bcm1480.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pci/pci-bcm1480.c
--- ./arch/mips/pci/pci-bcm1480.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pci/pci-bcm1480.c	2023-04-23 11:58:31.234189600 +0100
@@ -39,6 +39,7 @@
 #include <linux/mm.h>
 #include <linux/console.h>
 #include <linux/tty.h>
+#include <linux/vt.h>
 
 #include <asm/sibyte/bcm1480_regs.h>
 #include <asm/sibyte/bcm1480_scd.h>
diff -ur ./arch/mips/pci/pci-octeon.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pci/pci-octeon.c
--- ./arch/mips/pci/pci-octeon.c	2023-04-26 12:25:55.030119610 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pci/pci-octeon.c	2023-04-23 11:58:31.391901100 +0100
@@ -586,15 +586,16 @@
 	else
 		octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_BIG;
 
-	/* PCI I/O and PCI MEM values */
-	set_io_port_base(OCTEON_PCI_IOSPACE_BASE);
-	ioport_resource.start = 0;
-	ioport_resource.end = OCTEON_PCI_IOSPACE_SIZE - 1;
 	if (!octeon_is_pci_host()) {
 		pr_notice("Not in host mode, PCI Controller not initialized\n");
 		return 0;
 	}
 
+	/* PCI I/O and PCI MEM values */
+	set_io_port_base(OCTEON_PCI_IOSPACE_BASE);
+	ioport_resource.start = 0;
+	ioport_resource.end = OCTEON_PCI_IOSPACE_SIZE - 1;
+
 	pr_notice("%s Octeon big bar support\n",
 		  (octeon_dma_bar_type ==
 		  OCTEON_DMA_BAR_TYPE_BIG) ? "Enabling" : "Disabling");
diff -ur ./arch/mips/pnx833x/common/platform.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pnx833x/common/platform.c
--- ./arch/mips/pnx833x/common/platform.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/pnx833x/common/platform.c	2023-04-23 11:58:32.031961600 +0100
@@ -206,11 +206,13 @@
 		.end   = PNX8335_IP3902_PORTS_END,
 		.flags = IORESOURCE_MEM,
 	},
+#ifdef CONFIG_SOC_PNX8335
 	[1] = {
 		.start = PNX8335_PIC_ETHERNET_INT,
 		.end   = PNX8335_PIC_ETHERNET_INT,
 		.flags = IORESOURCE_IRQ,
 	},
+#endif
 };
 
 static struct platform_device pnx833x_ethernet_device = {
diff -ur ./arch/mips/powertv/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/Kconfig
--- ./arch/mips/powertv/Kconfig	2023-04-26 12:25:55.040119616 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/Kconfig	2023-04-23 11:58:32.275454400 +0100
@@ -1,14 +1,7 @@
-config BOOTLOADER_DRIVER
-	bool "PowerTV Bootloader Driver Support"
-	default n
-	depends on POWERTV
-	help
-	  Use this option if you want to load bootloader driver.
-
 config BOOTLOADER_FAMILY
 	string "POWERTV Bootloader Family string"
 	default "85"
-	depends on POWERTV && !BOOTLOADER_DRIVER
+	depends on POWERTV
 	help
 	  This value should be specified when the bootloader driver is disabled
 	  and must be exactly two characters long. Families supported are:
diff -ur ./arch/mips/powertv/asic/asic_devices.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/asic/asic_devices.c
--- ./arch/mips/powertv/asic/asic_devices.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/asic/asic_devices.c	2023-04-23 11:58:32.495838900 +0100
@@ -147,20 +147,10 @@
 	if (check_forcefamily(forced_family) == 0)
 		bootldr_family = BOOTLDRFAMILY(forced_family[0],
 			forced_family[1]);
-	else {
-
-#ifdef CONFIG_BOOTLOADER_DRIVER
-		bootldr_family = (unsigned short) kbldr_GetSWFamily();
-#else
-#if defined(CONFIG_BOOTLOADER_FAMILY)
+	else
 		bootldr_family = (unsigned short) BOOTLDRFAMILY(
 			CONFIG_BOOTLOADER_FAMILY[0],
 			CONFIG_BOOTLOADER_FAMILY[1]);
-#else
-#error "Unknown Bootloader Family"
-#endif
-#endif
-	}
 
 	pr_info("Bootloader Family = 0x%04X\n", bootldr_family);
 
@@ -529,17 +519,7 @@
  */
 void platform_release_memory(void *ptr, int size)
 {
-	unsigned long addr;
-	unsigned long end;
-
-	addr = ((unsigned long)ptr + (PAGE_SIZE - 1)) & PAGE_MASK;
-	end = ((unsigned long)ptr + size) & PAGE_MASK;
-
-	for (; addr < end; addr += PAGE_SIZE) {
-		ClearPageReserved(virt_to_page(__va(addr)));
-		init_page_count(virt_to_page(__va(addr)));
-		free_page((unsigned long)__va(addr));
-	}
+	free_reserved_area(ptr, ptr + size, -1, NULL);
 }
 EXPORT_SYMBOL(platform_release_memory);
 
diff -ur ./arch/mips/powertv/init.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/init.c
--- ./arch/mips/powertv/init.c	2023-04-26 12:25:55.050119622 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/init.c	2023-04-23 11:58:32.593845400 +0100
@@ -87,8 +87,4 @@
 
 	configure_platform();
 	prom_meminit();
-
-#ifndef CONFIG_BOOTLOADER_DRIVER
-	pr_info("\nBootloader driver isn't loaded...\n");
-#endif
 }
diff -ur ./arch/mips/powertv/reset.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/reset.c
--- ./arch/mips/powertv/reset.c	2023-04-26 12:25:55.050119622 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/powertv/reset.c	2023-04-23 11:58:32.753022300 +0100
@@ -21,24 +21,12 @@
 #include <linux/io.h>
 #include <asm/reboot.h>			/* Not included by linux/reboot.h */
 
-#ifdef CONFIG_BOOTLOADER_DRIVER
-#include <asm/mach-powertv/kbldr.h>
-#endif
-
 #include <asm/mach-powertv/asic_regs.h>
 #include "reset.h"
 
 static void mips_machine_restart(char *command)
 {
-#ifdef CONFIG_BOOTLOADER_DRIVER
-	/*
-	 * Call the bootloader's reset function to ensure
-	 * that persistent data is flushed before hard reset
-	 */
-	kbldr_SetCauseAndReset();
-#else
 	writel(0x1, asic_reg_addr(watchdog));
-#endif
 }
 
 void mips_reboot_setup(void)
diff -ur ./arch/mips/sibyte/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/Kconfig
--- ./arch/mips/sibyte/Kconfig	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/Kconfig	2023-04-23 11:58:34.430076000 +0100
@@ -147,7 +147,8 @@
 
 config SIBYTE_BUS_WATCHER
 	bool "Support for Bus Watcher statistics"
-	depends on SIBYTE_SB1xxx_SOC
+	depends on SIBYTE_SB1xxx_SOC && \
+		(SIBYTE_BCM112X || SIBYTE_SB1250)
 	help
 	  Handle and keep statistics on the bus error interrupts (COR_ECC,
 	  BAD_ECC, IO_BUS).
diff -ur ./arch/mips/sibyte/Platform /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/Platform
--- ./arch/mips/sibyte/Platform	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/Platform	2023-04-23 11:58:34.429076700 +0100
@@ -41,3 +41,4 @@
 load-$(CONFIG_SIBYTE_SENTOSA)	:= 0xffffffff80100000
 load-$(CONFIG_SIBYTE_SWARM)	:= 0xffffffff80100000
 load-$(CONFIG_SIBYTE_BIGSUR)	:= 0xffffffff80100000
+load-$(CONFIG_SIBYTE_LITTLESUR) := 0xffffffff80100000
diff -ur ./arch/mips/sibyte/common/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/common/Makefile
--- ./arch/mips/sibyte/common/Makefile	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/common/Makefile	2023-04-23 11:58:34.597180400 +0100
@@ -1,3 +1,4 @@
 obj-y := cfe.o
+obj-$(CONFIG_SIBYTE_BUS_WATCHER)	+= bus_watcher.o
 obj-$(CONFIG_SIBYTE_CFE_CONSOLE)	+= cfe_console.o
 obj-$(CONFIG_SIBYTE_TBPROF)		+= sb_tbprof.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/common: bus_watcher.c
diff -ur ./arch/mips/sibyte/common/sb_tbprof.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/common/sb_tbprof.c
--- ./arch/mips/sibyte/common/sb_tbprof.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/common/sb_tbprof.c	2023-04-23 11:58:34.671604800 +0100
@@ -27,6 +27,7 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/sched.h>
 #include <linux/vmalloc.h>
 #include <linux/fs.h>
 #include <linux/errno.h>
diff -ur ./arch/mips/sibyte/sb1250/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/sb1250/Makefile
--- ./arch/mips/sibyte/sb1250/Makefile	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sibyte/sb1250/Makefile	2023-04-23 11:58:34.671206400 +0100
@@ -1,4 +1,3 @@
 obj-y := setup.o irq.o time.o
 
 obj-$(CONFIG_SMP)			+= smp.o
-obj-$(CONFIG_SIBYTE_BUS_WATCHER)	+= bus_watcher.o
Only in ./arch/mips/sibyte/sb1250: bus_watcher.c
diff -ur ./arch/mips/sni/pcimt.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sni/pcimt.c
--- ./arch/mips/sni/pcimt.c	2023-04-26 12:56:04.250118963 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/sni/pcimt.c	2023-04-23 11:58:35.073202400 +0100
@@ -185,6 +185,7 @@
 
 extern struct pci_ops sni_pcimt_ops;
 
+#ifdef CONFIG_PCI
 static struct pci_controller sni_controller = {
 	.pci_ops	= &sni_pcimt_ops,
 	.mem_resource	= &sni_mem_resource,
@@ -193,6 +194,7 @@
 	.io_offset	= 0x00000000UL,
 	.io_map_base	= SNI_PORT_BASE
 };
+#endif
 
 static void enable_pcimt_irq(struct irq_data *d)
 {
diff -ur ./arch/mips/txx9/generic/setup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/txx9/generic/setup.c
--- ./arch/mips/txx9/generic/setup.c	2023-04-26 12:25:55.100119654 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips/txx9/generic/setup.c	2023-04-23 11:58:35.552724900 +0100
@@ -350,7 +350,7 @@
 	}
 
 	/* select "default" board */
-#ifdef CONFIG_CPU_TX39XX
+#ifdef CONFIG_TOSHIBA_JMR3927
 	txx9_board_vec = &jmr3927_vec;
 #endif
 #ifdef CONFIG_CPU_TX49XX
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/mips: xburst
Only in ./arch/sh/boot/compressed: vmlinux.scr
Only in ./arch/sh/boot/romimage: vmlinux.scr
diff -ur ./arch/x86/include/asm/idle.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/x86/include/asm/idle.h
--- ./arch/x86/include/asm/idle.h	2023-04-26 12:25:58.030121427 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/x86/include/asm/idle.h	2023-04-23 12:00:36.912112600 +0100
@@ -1,13 +1,6 @@
 #ifndef _ASM_X86_IDLE_H
 #define _ASM_X86_IDLE_H
 
-#define IDLE_START 1
-#define IDLE_END 2
-
-struct notifier_block;
-void idle_notifier_register(struct notifier_block *n);
-void idle_notifier_unregister(struct notifier_block *n);
-
 #ifdef CONFIG_X86_64
 void enter_idle(void);
 void exit_idle(void);
diff -ur ./arch/x86/kernel/process.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/x86/kernel/process.c
--- ./arch/x86/kernel/process.c	2023-04-26 12:56:04.570118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/arch/x86/kernel/process.c	2023-04-23 12:00:44.355098600 +0100
@@ -40,19 +40,6 @@
 
 #ifdef CONFIG_X86_64
 static DEFINE_PER_CPU(unsigned char, is_idle);
-static ATOMIC_NOTIFIER_HEAD(idle_notifier);
-
-void idle_notifier_register(struct notifier_block *n)
-{
-	atomic_notifier_chain_register(&idle_notifier, n);
-}
-EXPORT_SYMBOL_GPL(idle_notifier_register);
-
-void idle_notifier_unregister(struct notifier_block *n)
-{
-	atomic_notifier_chain_unregister(&idle_notifier, n);
-}
-EXPORT_SYMBOL_GPL(idle_notifier_unregister);
 #endif
 
 struct kmem_cache *task_xstate_cachep;
@@ -257,14 +244,14 @@
 void enter_idle(void)
 {
 	this_cpu_write(is_idle, 1);
-	atomic_notifier_call_chain(&idle_notifier, IDLE_START, NULL);
+	idle_notifier_call_chain(IDLE_START);
 }
 
 static void __exit_idle(void)
 {
 	if (x86_test_and_clear_bit_percpu(0, is_idle) == 0)
 		return;
-	atomic_notifier_call_chain(&idle_notifier, IDLE_END, NULL);
+	idle_notifier_call_chain(IDLE_END);
 }
 
 /* Called from interrupts to signify idle end */
diff -ur ./block/genhd.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/genhd.c
--- ./block/genhd.c	2023-04-26 12:56:04.710118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/genhd.c	2023-04-23 12:00:58.841706000 +0100
@@ -1107,6 +1107,22 @@
 		blk_put_queue(disk->queue);
 	kfree(disk);
 }
+
+static int disk_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+	int cnt = 0;
+
+	disk_part_iter_init(&piter, disk, 0);
+	while((part = disk_part_iter_next(&piter)))
+		cnt++;
+	disk_part_iter_exit(&piter);
+	add_uevent_var(env, "NPARTS=%u", cnt);
+	return 0;
+}
+
 struct class block_class = {
 	.name		= "block",
 };
@@ -1126,6 +1142,7 @@
 	.groups		= disk_attr_groups,
 	.release	= disk_release,
 	.devnode	= block_devnode,
+	.uevent		= disk_uevent,
 };
 
 #ifdef CONFIG_PROC_FS
diff -ur ./block/partition-generic.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/partition-generic.c
--- ./block/partition-generic.c	2023-04-26 12:25:58.920121426 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/partition-generic.c	2023-04-23 12:00:58.909158000 +0100
@@ -216,10 +216,21 @@
 	kfree(p);
 }
 
+static int part_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct hd_struct *part = dev_to_part(dev);
+
+	add_uevent_var(env, "PARTN=%u", part->partno);
+	if (part->info && part->info->volname[0])
+		add_uevent_var(env, "PARTNAME=%s", part->info->volname);
+	return 0;
+}
+
 struct device_type part_type = {
 	.name		= "partition",
 	.groups		= part_attr_groups,
 	.release	= part_release,
+	.uevent		= part_uevent,
 };
 
 static void delete_partition_rcu_cb(struct rcu_head *head)
diff -ur ./block/partitions/efi.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/partitions/efi.c
--- ./block/partitions/efi.c	2023-04-26 12:25:58.930121426 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/block/partitions/efi.c	2023-04-23 12:00:59.071306900 +0100
@@ -34,7 +34,7 @@
  * - Ported to 2.5.7-pre1 and 2.5.7-dj2
  * - Applied patch to avoid fault in alternate header handling
  * - cleaned up find_valid_gpt
- * - On-disk structure and copy in memory is *always* LE now - 
+ * - On-disk structure and copy in memory is *always* LE now -
  *   swab fields as needed
  * - remove print_gpt_header()
  * - only use first max_p partition entries, to keep the kernel minor number
@@ -51,7 +51,7 @@
  * - moved le_efi_guid_to_cpus() back into this file.  GPT is the only
  *   thing that keeps EFI GUIDs on disk.
  * - Changed gpt structure names and members to be simpler and more Linux-like.
- * 
+ *
  * Wed Oct 17 2001 Matt Domsch <Matt_Domsch@dell.com>
  * - Removed CONFIG_DEVFS_VOLUMES_UUID code entirely per Martin Wilck
  *
@@ -76,7 +76,7 @@
  *
  * Wed Jun  6 2001 Martin Wilck <Martin.Wilck@Fujitsu-Siemens.com>
  * - added devfs volume UUID support (/dev/volumes/uuids) for
- *   mounting file systems by the partition GUID. 
+ *   mounting file systems by the partition GUID.
  *
  * Tue Dec  5 2000 Matt Domsch <Matt_Domsch@dell.com>
  * - Moved crc32() to linux/lib, added efi_crc32().
@@ -100,6 +100,24 @@
 #include "check.h"
 #include "efi.h"
 
+#define MAKE_SIGNATURE32( a, b, c, d ) \
+        (((u32)(u8)(d)       ) | \
+        ( (u32)(u8)(c) << 8  ) | \
+        ( (u32)(u8)(b) << 16 ) | \
+        ( (u32)(u8)(a) << 24 ) )
+
+#define INGENIC_SIGNATURE  (MAKE_SIGNATURE32('I','N','G','E'))
+
+typedef struct _custom_mbr {
+	u8 boot_code[432];
+	u32 custom_signature;
+	u32 gpt_header_lba;  // gpt header position
+	__le32 unique_mbr_signature;
+	__le16 unknown;
+	struct partition partition_record[4];
+	__le16 signature;
+} __attribute__ ((packed)) custom_mbr;
+
 /* This allows a kernel command line option 'gpt' to override
  * the test for invalid PMBR.  Not __initdata because reloading
  * the partition tables happens after init too.
@@ -120,7 +138,7 @@
  * @len - length of buf
  *
  * Description: Returns EFI-style CRC32 value for @buf
- * 
+ *
  * This function uses the little endian Ethernet polynomial
  * but seeds the function with ~0, and xor's with ~0 at the end.
  * Note, the EFI Specification, v1.02, has a reference to
@@ -135,7 +153,7 @@
 /**
  * last_lba(): return number of last logical block of device
  * @bdev: block device
- * 
+ *
  * Description: Returns last LBA value on success, 0 on error.
  * This is stored (by sd and ide-geometry) in
  *  the part[0] entry for this disk, and is the number of
@@ -220,7 +238,7 @@
  * alloc_read_gpt_entries(): reads partition entries from disk
  * @state
  * @gpt - GPT header
- * 
+ *
  * Description: Returns ptes on success,  NULL on error.
  * Allocates space for PTEs based on information found in @gpt.
  * Notes: remember to free pte when you're done!
@@ -238,7 +256,7 @@
                 le32_to_cpu(gpt->sizeof_partition_entry);
 	if (!count)
 		return NULL;
-	pte = kmalloc(count, GFP_KERNEL);
+	pte = kzalloc(count, GFP_KERNEL);
 	if (!pte)
 		return NULL;
 
@@ -256,7 +274,7 @@
  * alloc_read_gpt_header(): Allocates GPT header, reads into it from disk
  * @state
  * @lba is the Logical Block Address of the partition table
- * 
+ *
  * Description: returns GPT header on success, NULL on error.   Allocates
  * and fills a GPT header starting at @ from @state->bdev.
  * Note: remember to free gpt when finished with it.
@@ -267,7 +285,7 @@
 	gpt_header *gpt;
 	unsigned ssz = bdev_logical_block_size(state->bdev);
 
-	gpt = kmalloc(ssz, GFP_KERNEL);
+	gpt = kzalloc(ssz, GFP_KERNEL);
 	if (!gpt)
 		return NULL;
 
@@ -352,6 +370,7 @@
 	 * within the disk.
 	 */
 	lastlba = last_lba(state->bdev);
+
 	if (le64_to_cpu((*gpt)->first_usable_lba) > lastlba) {
 		pr_debug("GPT: first_usable_lba incorrect: %lld > %lld\n",
 			 (unsigned long long)le64_to_cpu((*gpt)->first_usable_lba),
@@ -359,10 +378,11 @@
 		goto fail;
 	}
 	if (le64_to_cpu((*gpt)->last_usable_lba) > lastlba) {
+		(*gpt)->last_usable_lba = lastlba;
 		pr_debug("GPT: last_usable_lba incorrect: %lld > %lld\n",
 			 (unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),
 			 (unsigned long long)lastlba);
-		goto fail;
+		//goto fail;
 	}
 
 	/* Check that sizeof_partition_entry has the correct value */
@@ -420,7 +440,7 @@
  * @lastlba is the last LBA number
  * Description: Returns nothing.  Sanity checks pgpt and agpt fields
  * and prints warnings on discrepancies.
- * 
+ *
  */
 static void
 compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
@@ -537,11 +557,13 @@
 	gpt_entry *pptes = NULL, *aptes = NULL;
 	legacy_mbr *legacymbr;
 	u64 lastlba;
+	u64 gpt_header_lba = GPT_PRIMARY_PARTITION_TABLE_LBA;
 
 	if (!ptes)
 		return 0;
 
 	lastlba = last_lba(state->bdev);
+
         if (!force_gpt) {
                 /* This will be added to the EFI Spec. per Intel after v1.02. */
                 legacymbr = kzalloc(sizeof (*legacymbr), GFP_KERNEL);
@@ -549,13 +571,24 @@
                         read_lba(state, 0, (u8 *) legacymbr,
 				 sizeof (*legacymbr));
                         good_pmbr = is_pmbr_valid(legacymbr);
+
+                        if (good_pmbr) {
+                            custom_mbr * tmp_mbr = (custom_mbr*)legacymbr;
+                            if (tmp_mbr->custom_signature == INGENIC_SIGNATURE) {
+                                gpt_header_lba = tmp_mbr->gpt_header_lba;
+                                if (gpt_header_lba == 0) {
+                                    gpt_header_lba = GPT_PRIMARY_PARTITION_TABLE_LBA;
+                                }
+                            }
+                        }
+
                         kfree(legacymbr);
                 }
                 if (!good_pmbr)
                         goto fail;
         }
 
-	good_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,
+	good_pgpt = is_gpt_valid(state, gpt_header_lba,
 				 &pgpt, &pptes);
         if (good_pgpt)
 		good_agpt = is_gpt_valid(state,
@@ -577,7 +610,7 @@
                 kfree(agpt);
                 kfree(aptes);
                 if (!good_agpt) {
-                        printk(KERN_WARNING 
+                        printk(KERN_WARNING
 			       "Alternate GPT is invalid, "
                                "using primary GPT.\n");
                 }
@@ -588,7 +621,7 @@
                 *ptes = aptes;
                 kfree(pgpt);
                 kfree(pptes);
-                printk(KERN_WARNING 
+                printk(KERN_WARNING
                        "Primary GPT is invalid, using alternate GPT.\n");
                 return 1;
         }
@@ -628,6 +661,7 @@
 	gpt_entry *ptes = NULL;
 	u32 i;
 	unsigned ssz = bdev_logical_block_size(state->bdev) / 512;
+	u8 unparsed_guid[37];
 
 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
@@ -656,7 +690,11 @@
 			state->parts[i + 1].flags = ADDPART_FLAG_RAID;
 
 		info = &state->parts[i + 1].info;
-		efi_guid_unparse(&ptes[i].unique_partition_guid, info->uuid);
+		/* Instead of doing a manual swap to big endian, reuse the
+		 * common ASCII hex format as the interim.
+		 */
+		efi_guid_unparse(&ptes[i].unique_partition_guid, unparsed_guid);
+		part_pack_uuid(unparsed_guid, info->uuid);
 
 		/* Naively convert UTF16-LE to 7 bits. */
 		label_max = min(sizeof(info->volname) - 1,
diff -ur ./crypto/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto/Kconfig
--- ./crypto/Kconfig	2023-04-26 12:56:04.720118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto/Kconfig	2023-04-23 12:00:59.390178300 +0100
@@ -1361,6 +1361,22 @@
 	help
 	  This is the 842 algorithm.
 
+config CRYPTO_LZ4
+	tristate "LZ4 compression algorithm"
+	select CRYPTO_ALGAPI
+	select LZ4_COMPRESS
+	select LZ4_DECOMPRESS
+	help
+	  This is the LZ4 algorithm.
+
+config CRYPTO_LZ4HC
+	tristate "LZ4HC compression algorithm"
+	select CRYPTO_ALGAPI
+	select LZ4HC_COMPRESS
+	select LZ4_DECOMPRESS
+	help
+	  This is the LZ4 high compression mode algorithm.
+
 comment "Random Number Generation"
 
 config CRYPTO_ANSI_CPRNG
diff -ur ./crypto/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto/Makefile
--- ./crypto/Makefile	2023-04-26 12:56:04.720118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto/Makefile	2023-04-23 12:00:59.469694300 +0100
@@ -85,6 +85,8 @@
 obj-$(CONFIG_CRYPTO_CRC32) += crc32.o
 obj-$(CONFIG_CRYPTO_AUTHENC) += authenc.o authencesn.o
 obj-$(CONFIG_CRYPTO_LZO) += lzo.o
+obj-$(CONFIG_CRYPTO_LZ4) += lz4.o
+obj-$(CONFIG_CRYPTO_LZ4HC) += lz4hc.o
 obj-$(CONFIG_CRYPTO_842) += 842.o
 obj-$(CONFIG_CRYPTO_RNG2) += rng.o
 obj-$(CONFIG_CRYPTO_RNG2) += krng.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto: lz4.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/crypto: lz4hc.c
diff -ur ./drivers/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/Kconfig
--- ./drivers/Kconfig	2023-04-26 12:56:04.720118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/Kconfig	2023-04-23 12:01:01.388263400 +0100
@@ -100,6 +100,8 @@
 
 source "drivers/leds/Kconfig"
 
+source "drivers/switch/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
@@ -166,4 +168,8 @@
 
 source "drivers/reset/Kconfig"
 
+source "drivers/nand/Kconfig"
+
+#source "drivers/dmic/Kconfig"
+
 endmenu
diff -ur ./drivers/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/Makefile
--- ./drivers/Makefile	2023-04-26 12:56:04.720118962 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/Makefile	2023-04-23 12:01:01.387679400 +0100
@@ -111,6 +111,7 @@
 obj-y				+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-y				+= leds/
+obj-$(CONFIG_SWITCH)		+= switch/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
@@ -152,3 +153,10 @@
 obj-$(CONFIG_VME_BUS)		+= vme/
 obj-$(CONFIG_IPACK_BUS)		+= ipack/
 obj-$(CONFIG_NTB)		+= ntb/
+obj-$(CONFIG_NAND)  +=nand/
+#obj-$(CONFIG_JZ_TS_DMIC)  +=dmic/
+
+
+
+
+
diff -ur ./drivers/base/power/main.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/base/power/main.c
--- ./drivers/base/power/main.c	2023-04-26 12:25:59.800123403 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/base/power/main.c	2023-04-23 12:01:09.150564500 +0100
@@ -29,6 +29,8 @@
 #include <linux/async.h>
 #include <linux/suspend.h>
 #include <linux/cpuidle.h>
+#include <linux/timer.h>
+
 #include "../base.h"
 #include "power.h"
 
@@ -54,6 +56,12 @@
 static DEFINE_MUTEX(dpm_list_mtx);
 static pm_message_t pm_transition;
 
+struct dpm_watchdog {
+	struct device		*dev;
+	struct task_struct	*tsk;
+	struct timer_list	timer;
+};
+
 static int async_error;
 
 /**
@@ -384,6 +392,56 @@
 	return error;
 }
 
+/**
+ * dpm_wd_handler - Driver suspend / resume watchdog handler.
+ *
+ * Called when a driver has timed out suspending or resuming.
+ * There's not much we can do here to recover so BUG() out for
+ * a crash-dump
+ */
+static void dpm_wd_handler(unsigned long data)
+{
+	struct dpm_watchdog *wd = (void *)data;
+	struct device *dev      = wd->dev;
+	struct task_struct *tsk = wd->tsk;
+
+	dev_emerg(dev, "**** DPM device timeout ****\n");
+	show_stack(tsk, NULL);
+
+	BUG();
+}
+
+/**
+ * dpm_wd_set - Enable pm watchdog for given device.
+ * @wd: Watchdog. Must be allocated on the stack.
+ * @dev: Device to handle.
+ */
+static void dpm_wd_set(struct dpm_watchdog *wd, struct device *dev)
+{
+	struct timer_list *timer = &wd->timer;
+
+	wd->dev = dev;
+	wd->tsk = get_current();
+
+	init_timer_on_stack(timer);
+	timer->expires = jiffies + HZ * 12;
+	timer->function = dpm_wd_handler;
+	timer->data = (unsigned long)wd;
+	add_timer(timer);
+}
+
+/**
+ * dpm_wd_clear - Disable pm watchdog.
+ * @wd: Watchdog to disable.
+ */
+static void dpm_wd_clear(struct dpm_watchdog *wd)
+{
+	struct timer_list *timer = &wd->timer;
+
+	del_timer_sync(timer);
+	destroy_timer_on_stack(timer);
+}
+
 /*------------------------- Resume routines -------------------------*/
 
 /**
@@ -570,6 +628,7 @@
 	pm_callback_t callback = NULL;
 	char *info = NULL;
 	int error = 0;
+	struct dpm_watchdog wd;
 
 	TRACE_DEVICE(dev);
 	TRACE_RESUME(0);
@@ -585,6 +644,7 @@
 	 * a resumed device, even if the device hasn't been completed yet.
 	 */
 	dev->power.is_prepared = false;
+	dpm_wd_set(&wd, dev);
 
 	if (!dev->power.is_suspended)
 		goto Unlock;
@@ -636,6 +696,7 @@
 
  Unlock:
 	device_unlock(dev);
+	dpm_wd_clear(&wd);
 
  Complete:
 	complete_all(&dev->power.completion);
@@ -1053,6 +1114,7 @@
 	pm_callback_t callback = NULL;
 	char *info = NULL;
 	int error = 0;
+	struct dpm_watchdog wd;
 
 	dpm_wait_for_children(dev, async);
 
@@ -1075,6 +1137,8 @@
 
 	if (dev->power.syscore)
 		goto Complete;
+	
+	dpm_wd_set(&wd, dev);
 
 	device_lock(dev);
 
@@ -1131,6 +1195,8 @@
 
 	device_unlock(dev);
 
+	dpm_wd_clear(&wd);
+
  Complete:
 	complete_all(&dev->power.completion);
 	if (error)
diff -ur ./drivers/base/power/wakeup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/base/power/wakeup.c
--- ./drivers/base/power/wakeup.c	2023-04-26 12:56:04.830118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/base/power/wakeup.c	2023-04-23 12:01:09.309311600 +0100
@@ -659,6 +659,23 @@
 }
 EXPORT_SYMBOL_GPL(pm_wakeup_event);
 
+int get_active_wakeup_sources(char *buf)
+{
+	struct wakeup_source *ws;
+	int count = 0;
+
+	count += sprintf(buf+count,"active wakeup source:\n");
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry) {
+		if (ws->active) {
+			count += sprintf(buf+count, "%s ", ws->name);
+		}
+	}
+	rcu_read_unlock();
+	count += sprintf(buf+count,"\n");
+	return count;
+}
+
 static void print_active_wakeup_sources(void)
 {
 	struct wakeup_source *ws;
diff -ur ./drivers/block/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/block/Kconfig
--- ./drivers/block/Kconfig	2023-04-26 12:56:04.840118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/block/Kconfig	2023-04-23 12:01:09.968705200 +0100
@@ -105,6 +105,8 @@
 
 source "drivers/block/mtip32xx/Kconfig"
 
+source "drivers/block/zram/Kconfig"
+
 config BLK_CPQ_DA
 	tristate "Compaq SMART2 support"
 	depends on PCI && VIRT_TO_BUS
diff -ur ./drivers/block/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/block/Makefile
--- ./drivers/block/Makefile	2023-04-26 12:25:59.880123991 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/block/Makefile	2023-04-23 12:01:09.968200200 +0100
@@ -41,6 +41,7 @@
 obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
 
 obj-$(CONFIG_BLK_DEV_RSXX) += rsxx/
+obj-$(CONFIG_ZRAM) += zram/
 
 nvme-y		:= nvme-core.o nvme-scsi.o
 swim_mod-y	:= swim.o swim_asm.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/block: zram
diff -ur ./drivers/char/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/Kconfig
--- ./drivers/char/Kconfig	2023-04-26 12:56:04.890118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/Kconfig	2023-04-23 12:01:13.069040800 +0100
@@ -6,6 +6,47 @@
 
 source "drivers/tty/Kconfig"
 
+config JZ_VP
+	bool "Virtual Privilege device driver"
+	default n
+	help
+	  Say Y here if you want to support Virtual Privilege device. The
+	  Virtual Privilege device supports flush cache and get phyaddr.
+	  When in doubt, say "N".
+
+config JZ_DMIC_V12
+	bool "Ingenic Dmic Driver"
+	default n
+	help
+		Say Y here if you want to support DMIC on your board. The Dmic Driver
+		support record and wakeup function. When in doubt, Say N here.
+config JZ_DMIC_WAKEUP
+	bool "Ingenic Voice Wakeup Driver"
+	depends on JZ_DMIC_V12
+	default n
+	help
+		Say Y here if you want to use voice wakeup function. The Voice Wakeup
+		Driver support voice wakeup. when in doubt , Say N here.
+config TEST_SECOND_REFRESH
+	bool "Ingenic Test second refresh for watch(test driver.)"
+	default n
+	help
+		This is a test driver for second refresh, this will remap tlb when system sleep.
+		do not choose this unless you know what you are doing.
+
+config DEVMEM
+	bool "Memory device driver"
+	default y
+	help
+	  The memory driver provides two character devices, mem and kmem, which
+	  provide access to the system's memory. The mem device is a view of
+	  physical memory, and each byte in the device corresponds to the
+	  matching physical address. The kmem device is the same as mem, but
+	  the addresses correspond to the kernel's virtual address space rather
+	  than physical memory. These devices are standard parts of a Linux
+	  system and most users should say Y here. You might say N if very
+	  security conscience or memory is tight.
+
 config DEVKMEM
 	bool "/dev/kmem virtual device support"
 	default y
@@ -584,6 +625,10 @@
 	depends on ISA || PCI
 	default y
 
+config DCC_TTY
+	tristate "DCC tty driver"
+	depends on ARM
+
 source "drivers/s390/char/Kconfig"
 
 config MSM_SMD_PKT
diff -ur ./drivers/char/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/Makefile
--- ./drivers/char/Makefile	2023-04-26 12:26:00.140125900 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/Makefile	2023-04-23 12:01:13.068522100 +0100
@@ -56,9 +56,16 @@
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
+obj-$(CONFIG_JZ_VP)     += jz_virtual_privilege.o
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
+
+obj-$(CONFIG_JZ_DMIC_V12)	+= voice_wakeup/
+obj-$(CONFIG_JZ_DMIC_V12)	+= jz_dmic.o
+obj-$(CONFIG_JZ_DMIC_WAKEUP) += jz_wakeup.o
+obj-$(CONFIG_TEST_SECOND_REFRESH)	+= second_refresh/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: dcc_tty.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: jz_dmic.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: jz_virtual_privilege.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: jz_wakeup.c
diff -ur ./drivers/char/mem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/mem.c
--- ./drivers/char/mem.c	2023-04-26 12:56:04.910118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char/mem.c	2023-04-23 12:01:14.838009600 +0100
@@ -60,6 +60,7 @@
 }
 #endif
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 #ifdef CONFIG_STRICT_DEVMEM
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
@@ -85,7 +86,9 @@
 	return 1;
 }
 #endif
+#endif
 
+#ifdef CONFIG_DEVMEM
 void __weak unxlate_dev_mem_ptr(unsigned long phys, void *addr)
 {
 }
@@ -212,6 +215,9 @@
 	*ppos += written;
 	return written;
 }
+#endif	/* CONFIG_DEVMEM */
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 
 int __weak phys_mem_access_prot_allowed(struct file *file,
 	unsigned long pfn, unsigned long size, pgprot_t *vma_prot)
@@ -333,6 +339,7 @@
 	}
 	return 0;
 }
+#endif	/* CONFIG_DEVMEM */
 
 #ifdef CONFIG_DEVKMEM
 static int mmap_kmem(struct file *file, struct vm_area_struct *vma)
@@ -727,6 +734,8 @@
 	return file->f_pos = 0;
 }
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
+
 /*
  * The memory devices use the full 32/64 bits of the offset, and so we cannot
  * check against negative addresses: they are ok. The return value is weird,
@@ -760,10 +769,14 @@
 	return ret;
 }
 
+#endif
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
 static int open_port(struct inode *inode, struct file *filp)
 {
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
+#endif
 
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
@@ -774,6 +787,7 @@
 #define open_kmem	open_mem
 #define open_oldmem	open_mem
 
+#ifdef CONFIG_DEVMEM
 static const struct file_operations mem_fops = {
 	.llseek		= memory_lseek,
 	.read		= read_mem,
@@ -782,6 +796,7 @@
 	.open		= open_mem,
 	.get_unmapped_area = get_unmapped_area_mem,
 };
+#endif
 
 #ifdef CONFIG_DEVKMEM
 static const struct file_operations kmem_fops = {
@@ -851,7 +866,9 @@
 	const struct file_operations *fops;
 	struct backing_dev_info *dev_info;
 } devlist[] = {
+#ifdef CONFIG_DEVMEM
 	 [1] = { "mem", 0, &mem_fops, &directly_mappable_cdev_bdi },
+#endif
 #ifdef CONFIG_DEVKMEM
 	 [2] = { "kmem", 0, &kmem_fops, &directly_mappable_cdev_bdi },
 #endif
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: second_refresh
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/char: voice_wakeup
diff -ur ./drivers/cpufreq/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/Makefile
--- ./drivers/cpufreq/Makefile	2023-04-26 12:56:04.970118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/Makefile	2023-04-23 12:01:21.465113000 +0100
@@ -50,7 +50,7 @@
 # LITTLE drivers, so that it is probed last.
 obj-$(CONFIG_ARM_DT_BL_CPUFREQ)		+= arm_big_little_dt.o
 
-obj-$(CONFIG_ARCH_DAVINCI_DA850)	+= davinci-cpufreq.o
+obj-$(CONFIG_ARCH_DAVINCI)		+= davinci-cpufreq.o
 obj-$(CONFIG_UX500_SOC_DB8500)		+= dbx500-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS_CPUFREQ)	+= exynos-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS4210_CPUFREQ)	+= exynos4210-cpufreq.o
diff -ur ./drivers/cpufreq/cpufreq.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq.c
--- ./drivers/cpufreq/cpufreq.c	2023-04-26 12:56:04.980118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq.c	2023-04-23 12:01:21.707828600 +0100
@@ -46,6 +46,7 @@
 static DEFINE_PER_CPU(char[CPUFREQ_NAME_LEN], cpufreq_cpu_governor);
 #endif
 static DEFINE_RWLOCK(cpufreq_driver_lock);
+static DEFINE_MUTEX(cpufreq_governor_lock);
 
 /*
  * cpu_policy_rwsem is a per CPU reader-writer semaphore designed to cure
@@ -1563,6 +1564,21 @@
 
 	pr_debug("__cpufreq_governor for CPU %u, event %u\n",
 						policy->cpu, event);
+
+	mutex_lock(&cpufreq_governor_lock);
+	if ((!policy->governor_enabled && (event == CPUFREQ_GOV_STOP)) ||
+	    (policy->governor_enabled && (event == CPUFREQ_GOV_START))) {
+		mutex_unlock(&cpufreq_governor_lock);
+		return -EBUSY;
+	}
+
+	if (event == CPUFREQ_GOV_STOP)
+		policy->governor_enabled = false;
+	else if (event == CPUFREQ_GOV_START)
+		policy->governor_enabled = true;
+
+	mutex_unlock(&cpufreq_governor_lock);
+
 	ret = policy->governor->governor(policy, event);
 
 	if (!ret) {
@@ -1570,6 +1586,14 @@
 			policy->governor->initialized++;
 		else if (event == CPUFREQ_GOV_POLICY_EXIT)
 			policy->governor->initialized--;
+	} else {
+		/* Restore original values */
+		mutex_lock(&cpufreq_governor_lock);
+		if (event == CPUFREQ_GOV_STOP)
+			policy->governor_enabled = true;
+		else if (event == CPUFREQ_GOV_START)
+			policy->governor_enabled = false;
+		mutex_unlock(&cpufreq_governor_lock);
 	}
 
 	/* we keep one module reference alive for
diff -ur ./drivers/cpufreq/cpufreq_governor.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq_governor.c
--- ./drivers/cpufreq/cpufreq_governor.c	2023-04-26 12:56:04.980118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq_governor.c	2023-04-23 12:01:21.706453100 +0100
@@ -177,6 +177,9 @@
 {
 	int i;
 
+	if (!policy->governor_enabled)
+		return;
+
 	if (!all_cpus) {
 		__gov_queue_work(smp_processor_id(), dbs_data, delay);
 	} else {
diff -ur ./drivers/cpufreq/cpufreq_ondemand.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq_ondemand.c
--- ./drivers/cpufreq/cpufreq_ondemand.c	2023-04-26 12:36:30.610095305 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/cpufreq_ondemand.c	2023-04-23 12:01:21.789663000 +0100
@@ -33,8 +33,8 @@
 #define DEF_FREQUENCY_UP_THRESHOLD		(80)
 #define DEF_SAMPLING_DOWN_FACTOR		(1)
 #define MAX_SAMPLING_DOWN_FACTOR		(100000)
-#define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(3)
-#define MICRO_FREQUENCY_UP_THRESHOLD		(95)
+#define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(50)
+#define MICRO_FREQUENCY_UP_THRESHOLD		(80)
 #define MICRO_FREQUENCY_MIN_SAMPLE_RATE		(10000)
 #define MIN_FREQUENCY_UP_THRESHOLD		(11)
 #define MAX_FREQUENCY_UP_THRESHOLD		(100)
diff -ur ./drivers/cpufreq/highbank-cpufreq.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/highbank-cpufreq.c
--- ./drivers/cpufreq/highbank-cpufreq.c	2023-04-26 12:26:00.520128690 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/highbank-cpufreq.c	2023-04-23 12:01:22.030080300 +0100
@@ -66,7 +66,8 @@
 	struct device_node *np;
 	int ret;
 
-	if (!of_machine_is_compatible("calxeda,highbank"))
+	if ((!of_machine_is_compatible("calxeda,highbank")) &&
+		(!of_machine_is_compatible("calxeda,ecx-2000")))
 		return -ENODEV;
 
 	for_each_child_of_node(of_find_node_by_path("/cpus"), np)
diff -ur ./drivers/cpufreq/intel_pstate.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/intel_pstate.c
--- ./drivers/cpufreq/intel_pstate.c	2023-04-26 12:56:04.990118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/intel_pstate.c	2023-04-23 12:01:22.153223800 +0100
@@ -48,7 +48,7 @@
 }
 
 struct sample {
-	int core_pct_busy;
+	int32_t core_pct_busy;
 	u64 aperf;
 	u64 mperf;
 	int freq;
@@ -68,7 +68,7 @@
 	int32_t i_gain;
 	int32_t d_gain;
 	int deadband;
-	int last_err;
+	int32_t last_err;
 };
 
 struct cpudata {
@@ -153,16 +153,15 @@
 	pid->d_gain = div_fp(int_tofp(percent), int_tofp(100));
 }
 
-static signed int pid_calc(struct _pid *pid, int busy)
+static signed int pid_calc(struct _pid *pid, int32_t busy)
 {
-	signed int err, result;
+	signed int result;
 	int32_t pterm, dterm, fp_error;
 	int32_t integral_limit;
 
-	err = pid->setpoint - busy;
-	fp_error = int_tofp(err);
+	fp_error = int_tofp(pid->setpoint) - busy;
 
-	if (abs(err) <= pid->deadband)
+	if (abs(fp_error) <= int_tofp(pid->deadband))
 		return 0;
 
 	pterm = mul_fp(pid->p_gain, fp_error);
@@ -176,8 +175,8 @@
 	if (pid->integral < -integral_limit)
 		pid->integral = -integral_limit;
 
-	dterm = mul_fp(pid->d_gain, (err - pid->last_err));
-	pid->last_err = err;
+	dterm = mul_fp(pid->d_gain, fp_error - pid->last_err);
+	pid->last_err = fp_error;
 
 	result = pterm + mul_fp(pid->integral, pid->i_gain) + dterm;
 
@@ -367,12 +366,13 @@
 static void intel_pstate_get_min_max(struct cpudata *cpu, int *min, int *max)
 {
 	int max_perf = cpu->pstate.turbo_pstate;
+	int max_perf_adj;
 	int min_perf;
 	if (limits.no_turbo)
 		max_perf = cpu->pstate.max_pstate;
 
-	max_perf = fp_toint(mul_fp(int_tofp(max_perf), limits.max_perf));
-	*max = clamp_t(int, max_perf,
+	max_perf_adj = fp_toint(mul_fp(int_tofp(max_perf), limits.max_perf));
+	*max = clamp_t(int, max_perf_adj,
 			cpu->pstate.min_pstate, cpu->pstate.turbo_pstate);
 
 	min_perf = fp_toint(mul_fp(int_tofp(max_perf), limits.min_perf));
@@ -394,7 +394,10 @@
 	trace_cpu_frequency(pstate * 100000, cpu->cpu);
 
 	cpu->pstate.current_pstate = pstate;
-	wrmsrl(MSR_IA32_PERF_CTL, pstate << 8);
+	if (limits.no_turbo)
+		wrmsrl(MSR_IA32_PERF_CTL, BIT(32) | (pstate << 8));
+	else
+		wrmsrl(MSR_IA32_PERF_CTL, pstate << 8);
 
 }
 
@@ -432,8 +435,9 @@
 					struct sample *sample)
 {
 	u64 core_pct;
-	core_pct = div64_u64(sample->aperf * 100, sample->mperf);
-	sample->freq = cpu->pstate.max_pstate * core_pct * 1000;
+	core_pct = div64_u64(int_tofp(sample->aperf * 100),
+			     sample->mperf);
+	sample->freq = fp_toint(cpu->pstate.max_pstate * core_pct * 1000);
 
 	sample->core_pct_busy = core_pct;
 }
@@ -465,22 +469,19 @@
 	mod_timer_pinned(&cpu->timer, jiffies + delay);
 }
 
-static inline int intel_pstate_get_scaled_busy(struct cpudata *cpu)
+static inline int32_t intel_pstate_get_scaled_busy(struct cpudata *cpu)
 {
-	int32_t busy_scaled;
 	int32_t core_busy, max_pstate, current_pstate;
 
-	core_busy = int_tofp(cpu->samples[cpu->sample_ptr].core_pct_busy);
+	core_busy = cpu->samples[cpu->sample_ptr].core_pct_busy;
 	max_pstate = int_tofp(cpu->pstate.max_pstate);
 	current_pstate = int_tofp(cpu->pstate.current_pstate);
-	busy_scaled = mul_fp(core_busy, div_fp(max_pstate, current_pstate));
-
-	return fp_toint(busy_scaled);
+	return mul_fp(core_busy, div_fp(max_pstate, current_pstate));
 }
 
 static inline void intel_pstate_adjust_busy_pstate(struct cpudata *cpu)
 {
-	int busy_scaled;
+	int32_t busy_scaled;
 	struct _pid *pid;
 	signed int ctl = 0;
 	int steps;
@@ -516,12 +517,18 @@
 }
 
 #define ICPU(model, policy) \
-	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, (unsigned long)&policy }
+	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_APERFMPERF,\
+			(unsigned long)&policy }
 
 static const struct x86_cpu_id intel_pstate_cpu_ids[] = {
 	ICPU(0x2a, default_policy),
 	ICPU(0x2d, default_policy),
 	ICPU(0x3a, default_policy),
+	ICPU(0x3c, default_policy),
+	ICPU(0x3e, default_policy),
+	ICPU(0x3f, default_policy),
+	ICPU(0x45, default_policy),
+	ICPU(0x46, default_policy),
 	{}
 };
 MODULE_DEVICE_TABLE(x86cpu, intel_pstate_cpu_ids);
@@ -543,6 +550,11 @@
 	cpu = all_cpu_data[cpunum];
 
 	intel_pstate_get_cpu_pstates(cpu);
+	if (!cpu->pstate.current_pstate) {
+		all_cpu_data[cpunum] = NULL;
+		kfree(cpu);
+		return -ENODATA;
+	}
 
 	cpu->cpu = cpunum;
 	cpu->pstate_policy =
@@ -629,8 +641,8 @@
 
 static int __cpuinit intel_pstate_cpu_init(struct cpufreq_policy *policy)
 {
-	int rc, min_pstate, max_pstate;
 	struct cpudata *cpu;
+	int rc;
 
 	rc = intel_pstate_init_cpu(policy->cpu);
 	if (rc)
@@ -644,9 +656,8 @@
 	else
 		policy->policy = CPUFREQ_POLICY_POWERSAVE;
 
-	intel_pstate_get_min_max(cpu, &min_pstate, &max_pstate);
-	policy->min = min_pstate * 100000;
-	policy->max = max_pstate * 100000;
+	policy->min = cpu->pstate.min_pstate * 100000;
+	policy->max = cpu->pstate.turbo_pstate * 100000;
 
 	/* cpuinfo and default policy values */
 	policy->cpuinfo.min_freq = cpu->pstate.min_pstate * 100000;
diff -ur ./drivers/cpufreq/powernow-k6.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/powernow-k6.c
--- ./drivers/cpufreq/powernow-k6.c	2023-04-26 12:56:05.000118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/powernow-k6.c	2023-04-23 12:01:22.272366700 +0100
@@ -26,41 +26,108 @@
 static unsigned int                     busfreq;   /* FSB, in 10 kHz */
 static unsigned int                     max_multiplier;
 
+static unsigned int			param_busfreq = 0;
+static unsigned int			param_max_multiplier = 0;
+
+module_param_named(max_multiplier, param_max_multiplier, uint, S_IRUGO);
+MODULE_PARM_DESC(max_multiplier, "Maximum multiplier (allowed values: 20 30 35 40 45 50 55 60)");
+
+module_param_named(bus_frequency, param_busfreq, uint, S_IRUGO);
+MODULE_PARM_DESC(bus_frequency, "Bus frequency in kHz");
 
 /* Clock ratio multiplied by 10 - see table 27 in AMD#23446 */
 static struct cpufreq_frequency_table clock_ratio[] = {
-	{45,  /* 000 -> 4.5x */ 0},
+	{60,  /* 110 -> 6.0x */ 0},
+	{55,  /* 011 -> 5.5x */ 0},
 	{50,  /* 001 -> 5.0x */ 0},
+	{45,  /* 000 -> 4.5x */ 0},
 	{40,  /* 010 -> 4.0x */ 0},
-	{55,  /* 011 -> 5.5x */ 0},
-	{20,  /* 100 -> 2.0x */ 0},
-	{30,  /* 101 -> 3.0x */ 0},
-	{60,  /* 110 -> 6.0x */ 0},
 	{35,  /* 111 -> 3.5x */ 0},
+	{30,  /* 101 -> 3.0x */ 0},
+	{20,  /* 100 -> 2.0x */ 0},
 	{0, CPUFREQ_TABLE_END}
 };
 
+static const u8 index_to_register[8] = { 6, 3, 1, 0, 2, 7, 5, 4 };
+static const u8 register_to_index[8] = { 3, 2, 4, 1, 7, 6, 0, 5 };
+
+static const struct {
+	unsigned freq;
+	unsigned mult;
+} usual_frequency_table[] = {
+	{ 400000, 40 },	// 100   * 4
+	{ 450000, 45 }, // 100   * 4.5
+	{ 475000, 50 }, //  95   * 5
+	{ 500000, 50 }, // 100   * 5
+	{ 506250, 45 }, // 112.5 * 4.5
+	{ 533500, 55 }, //  97   * 5.5
+	{ 550000, 55 }, // 100   * 5.5
+	{ 562500, 50 }, // 112.5 * 5
+	{ 570000, 60 }, //  95   * 6
+	{ 600000, 60 }, // 100   * 6
+	{ 618750, 55 }, // 112.5 * 5.5
+	{ 660000, 55 }, // 120   * 5.5
+	{ 675000, 60 }, // 112.5 * 6
+	{ 720000, 60 }, // 120   * 6
+};
+
+#define FREQ_RANGE		3000
 
 /**
  * powernow_k6_get_cpu_multiplier - returns the current FSB multiplier
  *
- *   Returns the current setting of the frequency multiplier. Core clock
+ * Returns the current setting of the frequency multiplier. Core clock
  * speed is frequency of the Front-Side Bus multiplied with this value.
  */
 static int powernow_k6_get_cpu_multiplier(void)
 {
-	u64 invalue = 0;
+	unsigned long invalue = 0;
 	u32 msrval;
 
+	local_irq_disable();
+
 	msrval = POWERNOW_IOPORT + 0x1;
 	wrmsr(MSR_K6_EPMR, msrval, 0); /* enable the PowerNow port */
 	invalue = inl(POWERNOW_IOPORT + 0x8);
 	msrval = POWERNOW_IOPORT + 0x0;
 	wrmsr(MSR_K6_EPMR, msrval, 0); /* disable it again */
 
-	return clock_ratio[(invalue >> 5)&7].index;
+	local_irq_enable();
+
+	return clock_ratio[register_to_index[(invalue >> 5)&7]].index;
 }
 
+static void powernow_k6_set_cpu_multiplier(unsigned int best_i)
+{
+	unsigned long outvalue, invalue;
+	unsigned long msrval;
+	unsigned long cr0;
+
+	/* we now need to transform best_i to the BVC format, see AMD#23446 */
+
+	/*
+	 * The processor doesn't respond to inquiry cycles while changing the
+	 * frequency, so we must disable cache.
+	 */
+	local_irq_disable();
+	cr0 = read_cr0();
+	write_cr0(cr0 | X86_CR0_CD);
+	wbinvd();
+
+	outvalue = (1<<12) | (1<<10) | (1<<9) | (index_to_register[best_i]<<5);
+
+	msrval = POWERNOW_IOPORT + 0x1;
+	wrmsr(MSR_K6_EPMR, msrval, 0); /* enable the PowerNow port */
+	invalue = inl(POWERNOW_IOPORT + 0x8);
+	invalue = invalue & 0x1f;
+	outvalue = outvalue | invalue;
+	outl(outvalue, (POWERNOW_IOPORT + 0x8));
+	msrval = POWERNOW_IOPORT + 0x0;
+	wrmsr(MSR_K6_EPMR, msrval, 0); /* disable it again */
+
+	write_cr0(cr0);
+	local_irq_enable();
+}
 
 /**
  * powernow_k6_set_state - set the PowerNow! multiplier
@@ -71,8 +138,6 @@
 static void powernow_k6_set_state(struct cpufreq_policy *policy,
 		unsigned int best_i)
 {
-	unsigned long outvalue = 0, invalue = 0;
-	unsigned long msrval;
 	struct cpufreq_freqs freqs;
 
 	if (clock_ratio[best_i].index > max_multiplier) {
@@ -85,18 +150,7 @@
 
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 
-	/* we now need to transform best_i to the BVC format, see AMD#23446 */
-
-	outvalue = (1<<12) | (1<<10) | (1<<9) | (best_i<<5);
-
-	msrval = POWERNOW_IOPORT + 0x1;
-	wrmsr(MSR_K6_EPMR, msrval, 0); /* enable the PowerNow port */
-	invalue = inl(POWERNOW_IOPORT + 0x8);
-	invalue = invalue & 0xf;
-	outvalue = outvalue | invalue;
-	outl(outvalue , (POWERNOW_IOPORT + 0x8));
-	msrval = POWERNOW_IOPORT + 0x0;
-	wrmsr(MSR_K6_EPMR, msrval, 0); /* disable it again */
+	powernow_k6_set_cpu_multiplier(best_i);
 
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 
@@ -141,18 +195,57 @@
 	return 0;
 }
 
-
 static int powernow_k6_cpu_init(struct cpufreq_policy *policy)
 {
 	unsigned int i, f;
 	int result;
+	unsigned khz;
 
 	if (policy->cpu != 0)
 		return -ENODEV;
 
-	/* get frequencies */
-	max_multiplier = powernow_k6_get_cpu_multiplier();
-	busfreq = cpu_khz / max_multiplier;
+	max_multiplier = 0;
+	khz = cpu_khz;
+	for (i = 0; i < ARRAY_SIZE(usual_frequency_table); i++) {
+		if (khz >= usual_frequency_table[i].freq - FREQ_RANGE &&
+		    khz <= usual_frequency_table[i].freq + FREQ_RANGE) {
+			khz = usual_frequency_table[i].freq;
+			max_multiplier = usual_frequency_table[i].mult;
+			break;
+		}
+	}
+	if (param_max_multiplier) {
+		for (i = 0; (clock_ratio[i].frequency != CPUFREQ_TABLE_END); i++) {
+			if (clock_ratio[i].index == param_max_multiplier) {
+				max_multiplier = param_max_multiplier;
+				goto have_max_multiplier;
+			}
+		}
+		printk(KERN_ERR "powernow-k6: invalid max_multiplier parameter, valid parameters 20, 30, 35, 40, 45, 50, 55, 60\n");
+		return -EINVAL;
+	}
+
+	if (!max_multiplier) {
+		printk(KERN_WARNING "powernow-k6: unknown frequency %u, cannot determine current multiplier\n", khz);
+		printk(KERN_WARNING "powernow-k6: use module parameters max_multiplier and bus_frequency\n");
+		return -EOPNOTSUPP;
+	}
+
+have_max_multiplier:
+	param_max_multiplier = max_multiplier;
+
+	if (param_busfreq) {
+		if (param_busfreq >= 50000 && param_busfreq <= 150000) {
+			busfreq = param_busfreq / 10;
+			goto have_busfreq;
+		}
+		printk(KERN_ERR "powernow-k6: invalid bus_frequency parameter, allowed range 50000 - 150000 kHz\n");
+		return -EINVAL;
+	}
+
+	busfreq = khz / max_multiplier;
+have_busfreq:
+	param_busfreq = busfreq * 10;
 
 	/* table init */
 	for (i = 0; (clock_ratio[i].frequency != CPUFREQ_TABLE_END); i++) {
@@ -164,7 +257,7 @@
 	}
 
 	/* cpuinfo and default policy values */
-	policy->cpuinfo.transition_latency = 200000;
+	policy->cpuinfo.transition_latency = 500000;
 	policy->cur = busfreq * max_multiplier;
 
 	result = cpufreq_frequency_table_cpuinfo(policy, clock_ratio);
diff -ur ./drivers/cpufreq/powernow-k8.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/powernow-k8.c
--- ./drivers/cpufreq/powernow-k8.c	2023-04-26 12:56:05.000118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpufreq/powernow-k8.c	2023-04-23 12:01:22.358432400 +0100
@@ -1100,7 +1100,7 @@
 {
 	struct powernow_k8_data *data;
 	struct init_on_cpu init_on_cpu;
-	int rc;
+	int rc, cpu;
 
 	smp_call_function_single(pol->cpu, check_supported_cpu, &rc, 1);
 	if (rc)
@@ -1169,7 +1169,9 @@
 	pr_debug("cpu_init done, current fid 0x%x, vid 0x%x\n",
 		 data->currfid, data->currvid);
 
-	per_cpu(powernow_data, pol->cpu) = data;
+	/* Point all the CPUs in this policy to the same data */
+	for_each_cpu(cpu, pol->cpus)
+		per_cpu(powernow_data, cpu) = data;
 
 	return 0;
 
@@ -1184,6 +1186,7 @@
 static int powernowk8_cpu_exit(struct cpufreq_policy *pol)
 {
 	struct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);
+	int cpu;
 
 	if (!data)
 		return -EINVAL;
@@ -1194,7 +1197,8 @@
 
 	kfree(data->powernow_table);
 	kfree(data);
-	per_cpu(powernow_data, pol->cpu) = NULL;
+	for_each_cpu(cpu, pol->cpus)
+		per_cpu(powernow_data, cpu) = NULL;
 
 	return 0;
 }
diff -ur ./drivers/cpuidle/governors/menu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpuidle/governors/menu.c
--- ./drivers/cpuidle/governors/menu.c	2023-04-26 12:36:30.630095264 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/cpuidle/governors/menu.c	2023-04-23 12:01:22.988293200 +0100
@@ -173,7 +173,12 @@
 
 	/* for higher loadavg, we are more reluctant */
 
-	mult += 2 * get_loadavg();
+	/*
+	 * this doesn't work as intended - it is almost always 0, but can
+	 * sometimes, depending on workload, spike very high into the hundreds
+	 * even when the average cpu load is under 10%.
+	 */
+	/* mult += 2 * get_loadavg(); */
 
 	/* for IO wait tasks (per cpu!) we add 5x each */
 	mult += 10 * nr_iowait_cpu(smp_processor_id());
diff -ur ./drivers/dma/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/dma/Kconfig
--- ./drivers/dma/Kconfig	2023-04-26 12:56:05.030118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/dma/Kconfig	2023-04-23 12:01:25.238658600 +0100
@@ -88,6 +88,14 @@
 	  Support the Synopsys DesignWare AHB DMA controller.  This
 	  can be integrated in chips such as the Atmel AT32ap7000.
 
+config XBURST_DMAC
+        tristate "XBURST DMA V12 support"
+        depends on SOC_4771 || SOC_4780 || SOC_4775 || SOC_M200 || SOC_T15 || SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+        select DMA_ENGINE
+        help
+          Support the XBURST DMA controller. This support the
+          jz4770 || jz4780 || jz4775 || jz m200 || jz t15 || jz t10 || jz t20 || jz t30 || jz t21 || jz t31 chip.
+
 config DW_DMAC_BIG_ENDIAN_IO
 	bool "Use big endian I/O register access"
 	default y if AVR32
diff -ur ./drivers/dma/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/dma/Makefile
--- ./drivers/dma/Makefile	2023-04-26 12:56:05.030118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/dma/Makefile	2023-04-23 12:01:25.237986300 +0100
@@ -38,3 +38,4 @@
 obj-$(CONFIG_MMP_TDMA) += mmp_tdma.o
 obj-$(CONFIG_DMA_OMAP) += omap-dma.o
 obj-$(CONFIG_MMP_PDMA) += mmp_pdma.o
+obj-$(CONFIG_XBURST_DMAC) += jzdma/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/dma: jzdma
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers: dmic
diff -ur ./drivers/gpio/gpio-pca953x.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpio/gpio-pca953x.c
--- ./drivers/gpio/gpio-pca953x.c	2023-04-26 12:26:00.950131848 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpio/gpio-pca953x.c	2023-04-23 12:01:29.867606800 +0100
@@ -1,5 +1,5 @@
 /*
- *  PCA953x 4/8/16 bit I/O ports
+ *  pca953x.c - 4/8/16 bit I/O ports
  *
  *  Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
  *  Copyright (C) 2007 Marvell International Ltd.
@@ -13,15 +13,16 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/delay.h>
 #include <linux/gpio.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <linux/irqdomain.h>
 #include <linux/i2c.h>
 #include <linux/i2c/pca953x.h>
 #include <linux/slab.h>
 #ifdef CONFIG_OF_GPIO
 #include <linux/of_platform.h>
+#include <linux/of_gpio.h>
 #endif
 
 #define PCA953X_INPUT		0
@@ -29,8 +30,6 @@
 #define PCA953X_INVERT		2
 #define PCA953X_DIRECTION	3
 
-#define REG_ADDR_AI		0x80
-
 #define PCA957X_IN		0
 #define PCA957X_INVRT		1
 #define PCA957X_BKEN		2
@@ -45,8 +44,8 @@
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
 
+static int irq_pc = -1;
 static const struct i2c_device_id pca953x_id[] = {
-	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "pca9535", 16 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9536", 4  | PCA953X_TYPE, },
@@ -67,99 +66,53 @@
 	{ "pca6107", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "tca6408", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "tca6416", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "tca6424", 24 | PCA953X_TYPE | PCA_INT, },
+	/* NYET:  { "tca6424", 24, }, */
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, pca953x_id);
 
-#define MAX_BANK 5
-#define BANK_SZ 8
-
-#define NBANK(chip) (chip->gpio_chip.ngpio / BANK_SZ)
-
 struct pca953x_chip {
 	unsigned gpio_start;
-	u8 reg_output[MAX_BANK];
-	u8 reg_direction[MAX_BANK];
+	uint16_t reg_output;
+	uint16_t reg_direction;
 	struct mutex i2c_lock;
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
 	struct mutex irq_lock;
-	u8 irq_mask[MAX_BANK];
-	u8 irq_stat[MAX_BANK];
-	u8 irq_trig_raise[MAX_BANK];
-	u8 irq_trig_fall[MAX_BANK];
-	struct irq_domain *domain;
+	uint16_t irq_mask;
+	uint16_t irq_stat;
+	uint16_t irq_trig_raise;
+	uint16_t irq_trig_fall;
+	int	 irq_base;
 #endif
 
 	struct i2c_client *client;
+	struct pca953x_platform_data *dyn_pdata;
 	struct gpio_chip gpio_chip;
 	const char *const *names;
 	int	chip_type;
 };
 
-static int pca953x_read_single(struct pca953x_chip *chip, int reg, u32 *val,
-				int off)
-{
-	int ret;
-	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
-	int offset = off / BANK_SZ;
-
-	ret = i2c_smbus_read_byte_data(chip->client,
-				(reg << bank_shift) + offset);
-	*val = ret;
-
-	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed reading register\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int pca953x_write_single(struct pca953x_chip *chip, int reg, u32 val,
-				int off)
-{
-	int ret = 0;
-	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
-	int offset = off / BANK_SZ;
-
-	ret = i2c_smbus_write_byte_data(chip->client,
-					(reg << bank_shift) + offset, val);
-
-	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed writing register\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int pca953x_write_regs(struct pca953x_chip *chip, int reg, u8 *val)
+static int pca953x_write_reg(struct pca953x_chip *chip, int reg, uint16_t val)
 {
 	int ret = 0;
 
 	if (chip->gpio_chip.ngpio <= 8)
-		ret = i2c_smbus_write_byte_data(chip->client, reg, *val);
-	else if (chip->gpio_chip.ngpio >= 24) {
-		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
-		ret = i2c_smbus_write_i2c_block_data(chip->client,
-					(reg << bank_shift) | REG_ADDR_AI,
-					NBANK(chip), val);
-	} else {
+		ret = i2c_smbus_write_byte_data(chip->client, reg, val);
+	else {
 		switch (chip->chip_type) {
 		case PCA953X_TYPE:
 			ret = i2c_smbus_write_word_data(chip->client,
-							reg << 1, (u16) *val);
+							reg << 1, val);
 			break;
 		case PCA957X_TYPE:
 			ret = i2c_smbus_write_byte_data(chip->client, reg << 1,
-							val[0]);
+							val & 0xff);
 			if (ret < 0)
 				break;
 			ret = i2c_smbus_write_byte_data(chip->client,
 							(reg << 1) + 1,
-							val[1]);
+							(val & 0xff00) >> 8);
 			break;
 		}
 	}
@@ -172,42 +125,34 @@
 	return 0;
 }
 
-static int pca953x_read_regs(struct pca953x_chip *chip, int reg, u8 *val)
+static int pca953x_read_reg(struct pca953x_chip *chip, int reg, uint16_t *val)
 {
 	int ret;
 
-	if (chip->gpio_chip.ngpio <= 8) {
+	if (chip->gpio_chip.ngpio <= 8)
 		ret = i2c_smbus_read_byte_data(chip->client, reg);
-		*val = ret;
-	} else if (chip->gpio_chip.ngpio >= 24) {
-		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
-
-		ret = i2c_smbus_read_i2c_block_data(chip->client,
-					(reg << bank_shift) | REG_ADDR_AI,
-					NBANK(chip), val);
-	} else {
+	else
 		ret = i2c_smbus_read_word_data(chip->client, reg << 1);
-		val[0] = (u16)ret & 0xFF;
-		val[1] = (u16)ret >> 8;
-	}
+
 	if (ret < 0) {
 		dev_err(&chip->client->dev, "failed reading register\n");
 		return ret;
 	}
 
+	*val = (uint16_t)ret;
 	return 0;
 }
 
 static int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)
 {
 	struct pca953x_chip *chip;
-	u8 reg_val;
+	uint16_t reg_val;
 	int ret, offset = 0;
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
 
 	mutex_lock(&chip->i2c_lock);
-	reg_val = chip->reg_direction[off / BANK_SZ] | (1u << (off % BANK_SZ));
+	reg_val = chip->reg_direction | (1u << off);
 
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
@@ -217,11 +162,11 @@
 		offset = PCA957X_CFG;
 		break;
 	}
-	ret = pca953x_write_single(chip, offset, reg_val, off);
+	ret = pca953x_write_reg(chip, offset, reg_val);
 	if (ret)
 		goto exit;
 
-	chip->reg_direction[off / BANK_SZ] = reg_val;
+	chip->reg_direction = reg_val;
 	ret = 0;
 exit:
 	mutex_unlock(&chip->i2c_lock);
@@ -232,7 +177,7 @@
 		unsigned off, int val)
 {
 	struct pca953x_chip *chip;
-	u8 reg_val;
+	uint16_t reg_val;
 	int ret, offset = 0;
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
@@ -240,11 +185,9 @@
 	mutex_lock(&chip->i2c_lock);
 	/* set output level */
 	if (val)
-		reg_val = chip->reg_output[off / BANK_SZ]
-			| (1u << (off % BANK_SZ));
+		reg_val = chip->reg_output | (1u << off);
 	else
-		reg_val = chip->reg_output[off / BANK_SZ]
-			& ~(1u << (off % BANK_SZ));
+		reg_val = chip->reg_output & ~(1u << off);
 
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
@@ -254,14 +197,14 @@
 		offset = PCA957X_OUT;
 		break;
 	}
-	ret = pca953x_write_single(chip, offset, reg_val, off);
+	ret = pca953x_write_reg(chip, offset, reg_val);
 	if (ret)
 		goto exit;
 
-	chip->reg_output[off / BANK_SZ] = reg_val;
+	chip->reg_output = reg_val;
 
 	/* then direction */
-	reg_val = chip->reg_direction[off / BANK_SZ] & ~(1u << (off % BANK_SZ));
+	reg_val = chip->reg_direction & ~(1u << off);
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
@@ -270,11 +213,11 @@
 		offset = PCA957X_CFG;
 		break;
 	}
-	ret = pca953x_write_single(chip, offset, reg_val, off);
+	ret = pca953x_write_reg(chip, offset, reg_val);
 	if (ret)
 		goto exit;
 
-	chip->reg_direction[off / BANK_SZ] = reg_val;
+	chip->reg_direction = reg_val;
 	ret = 0;
 exit:
 	mutex_unlock(&chip->i2c_lock);
@@ -284,7 +227,7 @@
 static int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)
 {
 	struct pca953x_chip *chip;
-	u32 reg_val;
+	uint16_t reg_val;
 	int ret, offset = 0;
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
@@ -298,7 +241,7 @@
 		offset = PCA957X_IN;
 		break;
 	}
-	ret = pca953x_read_single(chip, offset, &reg_val, off);
+	ret = pca953x_read_reg(chip, offset, &reg_val);
 	mutex_unlock(&chip->i2c_lock);
 	if (ret < 0) {
 		/* NOTE:  diagnostic already emitted; that's all we should
@@ -314,18 +257,16 @@
 static void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
 {
 	struct pca953x_chip *chip;
-	u8 reg_val;
+	uint16_t reg_val;
 	int ret, offset = 0;
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
 
 	mutex_lock(&chip->i2c_lock);
 	if (val)
-		reg_val = chip->reg_output[off / BANK_SZ]
-			| (1u << (off % BANK_SZ));
+		reg_val = chip->reg_output | (1u << off);
 	else
-		reg_val = chip->reg_output[off / BANK_SZ]
-			& ~(1u << (off % BANK_SZ));
+		reg_val = chip->reg_output & ~(1u << off);
 
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
@@ -335,11 +276,11 @@
 		offset = PCA957X_OUT;
 		break;
 	}
-	ret = pca953x_write_single(chip, offset, reg_val, off);
+	ret = pca953x_write_reg(chip, offset, reg_val);
 	if (ret)
 		goto exit;
 
-	chip->reg_output[off / BANK_SZ] = reg_val;
+	chip->reg_output = reg_val;
 exit:
 	mutex_unlock(&chip->i2c_lock);
 }
@@ -354,7 +295,7 @@
 	gc->direction_output = pca953x_gpio_direction_output;
 	gc->get = pca953x_gpio_get_value;
 	gc->set = pca953x_gpio_set_value;
-	gc->can_sleep = 1;
+//	gc->can_sleep = 1;
 
 	gc->base = chip->gpio_start;
 	gc->ngpio = gpios;
@@ -370,21 +311,21 @@
 	struct pca953x_chip *chip;
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
-	return irq_create_mapping(chip->domain, off);
+	return chip->irq_base + off;
 }
 
 static void pca953x_irq_mask(struct irq_data *d)
 {
 	struct pca953x_chip *chip = irq_data_get_irq_chip_data(d);
 
-	chip->irq_mask[d->hwirq / BANK_SZ] &= ~(1 << (d->hwirq % BANK_SZ));
+	chip->irq_mask &= ~(1 << (d->irq - chip->irq_base));
 }
 
 static void pca953x_irq_unmask(struct irq_data *d)
 {
 	struct pca953x_chip *chip = irq_data_get_irq_chip_data(d);
 
-	chip->irq_mask[d->hwirq / BANK_SZ] |= 1 << (d->hwirq % BANK_SZ);
+	chip->irq_mask |= 1 << (d->irq - chip->irq_base);
 }
 
 static void pca953x_irq_bus_lock(struct irq_data *d)
@@ -397,20 +338,17 @@
 static void pca953x_irq_bus_sync_unlock(struct irq_data *d)
 {
 	struct pca953x_chip *chip = irq_data_get_irq_chip_data(d);
-	u8 new_irqs;
-	int level, i;
+	uint16_t new_irqs;
+	uint16_t level;
 
 	/* Look for any newly setup interrupt */
-	for (i = 0; i < NBANK(chip); i++) {
-		new_irqs = chip->irq_trig_fall[i] | chip->irq_trig_raise[i];
-		new_irqs &= ~chip->reg_direction[i];
-
-		while (new_irqs) {
-			level = __ffs(new_irqs);
-			pca953x_gpio_direction_input(&chip->gpio_chip,
-							level + (BANK_SZ * i));
-			new_irqs &= ~(1 << level);
-		}
+	new_irqs = chip->irq_trig_fall | chip->irq_trig_raise;
+	new_irqs &= ~chip->reg_direction;
+
+	while (new_irqs) {
+		level = __ffs(new_irqs);
+		pca953x_gpio_direction_input(&chip->gpio_chip, level);
+		new_irqs &= ~(1 << level);
 	}
 
 	mutex_unlock(&chip->irq_lock);
@@ -419,8 +357,8 @@
 static int pca953x_irq_set_type(struct irq_data *d, unsigned int type)
 {
 	struct pca953x_chip *chip = irq_data_get_irq_chip_data(d);
-	int bank_nb = d->hwirq / BANK_SZ;
-	u8 mask = 1 << (d->hwirq % BANK_SZ);
+	uint16_t level = d->irq - chip->irq_base;
+	uint16_t mask = 1 << level;
 
 	if (!(type & IRQ_TYPE_EDGE_BOTH)) {
 		dev_err(&chip->client->dev, "irq %d: unsupported type %d\n",
@@ -429,18 +367,23 @@
 	}
 
 	if (type & IRQ_TYPE_EDGE_FALLING)
-		chip->irq_trig_fall[bank_nb] |= mask;
+		chip->irq_trig_fall |= mask;
 	else
-		chip->irq_trig_fall[bank_nb] &= ~mask;
+		chip->irq_trig_fall &= ~mask;
 
 	if (type & IRQ_TYPE_EDGE_RISING)
-		chip->irq_trig_raise[bank_nb] |= mask;
+		chip->irq_trig_raise |= mask;
 	else
-		chip->irq_trig_raise[bank_nb] &= ~mask;
+		chip->irq_trig_raise &= ~mask;
 
 	return 0;
 }
 
+static int pca953x_irq_set_wake(struct irq_data *d, unsigned int type)
+{
+	return 0;
+}
+
 static struct irq_chip pca953x_irq_chip = {
 	.name			= "pca953x",
 	.irq_mask		= pca953x_irq_mask,
@@ -448,15 +391,16 @@
 	.irq_bus_lock		= pca953x_irq_bus_lock,
 	.irq_bus_sync_unlock	= pca953x_irq_bus_sync_unlock,
 	.irq_set_type		= pca953x_irq_set_type,
+	.irq_set_wake      = pca953x_irq_set_wake,
 };
 
-static u8 pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
+static uint16_t pca953x_irq_pending(struct pca953x_chip *chip)
 {
-	u8 cur_stat[MAX_BANK];
-	u8 old_stat[MAX_BANK];
-	u8 pendings = 0;
-	u8 trigger[MAX_BANK], triggers = 0;
-	int ret, i, offset = 0;
+	uint16_t cur_stat;
+	uint16_t old_stat;
+	uint16_t pending;
+	uint16_t trigger;
+	int ret, offset = 0;
 
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
@@ -466,88 +410,59 @@
 		offset = PCA957X_IN;
 		break;
 	}
-	ret = pca953x_read_regs(chip, offset, cur_stat);
+	ret = pca953x_read_reg(chip, offset, &cur_stat);
 	if (ret)
 		return 0;
 
 	/* Remove output pins from the equation */
-	for (i = 0; i < NBANK(chip); i++)
-		cur_stat[i] &= chip->reg_direction[i];
+	cur_stat &= chip->reg_direction;
 
-	memcpy(old_stat, chip->irq_stat, NBANK(chip));
+	old_stat = chip->irq_stat;
+	trigger = (cur_stat ^ old_stat) & chip->irq_mask;
 
-	for (i = 0; i < NBANK(chip); i++) {
-		trigger[i] = (cur_stat[i] ^ old_stat[i]) & chip->irq_mask[i];
-		triggers += trigger[i];
-	}
-
-	if (!triggers)
+	if (!trigger)
 		return 0;
 
-	memcpy(chip->irq_stat, cur_stat, NBANK(chip));
+	chip->irq_stat = cur_stat;
 
-	for (i = 0; i < NBANK(chip); i++) {
-		pending[i] = (old_stat[i] & chip->irq_trig_fall[i]) |
-			(cur_stat[i] & chip->irq_trig_raise[i]);
-		pending[i] &= trigger[i];
-		pendings += pending[i];
-	}
+	pending = (old_stat & chip->irq_trig_fall) |
+		  (cur_stat & chip->irq_trig_raise);
+	pending &= trigger;
 
-	return pendings;
+	return pending;
 }
 
 static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 {
 	struct pca953x_chip *chip = devid;
-	u8 pending[MAX_BANK];
-	u8 level;
-	int i;
+	uint16_t pending;
+	uint16_t level;
 
-	if (!pca953x_irq_pending(chip, pending))
+	pending = pca953x_irq_pending(chip);
+
+	if (!pending)
 		return IRQ_HANDLED;
 
-	for (i = 0; i < NBANK(chip); i++) {
-		while (pending[i]) {
-			level = __ffs(pending[i]);
-			handle_nested_irq(irq_find_mapping(chip->domain,
-							level + (BANK_SZ * i)));
-			pending[i] &= ~(1 << level);
-		}
-	}
+	do {
+		level = __ffs(pending);
+		generic_handle_irq(level + chip->irq_base);
 
-	return IRQ_HANDLED;
-}
+		pending &= ~(1 << level);
+	} while (pending);
 
-static int pca953x_gpio_irq_map(struct irq_domain *d, unsigned int irq,
-		       irq_hw_number_t hwirq)
-{
-	irq_clear_status_flags(irq, IRQ_NOREQUEST);
-	irq_set_chip_data(irq, d->host_data);
-	irq_set_chip(irq, &pca953x_irq_chip);
-	irq_set_nested_thread(irq, true);
-#ifdef CONFIG_ARM
-	set_irq_flags(irq, IRQF_VALID);
-#else
-	irq_set_noprobe(irq);
-#endif
-
-	return 0;
+	return IRQ_HANDLED;
 }
 
-static const struct irq_domain_ops pca953x_irq_simple_ops = {
-	.map = pca953x_gpio_irq_map,
-	.xlate = irq_domain_xlate_twocell,
-};
-
 static int pca953x_irq_setup(struct pca953x_chip *chip,
-			     const struct i2c_device_id *id,
-			     int irq_base)
+			     const struct i2c_device_id *id)
 {
 	struct i2c_client *client = chip->client;
-	int ret, i, offset = 0;
+	struct pca953x_platform_data *pdata = client->dev.platform_data;
+	int ret, offset = 0;
 
-	if (irq_base != -1
+	if (pdata->irq_base != -1
 			&& (id->driver_data & PCA_INT)) {
+		int lvl;
 
 		switch (chip->chip_type) {
 		case PCA953X_TYPE:
@@ -557,57 +472,79 @@
 			offset = PCA957X_IN;
 			break;
 		}
-		ret = pca953x_read_regs(chip, offset, chip->irq_stat);
+		ret = pca953x_read_reg(chip, offset, &chip->irq_stat);
 		if (ret)
-			return ret;
+			goto out_failed;
 
 		/*
 		 * There is no way to know which GPIO line generated the
 		 * interrupt.  We have to rely on the previous read for
 		 * this purpose.
 		 */
-		for (i = 0; i < NBANK(chip); i++)
-			chip->irq_stat[i] &= chip->reg_direction[i];
+		chip->irq_stat &= chip->reg_direction;
+		chip->irq_base = pdata->irq_base;
 		mutex_init(&chip->irq_lock);
 
-		chip->domain = irq_domain_add_simple(client->dev.of_node,
-						chip->gpio_chip.ngpio,
-						irq_base,
-						&pca953x_irq_simple_ops,
-						chip);
-		if (!chip->domain)
-			return -ENODEV;
-
-		ret = devm_request_threaded_irq(&client->dev,
-					client->irq,
-					   NULL,
-					   pca953x_irq_handler,
-					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-					   dev_name(&client->dev), chip);
-		if (ret) {
-			dev_err(&client->dev, "failed to request irq %d\n",
-				client->irq);
-			return ret;
+		for (lvl = 0; lvl < chip->gpio_chip.ngpio; lvl++) {
+			int irq = lvl + chip->irq_base;
+
+			irq_set_chip_data(irq, chip);
+			irq_set_chip_and_handler(irq, &pca953x_irq_chip,
+						 handle_simple_irq);
+#ifdef CONFIG_ARM
+			set_irq_flags(irq, IRQF_VALID);
+#else
+			irq_set_noprobe(irq);
+#endif
+		}
+
+		if(irq_pc >= 0){
+			ret = request_threaded_irq(irq_pc,
+					NULL,
+					pca953x_irq_handler,
+					IRQF_TRIGGER_RISING |
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					dev_name(&client->dev), chip);
+			if (ret) {
+				dev_err(&client->dev, "failed to request irq %d\n",
+						client->irq);
+				goto out_failed;
+			}
+		}else{
+				dev_err(&client->dev, " the pca9539 request irq fail!\n");
 		}
 
 		chip->gpio_chip.to_irq = pca953x_gpio_to_irq;
 	}
 
 	return 0;
+
+out_failed:
+	chip->irq_base = -1;
+	return ret;
 }
 
+static void pca953x_irq_teardown(struct pca953x_chip *chip)
+{
+	if (chip->irq_base != -1)
+		free_irq(chip->client->irq, chip);
+}
 #else /* CONFIG_GPIO_PCA953X_IRQ */
 static int pca953x_irq_setup(struct pca953x_chip *chip,
-			     const struct i2c_device_id *id,
-			     int irq_base)
+			     const struct i2c_device_id *id)
 {
 	struct i2c_client *client = chip->client;
+	struct pca953x_platform_data *pdata = client->dev.platform_data;
 
-	if (irq_base != -1 && (id->driver_data & PCA_INT))
+	if (pdata->irq_base != -1 && (id->driver_data & PCA_INT))
 		dev_warn(&client->dev, "interrupt support not compiled in\n");
 
 	return 0;
 }
+
+static void pca953x_irq_teardown(struct pca953x_chip *chip)
+{
+}
 #endif
 
 /*
@@ -616,64 +553,66 @@
 #ifdef CONFIG_OF_GPIO
 /*
  * Translate OpenFirmware node properties into platform_data
- * WARNING: This is DEPRECATED and will be removed eventually!
  */
-static void
-pca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, u32 *invert)
+static struct pca953x_platform_data *
+pca953x_get_alt_pdata(struct i2c_client *client)
 {
+	struct pca953x_platform_data *pdata;
 	struct device_node *node;
 	const __be32 *val;
 	int size;
 
 	node = client->dev.of_node;
 	if (node == NULL)
-		return;
+		return NULL;
+
+	pdata = kzalloc(sizeof(struct pca953x_platform_data), GFP_KERNEL);
+	if (pdata == NULL) {
+		dev_err(&client->dev, "Unable to allocate platform_data\n");
+		return NULL;
+	}
 
-	*gpio_base = -1;
+	pdata->gpio_base = -1;
 	val = of_get_property(node, "linux,gpio-base", &size);
-	WARN(val, "%s: device-tree property 'linux,gpio-base' is deprecated!", __func__);
 	if (val) {
 		if (size != sizeof(*val))
 			dev_warn(&client->dev, "%s: wrong linux,gpio-base\n",
 				 node->full_name);
 		else
-			*gpio_base = be32_to_cpup(val);
+			pdata->gpio_base = be32_to_cpup(val);
 	}
 
 	val = of_get_property(node, "polarity", NULL);
-	WARN(val, "%s: device-tree property 'polarity' is deprecated!", __func__);
 	if (val)
-		*invert = *val;
+		pdata->invert = *val;
+
+	return pdata;
 }
 #else
-static void
-pca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, u32 *invert)
+static struct pca953x_platform_data * pca953x_get_alt_pdata(struct i2c_client *client)
 {
-	*gpio_base = -1;
+	return NULL;
 }
 #endif
 
 static int device_pca953x_init(struct pca953x_chip *chip, u32 invert)
 {
 	int ret;
-	u8 val[MAX_BANK];
 
-	ret = pca953x_read_regs(chip, PCA953X_OUTPUT, chip->reg_output);
+	ret = pca953x_read_reg(chip, PCA953X_OUTPUT, &chip->reg_output);
 	if (ret)
 		goto out;
 
-	ret = pca953x_read_regs(chip, PCA953X_DIRECTION,
-			       chip->reg_direction);
+	ret = pca953x_read_reg(chip, PCA953X_DIRECTION,
+			       &chip->reg_direction);
 	if (ret)
 		goto out;
 
 	/* set platform specific polarity inversion */
-	if (invert)
-		memset(val, 0xFF, NBANK(chip));
-	else
-		memset(val, 0, NBANK(chip));
-
-	ret = pca953x_write_regs(chip, PCA953X_INVERT, val);
+	ret = pca953x_write_reg(chip, PCA953X_INVERT, invert);
+	if (ret)
+		goto out;
+	return 0;
 out:
 	return ret;
 }
@@ -681,36 +620,28 @@
 static int device_pca957x_init(struct pca953x_chip *chip, u32 invert)
 {
 	int ret;
-	u8 val[MAX_BANK];
+	uint16_t val = 0;
 
 	/* Let every port in proper state, that could save power */
-	memset(val, 0, NBANK(chip));
-	pca953x_write_regs(chip, PCA957X_PUPD, val);
-	memset(val, 0xFF, NBANK(chip));
-	pca953x_write_regs(chip, PCA957X_CFG, val);
-	memset(val, 0, NBANK(chip));
-	pca953x_write_regs(chip, PCA957X_OUT, val);
+	pca953x_write_reg(chip, PCA957X_PUPD, 0x0);
+	pca953x_write_reg(chip, PCA957X_CFG, 0xffff);
+	pca953x_write_reg(chip, PCA957X_OUT, 0x0);
 
-	ret = pca953x_read_regs(chip, PCA957X_IN, val);
+	ret = pca953x_read_reg(chip, PCA957X_IN, &val);
 	if (ret)
 		goto out;
-	ret = pca953x_read_regs(chip, PCA957X_OUT, chip->reg_output);
+	ret = pca953x_read_reg(chip, PCA957X_OUT, &chip->reg_output);
 	if (ret)
 		goto out;
-	ret = pca953x_read_regs(chip, PCA957X_CFG, chip->reg_direction);
+	ret = pca953x_read_reg(chip, PCA957X_CFG, &chip->reg_direction);
 	if (ret)
 		goto out;
 
 	/* set platform specific polarity inversion */
-	if (invert)
-		memset(val, 0xFF, NBANK(chip));
-	else
-		memset(val, 0, NBANK(chip));
-	pca953x_write_regs(chip, PCA957X_INVRT, val);
+	pca953x_write_reg(chip, PCA957X_INVRT, invert);
 
 	/* To enable register 6, 7 to controll pull up and pull down */
-	memset(val, 0x02, NBANK(chip));
-	pca953x_write_regs(chip, PCA957X_BKEN, val);
+	pca953x_write_reg(chip, PCA957X_BKEN, 0x202);
 
 	return 0;
 out:
@@ -722,32 +653,57 @@
 {
 	struct pca953x_platform_data *pdata;
 	struct pca953x_chip *chip;
-	int irq_base = 0;
-	int ret;
-	u32 invert = 0;
+	int ret = 0;
 
-	chip = devm_kzalloc(&client->dev,
-			sizeof(struct pca953x_chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(struct pca953x_chip), GFP_KERNEL);
 	if (chip == NULL)
 		return -ENOMEM;
 
 	pdata = client->dev.platform_data;
-	if (pdata) {
-		irq_base = pdata->irq_base;
-		chip->gpio_start = pdata->gpio_base;
-		invert = pdata->invert;
-		chip->names = pdata->names;
+	if (pdata == NULL) {
+		pdata = pca953x_get_alt_pdata(client);
+		/*
+		 * Unlike normal platform_data, this is allocated
+		 * dynamically and must be freed in the driver
+		 */
+		chip->dyn_pdata = pdata;
+	}
+
+	if (pdata == NULL) {
+		dev_dbg(&client->dev, "no platform data\n");
+		ret = -EINVAL;
+		goto out_failed;
+	}
+
+	/*request irq*/
+	if (gpio_request_one(pdata->irq_n,
+				GPIOF_DIR_OUT, "pca9539_irq")) {
+		pr_err("The GPIO %d is requested by other driver,"
+				" not available for pca9539\n", pdata->irq_n);
+		irq_pc = -1;
 	} else {
-		pca953x_get_alt_pdata(client, &chip->gpio_start, &invert);
-#ifdef CONFIG_OF_GPIO
-		/* If I2C node has no interrupts property, disable GPIO interrupts */
-		if (of_find_property(client->dev.of_node, "interrupts", NULL) == NULL)
-			irq_base = -1;
-#endif
+		irq_pc = gpio_to_irq(pdata->irq_n);
 	}
 
+	/*reset first*/
+	if(pdata->reset_n != -1){
+		printk("the pca9539 need reset\n");
+		if (gpio_request_one(pdata->reset_n,
+					GPIOF_DIR_OUT, "pca9539_rst")) {
+			pr_err("The GPIO %d is requested by other driver,"
+					" not available for pca9539\n", pdata->reset_n);
+		}
+		gpio_direction_output(pdata->reset_n, 0);
+		udelay(1000);
+		gpio_direction_output(pdata->reset_n, 1);
+	}else{
+		printk("the pca9539 not need reset\n");
+	}
 	chip->client = client;
 
+	chip->gpio_start = pdata->gpio_base;
+
+	chip->names = pdata->names;
 	chip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);
 
 	mutex_init(&chip->i2c_lock);
@@ -758,21 +714,21 @@
 	pca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);
 
 	if (chip->chip_type == PCA953X_TYPE)
-		ret = device_pca953x_init(chip, invert);
+		device_pca953x_init(chip, pdata->invert);
+	else if (chip->chip_type == PCA957X_TYPE)
+		device_pca957x_init(chip, pdata->invert);
 	else
-		ret = device_pca957x_init(chip, invert);
-	if (ret)
-		return ret;
+		goto out_failed;
 
-	ret = pca953x_irq_setup(chip, id, irq_base);
+	ret = pca953x_irq_setup(chip, id);
 	if (ret)
-		return ret;
+		goto out_failed;
 
 	ret = gpiochip_add(&chip->gpio_chip);
 	if (ret)
-		return ret;
+		goto out_failed_irq;
 
-	if (pdata && pdata->setup) {
+	if (pdata->setup) {
 		ret = pdata->setup(client, chip->gpio_chip.base,
 				chip->gpio_chip.ngpio, pdata->context);
 		if (ret < 0)
@@ -780,7 +736,15 @@
 	}
 
 	i2c_set_clientdata(client, chip);
+	dev_info(&chip->client->dev, " pca9539 init ok\n");
 	return 0;
+
+out_failed_irq:
+	pca953x_irq_teardown(chip);
+out_failed:
+	kfree(chip->dyn_pdata);
+	kfree(chip);
+	return ret;
 }
 
 static int pca953x_remove(struct i2c_client *client)
@@ -789,7 +753,7 @@
 	struct pca953x_chip *chip = i2c_get_clientdata(client);
 	int ret = 0;
 
-	if (pdata && pdata->teardown) {
+	if (pdata->teardown) {
 		ret = pdata->teardown(client, chip->gpio_chip.base,
 				chip->gpio_chip.ngpio, pdata->context);
 		if (ret < 0) {
@@ -806,42 +770,15 @@
 		return ret;
 	}
 
+	pca953x_irq_teardown(chip);
+	kfree(chip->dyn_pdata);
+	kfree(chip);
 	return 0;
 }
 
-static const struct of_device_id pca953x_dt_ids[] = {
-	{ .compatible = "nxp,pca9505", },
-	{ .compatible = "nxp,pca9534", },
-	{ .compatible = "nxp,pca9535", },
-	{ .compatible = "nxp,pca9536", },
-	{ .compatible = "nxp,pca9537", },
-	{ .compatible = "nxp,pca9538", },
-	{ .compatible = "nxp,pca9539", },
-	{ .compatible = "nxp,pca9554", },
-	{ .compatible = "nxp,pca9555", },
-	{ .compatible = "nxp,pca9556", },
-	{ .compatible = "nxp,pca9557", },
-	{ .compatible = "nxp,pca9574", },
-	{ .compatible = "nxp,pca9575", },
-
-	{ .compatible = "maxim,max7310", },
-	{ .compatible = "maxim,max7312", },
-	{ .compatible = "maxim,max7313", },
-	{ .compatible = "maxim,max7315", },
-
-	{ .compatible = "ti,pca6107", },
-	{ .compatible = "ti,tca6408", },
-	{ .compatible = "ti,tca6416", },
-	{ .compatible = "ti,tca6424", },
-	{ }
-};
-
-MODULE_DEVICE_TABLE(of, pca953x_dt_ids);
-
 static struct i2c_driver pca953x_driver = {
 	.driver = {
 		.name	= "pca953x",
-		.of_match_table = pca953x_dt_ids,
 	},
 	.probe		= pca953x_probe,
 	.remove		= pca953x_remove,
diff -ur ./drivers/gpio/gpiolib.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpio/gpiolib.c
--- ./drivers/gpio/gpiolib.c	2023-04-26 12:56:05.100118961 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpio/gpiolib.c	2023-04-23 12:01:30.507142000 +0100
@@ -136,7 +136,7 @@
  */
 static int desc_to_gpio(const struct gpio_desc *desc)
 {
-	return desc->chip->base + gpio_chip_hwgpio(desc);
+	return desc - &gpio_desc[0];
 }
 
 
@@ -1214,15 +1214,14 @@
 		}
 	}
 
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
 #ifdef CONFIG_PINCTRL
 	INIT_LIST_HEAD(&chip->pin_ranges);
 #endif
 
 	of_gpiochip_add(chip);
 
-unlock:
-	spin_unlock_irqrestore(&gpio_lock, flags);
-
 	if (status)
 		goto fail;
 
@@ -1235,6 +1234,9 @@
 		chip->label ? : "generic");
 
 	return 0;
+
+unlock:
+	spin_unlock_irqrestore(&gpio_lock, flags);
 fail:
 	/* failures here can mean systems won't boot... */
 	pr_err("gpiochip_add: gpios %d..%d (%s) failed to register\n",
diff -ur ./drivers/gpu/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpu/Makefile
--- ./drivers/gpu/Makefile	2023-04-26 12:26:00.990132142 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpu/Makefile	2023-04-23 12:01:30.506470700 +0100
@@ -1,2 +1,2 @@
-obj-y			+= drm/ vga/
+obj-y			+= drm/ vga/ vivante/
 obj-$(CONFIG_TEGRA_HOST1X)	+= host1x/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpu/drm/nouveau/core/subdev/i2c: AHY9U3~9.C
Only in ./drivers/gpu/drm/nouveau/core/subdev/i2c: aux.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/gpu: vivante
diff -ur ./drivers/hid/hid-input.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/hid/hid-input.c
--- ./drivers/hid/hid-input.c	2023-04-26 12:56:05.300118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/hid/hid-input.c	2023-04-23 12:01:58.665425600 +0100
@@ -1338,8 +1338,9 @@
 				 * UGCI) cram a lot of unrelated inputs into the
 				 * same interface. */
 				hidinput->report = report;
-				if (drv->input_configured)
-					drv->input_configured(hid, hidinput);
+				if (drv->input_configured &&
+				    drv->input_configured(hid, hidinput))
+					goto out_cleanup;
 				if (input_register_device(hidinput->input))
 					goto out_cleanup;
 				hidinput = NULL;
@@ -1360,8 +1361,9 @@
 	}
 
 	if (hidinput) {
-		if (drv->input_configured)
-			drv->input_configured(hid, hidinput);
+		if (drv->input_configured &&
+		    drv->input_configured(hid, hidinput))
+			goto out_cleanup;
 		if (input_register_device(hidinput->input))
 			goto out_cleanup;
 	}
diff -ur ./drivers/hid/hid-multitouch.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/hid/hid-multitouch.c
--- ./drivers/hid/hid-multitouch.c	2023-04-26 12:56:05.310118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/hid/hid-multitouch.c	2023-04-23 12:01:58.986841200 +0100
@@ -443,6 +443,16 @@
 	    (usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)
 		td->mt_flags |= INPUT_MT_POINTER;
 
+	/* Only map fields from TouchScreen or TouchPad collections.
+         * We need to ignore fields that belong to other collections
+         * such as Mouse that might have the same GenericDesktop usages. */
+	if (field->application == HID_DG_TOUCHSCREEN)
+		set_bit(INPUT_PROP_DIRECT, hi->input->propbit);
+	else if (field->application == HID_DG_TOUCHPAD)
+		set_bit(INPUT_PROP_POINTER, hi->input->propbit);
+	else
+		return 0;
+
 	if (usage->usage_index)
 		prev_usage = &field->usage[usage->usage_index - 1];
 
@@ -772,12 +782,13 @@
 		mt_sync_frame(td, report->field[0]->hidinput->input);
 }
 
-static void mt_touch_input_configured(struct hid_device *hdev,
+static int mt_touch_input_configured(struct hid_device *hdev,
 					struct hid_input *hi)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
 	struct mt_class *cls = &td->mtclass;
 	struct input_dev *input = hi->input;
+	int ret;
 
 	if (!td->maxcontacts)
 		td->maxcontacts = MT_DEFAULT_MAXCONTACT;
@@ -792,9 +803,12 @@
 	if (cls->quirks & MT_QUIRK_NOT_SEEN_MEANS_UP)
 		td->mt_flags |= INPUT_MT_DROP_UNUSED;
 
-	input_mt_init_slots(input, td->maxcontacts, td->mt_flags);
+	ret = input_mt_init_slots(input, td->maxcontacts, td->mt_flags);
+	if (ret)
+		return ret;
 
 	td->mt_flags = 0;
+	return 0;
 }
 
 static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
@@ -927,19 +941,21 @@
 		cls->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;
 }
 
-static void mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
+static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
 	char *name = kstrdup(hdev->name, GFP_KERNEL);
+	int ret = 0;
 
 	if (name)
 		hi->input->name = name;
 
 	if (hi->report->id == td->mt_report_id)
-		mt_touch_input_configured(hdev, hi);
+		ret = mt_touch_input_configured(hdev, hi);
 
 	if (hi->report->id == td->pen_report_id)
 		mt_pen_input_configured(hdev, hi);
+	return ret;
 }
 
 static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
diff -ur ./drivers/i2c/busses/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/i2c/busses/Kconfig
--- ./drivers/i2c/busses/Kconfig	2023-04-26 12:56:05.330118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/i2c/busses/Kconfig	2023-04-23 12:02:04.271384400 +0100
@@ -765,6 +765,132 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-rcar.
 
+config I2C_V12_JZ
+        tristate "Ingenic SoC based on Xburst arch's I2C controler Driver support"
+	depends on MACH_XBURST
+	default n
+	help
+	  Say Y here in order to support Ingenic SoC's I2C Controller Drvier,
+	  for example, M200, M150, JZ4775, JZ4780, and so on.
+
+config I2C_FIFO_LEN
+        int "JZ_V12 I2C Controller FIFO length"
+	default 64
+	depends on I2C_V12_JZ
+	help
+	  M200 and JZ4775 have 64 entries FIFO.
+
+config I2C_DEBUG_INFO
+	bool "enable or disable Ingenic Soc's I2C driver debug info"
+	default n
+	depends on I2C_V12_JZ
+	help
+	  I2C debug print info, you can get the debug information from
+	  /sys/devices/platform/jz_i2c.x/debug_info,
+	  for example, echo 3 > /sys/devices/platform/jz_i2c.x/debug
+
+config SOFT_I2C0_GPIO_V12_JZ
+	bool "soft gpio for i2c controler 0 Interface support"
+	depends on I2C_GPIO
+
+config I2C0_V12_JZ
+        tristate "JZ_v12 i2c controler 0 Interface support"
+	depends on I2C_V12_JZ && !SOFT_I2C0_GPIO_V12_JZ
+	default n
+
+choice
+	prompt "JZ_v12 i2c controler 0 function pins select"
+	depends on I2C0_V12_JZ
+	default I2C0_PA12_PA13
+config I2C0_PA12_PA13
+	depends on SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	bool "GPIO_PA12 & GPIO_PA13"
+endchoice
+
+config I2C0_NON_RESTART_MODE
+	bool "controler i2c0 no restart mode"
+	depends on I2C0_V12_JZ
+	default n
+
+config I2C0_SPEED
+        int "Jz_v12 i2c0 speed in KHZ"
+        range 100 400
+        default 400
+        depends on I2C0_V12_JZ || SOFT_I2C0_GPIO_V12_JZ
+
+config SOFT_I2C1_GPIO_V12_JZ
+	bool "soft gpio for i2c controler 1 Interface support"
+	depends on I2C_GPIO
+
+config I2C1_V12_JZ
+        tristate "JZ_v12 i2c controler 1 Interface support"
+	depends on I2C_V12_JZ && !SOFT_I2C1_GPIO_V12_JZ
+	default n
+
+choice
+	prompt "JZ_v12 i2c controler 1 function pins select"
+	depends on I2C1_V12_JZ
+	default I2C1_PB25_PB26
+config I2C1_PB25_PB26
+	depends on SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	bool "GPIO_PB25 & GPIO_PB26"
+config I2C1_PC08_PC09
+	depends on SOC_T31
+	bool "GPIO_PC08 & GPIO_PC09"
+endchoice
+
+config I2C1_SPEED
+        int "Jz_v12 i2c1 speed in KHZ"
+        range 10 400
+        default 400
+	depends on I2C1_V12_JZ || SOFT_I2C1_GPIO_V12_JZ
+
+config I2C1_NON_RESTART_MODE
+	bool "controler i2c1 no restart mode"
+	depends on I2C1_V12_JZ
+	default n
+
+config SOFT_I2C2_GPIO_V12_JZ
+	bool "soft gpio for i2c controler 2 Interface support"
+	depends on I2C_GPIO
+
+config I2C2_V12_JZ
+        tristate "JZ_v12 i2c controler 2 Interface support"
+	depends on I2C_V12_JZ && !SOFT_I2C2_GPIO_V12_JZ
+	default n
+
+choice
+	prompt "JZ_v12 i2c controler 2 function pins select"
+	depends on I2C2_V12_JZ
+	default I2C2_PC27_PC28
+config I2C2_PC27_PC28
+	depends on SOC_T30
+	bool "GPIO_PC27 & GPIO_PC28"
+endchoice
+
+config I2C2_SPEED
+        int "Jz_v12 i2c2 speed in KHZ"
+        range 10 400
+        default 400
+	depends on I2C2_V12_JZ || SOFT_I2C2_GPIO_V12_JZ
+
+config I2C2_NON_RESTART_MODE
+	bool "controler i2c2 no restart mode"
+	depends on I2C2_V12_JZ
+	default n
+
+config I2C_JZV12_WAIT_MS
+        int "JZ i2c bus wait timeout in ms"
+	range 10 1000
+        default 1000
+        depends on I2C0_V12_JZ || I2C1_V12_JZ
+        help
+        Select Jz bus wait time in ms.
+         Examples:
+	      100 => 100 ms
+              200 => 200 ms
+	      300 => 300 ms
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_DIOLAN_U2C
diff -ur ./drivers/i2c/busses/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/i2c/busses/Makefile
--- ./drivers/i2c/busses/Makefile	2023-04-26 12:56:05.330118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/i2c/busses/Makefile	2023-04-23 12:02:04.270975300 +0100
@@ -76,6 +76,13 @@
 obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
 obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
 
+obj-$(CONFIG_I2C0_V12_JZ) 	+= i2c-v12-jz.o
+obj-$(CONFIG_I2C1_V12_JZ)       += i2c-v12-jz.o
+obj-$(CONFIG_I2C2_V12_JZ)       += i2c-v12-jz.o
+obj-$(CONFIG_I2C3_V12_JZ)       += i2c-v12-jz.o
+
+
+
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_DIOLAN_U2C)	+= i2c-diolan-u2c.o
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/i2c/busses: i2c-v12-jz.c
diff -ur ./drivers/ide/ide-taskfile.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/ide/ide-taskfile.c
--- ./drivers/ide/ide-taskfile.c	2023-04-26 12:56:05.350118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/ide/ide-taskfile.c	2023-04-23 12:02:07.548258100 +0100
@@ -239,9 +239,6 @@
 		unsigned nr_bytes = min(len, cursg->length - cmd->cursg_ofs);
 		int page_is_high;
 
-		if (nr_bytes > PAGE_SIZE)
-			nr_bytes = PAGE_SIZE;
-
 		page = sg_page(cursg);
 		offset = cursg->offset + cmd->cursg_ofs;
 
@@ -249,6 +246,8 @@
 		page = nth_page(page, (offset >> PAGE_SHIFT));
 		offset %= PAGE_SIZE;
 
+		nr_bytes = min_t(unsigned, nr_bytes, (PAGE_SIZE - offset));
+
 		page_is_high = PageHighMem(page);
 		if (page_is_high)
 			local_irq_save(flags);
diff -ur ./drivers/iio/imu/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/imu/Kconfig
--- ./drivers/iio/imu/Kconfig	2023-04-26 12:26:02.520133201 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/imu/Kconfig	2023-04-23 12:02:09.788444600 +0100
@@ -23,6 +23,7 @@
 	  Say yes here to build support for Analog Devices ADIS16375, ADIS16480,
 	  ADIS16485, ADIS16488 inertial sensors.
 
+source "drivers/iio/imu/inv_mpu/Kconfig"
 endmenu
 
 config IIO_ADIS_LIB
diff -ur ./drivers/iio/imu/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/imu/Makefile
--- ./drivers/iio/imu/Makefile	2023-04-26 12:26:02.520133201 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/imu/Makefile	2023-04-23 12:02:09.787821200 +0100
@@ -12,4 +12,5 @@
 adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_buffer.o
 obj-$(CONFIG_IIO_ADIS_LIB) += adis_lib.o
 
+obj-y += inv_mpu/
 obj-y += inv_mpu6050/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/imu: inv_mpu
diff -ur ./drivers/iio/industrialio-core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/industrialio-core.c
--- ./drivers/iio/industrialio-core.c	2023-04-26 12:26:02.540133201 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/industrialio-core.c	2023-04-23 12:02:10.349971600 +0100
@@ -691,34 +691,35 @@
 
 	if (chan->channel < 0)
 		return 0;
-	for_each_set_bit(i, &chan->info_mask_separate, sizeof(long)*8) {
-		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
-					     chan,
-					     &iio_read_channel_info,
-					     &iio_write_channel_info,
-					     i,
-					     0,
-					     &indio_dev->dev,
-					     &indio_dev->channel_attr_list);
-		if (ret < 0)
-			goto error_ret;
-		attrcount++;
-	}
-	for_each_set_bit(i, &chan->info_mask_shared_by_type, sizeof(long)*8) {
-		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
+
+	ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
+			chan,
+			&iio_read_channel_info,
+			&iio_write_channel_info,
+			i,
+			0,
+			&indio_dev->dev,
+			&indio_dev->channel_attr_list);
+	if (ret < 0)
+		goto error_ret;
+	attrcount++;
+
+
+	for_each_set_bit(i, &chan->info_mask, sizeof(long)*8) {
+		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i/2],
 					     chan,
 					     &iio_read_channel_info,
 					     &iio_write_channel_info,
-					     i,
-					     1,
+					     i/2,
+					     !(i%2),
 					     &indio_dev->dev,
 					     &indio_dev->channel_attr_list);
-		if (ret == -EBUSY) {
+		if (ret == -EBUSY && (i%2 == 0)) {
 			ret = 0;
 			continue;
-		} else if (ret < 0) {
-			goto error_ret;
 		}
+		if (ret < 0)
+			goto error_ret;
 		attrcount++;
 	}
 
diff -ur ./drivers/iio/industrialio-event.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/industrialio-event.c
--- ./drivers/iio/industrialio-event.c	2023-04-26 12:26:02.540133201 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio/industrialio-event.c	2023-04-23 12:02:10.349033300 +0100
@@ -35,6 +35,7 @@
  */
 struct iio_event_interface {
 	wait_queue_head_t	wait;
+	struct mutex		read_lock;
 	DECLARE_KFIFO(det_events, struct iio_event_data, 16);
 
 	struct list_head	dev_attr_list;
@@ -97,14 +98,16 @@
 	if (count < sizeof(struct iio_event_data))
 		return -EINVAL;
 
-	spin_lock_irq(&ev_int->wait.lock);
+	if (mutex_lock_interruptible(&ev_int->read_lock))
+		return -ERESTARTSYS;
+
 	if (kfifo_is_empty(&ev_int->det_events)) {
 		if (filep->f_flags & O_NONBLOCK) {
 			ret = -EAGAIN;
 			goto error_unlock;
 		}
 		/* Blocking on device; waiting for something to be there */
-		ret = wait_event_interruptible_locked_irq(ev_int->wait,
+		ret = wait_event_interruptible(ev_int->wait,
 					!kfifo_is_empty(&ev_int->det_events));
 		if (ret)
 			goto error_unlock;
@@ -114,7 +117,7 @@
 	ret = kfifo_to_user(&ev_int->det_events, buf, count, &copied);
 
 error_unlock:
-	spin_unlock_irq(&ev_int->wait.lock);
+	mutex_unlock(&ev_int->read_lock);
 
 	return ret ? ret : copied;
 }
@@ -371,6 +374,7 @@
 {
 	INIT_KFIFO(ev_int->det_events);
 	init_waitqueue_head(&ev_int->wait);
+	mutex_init(&ev_int->read_lock);
 }
 
 static const char *iio_event_group_name = "events";
@@ -434,6 +438,7 @@
 
 error_free_setup_event_lines:
 	__iio_remove_event_config_attrs(indio_dev);
+	mutex_destroy(&indio_dev->event_interface->read_lock);
 	kfree(indio_dev->event_interface);
 error_ret:
 
@@ -446,5 +451,6 @@
 		return;
 	__iio_remove_event_config_attrs(indio_dev);
 	kfree(indio_dev->event_interface->group.attrs);
+	mutex_destroy(&indio_dev->event_interface->read_lock);
 	kfree(indio_dev->event_interface);
 }
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio: industrialio-ring.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/iio: inv_test
diff -ur ./drivers/input/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/Kconfig
--- ./drivers/input/Kconfig	2023-04-26 12:26:02.930133202 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/Kconfig	2023-04-23 12:02:17.705993900 +0100
@@ -174,6 +174,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 comment "Input Device Drivers"
 
 source "drivers/input/keyboard/Kconfig"
diff -ur ./drivers/input/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/Makefile
--- ./drivers/input/Makefile	2023-04-26 12:26:02.930133202 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/Makefile	2023-04-23 12:02:17.705456100 +0100
@@ -25,3 +25,4 @@
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
diff -ur ./drivers/input/evdev.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/evdev.c
--- ./drivers/input/evdev.c	2023-04-26 12:56:05.400118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/evdev.c	2023-04-23 12:02:17.787646400 +0100
@@ -24,6 +24,7 @@
 #include <linux/major.h>
 #include <linux/device.h>
 #include <linux/cdev.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -44,6 +45,9 @@
 	unsigned int tail;
 	unsigned int packet_head; /* [future] position of the first element of next packet */
 	spinlock_t buffer_lock; /* protects access to buffer, head and tail */
+	struct wake_lock wake_lock;
+	bool use_wake_lock;
+	char name[28];
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
@@ -71,10 +75,14 @@
 		client->buffer[client->tail].value = 0;
 
 		client->packet_head = client->tail;
+		if (client->use_wake_lock)
+			wake_unlock(&client->wake_lock);
 	}
 
 	if (event->type == EV_SYN && event->code == SYN_REPORT) {
 		client->packet_head = client->head;
+		if (client->use_wake_lock)
+			wake_lock(&client->wake_lock);
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
 }
@@ -289,6 +297,8 @@
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	if (client->use_wake_lock)
+		wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -320,6 +330,8 @@
 
 	client->bufsize = bufsize;
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d",
+			dev_name(&evdev->dev), task_tgid_vnr(current));
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -386,6 +398,9 @@
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= client->bufsize - 1;
+		if (client->use_wake_lock &&
+		    client->packet_head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
@@ -674,6 +689,35 @@
 	return 0;
 }
 
+static int evdev_enable_suspend_block(struct evdev *evdev,
+				      struct evdev_client *client)
+{
+	if (client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
+	client->use_wake_lock = true;
+	if (client->packet_head != client->tail)
+		wake_lock(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+	return 0;
+}
+
+static int evdev_disable_suspend_block(struct evdev *evdev,
+				       struct evdev_client *client)
+{
+	if (!client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	client->use_wake_lock = false;
+	wake_lock_destroy(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+
+	return 0;
+}
+
 static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 			   void __user *p, int compat_mode)
 {
@@ -755,6 +799,15 @@
 
 	case EVIOCSKEYCODE_V2:
 		return evdev_handle_set_keycode_v2(dev, p);
+
+	case EVIOCGSUSPENDBLOCK:
+		return put_user(client->use_wake_lock, ip);
+
+	case EVIOCSSUSPENDBLOCK:
+		if (p)
+			return evdev_enable_suspend_block(evdev, client);
+		else
+			return evdev_disable_suspend_block(evdev, client);
 	}
 
 	size = _IOC_SIZE(cmd);
diff -ur ./drivers/input/input.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/input.c
--- ./drivers/input/input.c	2023-04-26 12:26:02.940133202 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/input.c	2023-04-23 12:02:18.028035500 +0100
@@ -27,6 +27,7 @@
 #include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/rcupdate.h>
+#include <linux/fb.h>
 #include "input-compat.h"
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
@@ -1979,6 +1980,9 @@
 
 	input_wakeup_procfs_readers();
 
+#ifdef CONFIG_FBBLANK_SUSPEND_TS
+	fb_unregister_client(&dev->fb_notif);
+#endif
 	mutex_unlock(&input_mutex);
 
 	device_del(&dev->dev);
@@ -1994,6 +1998,38 @@
 	__input_unregister_device(input);
 }
 
+#ifdef CONFIG_FBBLANK_SUSPEND_TS
+static int fb_notifier_callback(struct notifier_block *self,unsigned long event, void *data)
+{
+	struct input_dev *dev;
+
+	/* If we aren't interested in this event, skip it immediately ... */
+	switch (event) {
+		case FB_EVENT_BLANK:
+		case FB_EVENT_MODE_CHANGE:
+		case FB_EVENT_MODE_CHANGE_ALL:
+		case FB_EARLY_EVENT_BLANK:
+		case FB_R_EARLY_EVENT_BLANK:
+			break;
+		default:
+			return 0;
+	}
+
+	dev = container_of(self, struct input_dev, fb_notif);
+
+	mutex_lock(&dev->mutex);
+	if (event == FB_EVENT_BLANK) {
+		if (dev->users && dev->open)
+			dev->open(dev);
+	} else {
+		if (dev->users && dev->close)
+			dev->close(dev);
+	}
+	mutex_unlock(&dev->mutex);
+	return 0;
+}
+#endif
+
 /**
  * input_register_device - register device with input core
  * @dev: device to be registered
@@ -2104,6 +2140,16 @@
 			__func__, dev_name(&dev->dev));
 		devres_add(dev->dev.parent, devres);
 	}
+#ifdef CONFIG_FBBLANK_SUSPEND_TS
+	memset(&dev->fb_notif, 0, sizeof(dev->fb_notif));
+	dev->fb_notif.notifier_call = fb_notifier_callback;
+
+	if (test_bit(BTN_TOUCH, dev->keybit) && test_bit(ABS_MT_POSITION_X, dev->absbit) && test_bit(ABS_MT_POSITION_Y, dev->absbit)) {
+		return fb_register_client(&dev->fb_notif);
+	} else if (test_bit(BTN_TOUCH, dev->keybit) && test_bit(ABS_X, dev->absbit) && test_bit(ABS_Y, dev->absbit)) {
+		return fb_register_client(&dev->fb_notif);
+	}
+#endif
 	return 0;
 
 err_device_del:
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input: keyreset.c
diff -ur ./drivers/input/misc/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc/Kconfig
--- ./drivers/input/misc/Kconfig	2023-04-26 12:56:05.410118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc/Kconfig	2023-04-23 12:02:19.628473800 +0100
@@ -299,6 +299,17 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control"
 	depends on USB_ARCH_HAS_HCD
@@ -434,6 +445,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called sgi_btns.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
diff -ur ./drivers/input/misc/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc/Makefile
--- ./drivers/input/misc/Makefile	2023-04-26 12:56:05.410118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc/Makefile	2023-04-23 12:02:19.628034600 +0100
@@ -28,9 +28,11 @@
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
 obj-$(CONFIG_INPUT_GP2A)		+= gp2ap002a00f.o
 obj-$(CONFIG_INPUT_GPIO_TILT_POLLED)	+= gpio_tilt_polled.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IMS_PCU)		+= ims-pcu.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_KXTJ9)		+= kxtj9.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: gpio_axis.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: gpio_event.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: gpio_input.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: gpio_matrix.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: gpio_output.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/misc: keychord.c
diff -ur ./drivers/input/serio/i8042-io.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/serio/i8042-io.h
--- ./drivers/input/serio/i8042-io.h	2023-04-26 12:26:03.090133203 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/serio/i8042-io.h	2023-04-23 12:02:21.631716700 +0100
@@ -76,7 +76,7 @@
 	if (check_legacy_ioport(I8042_DATA_REG))
 		return -ENODEV;
 #endif
-#if !defined(__sh__) && !defined(__alpha__)
+#if !defined(__sh__) && !defined(__alpha__) && !defined(__mips__)
 	if (!request_region(I8042_DATA_REG, 16, "i8042"))
 		return -EBUSY;
 #endif
@@ -87,7 +87,7 @@
 
 static inline void i8042_platform_exit(void)
 {
-#if !defined(__sh__) && !defined(__alpha__)
+#if !defined(__sh__) && !defined(__alpha__) && !defined(__mips__)
 	release_region(I8042_DATA_REG, 16);
 #endif
 }
diff -ur ./drivers/input/touchscreen/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen/Kconfig
--- ./drivers/input/touchscreen/Kconfig	2023-04-26 12:56:05.430118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen/Kconfig	2023-04-23 12:02:22.266227500 +0100
@@ -10,6 +10,97 @@
 	  If unsure, say Y.
 
 if INPUT_TOUCHSCREEN
+############-ingenic-touchscreen-############
+config M200_SUPPORT_TSC
+	bool "Touchscreen Supported on M200"
+	depends on SOC_M200 && INPUT_TOUCHSCREEN
+	help
+	  This selects the touchscreen that Ingenic XBurst M200 support,
+	  say Y or N here.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_FT5336
+	tristate "FocalTech FT5336 TouchScreen driver"
+	depends on I2C && M200_SUPPORT_TSC && I2C0_V12_JZ
+	default n
+	help
+	  FocalTech FT5336GQQ TouchSreen Driver implemented by Ingenic.
+config TOUCHSCREEN_FT6X06
+	tristate "FocalTech FT6X06 TouchScreen driver"
+	depends on I2C && M200_SUPPORT_TSC && I2C0_V12_JZ
+	default n
+	help
+	  pisecs FocalTech FT6X06 TouchSreen Driver implemented by Ingenic.
+
+config FT6X06_MULTITOUCH
+	bool "Enable multi-touch on FocalTech FT6X06 "
+	depends on TOUCHSCREEN_FT6X06
+	default y
+	help
+	  support multitouch ft6206,if you want , say Y here.
+
+config TOUCHSCREEN_FT6X0X
+       tristate "Touchscreen ft6x0x"
+       depends on I2C && M200_SUPPORT_TSC
+       help
+       ft6x0x is a CTP controller
+
+if TOUCHSCREEN_FT6X0X
+config FT6X0X_EXT_FUNC
+	 bool "ft6x0x extra function"
+	 depends on TOUCHSCREEN_FT6X0X
+	 default n
+	 help
+		ft6x0x extra function:
+		l.sysfs inferface
+		2.tp firmware upgrade control
+		3.tp regs read write
+
+if FT6X0X_EXT_FUNC
+choice
+	 prompt "ft6x0x fireware"
+		  depends on FT6X0X_EXT_FUNC
+		  default TOUCHSCREEN_FT6X0X_YIYANG_1S
+config TOUCHSCREEN_FT6X0X_YIYANG_1S
+	 bool "YIYANG fireware monitor 1S"
+
+config TOUCHSCREEN_FT6X0X_YIYANG_10S
+	 bool "YIYANG fireware monitor 10S"
+
+config TOUCHSCREEN_FT6X0X_TWS
+	 bool "TWS fireware"
+endchoice
+endif
+endif
+
+config 	TSC_SWAP_XY
+		bool "swap x and y "
+		depends on INPUT_TOUCHSCREEN
+		default n
+		help
+			say Y here if you need flip x y.
+config 	TSC_SWAP_X
+		bool "swap x"
+		depends on INPUT_TOUCHSCREEN
+		default n
+		help
+			say Y here if you need flip x y.
+config 	TSC_SWAP_Y
+		bool "swap y "
+		depends on INPUT_TOUCHSCREEN
+		default n
+		help
+			say Y here if you need flip x y.
+
+config FT5X0X_DEBUG
+		bool "Enable FT5X0X TouchScreen driver Debug output"
+		depends on TOUCHSCREEN_FT5306 || TOUCHSCREEN_FT5X0X
+		default n
+		help
+			say Y here if you are trying to debug cft5306
+
+#############################################
 
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
@@ -66,6 +157,19 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7879.
 
+config TOUCHSCREEN_ITE7258
+	tristate "Touchscreen ite7258"
+	depends on I2C && M200_SUPPORT_TSC
+	help
+		ite7258 a CTP controller,support panel unknown
+
+config ITE7258_MULTITOUCH
+	bool "Enable multi-touch on FocalTech ITE7258 "
+	depends on TOUCHSCREEN_ITE7258
+	default y
+	help
+	  support multitouch ite7258,if you want , say Y here.
+
 config TOUCHSCREEN_AD7879_I2C
 	tristate "support I2C bus connection"
 	depends on TOUCHSCREEN_AD7879 && I2C
@@ -86,6 +190,7 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7879-spi.
 
+
 config TOUCHSCREEN_ATMEL_MXT
 	tristate "Atmel mXT I2C Touchscreen"
 	depends on I2C
diff -ur ./drivers/input/touchscreen/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen/Makefile
--- ./drivers/input/touchscreen/Makefile	2023-04-26 12:56:05.430118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen/Makefile	2023-04-23 12:02:22.265936600 +0100
@@ -6,6 +6,26 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+##########-ingenic-touchscreen-###########
+
+obj-$(CONFIG_TOUCHSCREEN_JZ_GT801)	+= tsc_gt801.o
+obj-$(CONFIG_TOUCHSCREEN_LDWZIC)        += ldwzic_ts.o
+obj-$(CONFIG_TOUCHSCREEN_JZ_SSD253X)	+= ssd253x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X0X)        += ft5x0x_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X06)        += ft5x06_ts.o
+obj-$(CONFIG_TOUCHSCREEN_MG8698S)        += mg8698s_ts.o
+obj-$(CONFIG_GSlX680_CAPACITIVE_TOUCHSCREEN)	+= gslX680.o
+obj-$(CONFIG_TOUCHSCREEN_ZET6221)        += zet6221_ts.o zet6221_downloader.o
+obj-$(CONFIG_TOUCHSCREEN_FT5306)        += ft5306_ts.o
+obj-$(CONFIG_TOUCHSCREEN_CTP_IT7260)    += ctp_it7260.o
+obj-$(CONFIG_TOUCHSCREEN_GWTC9XXXB)     += gwtc9xxxb_ts.o
+obj-$(CONFIG_TOUCHSCREEN_NOVATEK)       += novatek_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix_ts.o
+obj-$(CONFIG_JZ4780_SUPPORT_RESISTANCE_TSC) +=jz4780_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5336)        += ft5336_ts.o
+obj-$(CONFIG_TOUCHSCREEN_ITE7258)        += ite7258_ts.o
+
+##########################################
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
@@ -64,6 +84,7 @@
 obj-$(CONFIG_TOUCHSCREEN_WACOM_I2C)	+= wacom_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_WM831X)	+= wm831x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX)	+= wm97xx-ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT6X06)	+= ft6x06_ts.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9705)	+= wm9705.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ft5336_ts.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ft6x06_ts.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ite7258_cfg.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ite7258_fw.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ite7258_ts.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/input/touchscreen: ite7258_ts.h
diff -ur ./drivers/media/i2c/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c/Kconfig
--- ./drivers/media/i2c/Kconfig	2023-04-26 12:56:05.520118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c/Kconfig	2023-04-23 12:02:41.946263900 +0100
@@ -444,6 +444,22 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov7640.
 
+config VIDEO_OV5645
+	tristate "OmniVision OV5645 sensor support"
+	depends on I2C && VIDEO_V4L2
+	depends on MEDIA_CAMERA_SUPPORT
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5645 camera.
+
+config VIDEO_OV9724
+	tristate "OmniVision OV9724 sensor support"
+	depends on I2C && VIDEO_V4L2
+	depends on MEDIA_CAMERA_SUPPORT
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV9724 camera.
+
 config VIDEO_OV7670
 	tristate "OmniVision OV7670 sensor support"
 	depends on I2C && VIDEO_V4L2
diff -ur ./drivers/media/i2c/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c/Makefile
--- ./drivers/media/i2c/Makefile	2023-04-26 12:56:05.520118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c/Makefile	2023-04-23 12:02:41.946750700 +0100
@@ -54,6 +54,8 @@
 obj-$(CONFIG_VIDEO_OV7640) += ov7640.o
 obj-$(CONFIG_VIDEO_OV7670) += ov7670.o
 obj-$(CONFIG_VIDEO_OV9650) += ov9650.o
+obj-$(CONFIG_VIDEO_OV9724) += ov9724.o
+obj-$(CONFIG_VIDEO_OV5645) += ov5645.o
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_MT9M032) += mt9m032.o
 obj-$(CONFIG_VIDEO_MT9P031) += mt9p031.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c: ov5645.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c: ov5645.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c: ov9724.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/i2c: ov9724.h
diff -ur ./drivers/media/platform/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/platform/Kconfig
--- ./drivers/media/platform/Kconfig	2023-04-26 12:56:05.620118960 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/platform/Kconfig	2023-04-23 12:02:52.670197300 +0100
@@ -53,6 +53,18 @@
 	  Say Y here if you want to enable VIU device on MPC5121e Rev2+.
 	  In doubt, say N.
 
+config VIDEO_TX_ISP
+	  bool "TX ISP MODULE"
+	  select VIDEOBUF2_CORE
+	  select VIDEOBUF2_MEMOPS
+	  depends on VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API
+	  ---help---
+	  Driver for TX ISP.
+
+if VIDEO_TX_ISP
+source "drivers/media/platform/tx-isp/Kconfig"
+endif #VIDEO_TX_ISP
+
 config VIDEO_TIMBERDALE
 	tristate "Support for timberdale Video In/LogiWIN"
 	depends on VIDEO_V4L2 && I2C && DMADEVICES
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/platform: ovisp
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/platform: tx-isp
diff -ur ./drivers/media/v4l2-core/v4l2-ioctl.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/v4l2-core/v4l2-ioctl.c
--- ./drivers/media/v4l2-core/v4l2-ioctl.c	2023-04-26 12:56:05.770118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/media/v4l2-core/v4l2-ioctl.c	2023-04-23 12:03:11.706390700 +0100
@@ -2124,6 +2124,8 @@
 
 struct mutex *v4l2_ioctl_get_lock(struct video_device *vdev, unsigned cmd)
 {
+	if(cmd == VIDIOC_DEFAULT_CMD_LISTEN_BUF)
+		return NULL;
 	if (_IOC_NR(cmd) >= V4L2_IOCTLS)
 		return vdev->lock;
 	if (test_bit(_IOC_NR(cmd), vdev->disable_locking))
diff -ur ./drivers/mfd/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd/Kconfig
--- ./drivers/mfd/Kconfig	2023-04-26 12:56:05.780118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd/Kconfig	2023-04-23 12:03:13.795352100 +0100
@@ -18,6 +18,15 @@
 	  This is the core driver for CS5535/CS5536 MFD functions.  This is
           necessary for using the board's GPIO and MFGPT functionality.
 
+config MFD_DA9024
+	  bool "Support PMIC DA9024 or D2041"
+	  depends on I2C=y && MACH_XBURST
+	  select MFD_CORE
+	  help
+	    This supports for DA9024 or D2041 Power Management IC.
+	    This includes the I2C driver and the core APIs _only_, you have to
+	    select individual components like voltage regulators, RTC.
+
 config MFD_AS3711
 	bool "AMS AS3711"
 	select MFD_CORE
@@ -242,6 +251,44 @@
 	  Say yes here if you want support for the ADC unit in the JZ4740 SoC.
 	  This driver is necessary for jz4740-battery and jz4740-hwmon driver.
 
+config MFD_JZ_SADC_V11
+    tristate "Support for the JZ V11 SADC core"
+	select MFD_CORE
+	depends on SOC_4775
+	help
+	Say yes here if you want support for the SADC unit in the JZ4775 SoC.
+	This driver is necessary for jz-battery driver.
+
+
+config MFD_JZ_SADC_V12
+	tristate "Support for the M200 SADC core"
+	select MFD_CORE
+	depends on SOC_M200
+	help
+	  Say yes here if you want support for the SADC unit in the M200 SoC.
+	  This driver is necessary for jz_battery driver.
+
+config MFD_JZ_SADC_V13
+	tristate "Support for the XBurst SADC core"
+	select MFD_CORE
+	depends on SOC_T15 || SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	help
+	  Say yes here if you want support for the SADC unit in the T15 SoC.
+
+config MFD_JZ_SADC_AUX
+	tristate "Support for the XBurst SADC AUX"
+	select MFD_CORE
+	depends on SOC_T15 || SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	help
+	  Say yes here if you want support for the SADC unit in the T15 SoC.
+
+config MFD_JZ_TCU
+	tristate "Support for XBurst TCU"
+	select MFD_CORE
+	depends on SOC_T15 || SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	help
+	  Say yes here if you want support for the TCU in the XBurst SoC.
+
 config MFD_88PM800
 	tristate "Marvell 88PM800"
 	depends on I2C=y && GENERIC_HARDIRQS
@@ -1116,6 +1163,19 @@
 	  core support for the WM8994, in order to use the actual
 	  functionaltiy of the device other drivers must be enabled.
 
+config MFD_RICOH619
+	bool "Ricoh R5T619 Power Management system device"
+	depends on I2C && GPIOLIB && GENERIC_HARDIRQS
+	select MFD_CORE
+	default n
+	help
+	  If you say yes here you get support for the Ricoh R5T619
+	  Power Management system device.
+	  This driver provides common support for accessing the device,
+	  additional drivers must be enabled in order to use the
+	  functionality of the device.
+
+
 endmenu
 endif
 
@@ -1148,3 +1208,5 @@
 	help
 	  Platform configuration infrastructure for the ARM Ltd.
 	  Versatile Express.
+
+
diff -ur ./drivers/mfd/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd/Makefile
--- ./drivers/mfd/Makefile	2023-04-26 12:56:05.780118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd/Makefile	2023-04-23 12:03:13.794819300 +0100
@@ -131,6 +131,10 @@
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
 obj-$(CONFIG_MFD_JANZ_CMODIO)	+= janz-cmodio.o
 obj-$(CONFIG_MFD_JZ4740_ADC)	+= jz4740-adc.o
+obj-$(CONFIG_MFD_JZ_SADC_V11)   += jz_adc_v12.o
+obj-$(CONFIG_MFD_JZ_SADC_V12)	+= jz_adc_v12.o
+obj-$(CONFIG_MFD_JZ_SADC_V13)	+= jz_adc_v13.o
+obj-$(CONFIG_MFD_JZ_SADC_AUX)	+= jz_adc_aux.o
 obj-$(CONFIG_MFD_TPS6586X)	+= tps6586x.o
 obj-$(CONFIG_MFD_VX855)		+= vx855.o
 obj-$(CONFIG_MFD_WL1273_CORE)	+= wl1273-core.o
@@ -155,3 +159,8 @@
 obj-$(CONFIG_VEXPRESS_CONFIG)	+= vexpress-config.o vexpress-sysreg.o
 obj-$(CONFIG_MFD_RETU)		+= retu-mfd.o
 obj-$(CONFIG_MFD_AS3711)	+= as3711.o
+
+obj-$(CONFIG_MFD_DA9024)    	+= d2041-core.o d2041-irq.o d2041-i2c.o
+obj-$(CONFIG_MFD_RICOH619)	+= ricoh619.o ricoh619-irq.o
+
+obj-$(CONFIG_MFD_JZ_TCU)		+= jz_tcu.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: d2041-core.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: d2041-i2c.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: d2041-irq.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: jz_adc_aux.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: jz_adc_v11.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: jz_adc_v12.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: jz_adc_v13.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: jz_tcu.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: ricoh619-irq.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mfd: ricoh619.c
diff -ur ./drivers/misc/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc/Kconfig
--- ./drivers/misc/Kconfig	2023-04-26 12:56:05.810118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc/Kconfig	2023-04-23 12:03:17.623941000 +0100
@@ -51,6 +51,20 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad525x_dpot-spi.
 
+config JZ_SPI_NOR
+	  tristate "Support SPI NOR at Ingenic"
+	  depends on JZRISC
+	  default n
+	  help
+		  Support SPI NOR Flash to JZ SOC.
+
+config PWM_SDK
+	bool "pwm sdk api"
+	depends on JZ_PWM
+	default y
+		help
+			pwm sdk api
+
 config ATMEL_PWM
 	tristate "Atmel AT32/AT91 PWM support"
 	depends on HAVE_CLK
@@ -424,6 +438,10 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called ti_dac7512.
 
+config UID_STAT
+	bool "UID based statistics tracking exported to /proc/uid_stat"
+	default n
+
 config VMWARE_BALLOON
 	tristate "VMware Balloon Driver"
 	depends on X86 && HYPERVISOR_GUEST
@@ -507,6 +525,44 @@
 	  stereo and mono audio, video, microphone and UART data to use
 	  a common connector port.
 
+config BROADCOM_RFKILL
+	tristate "Bluetooth power control driver "
+	depends on RFKILL
+	default n
+	---help---
+	Creates an rfkill entry in sysfs for power control of Bluetooth
+	bcm4330 chips.
+
+config BT_BLUEDROID_SUPPORT
+	tristate "BLUEDROID power consumption sleep mode support"
+	depends on BROADCOM_RFKILL
+	default n
+	---help---
+	Add a policy for BT bluedroid stack about power consumption
+
+config BCM_PM_CORE
+	tristate "BCM module power control core driver"
+	default n
+	---help---
+	The driver is for power management of BCM chips, NFC, BT, WiFi.
+
+config BCM_RFKILL
+	tristate "Bluetooth power control driver for BCM-xxxx module"
+	depends on RFKILL
+	default n
+	---help---
+	Creates an rfkill entry in sysfs for power control of Bluetooth
+	bcm-xxxx chips.
+
+
+config GPS_RFKILL
+	tristate "GPS power control driver"
+	depends on RFKILL
+	default n
+	---help---
+	Creates an rfkill entry in sysfs for power control of GPS chips.
+
+
 config LATTICE_ECP3_CONFIG
 	tristate "Lattice ECP3 FPGA bitstream configuration via SPI"
 	depends on SPI && SYSFS
@@ -527,6 +583,37 @@
 	  the genalloc API. It is supposed to be used for small on-chip SRAM
 	  areas found on many SoCs.
 
+config JZ_EFUSE_V13
+	  bool "JZ V13 EFUSE Driver"
+	  default n
+
+config JZ_IRDA_V11
+	  bool "JZ V11_IRDA Driver"
+	  default n
+
+config LOGGER
+	tristate "Log driver porting from Android"
+	default n
+
+config LINUX_PMEM
+	bool "linux pmem allocator"
+	depends on !ANDROID_PMEM
+	default n
+
+config ANDROID_PMEM
+	bool "Android pmem allocator"
+	default n
+
+config JZ_AES
+	bool "JZ SC AES HDL for AES driver"
+
+config JZ_DES
+	bool "JZ SC DES HDL for DES driver"
+
+config RMEM
+	bool "Reserved memory driver(rmem)"
+	default y
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff -ur ./drivers/misc/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc/Makefile
--- ./drivers/misc/Makefile	2023-04-26 12:26:05.550133210 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc/Makefile	2023-04-23 12:03:17.707894700 +0100
@@ -36,8 +36,10 @@
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
+obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
+obj-$(CONFIG_JZ_SPI_NOR)        += jz_spi_nor/
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_SPEAR13XX_PCIE_GADGET)	+= spear13xx_pcie_gadget.o
@@ -47,9 +49,20 @@
 obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
 obj-y				+= carma/
+obj-$(CONFIG_BCM_PM_CORE) 	+= bcm-pm-core.o
+obj-$(CONFIG_BROADCOM_RFKILL)   += bt-power-bluesleep.o
+obj-$(CONFIG_GPS_RFKILL)    += gps-power.o
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
+obj-$(CONFIG_JZ_EFUSE_V13)  += jz_efuse_v13.o
+obj-$(CONFIG_JZ_IRDA_V11)   += jz_irda_v11.o
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
+obj-$(CONFIG_LOGGER)		+= logger.o
+obj-$(CONFIG_LINUX_PMEM)	+= linux_pmem.o
+obj-$(CONFIG_JZ_AES)		+= jz_aes/
+obj-$(CONFIG_JZ_DES)		+= jz_des/
+obj-$(CONFIG_RMEM)		+= rmem.o
+obj-$(CONFIG_PWM_SDK)		+= pwm_sdk.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: bcm-pm-core.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: bluesleep.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: bt-power-bluesleep.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: gps-power.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_aes
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_des
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_efuse_v11.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_efuse_v13.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_irda_v11.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: jz_spi_nor
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: linux_pmem.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: logger.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: logger.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: pwm_sdk.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: rmem.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/misc: uid_stat.c
diff -ur ./drivers/mmc/card/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/card/Kconfig
--- ./drivers/mmc/card/Kconfig	2023-04-26 12:26:05.690133210 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/card/Kconfig	2023-04-23 12:03:21.463292700 +0100
@@ -50,6 +50,15 @@
 
 	  If unsure, say Y here.
 
+config MMC_BLOCK_DEFERRED_RESUME
+	bool "Deferr MMC layer resume until I/O is requested"
+	depends on MMC_BLOCK
+	default n
+	help
+	  Say Y here to enable deferred MMC resume until I/O
+	  is requested. This will reduce overall resume latency and
+	  save power when theres an SD card inserted but not being used.
+
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	depends on TTY
diff -ur ./drivers/mmc/card/block.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/card/block.c
--- ./drivers/mmc/card/block.c	2023-04-26 12:56:05.840118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/card/block.c	2023-04-23 12:03:21.544794800 +0100
@@ -35,6 +35,9 @@
 #include <linux/capability.h>
 #include <linux/compat.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/mmc.h>
+
 #include <linux/mmc/ioctl.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -163,11 +166,7 @@
 
 static inline int mmc_get_devidx(struct gendisk *disk)
 {
-	int devmaj = MAJOR(disk_devt(disk));
-	int devidx = MINOR(disk_devt(disk)) / perdev_minors;
-
-	if (!devmaj)
-		devidx = disk->first_minor / perdev_minors;
+	int devidx = disk->first_minor / perdev_minors;
 	return devidx;
 }
 
@@ -728,18 +727,22 @@
 			req->rq_disk->disk_name, "timed out", name, status);
 
 		/* If the status cmd initially failed, retry the r/w cmd */
-		if (!status_valid)
+		if (!status_valid) {
+			pr_err("%s: status not valid, retrying timeout\n", req->rq_disk->disk_name);
 			return ERR_RETRY;
-
+		}
 		/*
 		 * If it was a r/w cmd crc error, or illegal command
 		 * (eg, issued in wrong state) then retry - we should
 		 * have corrected the state problem above.
 		 */
-		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND))
+		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND)) {
+			pr_err("%s: command error, retrying timeout\n", req->rq_disk->disk_name);
 			return ERR_RETRY;
+		}
 
 		/* Otherwise abort the command */
+		pr_err("%s: not retrying timeout\n", req->rq_disk->disk_name);
 		return ERR_ABORT;
 
 	default:
@@ -1002,9 +1005,12 @@
 			goto out;
 	}
 
-	if (mmc_can_sanitize(card))
+	if (mmc_can_sanitize(card)) {
+		trace_mmc_blk_erase_start(EXT_CSD_SANITIZE_START, 0, 0);
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				 EXT_CSD_SANITIZE_START, 1, 0);
+		trace_mmc_blk_erase_end(EXT_CSD_SANITIZE_START, 0, 0);
+	}
 out_retry:
 	if (err && !mmc_blk_reset(md, card->host, type))
 		goto retry;
@@ -1893,6 +1899,11 @@
 	struct mmc_host *host = card->host;
 	unsigned long flags;
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	if (mmc_bus_needs_resume(card->host))
+		mmc_resume_bus(card->host);
+#endif
+
 	if (req && !mq->mqrq_prev->req)
 		/* claim host only for the first request */
 		mmc_claim_host(card->host);
@@ -2015,6 +2026,7 @@
 	md->disk->queue = md->queue.queue;
 	md->disk->driverfs_dev = parent;
 	set_disk_ro(md->disk, md->read_only || default_ro);
+	md->disk->flags = GENHD_FL_EXT_DEVT;
 	if (area_type & MMC_BLK_DATA_AREA_RPMB)
 		md->disk->flags |= GENHD_FL_NO_PART_SCAN;
 
@@ -2136,7 +2148,7 @@
 
 	if (!mmc_card_mmc(card))
 		return 0;
-
+#if 0
 	for (idx = 0; idx < card->nr_parts; idx++) {
 		if (card->part[idx].size) {
 			ret = mmc_blk_alloc_part(card, md,
@@ -2149,7 +2161,7 @@
 				return ret;
 		}
 	}
-
+#endif
 	return ret;
 }
 
@@ -2329,6 +2341,9 @@
 	mmc_set_drvdata(card, md);
 	mmc_fixup_device(card, blk_fixups);
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 1);
+#endif
 	if (mmc_add_disk(md))
 		goto out;
 
@@ -2354,6 +2369,9 @@
 	mmc_release_host(card->host);
 	mmc_blk_remove_req(md);
 	mmc_set_drvdata(card, NULL);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 0);
+#endif
 }
 
 #ifdef CONFIG_PM
diff -ur ./drivers/mmc/core/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/Kconfig
--- ./drivers/mmc/core/Kconfig	2023-04-26 12:26:05.700133210 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/Kconfig	2023-04-23 12:03:21.625393400 +0100
@@ -26,3 +26,18 @@
 	  support handling this in order for it to be of any use.
 
 	  If unsure, say N.
+
+config MMC_EMBEDDED_SDIO
+	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
+	help
+	  If you say Y here, support will be added for embedded SDIO
+	  devices which do not contain the necessary enumeration
+	  support in hardware to be properly detected.
+
+config MMC_PARANOID_SD_INIT
+	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
+	help
+	  If you say Y here, the MMC layer will be extra paranoid
+	  about re-trying SD init requests. This can be a useful
+	  work-around for buggy controllers and hardware. Enable
+	  if you are experiencing issues with SD detection.
diff -ur ./drivers/mmc/core/core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/core.c
--- ./drivers/mmc/core/core.c	2023-04-26 12:56:05.840118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/core.c	2023-04-23 12:03:21.711824100 +0100
@@ -27,6 +27,9 @@
 #include <linux/fault-inject.h>
 #include <linux/random.h>
 #include <linux/slab.h>
+#include <linux/wakelock.h>
+
+#include <trace/events/mmc.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -172,6 +175,7 @@
 			pr_debug("%s:     %d bytes transferred: %d\n",
 				mmc_hostname(host),
 				mrq->data->bytes_xfered, mrq->data->error);
+			trace_mmc_blk_rw_end(cmd->opcode, cmd->arg, mrq->data);
 		}
 
 		if (mrq->stop) {
@@ -536,8 +540,12 @@
 			mmc_start_bkops(host->card, true);
 	}
 
-	if (!err && areq)
+	if (!err && areq) {
+		trace_mmc_blk_rw_start(areq->mrq->cmd->opcode,
+				       areq->mrq->cmd->arg,
+				       areq->mrq->data);
 		start_err = __mmc_start_data_req(host, areq->mrq);
+	}
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
@@ -1591,6 +1599,36 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
+int mmc_resume_bus(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	if (!mmc_bus_needs_resume(host))
+		return -EINVAL;
+
+	printk("%s: Starting deferred resume\n", mmc_hostname(host));
+	spin_lock_irqsave(&host->lock, flags);
+	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
+	host->rescan_disable = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		mmc_power_up(host);
+		BUG_ON(!host->bus_ops->resume);
+		host->bus_ops->resume(host);
+	}
+
+	if (host->bus_ops->detect && !host->bus_dead)
+		host->bus_ops->detect(host);
+
+	mmc_bus_put(host);
+	printk("%s: Deferred resume completed\n", mmc_hostname(host));
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_bus);
+
 /*
  * Assign a mmc bus handler to a host. Only one bus handler may control a
  * host at any given time.
@@ -1656,6 +1694,8 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 	host->detect_change = 1;
+
+	wake_lock(&host->detect_wake_lock);
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
@@ -1815,8 +1855,13 @@
 	struct mmc_command cmd = {0};
 	unsigned int qty = 0;
 	unsigned long timeout;
+	unsigned int fr, nr;
 	int err;
 
+	fr = from;
+	nr = to - from + 1;
+	trace_mmc_blk_erase_start(arg, fr, nr);
+
 	/*
 	 * qty is used to calculate the erase timeout which depends on how many
 	 * erase groups (or allocation units in SD terminology) are affected.
@@ -1920,6 +1965,8 @@
 	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
 		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
 out:
+
+	trace_mmc_blk_erase_end(arg, fr, nr);
 	return err;
 }
 
@@ -2351,14 +2398,18 @@
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
 	int i;
+	bool extend_wakelock = false;
 
 	if (host->rescan_disable)
 		return;
 
 	/* If there is a non-removable card registered, only scan once */
 	if ((host->caps & MMC_CAP_NONREMOVABLE) && host->rescan_entered)
+	{
+		wake_unlock(&host->detect_wake_lock);
 		return;
-	host->rescan_entered = 1;
+	}
+//	host->rescan_entered = 1;
 
 	mmc_bus_get(host);
 
@@ -2372,6 +2423,12 @@
 
 	host->detect_change = 0;
 
+	/* If the card was removed the bus will be marked
+	 * as dead - extend the wakelock so userspace
+	 * can respond */
+	if (host->bus_dead)
+		extend_wakelock = 1;
+
 	/*
 	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
 	 * the card is no longer present.
@@ -2400,16 +2457,24 @@
 
 	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
+			extend_wakelock = true;
 			break;
+		}
 		if (freqs[i] <= host->f_min)
 			break;
 	}
 	mmc_release_host(host);
-
+	host->rescan_entered = 1;
  out:
-	if (host->caps & MMC_CAP_NEEDS_POLL)
+	if (extend_wakelock)
+		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
+	else
+		wake_unlock(&host->detect_wake_lock);
+	if (host->caps & MMC_CAP_NEEDS_POLL) {
+		wake_lock(&host->detect_wake_lock);
 		mmc_schedule_delayed_work(&host->detect, HZ);
+	}
 }
 
 void mmc_start_host(struct mmc_host *host)
@@ -2433,7 +2498,8 @@
 #endif
 
 	host->rescan_disable = 1;
-	cancel_delayed_work_sync(&host->detect);
+	if (cancel_delayed_work_sync(&host->detect))
+		wake_unlock(&host->detect_wake_lock);
 	mmc_flush_scheduled_work();
 
 	/* clear pm flags now and let card drivers set them as needed */
@@ -2628,7 +2694,11 @@
 {
 	int err = 0;
 
-	cancel_delayed_work(&host->detect);
+	if (mmc_bus_needs_resume(host))
+		return 0;
+
+	if (cancel_delayed_work(&host->detect))
+		wake_unlock(&host->detect_wake_lock);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);
@@ -2679,6 +2749,12 @@
 	int err = 0;
 
 	mmc_bus_get(host);
+	if (mmc_bus_manual_resume(host)) {
+		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
+		mmc_bus_put(host);
+		return 0;
+	}
+
 	if (host->bus_ops && !host->bus_dead) {
 		if (!mmc_card_keep_power(host)) {
 			mmc_power_up(host);
@@ -2739,9 +2815,14 @@
 		}
 
 		spin_lock_irqsave(&host->lock, flags);
+		if (mmc_bus_needs_resume(host)) {
+			spin_unlock_irqrestore(&host->lock, flags);
+			break;
+		}
 		host->rescan_disable = 1;
 		spin_unlock_irqrestore(&host->lock, flags);
-		cancel_delayed_work_sync(&host->detect);
+		if (cancel_delayed_work_sync(&host->detect))
+			wake_unlock(&host->detect_wake_lock);
 
 		if (!host->bus_ops || host->bus_ops->suspend)
 			break;
@@ -2762,6 +2843,10 @@
 	case PM_POST_RESTORE:
 
 		spin_lock_irqsave(&host->lock, flags);
+		if (mmc_bus_manual_resume(host)) {
+			spin_unlock_irqrestore(&host->lock, flags);
+			break;
+		}
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
@@ -2789,6 +2874,22 @@
 	init_waitqueue_head(&host->context_info.wait);
 }
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				struct sdio_cis *cis,
+				struct sdio_cccr *cccr,
+				struct sdio_embedded_func *funcs,
+				int num_funcs)
+{
+	host->embedded_sdio_data.cis = cis;
+	host->embedded_sdio_data.cccr = cccr;
+	host->embedded_sdio_data.funcs = funcs;
+	host->embedded_sdio_data.num_funcs = num_funcs;
+}
+
+EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
+#endif
+
 static int __init mmc_init(void)
 {
 	int ret;
diff -ur ./drivers/mmc/core/host.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/host.c
--- ./drivers/mmc/core/host.c	2023-04-26 12:56:05.840118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/host.c	2023-04-23 12:03:21.792986800 +0100
@@ -459,6 +459,8 @@
 
 	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
+	wake_lock_init(&host->detect_wake_lock, WAKE_LOCK_SUSPEND,
+		kasprintf(GFP_KERNEL, "%s_detect", mmc_hostname(host)));
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 #ifdef CONFIG_PM
 	host->pm_notify.notifier_call = mmc_pm_notify;
@@ -511,7 +513,8 @@
 	mmc_host_clk_sysfs_init(host);
 
 	mmc_start_host(host);
-	register_pm_notifier(&host->pm_notify);
+	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
+		register_pm_notifier(&host->pm_notify);
 
 	return 0;
 }
@@ -528,7 +531,9 @@
  */
 void mmc_remove_host(struct mmc_host *host)
 {
-	unregister_pm_notifier(&host->pm_notify);
+	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
+		unregister_pm_notifier(&host->pm_notify);
+
 	mmc_stop_host(host);
 
 #ifdef CONFIG_DEBUG_FS
@@ -555,6 +560,7 @@
 	spin_lock(&mmc_host_lock);
 	idr_remove(&mmc_host_idr, host->index);
 	spin_unlock(&mmc_host_lock);
+	wake_lock_destroy(&host->detect_wake_lock);
 
 	put_device(&host->class_dev);
 }
diff -ur ./drivers/mmc/core/mmc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/mmc.c
--- ./drivers/mmc/core/mmc.c	2023-04-26 12:56:05.840118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/mmc.c	2023-04-23 12:03:21.784551500 +0100
@@ -293,7 +293,7 @@
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 6) {
+	if (card->ext_csd.rev > 7) {
 		pr_err("%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
@@ -464,6 +464,7 @@
 	}
 
 	if (card->ext_csd.rev >= 5) {
+#if 0
 		/* check whether the eMMC card supports BKOPS */
 		if (ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1) {
 			card->ext_csd.bkops = 1;
@@ -489,7 +490,7 @@
 			card->ext_csd.out_of_int_time =
 				ext_csd[EXT_CSD_OUT_OF_INTERRUPT_TIME] * 10;
 		}
-
+#endif
 		card->ext_csd.rel_param = ext_csd[EXT_CSD_WR_REL_PARAM];
 		card->ext_csd.rst_n_function = ext_csd[EXT_CSD_RST_N_FUNCTION];
 
diff -ur ./drivers/mmc/core/sd.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sd.c
--- ./drivers/mmc/core/sd.c	2023-04-26 12:56:05.850118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sd.c	2023-04-23 12:03:21.896582500 +0100
@@ -805,6 +805,9 @@
 	bool reinit)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	if (!reinit) {
 		/*
@@ -831,7 +834,26 @@
 		/*
 		 * Fetch switch information from card.
 		 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+		for (retries = 1; retries <= 3; retries++) {
+			err = mmc_read_switch(card);
+			if (!err) {
+				if (retries > 1) {
+					printk(KERN_WARNING
+					       "%s: recovered\n", 
+					       mmc_hostname(host));
+				}
+				break;
+			} else {
+				printk(KERN_WARNING
+				       "%s: read switch failed (attempt %d)\n",
+				       mmc_hostname(host), retries);
+			}
+		}
+#else
 		err = mmc_read_switch(card);
+#endif
+
 		if (err)
 			return err;
 	}
@@ -1032,7 +1054,10 @@
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries = 5;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1042,7 +1067,23 @@
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	while(retries) {
+		err = mmc_send_status(host->card, NULL);
+		if (err) {
+			retries--;
+			udelay(5);
+			continue;
+		}
+		break;
+	}
+	if (!retries) {
+		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
+		       __func__, mmc_hostname(host), err);
+	}
+#else
 	err = _mmc_detect_card_removed(host);
+#endif
 
 	mmc_release_host(host);
 
@@ -1084,12 +1125,31 @@
 static int mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, host->card);
+
+		if (err) {
+			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
+			       mmc_hostname(host), err, retries);
+			mdelay(5);
+			retries--;
+			continue;
+		}
+		break;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
 	return err;
@@ -1143,6 +1203,9 @@
 {
 	int err;
 	u32 ocr;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -1198,9 +1261,27 @@
 	/*
 	 * Detect and init the card.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, NULL);
+		if (err) {
+			retries--;
+			continue;
+		}
+		break;
+	}
+
+	if (!retries) {
+		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
+		       mmc_hostname(host), err);
+		goto err;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
+#endif
 
 	mmc_release_host(host);
 	err = mmc_add_card(host->card);
diff -ur ./drivers/mmc/core/sdio.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio.c
--- ./drivers/mmc/core/sdio.c	2023-04-26 12:56:05.850118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio.c	2023-04-23 12:03:21.952854000 +0100
@@ -10,6 +10,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/module.h>
 #include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
@@ -28,6 +29,10 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/sdio_ids.h>
+#endif
+
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -728,19 +733,35 @@
 		goto finish;
 	}
 
-	/*
-	 * Read the common registers.
-	 */
-	err = sdio_read_cccr(card, ocr);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cccr)
+		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
+	else {
+#endif
+		/*
+		 * Read the common registers.
+		 */
+		err = sdio_read_cccr(card,  ocr);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cis)
+		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
+	else {
+#endif
+		/*
+		 * Read the common CIS tuples.
+		 */
+		err = sdio_read_common_cis(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
 	if (oldcard) {
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
@@ -1147,14 +1168,36 @@
 	funcs = (ocr & 0x70000000) >> 28;
 	card->sdio_funcs = 0;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.funcs)
+		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
+#endif
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
 	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
-		err = sdio_init_func(host->card, i + 1);
-		if (err)
-			goto remove;
-
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		if (host->embedded_sdio_data.funcs) {
+			struct sdio_func *tmp;
+
+			tmp = sdio_alloc_func(host->card);
+			if (IS_ERR(tmp))
+				goto remove;
+			tmp->num = (i + 1);
+			card->sdio_func[i] = tmp;
+			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
+			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
+			tmp->vendor = card->cis.vendor;
+			tmp->device = card->cis.device;
+		} else {
+#endif
+			err = sdio_init_func(host->card, i + 1);
+			if (err)
+				goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		}
+#endif
 		/*
 		 * Enable Runtime PM for this func (if supported)
 		 */
@@ -1202,3 +1245,39 @@
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+
+	printk("%s():\n", __func__);
+	mmc_claim_host(host);
+
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_sdio_init_card(host, host->ocr, card, 0);
+	if (err)
+		goto err;
+
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff -ur ./drivers/mmc/core/sdio_bus.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_bus.c
--- ./drivers/mmc/core/sdio_bus.c	2023-04-26 12:56:05.850118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_bus.c	2023-04-23 12:03:21.952269100 +0100
@@ -25,6 +25,10 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/host.h>
+#endif
+
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\
@@ -270,7 +274,14 @@
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-	sdio_free_func_cis(func);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	/*
+	 * If this device is embedded then we never allocated
+	 * cis tables for this func
+	 */
+	if (!func->card->host->embedded_sdio_data.funcs)
+#endif
+		sdio_free_func_cis(func);
 
 	kfree(func->info);
 
diff -ur ./drivers/mmc/core/sdio_cis.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_cis.c
--- ./drivers/mmc/core/sdio_cis.c	2023-04-26 12:26:05.720133210 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_cis.c	2023-04-23 12:03:22.032997900 +0100
@@ -154,9 +154,12 @@
 	card->cis.blksize = buf[1] | (buf[2] << 8);
 
 	/* TPLFE_MAX_TRAN_SPEED */
+#ifdef CONFIG_BCMDHD_1_141_66
+	card->cis.max_dtr = 24000000;
+#else
 	card->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *
 			    speed_unit[buf[3] & 7];
-
+#endif
 	return 0;
 }
 
diff -ur ./drivers/mmc/core/sdio_io.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_io.c
--- ./drivers/mmc/core/sdio_io.c	2023-04-26 12:26:05.720133210 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/core/sdio_io.c	2023-04-23 12:03:22.031901700 +0100
@@ -384,6 +384,39 @@
 EXPORT_SYMBOL_GPL(sdio_readb);
 
 /**
+ *	sdio_readb_ext - read a single byte from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *	@in: value to add to argument
+ *
+ *	Reads a single byte from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xff
+ *	is returned and @err_ret will contain the error code.
+ */
+unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
+	int *err_ret, unsigned in)
+{
+	int ret;
+	unsigned char val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_readb_ext);
+
+/**
  *	sdio_writeb - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
diff -ur ./drivers/mmc/host/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/Kconfig
--- ./drivers/mmc/host/Kconfig	2023-04-26 12:56:05.850118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/Kconfig	2023-04-23 12:03:22.106005800 +0100
@@ -4,6 +4,355 @@
 
 comment "MMC/SD/SDIO Host Controller Drivers"
 
+config JZMMC_V12
+	tristate "Ingenic(XBurst)  MMC/SD Card Controller(MSC) v1.2 support"
+	depends on SOC_M200 || SOC_T15 || SOC_T10 || SOC_T20 || SOC_T30 || SOC_T21 || SOC_T31
+	help
+	  This selects the Ingenic XBurst SD/MMC Card Controller v1.2.
+	  If you have platform with a SD/Multimedia Card slot and compact
+	  with this version, say Y or M here.
+	  If unsure, say N.
+choice
+	prompt "JZMMC_V12 data transfer method select"
+	depends on JZMMC_V12
+	default JZMMC_V12_SDMA
+config JZMMC_V12_SDMA
+	bool "JZMMC_V12 data transfer using MSC SDMA"
+endchoice
+
+config JZMMC_V12_MMC0
+	bool "JZMMC_V12 MMC0"
+	depends on JZMMC_V12
+choice
+	prompt "JZMMC_V12 GPIO function pins select"
+	depends on JZMMC_V12_MMC0
+	default JZMMC_V12_MMC0_PA_4BIT
+config JZMMC_V12_MMC0_PA_4BIT
+	bool "GPIO A, data with 4 bit"
+config JZMMC_V12_MMC0_PA_8BIT
+	bool "GPIO A, data with 8 bit"
+config JZMMC_V12_MMC0_PB_4BIT
+	bool "GPIO B, data with 4 bit"
+endchoice
+
+config MMC0_MAX_FREQ
+	int "msc0 max frequency"
+	depends on JZMMC_V12_MMC0
+	default 24000000
+	help
+	  The max frequency of msc0, it should NOT be higher than 50mHz.
+	  If unsure, say N.
+
+config MMC0_PIO_MODE
+	bool "Use PIO mode for MSC0"
+	depends on JZMMC_V12_MMC0 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC0, say Y or N here.
+	  If unsure, say N.
+
+config JZMMC_V12_MMC1
+	bool "JZMMC_V12 MMC1"
+	depends on JZMMC_V12
+choice
+	depends on JZMMC_V12_MMC1
+	prompt "JZMMC_V12 GPIO function pins select"
+	default JZMMC_V12_MMC1_PC_4BIT
+config JZMMC_V12_MMC1_PD_4BIT
+	bool "GPIO D, Data width 4 bit"
+config JZMMC_V12_MMC1_PB_4BIT
+	bool "GPIO B, Data width 4 bit"
+config JZMMC_V12_MMC1_PC_4BIT
+	bool "GPIO C, Data width 4 bit"
+endchoice
+
+config MMC1_MAX_FREQ
+	int "MSC1 max frequency"
+	depends on JZMMC_V12_MMC1
+	default 24000000
+	help
+	  The max frequency of msc1, it should not be higher than 50 Mhz
+	  If unsure, say N.
+
+config MMC1_PIO_MODE
+	bool "Use PIO mode for MSC1"
+	depends on JZMMC_V12_MMC1 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	 Use PIO mode to transfer data for MSC1, say Y or N here.
+	 If unsure, say N.
+
+config JZMMC_V12_MMC2
+	bool "JZMMC_V12 MMC2"
+	depends on JZMMC_V12
+choice
+	prompt "JZMMC_V12 GPIO function pins select"
+	depends on JZMMC_V12_MMC2
+	default JZMMC_V12_MMC2_PE_4BIT
+config JZMMC_V12_MMC2_PB_4BIT
+	bool "GPIO B, Data width 4 bit"
+config JZMMC_V12_MMC2_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC2_MAX_FREQ
+	int "MSC2 max frequency"
+	depends on JZMMC_V12_MMC2
+	default 24000000
+	help
+	 The max frequency of msc2, it should not be higher than 50 Mhz,
+	 If unsure , say N.
+
+config MMC2_PIO_MODE
+	bool "Use PIO mode for MSC2"
+	depends on JZMMC_V12_MMC2 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	 Use PIO mode to transfer data for MSC2, say Y or N here.
+	 If unsure, say N.
+
+config MMC_JZ4780
+	tristate "Ingenic(XBurst) JZ4780 MMC/SD Card Controller(MSC) support"
+	depends on SOC_4780
+	help
+	  This selects the Ingenic XBurst SD/MMC Card Controller
+	  for JZ4780 support. If you have an JZ4780
+	  platform with a SD/Multimedia Card slot, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC0_JZ4780
+	bool "MSC0"
+	depends on MMC_JZ4780
+	help
+	  If you want enable MSC0, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "JZ4780 MSC0 function pins select"
+	depends on MMC0_JZ4780
+	default MMC0_JZ4780_PA_4BIT
+config MMC0_JZ4780_PA_4BIT
+	bool "GPIO A, Data width 4 bit"
+config MMC0_JZ4780_PA_8BIT
+	bool "GPIO A, Data width 8 bit"
+config MMC0_JZ4780_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+config MMC0_JZ4780_PA_4BIT_RESET
+	bool "GPIO A, Data width 4 bit, use Reset pin(eMMC)"
+config MMC0_JZ4780_PA_8BIT_RESET
+	bool "GPIO A, Data width 8 bit, use Reset pin(eMMC)"
+endchoice
+
+config MMC0_MAX_FREQ
+	int "MSC0 max frequency"
+	depends on MMC0_JZ4780
+	default 24000000
+	help
+	  The max frequency of msc0, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC0_PIO_MODE
+	bool "Use PIO mode for MSC0"
+	depends on MMC0_JZ4780 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC0, say Y or N here.
+
+	  If unsure, say N.
+
+config MMC1_JZ4780
+	bool "MSC1"
+	depends on MMC_JZ4780
+	help
+	  If you want enable MSC1, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "JZ4780 MSC1 function pins select"
+	depends on MMC1_JZ4780
+	default MMC1_JZ4780_PD_4BIT
+config MMC1_JZ4780_PD_4BIT
+	bool "GPIO D, Data width 4 bit"
+config MMC1_JZ4780_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC1_MAX_FREQ
+	int "MSC1 max frequency"
+	depends on MMC1_JZ4780
+	default 24000000
+	help
+	  The max frequency of msc1, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC1_PIO_MODE
+	bool "Use PIO mode for MSC1"
+	depends on MMC1_JZ4780 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC1, say Y or N here.
+
+	  If unsure, say N.
+
+config MMC2_JZ4780
+	bool "MSC2"
+	depends on MMC_JZ4780
+	help
+	  If you want enable MSC2, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "JZ4780 MSC2 function pins select"
+	depends on MMC2_JZ4780
+	default MMC2_JZ4780_PB_4BIT
+config MMC2_JZ4780_PB_4BIT
+	bool "GPIO B, Data width 4 bit"
+config MMC2_JZ4780_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC2_MAX_FREQ
+	int "MSC2 max frequency"
+	depends on MMC2_JZ4780
+	default 24000000
+	help
+	  The max frequency of msc2, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC2_PIO_MODE
+	bool "Use PIO mode for MSC2"
+	depends on MMC2_JZ4780 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC2, say Y or N here.
+
+	  If unsure, say N.
+
+
+config JZMMC_V11
+	tristate "Ingenic(XBurst) Halley MMC/SD Card Controller(MSC) support"
+	depends on SOC_4775
+	help
+	  This selects the Ingenic XBurst SD/MMC Card Controller
+	  for Halley support. If you have an Halley
+	  platform with a SD/Multimedia Card slot, say Y or M here.
+
+	  If unsure, say N.
+
+config JZMMC_V11_MMC0
+	bool "MSC0"
+	depends on JZMMC_V11
+	help
+	  If you want enable MSC0, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "Halley MSC0 function pins select"
+	depends on JZMMC_V11_MMC0
+	default JZMMC_V11_MMC0_PA_4BIT
+config JZMMC_V11_MMC0_PA_4BIT
+	bool "GPIO A, Data width 4 bit"
+config JZMMC_V11_MMC0_PA_8BIT
+	bool "GPIO A, Data width 8 bit"
+config JZMMC_V11_MMC0_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC0_MAX_FREQ
+	int "MSC0 max frequency"
+	depends on JZMMC_V11_MMC0
+	default 24000000
+	help
+	  The max frequency of msc0, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC0_PIO_MODE
+	bool "Use PIO mode for MSC0"
+	depends on JZMMC_V11_MMC0 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC0, say Y or N here.
+
+	  If unsure, say N.
+
+config JZMMC_V11_MMC1
+	bool "MSC1"
+	depends on JZMMC_V11
+	help
+	  If you want enable MSC1, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "Halley MSC1 function pins select"
+	depends on JZMMC_V11_MMC1
+	default JZMMC_V11_MMC1_PD_4BIT
+config JZMMC_V11_MMC1_PD_4BIT
+	bool "GPIO D, Data width 4 bit"
+config JZMMC_V11_MMC1_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC1_MAX_FREQ
+	int "MSC1 max frequency"
+	depends on JZMMC_V11_MMC1
+	default 24000000
+	help
+	  The max frequency of msc1, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC1_PIO_MODE
+	bool "Use PIO mode for MSC1"
+	depends on JZMMC_V11_MMC1 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC1, say Y or N here.
+
+	  If unsure, say N.
+
+config JZMMC_V11_MMC2
+	bool "MSC2"
+	depends on JZMMC_V11
+	help
+	  If you want enable MSC2, say Y or M here.
+
+	  If unsure, say N.
+choice
+	prompt "Halley MSC2 function pins select"
+	depends on JZMMC_V11_MMC2
+	default JZMMC_V11_MMC2_PB_4BIT
+config JZMMC_V11_MMC2_PB_4BIT
+	bool "GPIO B, Data width 4 bit"
+config JZMMC_V11_MMC2_PE_4BIT
+	bool "GPIO E, Data width 4 bit"
+endchoice
+
+config MMC2_MAX_FREQ
+	int "MSC2 max frequency"
+	depends on JZMMC_V11_MMC2
+	default 24000000
+	help
+	  The max frequency of msc2, it should NOT be higher than 50mHz.
+
+	  If unsure, say N.
+
+config MMC2_PIO_MODE
+	bool "Use PIO mode for MSC2"
+	depends on JZMMC_V11_MMC2 && MMC_BLOCK_BOUNCE
+	default n
+	help
+	  Use PIO mode to transfer data for MSC2, say Y or N here.
+
+	  If unsure, say N.
+
+
+
+
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
 	depends on ARM_AMBA
diff -ur ./drivers/mmc/host/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/Makefile
--- ./drivers/mmc/host/Makefile	2023-04-26 12:56:05.850118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/Makefile	2023-04-23 12:03:22.190525900 +0100
@@ -2,6 +2,12 @@
 # Makefile for MMC/SD host controller drivers
 #
 
+obj-$(CONFIG_JZMMC_V12)		+= jzmmc_v12.o
+obj-$(CONFIG_JZMMC_V11)		+= jzmmc_v11.o
+obj-$(CONFIG_MMC0_JZ4780)	+= jz4780_mmc.o
+obj-$(CONFIG_MMC1_JZ4780)	+= jz4780_mmc.o
+obj-$(CONFIG_MMC2_JZ4780)	+= jz4780_mmc.o
+
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_MXC)		+= mxcmmc.o
diff -ur ./drivers/mmc/host/jz4740_mmc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/jz4740_mmc.c
--- ./drivers/mmc/host/jz4740_mmc.c	2023-04-26 12:56:05.860118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host/jz4740_mmc.c	2023-04-23 12:03:22.427305500 +0100
@@ -702,7 +702,7 @@
 	JZ_GPIO_BULK_PIN(MSC_DATA3),
 };
 
-static int jz4740_mmc_request_gpio(struct device *dev, int gpio,
+static int __devinit jz4740_mmc_request_gpio(struct device *dev, int gpio,
 	const char *name, bool output, int value)
 {
 	int ret;
@@ -724,7 +724,7 @@
 	return 0;
 }
 
-static int jz4740_mmc_request_gpios(struct platform_device *pdev)
+static int __devinit jz4740_mmc_request_gpios(struct platform_device *pdev)
 {
 	int ret;
 	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
@@ -759,7 +759,7 @@
 	return ret;
 }
 
-static int jz4740_mmc_request_cd_irq(struct platform_device *pdev,
+static int __devinit jz4740_mmc_request_cd_irq(struct platform_device *pdev,
 	struct jz4740_mmc_host *host)
 {
 	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
@@ -802,7 +802,7 @@
 	return num_pins;
 }
 
-static int jz4740_mmc_probe(struct platform_device* pdev)
+static int __devinit jz4740_mmc_probe(struct platform_device* pdev)
 {
 	int ret;
 	struct mmc_host *mmc;
@@ -938,7 +938,7 @@
 	return ret;
 }
 
-static int jz4740_mmc_remove(struct platform_device *pdev)
+static int __devexit jz4740_mmc_remove(struct platform_device *pdev)
 {
 	struct jz4740_mmc_host *host = platform_get_drvdata(pdev);
 
@@ -1004,7 +1004,7 @@
 
 static struct platform_driver jz4740_mmc_driver = {
 	.probe = jz4740_mmc_probe,
-	.remove = jz4740_mmc_remove,
+	.remove = __devexit_p(jz4740_mmc_remove),
 	.driver = {
 		.name = "jz4740-mmc",
 		.owner = THIS_MODULE,
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jz4780_mmc.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jz4780_mmc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jzmmc_v11.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jzmmc_v11.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jzmmc_v12.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mmc/host: jzmmc_v12.h
diff -ur ./drivers/mtd/devices/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices/Kconfig
--- ./drivers/mtd/devices/Kconfig	2023-04-26 12:26:05.860133211 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices/Kconfig	2023-04-23 12:03:24.504849800 +0100
@@ -68,6 +68,67 @@
 	  device thinks the write was successful, a bit could have been
 	  flipped accidentally due to device wear or something else.
 
+config MTD_JZ_SPI_NORFLASH
+	bool "Support ingenic spi-mtd"
+	help
+		Now support GD25LQ64C
+
+config MTD_JZ_SFC
+	tristate "Ingenic JZ series SFC driver"
+	depends on  MACH_XBURST
+	help
+		SFC driver for Ingenic JZ series SoCs
+
+config MTD_JZ_SFC_NOR
+	tristate "Ingenic JZ SFC nor"
+	depends on MTD_JZ_SFC
+	help
+		SFC driver for Ingenic JZ sfc nor
+
+config MTD_JZ_SFC_NAND
+	tristate "Ingenic JZ SFC nand"
+	depends on MTD_JZ_SFC
+	help
+		SFC driver for Ingenic JZ sfc nand
+
+config SFC_DMA
+	bool "used dma"
+	depends on MTD_JZ_SFC_NOR
+	help
+		used dma
+
+config SFC_SPEED
+    int "JZ SFC speed in MHZ"
+	range 10 200
+	default 50
+	depends on MTD_JZ_SFC
+	help
+	    Select sfc speed.
+		Examples:
+			50 =>  50 MHZ
+
+if MTD_JZ_SFC
+
+choice
+	prompt "sfc Mode"
+	help
+	  Select sfc Mode
+
+config SPI_STARDARD
+	bool "standard spi mode"
+	depends on MTD_JZ_SFC
+	help
+	  Say Y here to enable spi STANDARD MODE
+
+config SPI_QUAD
+	bool "quad spi mode"
+	depends on MTD_JZ_SFC
+	help
+	  Say Y Here to enable spi QUAD MODE
+endchoice
+
+endif
+
 config MTD_DATAFLASH_OTP
 	bool "DataFlash OTP support (Security Register)"
 	depends on MTD_DATAFLASH
diff -ur ./drivers/mtd/devices/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices/Makefile
--- ./drivers/mtd/devices/Makefile	2023-04-26 12:26:05.860133211 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices/Makefile	2023-04-23 12:03:24.504159600 +0100
@@ -16,6 +16,9 @@
 obj-$(CONFIG_MTD_SPEAR_SMI)	+= spear_smi.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
 obj-$(CONFIG_MTD_BCM47XXSFLASH)	+= bcm47xxsflash.o
+obj-$(CONFIG_MTD_JZ_SPI_NORFLASH)	+= jz_spi_norflash.o
+obj-$(CONFIG_MTD_JZ_SFC_NOR)	+= jz_sfc.o
+obj-$(CONFIG_MTD_JZ_SFC_NAND)       += jz_sfc_common.o jz_sfc_nand.o nand_device/
 
 
 CFLAGS_docg3.o			+= -I$(src)
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc_common.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc_common.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc_nand.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_sfc_nand.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_spi_norflash.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: jz_spi_norflash.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/devices: nand_device
diff -ur ./drivers/mtd/nand/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand/Kconfig
--- ./drivers/mtd/nand/Kconfig	2023-04-26 12:36:31.740092993 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand/Kconfig	2023-04-23 12:03:26.346664400 +0100
@@ -1,3 +1,10 @@
+config MTD_NAND_IDS
+	tristate "Include chip ids for known NAND devices."
+	depends on MTD
+	help
+	  Useful for NAND drivers that do not use the NAND subsystem but
+	  still like to take advantage of the known chip information.
+
 config MTD_NAND_ECC
 	tristate
 
@@ -133,9 +140,6 @@
 	default 8 if MTD_NAND_OMAP_BCH8
 endif
 
-config MTD_NAND_IDS
-	tristate
-
 config MTD_NAND_RICOH
 	tristate "Ricoh xD card reader"
 	default n
@@ -529,6 +533,12 @@
 	help
 		Enables support for NAND Flash on JZ4740 SoC based boards.
 
+config MTD_JZ_SPI_NAND
+	tristate "Support for SPI_NAND"
+	depends on (JZ_SPI0 || JZ_SPI1) && !NAND
+	help
+	Enables support for MTD SPI NAND Flash.
+
 config MTD_NAND_FSMC
 	tristate "Support for NAND on ST Micros FSMC"
 	depends on PLAT_SPEAR || ARCH_NOMADIK || ARCH_U8500 || MACH_U300
diff -ur ./drivers/mtd/nand/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand/Makefile
--- ./drivers/mtd/nand/Makefile	2023-04-26 12:26:06.000133211 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand/Makefile	2023-04-23 12:03:26.343879700 +0100
@@ -2,10 +2,13 @@
 # linux/drivers/nand/Makefile
 #
 
-obj-$(CONFIG_MTD_NAND)			+= nand.o
-obj-$(CONFIG_MTD_NAND_ECC)		+= nand_ecc.o
+#obj-$(CONFIG_MTD_NAND)			+= nand.o
+obj-y         += nand.o
+#obj-$(CONFIG_MTD_NAND_ECC)		+= nand_ecc.o
+obj-y         += nand_ecc.o
 obj-$(CONFIG_MTD_NAND_BCH)		+= nand_bch.o
-obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
+#obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
+obj-y         += nand_ids.o
 obj-$(CONFIG_MTD_SM_COMMON) 		+= sm_common.o
 
 obj-$(CONFIG_MTD_NAND_CAFE)		+= cafe_nand.o
@@ -50,5 +53,6 @@
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
 obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
+obj-$(CONFIG_MTD_JZ_SPI_NAND)           += jz_spi_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand: jz_spi_nand.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/nand: jz_spi_nand.h
diff -ur ./drivers/mtd/ubi/attach.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/ubi/attach.c
--- ./drivers/mtd/ubi/attach.c	2023-04-26 12:26:06.090133212 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/mtd/ubi/attach.c	2023-04-23 12:03:28.026093400 +0100
@@ -767,6 +767,7 @@
 
 	err = ubi_io_read(ubi, ubi->peb_buf, pnum, ubi->leb_start,
 			  ubi->leb_size);
+	ubi_msg("buf=%x",(unsigned int)ubi->peb_buf);
 	if (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err)) {
 		/*
 		 * Bit-flips or integrity errors while reading the data area.
@@ -781,7 +782,6 @@
 
 	if (err)
 		goto out_unlock;
-
 	if (ubi_check_pattern(ubi->peb_buf, 0xFF, ubi->leb_size))
 		goto out_unlock;
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers: nand
diff -ur ./drivers/net/ethernet/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ethernet/Kconfig
--- ./drivers/net/ethernet/Kconfig	2023-04-26 12:56:05.920118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ethernet/Kconfig	2023-04-23 12:03:33.385518700 +0100
@@ -88,6 +88,7 @@
 source "drivers/net/ethernet/marvell/Kconfig"
 source "drivers/net/ethernet/mellanox/Kconfig"
 source "drivers/net/ethernet/micrel/Kconfig"
+source "drivers/net/ethernet/ingenic/Kconfig"
 source "drivers/net/ethernet/microchip/Kconfig"
 source "drivers/net/ethernet/myricom/Kconfig"
 
diff -ur ./drivers/net/ethernet/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ethernet/Makefile
--- ./drivers/net/ethernet/Makefile	2023-04-26 12:56:05.920118959 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ethernet/Makefile	2023-04-23 12:03:33.385242700 +0100
@@ -74,3 +74,4 @@
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_JZ_MAC) += ingenic/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ethernet: ingenic
diff -ur ./drivers/net/phy/phy_device.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/phy/phy_device.c
--- ./drivers/net/phy/phy_device.c	2023-04-26 12:56:06.260118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/phy/phy_device.c	2023-04-23 12:04:03.309134000 +0100
@@ -921,7 +921,7 @@
 	 * all possible port types */
 	features = (SUPPORTED_TP | SUPPORTED_MII
 			| SUPPORTED_AUI | SUPPORTED_FIBRE |
-			SUPPORTED_BNC);
+			SUPPORTED_BNC | SUPPORTED_Pause | SUPPORTED_Asym_Pause);
 
 	/* Do we support autonegotiation? */
 	val = phy_read(phydev, MII_BMSR);
diff -ur ./drivers/net/phy/smsc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/phy/smsc.c
--- ./drivers/net/phy/smsc.c	2023-04-26 12:26:09.620133005 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/phy/smsc.c	2023-04-23 12:04:03.400645000 +0100
@@ -71,12 +71,13 @@
 	if (rc < 0)
 		return rc;
 
+#if 0
 	/* Enable energy detect mode for this SMSC Transceivers */
 	rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
 		       rc | MII_LAN83C185_EDPWRDOWN);
 	if (rc < 0)
 		return rc;
-
+#endif
 	return smsc_phy_ack_interrupt (phydev);
 }
 
@@ -105,12 +106,12 @@
 		int rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
 		if (rc < 0)
 			return rc;
-
+#if 0
 		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
 			       rc & ~MII_LAN83C185_EDPWRDOWN);
 		if (rc < 0)
 			return rc;
-
+#endif
 		/* Sleep 64 ms to allow ~5 link test pulses to be sent */
 		msleep(64);
 
@@ -118,11 +119,12 @@
 		rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
 		if (rc < 0)
 			return rc;
-
+#if 0
 		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
 			       rc | MII_LAN83C185_EDPWRDOWN);
 		if (rc < 0)
 			return rc;
+#endif
 	}
 
 	return err;
diff -ur ./drivers/net/ppp/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp/Kconfig
--- ./drivers/net/ppp/Kconfig	2023-04-26 12:26:09.620133005 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp/Kconfig	2023-04-23 12:04:03.865954100 +0100
@@ -149,6 +149,23 @@
 	  tunnels. L2TP is replacing PPTP for VPN uses.
 if TTY
 
+config PPPOLAC
+	tristate "PPP on L2TP Access Concentrator"
+	depends on PPP && INET
+	help
+	  L2TP (RFC 2661) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles L2TP data packets between a UDP socket
+	  and a PPP channel, but only permits one session per socket. Thus it is
+	  fairly simple and suited for clients.
+
+config PPPOPNS
+	tristate "PPP on PPTP Network Server"
+	depends on PPP && INET
+	help
+	  PPTP (RFC 2637) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles PPTP data packets between a RAW socket
+	  and a PPP channel. It is fairly simple and easy to use.
+
 config PPP_ASYNC
 	tristate "PPP support for async serial ports"
 	depends on PPP
diff -ur ./drivers/net/ppp/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp/Makefile
--- ./drivers/net/ppp/Makefile	2023-04-26 12:26:09.620133005 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp/Makefile	2023-04-23 12:04:03.865430500 +0100
@@ -11,3 +11,5 @@
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o
 obj-$(CONFIG_PPTP) += pppox.o pptp.o
+obj-$(CONFIG_PPPOLAC) += pppox.o pppolac.o
+obj-$(CONFIG_PPPOPNS) += pppox.o pppopns.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp: pppolac.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/ppp: pppopns.c
diff -ur ./drivers/net/tun.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/tun.c
--- ./drivers/net/tun.c	2023-04-26 12:56:06.260118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/tun.c	2023-04-23 12:04:05.156069500 +0100
@@ -1883,6 +1883,12 @@
 	int vnet_hdr_sz;
 	int ret;
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cmd != TUNGETIFF && !capable(CAP_NET_ADMIN)) {
+		return -EPERM;
+	}
+#endif
+
 	if (cmd == TUNSETIFF || cmd == TUNSETQUEUE || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
diff -ur ./drivers/net/wireless/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/Kconfig
--- ./drivers/net/wireless/Kconfig	2023-04-26 12:56:06.280118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/Kconfig	2023-04-23 12:04:08.107082300 +0100
@@ -7,6 +7,8 @@
 	depends on !S390
 	depends on NET
 	select WIRELESS
+	select WIRELESS_EXT
+	select WEXT_PRIV
 	default y
 	---help---
 	  This section contains all the pre 802.11 and 802.11 wireless
@@ -264,6 +266,11 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
 
+config WIFI_CONTROL_FUNC
+	bool "Enable WiFi control function abstraction"
+	help
+	  Enables Power/Reset/Carddetect function abstraction
+
 source "drivers/net/wireless/ath/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
@@ -280,5 +287,9 @@
 source "drivers/net/wireless/ti/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/mwifiex/Kconfig"
+source "drivers/net/wireless/bcm43341/Kconfig"
+source "drivers/net/wireless/bcmdhd_1_141_66/Kconfig"
+source "drivers/net/wireless/bcmdhd_ap6181/Kconfig"
+source "drivers/net/wireless/mt7601u/Kconfig"
 
 endif # WLAN
diff -ur ./drivers/net/wireless/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/Makefile
--- ./drivers/net/wireless/Makefile	2023-04-26 12:56:06.280118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/Makefile	2023-04-23 12:04:08.106370000 +0100
@@ -11,7 +11,7 @@
 obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
 
 obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
+obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
 obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
@@ -24,6 +24,7 @@
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 obj-$(CONFIG_RTL8180)		+= rtl818x/
 obj-$(CONFIG_RTL8187)		+= rtl818x/
+obj-$(CONFIG_RTL8188EU)		+= rtl818x/
 obj-$(CONFIG_RTLWIFI)		+= rtlwifi/
 
 # 16-bit wireless PCMCIA client drivers
@@ -57,3 +58,7 @@
 
 obj-$(CONFIG_BRCMFMAC)	+= brcm80211/
 obj-$(CONFIG_BRCMSMAC)	+= brcm80211/
+obj-$(CONFIG_BCM43341)  += bcm43341/
+obj-$(CONFIG_BCMDHD_1_141_66)   += bcmdhd_1_141_66/
+obj-$(CONFIG_BCMDHD_AP6181)   += bcmdhd_ap6181/
+obj-$(CONFIG_MT7601_STA)   += mt7601u/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless: bcm43341
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless: bcmdhd_1_141_66
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless: bcmdhd_ap6181
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless: mt7601u
diff -ur ./drivers/net/wireless/rtl818x/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/rtl818x/Kconfig
--- ./drivers/net/wireless/rtl818x/Kconfig	2023-04-26 12:26:10.800132885 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/rtl818x/Kconfig	2023-04-23 12:04:46.584507700 +0100
@@ -86,3 +86,12 @@
 	depends on RTL8187 && MAC80211_LEDS && (LEDS_CLASS = y || LEDS_CLASS = RTL8187)
 	default y
 
+config RTL8188EU
+        tristate "Realtek 8188EU USB support"
+        depends on MAC80211 && USB
+        select WIRELESS_EXT
+        select WEXT_PRIV
+        select CRYPTO
+        ---help---
+          This is a driver for RTL8188EU based cards.
+
diff -ur ./drivers/net/wireless/rtl818x/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/rtl818x/Makefile
--- ./drivers/net/wireless/rtl818x/Makefile	2023-04-26 12:26:10.800132885 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/rtl818x/Makefile	2023-04-23 12:04:46.584007200 +0100
@@ -1,2 +1,3 @@
 obj-$(CONFIG_RTL8180)	+= rtl8180/
 obj-$(CONFIG_RTL8187)	+= rtl8187/
+obj-$(CONFIG_RTL8188EU) += rtl8188eu/
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/net/wireless/rtl818x: rtl8188eu
diff -ur ./drivers/nfc/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/nfc/Kconfig
--- ./drivers/nfc/Kconfig	2023-04-26 12:56:06.510118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/nfc/Kconfig	2023-04-23 12:04:59.782519400 +0100
@@ -5,6 +5,26 @@
 menu "Near Field Communication (NFC) devices"
 	depends on NFC
 
+
+config BCM2079X_NFC
+         tristate "BCM2079X NFC driver"
+         depends on I2C
+         select CRC_CCITT
+         default n
+         ---help---
+           Say yes if you want BCM2079X Near Field Communication driver.
+           This is for i2c connected version. If unsure, say N here.
+           To compile this driver as a module, choose m here. The module will
+           be called bcm2079x.
+
+ config BCM2079X_NFC_I2C_BUSNUM
+         int "BCM2079x NFC i2c bus number"
+         depends on BCM2079X_NFC
+         default 0
+         help
+	 The bcm2079x nfc uses which one i2c controller, you must check the schematic.
+             The bcm2079x nfc uses which one i2c controller, you must check the schematic.
+
 config NFC_PN533
 	tristate "NXP PN533 USB driver"
 	depends on USB
diff -ur ./drivers/nfc/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/nfc/Makefile
--- ./drivers/nfc/Makefile	2023-04-26 12:56:06.510118958 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/nfc/Makefile	2023-04-23 12:04:59.782050900 +0100
@@ -7,5 +7,6 @@
 obj-$(CONFIG_NFC_PN533)		+= pn533.o
 obj-$(CONFIG_NFC_WILINK)	+= nfcwilink.o
 obj-$(CONFIG_NFC_MEI_PHY)	+= mei_phy.o
+obj-$(CONFIG_BCM2079X_NFC)	+= bcm2079x-i2c.o
 
 ccflags-$(CONFIG_NFC_DEBUG) := -DDEBUG
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/nfc: bcm2079x-i2c.c
diff -ur ./drivers/power/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/Kconfig
--- ./drivers/power/Kconfig	2023-04-26 12:26:11.230132841 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/Kconfig	2023-04-23 12:05:10.103425300 +0100
@@ -342,6 +342,25 @@
 	  Say Y to include support for Summit Microelectronics SMB347
 	  Battery Charger.
 
+config BATTERY_RICOH619
+	tristate "Ricoh R5T619 PMIC battery driver"
+	depends on MFD_RICOH619 && I2C && GENERIC_HARDIRQS
+	help
+	  Say Y to enable support for the battery control of the Ricoh R5T619
+	  Power Management device.
+choice
+	prompt "BATTERY_RICOH619 battery select"
+	depends on BATTERY_RICOH619
+	default LARGE_CAPACITY_BATTERY
+
+config LARGE_CAPACITY_BATTERY
+	  bool "Large capacity battery for 2000mA 4000mA"
+
+config SMALL_CAPACITY_BATTERY
+	  bool "Small capacity battery for 260mA 500mA"
+endchoice
+
+
 config CHARGER_TPS65090
 	tristate "TPS65090 battery charger driver"
 	depends on MFD_TPS65090
diff -ur ./drivers/power/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/Makefile
--- ./drivers/power/Makefile	2023-04-26 12:26:11.230132841 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/Makefile	2023-04-23 12:05:10.102804100 +0100
@@ -54,3 +54,6 @@
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_POWER_RESET)	+= reset/
+
+obj-$(CONFIG_BATTERY_RICOH619)	+= ricoh619-battery.o
+
diff -ur ./drivers/power/power_supply_core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/power_supply_core.c
--- ./drivers/power/power_supply_core.c	2023-04-26 12:56:06.620118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/power_supply_core.c	2023-04-23 12:05:10.982404000 +0100
@@ -67,23 +67,40 @@
 
 static void power_supply_changed_work(struct work_struct *work)
 {
+	unsigned long flags;
 	struct power_supply *psy = container_of(work, struct power_supply,
 						changed_work);
 
 	dev_dbg(psy->dev, "%s\n", __func__);
 
-	class_for_each_device(power_supply_class, NULL, psy,
-			      __power_supply_changed_work);
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	if (psy->changed) {
+		psy->changed = false;
+		spin_unlock_irqrestore(&psy->changed_lock, flags);
 
-	power_supply_update_leds(psy);
+		class_for_each_device(power_supply_class, NULL, psy,
+				      __power_supply_changed_work);
 
-	kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		power_supply_update_leds(psy);
+
+		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		spin_lock_irqsave(&psy->changed_lock, flags);
+	}
+	if (!psy->changed)
+		pm_relax(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
 
 void power_supply_changed(struct power_supply *psy)
 {
+	unsigned long flags;
+
 	dev_dbg(psy->dev, "%s\n", __func__);
 
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	psy->changed = true;
+	pm_stay_awake(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 	schedule_work(&psy->changed_work);
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
@@ -504,6 +521,11 @@
 	if (rc)
 		goto device_add_failed;
 
+	spin_lock_init(&psy->changed_lock);
+	rc = device_init_wakeup(dev, true);
+	if (rc)
+		goto wakeup_init_failed;
+
 	rc = psy_register_thermal(psy);
 	if (rc)
 		goto register_thermal_failed;
@@ -525,6 +547,7 @@
 register_cooler_failed:
 	psy_unregister_thermal(psy);
 register_thermal_failed:
+wakeup_init_failed:
 	device_del(dev);
 kobject_set_name_failed:
 device_add_failed:
diff -ur ./drivers/power/power_supply_sysfs.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/power_supply_sysfs.c
--- ./drivers/power/power_supply_sysfs.c	2023-04-26 12:26:11.250132839 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power/power_supply_sysfs.c	2023-04-23 12:05:11.061933700 +0100
@@ -189,6 +189,10 @@
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
 	POWER_SUPPLY_ATTR(scope),
+	/* Local extensions */
+	POWER_SUPPLY_ATTR(usb_hc),
+	POWER_SUPPLY_ATTR(usb_otg),
+	POWER_SUPPLY_ATTR(charge_enabled),
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_ATTR(model_name),
 	POWER_SUPPLY_ATTR(manufacturer),
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/power: ricoh619-battery.c
diff -ur ./drivers/pwm/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/Kconfig
--- ./drivers/pwm/Kconfig	2023-04-26 12:56:06.620118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/Kconfig	2023-04-23 12:05:12.182632500 +0100
@@ -201,4 +201,41 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-vt8500.
 
+config JZ_PWM
+	bool "JZ PWM driver"
+	default y
+comment "JZ PWM function pin select"
+	depends on JZ_PWM
+config JZ_PWM_GPIO_E0
+	bool "GPIO Port E pwm0"
+	depends on JZ_PWM
+	default y
+config JZ_PWM_GPIO_E1
+	bool "GPIO Port E pwm1"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_E2
+	bool "GPIO Port E pwm2"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_E3
+	bool "GPIO Port E pwm3"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_E4
+	bool "GPIO Port E pwm4"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_E5
+	bool "GPIO Port E pwm5"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_D10
+	bool "GPIO Port D pwm6"
+	depends on JZ_PWM
+	default n
+config JZ_PWM_GPIO_D11
+	bool "GPIO Port D pwm7"
+	depends on JZ_PWM
+	default n
 endif
diff -ur ./drivers/pwm/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/Makefile
--- ./drivers/pwm/Makefile	2023-04-26 12:56:06.620118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/Makefile	2023-04-23 12:05:12.182223600 +0100
@@ -17,3 +17,4 @@
 obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
+obj-$(CONFIG_JZ_PWM)		+= pwm-jz.o
diff -ur ./drivers/pwm/core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/core.c
--- ./drivers/pwm/core.c	2023-04-26 12:56:06.620118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm/core.c	2023-04-23 12:05:12.181751700 +0100
@@ -553,7 +553,7 @@
  * @table: array of consumers to register
  * @num: number of consumers in table
  */
-void __init pwm_add_table(struct pwm_lookup *table, size_t num)
+void pwm_add_table(struct pwm_lookup *table, size_t num)
 {
 	mutex_lock(&pwm_lookup_lock);
 
@@ -564,6 +564,7 @@
 
 	mutex_unlock(&pwm_lookup_lock);
 }
+EXPORT_SYMBOL_GPL(pwm_add_table);
 
 /**
  * pwm_get() - look up and request a PWM device
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/pwm: pwm-jz.c
diff -ur ./drivers/regulator/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/regulator/Kconfig
--- ./drivers/regulator/Kconfig	2023-04-26 12:56:06.630118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/regulator/Kconfig	2023-04-23 12:05:13.067283700 +0100
@@ -507,6 +507,14 @@
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
+config REGULATOR_RICOH619
+	tristate "Ricoh R5T619 Power regulators"
+	depends on MFD_RICOH619
+	default n
+	help
+	  This driver supports regulator driver for the Ricoh R5T619
+	  Power Management device.
+
 config REGULATOR_AS3711
 	tristate "AS3711 PMIC"
 	depends on MFD_AS3711
diff -ur ./drivers/regulator/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/regulator/Makefile
--- ./drivers/regulator/Makefile	2023-04-26 12:56:06.630118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/regulator/Makefile	2023-04-23 12:05:13.066550200 +0100
@@ -71,5 +71,6 @@
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
 
+obj-$(CONFIG_REGULATOR_RICOH619) += ricoh619-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/regulator: ricoh619-regulator.c
diff -ur ./drivers/rtc/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc/Kconfig
--- ./drivers/rtc/Kconfig	2023-04-26 12:56:06.660118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc/Kconfig	2023-04-23 12:05:15.062741400 +0100
@@ -114,6 +114,23 @@
 	  clock several times per second, please enable this option
 	  only if you know that you really need it.
 
+config RTC_INTF_ALARM
+        bool "Android alarm driver"
+        depends on RTC_CLASS
+        default y
+        help
+          Provides non-wakeup and rtc backed wakeup alarms based on rtc or
+          elapsed realtime, and a non-wakeup alarm on the monotonic clock.
+          Also provides an interface to set the wall time which must be used
+          for elapsed realtime to work.
+
+config RTC_INTF_ALARM_DEV
+    bool "Android alarm device"
+    depends on RTC_INTF_ALARM
+    default y
+    help
+        Exports the alarm interface to user-space.
+
 config RTC_DRV_TEST
 	tristate "Test driver/device"
 	help
@@ -128,6 +145,23 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-test.
 
+config RTC_DRV_JZ
+    tristate "JZ RTC"
+        help
+        If you say Y here you will get access to the real time clock
+          built into your JZ CPU.
+
+          To compile this driver as a module, choose M here: the
+          module will be called rtc-jz.
+
+config USE_EXTERNAL_24M_CLOCK
+    bool "use external 24M clock"
+	depends on RTC_DRV_JZ
+    default n
+        help
+        If you say Y here the RTC will use an external 24M clock
+         as the clock source
+
 comment "I2C RTC drivers"
 	depends on I2C
 
diff -ur ./drivers/rtc/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc/Makefile
--- ./drivers/rtc/Makefile	2023-04-26 12:56:06.660118957 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc/Makefile	2023-04-23 12:05:15.062254200 +0100
@@ -128,3 +128,4 @@
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_JZ)        += rtc-jz.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc: rtc-jz.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/rtc: rtc-jz.h
diff -ur ./drivers/spi/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi/Kconfig
--- ./drivers/spi/Kconfig	2023-04-26 12:56:07.150118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi/Kconfig	2023-04-23 12:05:41.072661100 +0100
@@ -86,6 +86,102 @@
 	  is for the regular SPI controller. Slave mode operation is not also
 	  not supported.
 
+config SPI_JZ_TEST
+	tristate "Ingeinc JZ47XX SPI controller test driver"
+	depends on JZ_SPI
+	default n
+	help
+		SPI controller of Ingenic JZ47xx series SoCs and it's driver test driver
+
+config JZ_SPI
+	tristate "Ingenic JZ series SPI driver"
+	depends on MACH_XBURST
+	select SPI_BITBANG
+	help
+		SPI driver for Ingenic JZ series SoCs
+
+config JZ_SPI0
+    bool "Ingenic SoC SSI controller 0 for SPI Host driver"
+	depends on JZ_SPI
+	select JZ_SPI0_PC
+
+config JZ_SPI0_PC
+    bool "JZ SSI0 controller function pins select"
+	depends on JZ_SPI0
+
+config SPI0_PIO_ONLY
+	bool 'Disable DMA (always use PIO) on JZ SSI controller 0'
+	depends on JZ_SPI0
+	default n
+	help
+		All data is copied between memory and FIFO by the CPU.
+		DMA controllers are ignored.
+
+		Do not select 'n' here unless DMA support for your SOC or board
+		is unavailable (or unstable).
+
+config JZ_SPI1
+	bool "Ingenic SoC SSI controller 1 for SPI Host driver"
+	depends on JZ_SPI
+
+config SPI1_PIO_ONLY
+	bool 'Disable DMA (always use PIO) on JZ SSI controller 1'
+	depends on JZ_SPI1
+	default n
+	help
+		All data is copied between memory and FIFO by the CPU.
+		DMA controllers are ignored.
+
+		Do not select 'n' here unless DMA support for your SOC or board
+		is unavailable (or unstable).
+
+choice
+	prompt "JZ SSI1 controller function pins select"
+	depends on JZ_SPI1
+	default JZ_SPI1_PB_2
+config JZ_SPI1_PB_1
+	bool "GPIO B(17,18,25,26)"
+config JZ_SPI1_PB_2
+	bool "GPIO B(27,28,29,30)"
+endchoice
+
+config JZ_SPI_BOARD_INFO_REGISTER
+	bool "Board info associated by spi master"
+	depends on JZ_SPI
+	default n
+
+config JZ_SPI_PIO_CE
+	bool "Use GPIO CE on JZ SSI controller 0"
+	depends on JZ_SPI
+	default n
+	help
+		Use GPIO control SSI CE by CPU. Sometimes controller's CE NOT match SPI Protocal
+
+config JZ_SPIDEV_TEST
+	tristate "Ingenic spi test driver"
+	depends on JZ_SPI
+	default n
+
+config JZ_SPI_SLAVE
+	bool "Ingenic SoC SSI SLAVE controller for device driver"
+	depends on JZ_SPI
+choice
+	prompt "JZ SSI SLAVE controller function pins select"
+	depends on JZ_SPI_SLAVE
+	default JZ_SPISLV_PB
+config JZ_SPISLV_PB
+	bool "GPIO B(00,01,04,05)"
+config JZ_SPISLV_PC
+	bool "GPIO C(02,03,04,05)"
+endchoice
+
+config JZ_SPI_SPISLV_LOOPTEST
+	bool "Ingenic SoC SSI and SSI SLAVE loop test"
+	depends on JZ_SPI_SLAVE
+
+
+##################################################
+
 config SPI_BFIN5XX
 	tristate "SPI controller driver for ADI Blackfin5xx"
 	depends on BLACKFIN
diff -ur ./drivers/spi/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi/Makefile
--- ./drivers/spi/Makefile	2023-04-26 12:26:14.340132525 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi/Makefile	2023-04-23 12:05:41.072124100 +0100
@@ -10,6 +10,7 @@
 obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
 
 # SPI master controller drivers (bus)
+obj-$(CONFIG_JZ_SPI)                += jz_spi.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
 obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi: jz_spi.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/spi: jz_spi.h
diff -ur ./drivers/ssb/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/ssb/Kconfig
--- ./drivers/ssb/Kconfig	2023-04-26 12:56:07.210118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/ssb/Kconfig	2023-04-23 12:05:42.422994700 +0100
@@ -144,7 +144,7 @@
 # Assumption: We are on embedded, if we compile the MIPS core.
 config SSB_EMBEDDED
 	bool
-	depends on SSB_DRIVER_MIPS
+	depends on SSB_DRIVER_MIPS && SSB_PCICORE_HOSTMODE
 	default y
 
 config SSB_DRIVER_EXTIF
diff -ur ./drivers/staging/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/Kconfig
--- ./drivers/staging/Kconfig	2023-04-26 12:56:07.210118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/Kconfig	2023-04-23 12:05:42.823505000 +0100
@@ -62,6 +62,8 @@
 
 source "drivers/staging/octeon/Kconfig"
 
+source "drivers/staging/octeon-usb/Kconfig"
+
 source "drivers/staging/serqt_usb2/Kconfig"
 
 source "drivers/staging/vt6655/Kconfig"
@@ -72,10 +74,6 @@
 
 source "drivers/staging/iio/Kconfig"
 
-source "drivers/staging/zsmalloc/Kconfig"
-
-source "drivers/staging/zram/Kconfig"
-
 source "drivers/staging/wlags49_h2/Kconfig"
 
 source "drivers/staging/wlags49_h25/Kconfig"
diff -ur ./drivers/staging/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/Makefile
--- ./drivers/staging/Makefile	2023-04-26 12:56:07.210118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/Makefile	2023-04-23 12:05:42.823005300 +0100
@@ -25,13 +25,12 @@
 obj-$(CONFIG_NETLOGIC_XLR_NET)	+= netlogic/
 obj-$(CONFIG_USB_SERIAL_QUATECH2)	+= serqt_usb2/
 obj-$(CONFIG_OCTEON_ETHERNET)	+= octeon/
+obj-$(CONFIG_OCTEON_USB)	+= octeon-usb/
 obj-$(CONFIG_VT6655)		+= vt6655/
 obj-$(CONFIG_VT6656)		+= vt6656/
 obj-$(CONFIG_VME_BUS)		+= vme/
 obj-$(CONFIG_DX_SEP)            += sep/
 obj-$(CONFIG_IIO)		+= iio/
-obj-$(CONFIG_ZRAM)		+= zram/
-obj-$(CONFIG_ZSMALLOC)		+= zsmalloc/
 obj-$(CONFIG_WLAGS49_H2)	+= wlags49_h2/
 obj-$(CONFIG_WLAGS49_H25)	+= wlags49_h25/
 obj-$(CONFIG_FB_SM7XX)		+= sm7xxfb/
diff -ur ./drivers/staging/android/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/Kconfig
--- ./drivers/staging/android/Kconfig	2023-04-26 12:26:14.570132501 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/Kconfig	2023-04-23 12:05:42.905408700 +0100
@@ -63,6 +63,15 @@
 	---help---
 	  Registers processes to be killed when memory is low
 
+config ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
+	bool "Android Low Memory Killer: detect oom_adj values"
+	depends on ANDROID_LOW_MEMORY_KILLER
+	default y
+	---help---
+	  Detect oom_adj values written to
+	  /sys/module/lowmemorykiller/parameters/adj and convert them
+	  to oom_score_adj values.
+
 config ANDROID_INTF_ALARM_DEV
 	bool "Android alarm driver"
 	depends on RTC_CLASS
@@ -99,6 +108,8 @@
 	  *WARNING* improper use of this can result in deadlocking kernel
 	  drivers from userspace.
 
+source "drivers/staging/android/ion/Kconfig"
+
 endif # if ANDROID
 
 endmenu
diff -ur ./drivers/staging/android/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/Makefile
--- ./drivers/staging/android/Makefile	2023-04-26 12:26:14.590132499 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/Makefile	2023-04-23 12:05:42.904892600 +0100
@@ -1,5 +1,7 @@
 ccflags-y += -I$(src)			# needed for trace events
 
+obj-y					+= ion/
+
 obj-$(CONFIG_ANDROID_BINDER_IPC)	+= binder.o
 obj-$(CONFIG_ASHMEM)			+= ashmem.o
 obj-$(CONFIG_ANDROID_LOGGER)		+= logger.o
Only in ./drivers/staging/android: TODO
diff -ur ./drivers/staging/android/android_alarm.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/android_alarm.h
--- ./drivers/staging/android/android_alarm.h	2023-04-26 12:26:14.600132498 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/android_alarm.h	2023-04-23 12:05:42.982845700 +0100
@@ -16,50 +16,10 @@
 #ifndef _LINUX_ANDROID_ALARM_H
 #define _LINUX_ANDROID_ALARM_H
 
-#include <linux/ioctl.h>
-#include <linux/time.h>
 #include <linux/compat.h>
+#include <linux/ioctl.h>
 
-enum android_alarm_type {
-	/* return code bit numbers or set alarm arg */
-	ANDROID_ALARM_RTC_WAKEUP,
-	ANDROID_ALARM_RTC,
-	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
-	ANDROID_ALARM_ELAPSED_REALTIME,
-	ANDROID_ALARM_SYSTEMTIME,
-
-	ANDROID_ALARM_TYPE_COUNT,
-
-	/* return code bit numbers */
-	/* ANDROID_ALARM_TIME_CHANGE = 16 */
-};
-
-enum android_alarm_return_flags {
-	ANDROID_ALARM_RTC_WAKEUP_MASK = 1U << ANDROID_ALARM_RTC_WAKEUP,
-	ANDROID_ALARM_RTC_MASK = 1U << ANDROID_ALARM_RTC,
-	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK =
-				1U << ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
-	ANDROID_ALARM_ELAPSED_REALTIME_MASK =
-				1U << ANDROID_ALARM_ELAPSED_REALTIME,
-	ANDROID_ALARM_SYSTEMTIME_MASK = 1U << ANDROID_ALARM_SYSTEMTIME,
-	ANDROID_ALARM_TIME_CHANGE_MASK = 1U << 16
-};
-
-/* Disable alarm */
-#define ANDROID_ALARM_CLEAR(type)           _IO('a', 0 | ((type) << 4))
-
-/* Ack last alarm and wait for next */
-#define ANDROID_ALARM_WAIT                  _IO('a', 1)
-
-#define ALARM_IOW(c, type, size)            _IOW('a', (c) | ((type) << 4), size)
-/* Set alarm */
-#define ANDROID_ALARM_SET(type)             ALARM_IOW(2, type, struct timespec)
-#define ANDROID_ALARM_SET_AND_WAIT(type)    ALARM_IOW(3, type, struct timespec)
-#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
-#define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)
-#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))
-#define ANDROID_ALARM_IOCTL_TO_TYPE(cmd)    (_IOC_NR(cmd) >> 4)
-
+#include "uapi/android_alarm.h"
 
 #ifdef CONFIG_COMPAT
 #define ANDROID_ALARM_SET_COMPAT(type)		ALARM_IOW(2, type, \
diff -ur ./drivers/staging/android/ashmem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/ashmem.c
--- ./drivers/staging/android/ashmem.c	2023-04-26 12:56:07.210118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/ashmem.c	2023-04-23 12:05:42.982417600 +0100
@@ -224,21 +224,29 @@
 
 	/* If size is not set, or set to 0, always return EOF. */
 	if (asma->size == 0)
-		goto out;
+		goto out_unlock;
 
 	if (!asma->file) {
 		ret = -EBADF;
-		goto out;
+		goto out_unlock;
 	}
 
-	ret = asma->file->f_op->read(asma->file, buf, len, pos);
-	if (ret < 0)
-		goto out;
+	mutex_unlock(&ashmem_mutex);
 
-	/** Update backing file pos, since f_ops->read() doesn't */
-	asma->file->f_pos = *pos;
+	/*
+	 * asma and asma->file are used outside the lock here.  We assume
+	 * once asma->file is set it will never be changed, and will not
+	 * be destroyed until all references to the file are dropped and
+	 * ashmem_release is called.
+	 */
+	ret = asma->file->f_op->read(asma->file, buf, len, pos);
+	if (ret >= 0) {
+		/** Update backing file pos, since f_ops->read() doesn't */
+		asma->file->f_pos = *pos;
+	}
+	return ret;
 
-out:
+out_unlock:
 	mutex_unlock(&ashmem_mutex);
 	return ret;
 }
@@ -317,22 +325,14 @@
 	}
 	get_file(asma->file);
 
-	/*
-	 * XXX - Reworked to use shmem_zero_setup() instead of
-	 * shmem_set_file while we're in staging. -jstultz
-	 */
-	if (vma->vm_flags & VM_SHARED) {
-		ret = shmem_zero_setup(vma);
-		if (ret) {
-			fput(asma->file);
-			goto out;
-		}
+	if (vma->vm_flags & VM_SHARED)
+		shmem_set_file(vma, asma->file);
+	else {
+		if (vma->vm_file)
+			fput(vma->vm_file);
+		vma->vm_file = asma->file;
 	}
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = asma->file;
-
 out:
 	mutex_unlock(&ashmem_mutex);
 	return ret;
@@ -413,6 +413,7 @@
 
 static int set_name(struct ashmem_area *asma, void __user *name)
 {
+	int len;
 	int ret = 0;
 	char local_name[ASHMEM_NAME_LEN];
 
@@ -425,21 +426,19 @@
 	 * variable that does not need protection and later copy the local
 	 * variable to the structure member with lock held.
 	 */
-	if (copy_from_user(local_name, name, ASHMEM_NAME_LEN))
-		return -EFAULT;
-
+	len = strncpy_from_user(local_name, name, ASHMEM_NAME_LEN);
+	if (len < 0)
+		return len;
+	if (len == ASHMEM_NAME_LEN)
+		local_name[ASHMEM_NAME_LEN - 1] = '\0';
 	mutex_lock(&ashmem_mutex);
 	/* cannot change an existing mapping's name */
-	if (unlikely(asma->file)) {
+	if (unlikely(asma->file))
 		ret = -EINVAL;
-		goto out;
-	}
-	memcpy(asma->name + ASHMEM_NAME_PREFIX_LEN,
-		local_name, ASHMEM_NAME_LEN);
-	asma->name[ASHMEM_FULL_NAME_LEN-1] = '\0';
-out:
-	mutex_unlock(&ashmem_mutex);
+	else
+		strcpy(asma->name + ASHMEM_NAME_PREFIX_LEN, local_name);
 
+	mutex_unlock(&ashmem_mutex);
 	return ret;
 }
 
diff -ur ./drivers/staging/android/ashmem.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/ashmem.h
--- ./drivers/staging/android/ashmem.h	2023-04-26 12:26:14.600132498 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/ashmem.h	2023-04-23 12:05:42.981918700 +0100
@@ -16,35 +16,7 @@
 #include <linux/ioctl.h>
 #include <linux/compat.h>
 
-#define ASHMEM_NAME_LEN		256
-
-#define ASHMEM_NAME_DEF		"dev/ashmem"
-
-/* Return values from ASHMEM_PIN: Was the mapping purged while unpinned? */
-#define ASHMEM_NOT_PURGED	0
-#define ASHMEM_WAS_PURGED	1
-
-/* Return values from ASHMEM_GET_PIN_STATUS: Is the mapping pinned? */
-#define ASHMEM_IS_UNPINNED	0
-#define ASHMEM_IS_PINNED	1
-
-struct ashmem_pin {
-	__u32 offset;	/* offset into region, in bytes, page-aligned */
-	__u32 len;	/* length forward from offset, in bytes, page-aligned */
-};
-
-#define __ASHMEMIOC		0x77
-
-#define ASHMEM_SET_NAME		_IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
-#define ASHMEM_GET_NAME		_IOR(__ASHMEMIOC, 2, char[ASHMEM_NAME_LEN])
-#define ASHMEM_SET_SIZE		_IOW(__ASHMEMIOC, 3, size_t)
-#define ASHMEM_GET_SIZE		_IO(__ASHMEMIOC, 4)
-#define ASHMEM_SET_PROT_MASK	_IOW(__ASHMEMIOC, 5, unsigned long)
-#define ASHMEM_GET_PROT_MASK	_IO(__ASHMEMIOC, 6)
-#define ASHMEM_PIN		_IOW(__ASHMEMIOC, 7, struct ashmem_pin)
-#define ASHMEM_UNPIN		_IOW(__ASHMEMIOC, 8, struct ashmem_pin)
-#define ASHMEM_GET_PIN_STATUS	_IO(__ASHMEMIOC, 9)
-#define ASHMEM_PURGE_ALL_CACHES	_IO(__ASHMEMIOC, 10)
+#include "uapi/ashmem.h"
 
 /* support of 32bit userspace on 64bit platforms */
 #ifdef CONFIG_COMPAT
diff -ur ./drivers/staging/android/binder.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/binder.c
--- ./drivers/staging/android/binder.c	2023-04-26 12:56:07.220118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/binder.c	2023-04-23 12:05:43.064627700 +0100
@@ -20,6 +20,7 @@
 #include <asm/cacheflush.h>
 #include <linux/fdtable.h>
 #include <linux/file.h>
+#include <linux/freezer.h>
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/miscdevice.h>
@@ -36,6 +37,7 @@
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
 #include <linux/pid_namespace.h>
+#include <linux/security.h>
 
 #include "binder.h"
 #include "binder_trace.h"
@@ -1382,6 +1384,10 @@
 			return_error = BR_DEAD_REPLY;
 			goto err_dead_binder;
 		}
+		if (security_binder_transaction(proc->tsk, target_proc->tsk) < 0) {
+			return_error = BR_FAILED_REPLY;
+			goto err_invalid_target_handle;
+		}
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
 			tmp = thread->transaction_stack;
@@ -1524,6 +1530,10 @@
 					fp->cookie, node->cookie);
 				goto err_binder_get_ref_for_node_failed;
 			}
+			if (security_binder_transfer_binder(proc->tsk, target_proc->tsk)) {
+				return_error = BR_FAILED_REPLY;
+				goto err_binder_get_ref_for_node_failed;
+			}
 			ref = binder_get_ref_for_node(target_proc, node);
 			if (ref == NULL) {
 				return_error = BR_FAILED_REPLY;
@@ -1553,6 +1563,10 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_binder_get_ref_failed;
 			}
+			if (security_binder_transfer_binder(proc->tsk, target_proc->tsk)) {
+				return_error = BR_FAILED_REPLY;
+				goto err_binder_get_ref_failed;
+			}
 			if (ref->node->proc == target_proc) {
 				if (fp->type == BINDER_TYPE_HANDLE)
 					fp->type = BINDER_TYPE_BINDER;
@@ -1609,6 +1623,11 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_fget_failed;
 			}
+			if (security_binder_transfer_file(proc->tsk, target_proc->tsk, file) < 0) {
+				fput(file);
+				return_error = BR_FAILED_REPLY;
+				goto err_get_unused_fd_failed;
+			}
 			target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);
 			if (target_fd < 0) {
 				fput(file);
@@ -2140,13 +2159,13 @@
 			if (!binder_has_proc_work(proc, thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_interruptible_exclusive(proc->wait, binder_has_proc_work(proc, thread));
+			ret = wait_event_freezable_exclusive(proc->wait, binder_has_proc_work(proc, thread));
 	} else {
 		if (non_block) {
 			if (!binder_has_thread_work(thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_interruptible(thread->wait, binder_has_thread_work(thread));
+			ret = wait_event_freezable(thread->wait, binder_has_thread_work(thread));
 	}
 
 	binder_lock(__func__);
@@ -2625,6 +2644,9 @@
 			ret = -EBUSY;
 			goto err;
 		}
+		ret = security_binder_set_context_mgr(proc->tsk);
+		if (ret < 0)
+			goto err;
 		if (uid_valid(binder_context_mgr_uid)) {
 			if (!uid_eq(binder_context_mgr_uid, current->cred->euid)) {
 				pr_err("BINDER_SET_CONTEXT_MGR bad uid %d != %d\n",
diff -ur ./drivers/staging/android/binder.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/binder.h
--- ./drivers/staging/android/binder.h	2023-04-26 12:26:14.600132498 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/binder.h	2023-04-23 12:05:43.064100300 +0100
@@ -20,311 +20,7 @@
 #ifndef _LINUX_BINDER_H
 #define _LINUX_BINDER_H
 
-#include <linux/ioctl.h>
-
-#define B_PACK_CHARS(c1, c2, c3, c4) \
-	((((c1)<<24)) | (((c2)<<16)) | (((c3)<<8)) | (c4))
-#define B_TYPE_LARGE 0x85
-
-enum {
-	BINDER_TYPE_BINDER	= B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE),
-	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE),
-	BINDER_TYPE_HANDLE	= B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE),
-	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE),
-	BINDER_TYPE_FD		= B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),
-};
-
-enum {
-	FLAT_BINDER_FLAG_PRIORITY_MASK = 0xff,
-	FLAT_BINDER_FLAG_ACCEPTS_FDS = 0x100,
-};
-
-/*
- * This is the flattened representation of a Binder object for transfer
- * between processes.  The 'offsets' supplied as part of a binder transaction
- * contains offsets into the data where these structures occur.  The Binder
- * driver takes care of re-writing the structure type and data as it moves
- * between processes.
- */
-struct flat_binder_object {
-	/* 8 bytes for large_flat_header. */
-	unsigned long		type;
-	unsigned long		flags;
-
-	/* 8 bytes of data. */
-	union {
-		void __user	*binder;	/* local object */
-		signed long	handle;		/* remote object */
-	};
-
-	/* extra data associated with local object */
-	void __user		*cookie;
-};
-
-/*
- * On 64-bit platforms where user code may run in 32-bits the driver must
- * translate the buffer (and local binder) addresses appropriately.
- */
-
-struct binder_write_read {
-	signed long	write_size;	/* bytes to write */
-	signed long	write_consumed;	/* bytes consumed by driver */
-	unsigned long	write_buffer;
-	signed long	read_size;	/* bytes to read */
-	signed long	read_consumed;	/* bytes consumed by driver */
-	unsigned long	read_buffer;
-};
-
-/* Use with BINDER_VERSION, driver fills in fields. */
-struct binder_version {
-	/* driver protocol version -- increment with incompatible change */
-	signed long	protocol_version;
-};
-
-/* This is the current protocol version. */
-#define BINDER_CURRENT_PROTOCOL_VERSION 7
-
-#define BINDER_WRITE_READ		_IOWR('b', 1, struct binder_write_read)
-#define	BINDER_SET_IDLE_TIMEOUT		_IOW('b', 3, __s64)
-#define	BINDER_SET_MAX_THREADS		_IOW('b', 5, size_t)
-#define	BINDER_SET_IDLE_PRIORITY	_IOW('b', 6, __s32)
-#define	BINDER_SET_CONTEXT_MGR		_IOW('b', 7, __s32)
-#define	BINDER_THREAD_EXIT		_IOW('b', 8, __s32)
-#define BINDER_VERSION			_IOWR('b', 9, struct binder_version)
-
-/*
- * NOTE: Two special error codes you should check for when calling
- * in to the driver are:
- *
- * EINTR -- The operation has been interupted.  This should be
- * handled by retrying the ioctl() until a different error code
- * is returned.
- *
- * ECONNREFUSED -- The driver is no longer accepting operations
- * from your process.  That is, the process is being destroyed.
- * You should handle this by exiting from your process.  Note
- * that once this error code is returned, all further calls to
- * the driver from any thread will return this same code.
- */
-
-enum transaction_flags {
-	TF_ONE_WAY	= 0x01,	/* this is a one-way call: async, no return */
-	TF_ROOT_OBJECT	= 0x04,	/* contents are the component's root object */
-	TF_STATUS_CODE	= 0x08,	/* contents are a 32-bit status code */
-	TF_ACCEPT_FDS	= 0x10,	/* allow replies with file descriptors */
-};
-
-struct binder_transaction_data {
-	/* The first two are only used for bcTRANSACTION and brTRANSACTION,
-	 * identifying the target and contents of the transaction.
-	 */
-	union {
-		size_t	handle;	/* target descriptor of command transaction */
-		void	*ptr;	/* target descriptor of return transaction */
-	} target;
-	void		*cookie;	/* target object cookie */
-	unsigned int	code;		/* transaction command */
-
-	/* General information about the transaction. */
-	unsigned int	flags;
-	pid_t		sender_pid;
-	uid_t		sender_euid;
-	size_t		data_size;	/* number of bytes of data */
-	size_t		offsets_size;	/* number of bytes of offsets */
-
-	/* If this transaction is inline, the data immediately
-	 * follows here; otherwise, it ends with a pointer to
-	 * the data buffer.
-	 */
-	union {
-		struct {
-			/* transaction data */
-			const void __user	*buffer;
-			/* offsets from buffer to flat_binder_object structs */
-			const void __user	*offsets;
-		} ptr;
-		uint8_t	buf[8];
-	} data;
-};
-
-struct binder_ptr_cookie {
-	void *ptr;
-	void *cookie;
-};
-
-struct binder_pri_desc {
-	int priority;
-	int desc;
-};
-
-struct binder_pri_ptr_cookie {
-	int priority;
-	void *ptr;
-	void *cookie;
-};
-
-enum binder_driver_return_protocol {
-	BR_ERROR = _IOR('r', 0, int),
-	/*
-	 * int: error code
-	 */
-
-	BR_OK = _IO('r', 1),
-	/* No parameters! */
-
-	BR_TRANSACTION = _IOR('r', 2, struct binder_transaction_data),
-	BR_REPLY = _IOR('r', 3, struct binder_transaction_data),
-	/*
-	 * binder_transaction_data: the received command.
-	 */
-
-	BR_ACQUIRE_RESULT = _IOR('r', 4, int),
-	/*
-	 * not currently supported
-	 * int: 0 if the last bcATTEMPT_ACQUIRE was not successful.
-	 * Else the remote object has acquired a primary reference.
-	 */
-
-	BR_DEAD_REPLY = _IO('r', 5),
-	/*
-	 * The target of the last transaction (either a bcTRANSACTION or
-	 * a bcATTEMPT_ACQUIRE) is no longer with us.  No parameters.
-	 */
-
-	BR_TRANSACTION_COMPLETE = _IO('r', 6),
-	/*
-	 * No parameters... always refers to the last transaction requested
-	 * (including replies).  Note that this will be sent even for
-	 * asynchronous transactions.
-	 */
-
-	BR_INCREFS = _IOR('r', 7, struct binder_ptr_cookie),
-	BR_ACQUIRE = _IOR('r', 8, struct binder_ptr_cookie),
-	BR_RELEASE = _IOR('r', 9, struct binder_ptr_cookie),
-	BR_DECREFS = _IOR('r', 10, struct binder_ptr_cookie),
-	/*
-	 * void *:	ptr to binder
-	 * void *: cookie for binder
-	 */
-
-	BR_ATTEMPT_ACQUIRE = _IOR('r', 11, struct binder_pri_ptr_cookie),
-	/*
-	 * not currently supported
-	 * int:	priority
-	 * void *: ptr to binder
-	 * void *: cookie for binder
-	 */
-
-	BR_NOOP = _IO('r', 12),
-	/*
-	 * No parameters.  Do nothing and examine the next command.  It exists
-	 * primarily so that we can replace it with a BR_SPAWN_LOOPER command.
-	 */
-
-	BR_SPAWN_LOOPER = _IO('r', 13),
-	/*
-	 * No parameters.  The driver has determined that a process has no
-	 * threads waiting to service incoming transactions.  When a process
-	 * receives this command, it must spawn a new service thread and
-	 * register it via bcENTER_LOOPER.
-	 */
-
-	BR_FINISHED = _IO('r', 14),
-	/*
-	 * not currently supported
-	 * stop threadpool thread
-	 */
-
-	BR_DEAD_BINDER = _IOR('r', 15, void *),
-	/*
-	 * void *: cookie
-	 */
-	BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR('r', 16, void *),
-	/*
-	 * void *: cookie
-	 */
-
-	BR_FAILED_REPLY = _IO('r', 17),
-	/*
-	 * The the last transaction (either a bcTRANSACTION or
-	 * a bcATTEMPT_ACQUIRE) failed (e.g. out of memory).  No parameters.
-	 */
-};
-
-enum binder_driver_command_protocol {
-	BC_TRANSACTION = _IOW('c', 0, struct binder_transaction_data),
-	BC_REPLY = _IOW('c', 1, struct binder_transaction_data),
-	/*
-	 * binder_transaction_data: the sent command.
-	 */
-
-	BC_ACQUIRE_RESULT = _IOW('c', 2, int),
-	/*
-	 * not currently supported
-	 * int:  0 if the last BR_ATTEMPT_ACQUIRE was not successful.
-	 * Else you have acquired a primary reference on the object.
-	 */
-
-	BC_FREE_BUFFER = _IOW('c', 3, int),
-	/*
-	 * void *: ptr to transaction data received on a read
-	 */
-
-	BC_INCREFS = _IOW('c', 4, int),
-	BC_ACQUIRE = _IOW('c', 5, int),
-	BC_RELEASE = _IOW('c', 6, int),
-	BC_DECREFS = _IOW('c', 7, int),
-	/*
-	 * int:	descriptor
-	 */
-
-	BC_INCREFS_DONE = _IOW('c', 8, struct binder_ptr_cookie),
-	BC_ACQUIRE_DONE = _IOW('c', 9, struct binder_ptr_cookie),
-	/*
-	 * void *: ptr to binder
-	 * void *: cookie for binder
-	 */
-
-	BC_ATTEMPT_ACQUIRE = _IOW('c', 10, struct binder_pri_desc),
-	/*
-	 * not currently supported
-	 * int: priority
-	 * int: descriptor
-	 */
-
-	BC_REGISTER_LOOPER = _IO('c', 11),
-	/*
-	 * No parameters.
-	 * Register a spawned looper thread with the device.
-	 */
-
-	BC_ENTER_LOOPER = _IO('c', 12),
-	BC_EXIT_LOOPER = _IO('c', 13),
-	/*
-	 * No parameters.
-	 * These two commands are sent as an application-level thread
-	 * enters and exits the binder loop, respectively.  They are
-	 * used so the binder can have an accurate count of the number
-	 * of looping threads it has available.
-	 */
-
-	BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14, struct binder_ptr_cookie),
-	/*
-	 * void *: ptr to binder
-	 * void *: cookie
-	 */
-
-	BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15, struct binder_ptr_cookie),
-	/*
-	 * void *: ptr to binder
-	 * void *: cookie
-	 */
-
-	BC_DEAD_BINDER_DONE = _IOW('c', 16, void *),
-	/*
-	 * void *: cookie
-	 */
-};
+#include "uapi/binder.h"
 
 #endif /* _LINUX_BINDER_H */
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android: ion
diff -ur ./drivers/staging/android/lowmemorykiller.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/lowmemorykiller.c
--- ./drivers/staging/android/lowmemorykiller.c	2023-04-26 12:26:14.660132492 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/lowmemorykiller.c	2023-04-23 12:05:43.462239200 +0100
@@ -39,7 +39,6 @@
 #include <linux/sched.h>
 #include <linux/swap.h>
 #include <linux/rcupdate.h>
-#include <linux/profile.h>
 #include <linux/notifier.h>
 
 static uint32_t lowmem_debug_level = 1;
@@ -74,6 +73,7 @@
 	int tasksize;
 	int i;
 	short min_score_adj = OOM_SCORE_ADJ_MAX + 1;
+	int minfree = 0;
 	int selected_tasksize = 0;
 	short selected_oom_score_adj;
 	int array_size = ARRAY_SIZE(lowmem_adj);
@@ -86,8 +86,8 @@
 	if (lowmem_minfree_size < array_size)
 		array_size = lowmem_minfree_size;
 	for (i = 0; i < array_size; i++) {
-		if (other_free < lowmem_minfree[i] &&
-		    other_file < lowmem_minfree[i]) {
+		minfree = lowmem_minfree[i];
+		if (other_free < minfree && other_file < minfree) {
 			min_score_adj = lowmem_adj[i];
 			break;
 		}
@@ -144,13 +144,22 @@
 		selected = p;
 		selected_tasksize = tasksize;
 		selected_oom_score_adj = oom_score_adj;
-		lowmem_print(2, "select %d (%s), adj %hd, size %d, to kill\n",
-			     p->pid, p->comm, oom_score_adj, tasksize);
+		lowmem_print(2, "select '%s' (%d), adj %hd, size %d, to kill\n",
+			     p->comm, p->pid, oom_score_adj, tasksize);
 	}
 	if (selected) {
-		lowmem_print(1, "send sigkill to %d (%s), adj %hd, size %d\n",
-			     selected->pid, selected->comm,
-			     selected_oom_score_adj, selected_tasksize);
+		lowmem_print(1, "Killing '%s' (%d), adj %hd,\n" \
+				"   to free %ldkB on behalf of '%s' (%d) because\n" \
+				"   cache %ldkB is below limit %ldkB for oom_score_adj %hd\n" \
+				"   Free memory is %ldkB above reserved\n",
+			     selected->comm, selected->pid,
+			     selected_oom_score_adj,
+			     selected_tasksize * (long)(PAGE_SIZE / 1024),
+			     current->comm, current->pid,
+			     other_file * (long)(PAGE_SIZE / 1024),
+			     minfree * (long)(PAGE_SIZE / 1024),
+			     min_score_adj,
+			     other_free * (long)(PAGE_SIZE / 1024));
 		lowmem_deathpending_timeout = jiffies + HZ;
 		send_sig(SIGKILL, selected, 0);
 		set_tsk_thread_flag(selected, TIF_MEMDIE);
@@ -178,9 +187,94 @@
 	unregister_shrinker(&lowmem_shrinker);
 }
 
+#ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
+static short lowmem_oom_adj_to_oom_score_adj(short oom_adj)
+{
+	if (oom_adj == OOM_ADJUST_MAX)
+		return OOM_SCORE_ADJ_MAX;
+	else
+		return (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;
+}
+
+static void lowmem_autodetect_oom_adj_values(void)
+{
+	int i;
+	short oom_adj;
+	short oom_score_adj;
+	int array_size = ARRAY_SIZE(lowmem_adj);
+
+	if (lowmem_adj_size < array_size)
+		array_size = lowmem_adj_size;
+
+	if (array_size <= 0)
+		return;
+
+	oom_adj = lowmem_adj[array_size - 1];
+	if (oom_adj > OOM_ADJUST_MAX)
+		return;
+
+	oom_score_adj = lowmem_oom_adj_to_oom_score_adj(oom_adj);
+	if (oom_score_adj <= OOM_ADJUST_MAX)
+		return;
+
+	lowmem_print(1, "lowmem_shrink: convert oom_adj to oom_score_adj:\n");
+	for (i = 0; i < array_size; i++) {
+		oom_adj = lowmem_adj[i];
+		oom_score_adj = lowmem_oom_adj_to_oom_score_adj(oom_adj);
+		lowmem_adj[i] = oom_score_adj;
+		lowmem_print(1, "oom_adj %d => oom_score_adj %d\n",
+			     oom_adj, oom_score_adj);
+	}
+}
+
+static int lowmem_adj_array_set(const char *val, const struct kernel_param *kp)
+{
+	int ret;
+
+	ret = param_array_ops.set(val, kp);
+
+	/* HACK: Autodetect oom_adj values in lowmem_adj array */
+	lowmem_autodetect_oom_adj_values();
+
+	return ret;
+}
+
+static int lowmem_adj_array_get(char *buffer, const struct kernel_param *kp)
+{
+	return param_array_ops.get(buffer, kp);
+}
+
+static void lowmem_adj_array_free(void *arg)
+{
+	param_array_ops.free(arg);
+}
+
+static struct kernel_param_ops lowmem_adj_array_ops = {
+	.set = lowmem_adj_array_set,
+	.get = lowmem_adj_array_get,
+	.free = lowmem_adj_array_free,
+};
+
+static const struct kparam_array __param_arr_adj = {
+	.max = ARRAY_SIZE(lowmem_adj),
+	.num = &lowmem_adj_size,
+	.ops = &param_ops_short,
+	.elemsize = sizeof(lowmem_adj[0]),
+	.elem = lowmem_adj,
+};
+#endif
+
 module_param_named(cost, lowmem_shrinker.seeks, int, S_IRUGO | S_IWUSR);
+#ifdef CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES
+__module_param_call(MODULE_PARAM_PREFIX, adj,
+		    &lowmem_adj_array_ops,
+		    .arr = &__param_arr_adj,
+		    S_IRUGO | S_IWUSR, -1);
+__MODULE_PARM_TYPE(adj, "array of short");
+#else
 module_param_array_named(adj, lowmem_adj, short, &lowmem_adj_size,
 			 S_IRUGO | S_IWUSR);
+#endif
 module_param_array_named(minfree, lowmem_minfree, uint, &lowmem_minfree_size,
 			 S_IRUGO | S_IWUSR);
 module_param_named(debug_level, lowmem_debug_level, uint, S_IRUGO | S_IWUSR);
diff -ur ./drivers/staging/android/sw_sync.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sw_sync.h
--- ./drivers/staging/android/sw_sync.h	2023-04-26 12:26:14.660132492 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sw_sync.h	2023-04-23 12:05:43.460644900 +0100
@@ -18,10 +18,9 @@
 #define _LINUX_SW_SYNC_H
 
 #include <linux/types.h>
-
-#ifdef __KERNEL__
-
+#include <linux/kconfig.h>
 #include "sync.h"
+#include "uapi/sw_sync.h"
 
 struct sw_sync_timeline {
 	struct	sync_timeline	obj;
@@ -35,24 +34,26 @@
 	u32			value;
 };
 
+#if IS_ENABLED(CONFIG_SW_SYNC)
 struct sw_sync_timeline *sw_sync_timeline_create(const char *name);
 void sw_sync_timeline_inc(struct sw_sync_timeline *obj, u32 inc);
 
 struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value);
-
-#endif /* __KERNEL __ */
-
-struct sw_sync_create_fence_data {
-	__u32	value;
-	char	name[32];
-	__s32	fence; /* fd of new fence */
-};
-
-#define SW_SYNC_IOC_MAGIC	'W'
-
-#define SW_SYNC_IOC_CREATE_FENCE	_IOWR(SW_SYNC_IOC_MAGIC, 0,\
-		struct sw_sync_create_fence_data)
-#define SW_SYNC_IOC_INC			_IOW(SW_SYNC_IOC_MAGIC, 1, __u32)
-
+#else
+static inline struct sw_sync_timeline *sw_sync_timeline_create(const char *name)
+{
+	return NULL;
+}
+
+static inline void sw_sync_timeline_inc(struct sw_sync_timeline *obj, u32 inc)
+{
+}
+
+static inline struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj,
+		u32 value)
+{
+	return NULL;
+}
+#endif /* IS_ENABLED(CONFIG_SW_SYNC) */
 
 #endif /* _LINUX_SW_SYNC_H */
diff -ur ./drivers/staging/android/sync.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sync.c
--- ./drivers/staging/android/sync.c	2023-04-26 12:56:07.220118956 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sync.c	2023-04-23 12:05:43.548437600 +0100
@@ -79,27 +79,27 @@
 		container_of(kref, struct sync_timeline, kref);
 	unsigned long flags;
 
-	if (obj->ops->release_obj)
-		obj->ops->release_obj(obj);
-
 	spin_lock_irqsave(&sync_timeline_list_lock, flags);
 	list_del(&obj->sync_timeline_list);
 	spin_unlock_irqrestore(&sync_timeline_list_lock, flags);
 
+	if (obj->ops->release_obj)
+		obj->ops->release_obj(obj);
+
 	kfree(obj);
 }
 
 void sync_timeline_destroy(struct sync_timeline *obj)
 {
 	obj->destroyed = true;
+	smp_wmb();
 
 	/*
-	 * If this is not the last reference, signal any children
-	 * that their parent is going away.
+	 * signal any children that their parent is going away.
 	 */
+	sync_timeline_signal(obj);
 
-	if (!kref_put(&obj->kref, sync_timeline_free))
-		sync_timeline_signal(obj);
+	kref_put(&obj->kref, sync_timeline_free);
 }
 EXPORT_SYMBOL(sync_timeline_destroy);
 
diff -ur ./drivers/staging/android/sync.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sync.h
--- ./drivers/staging/android/sync.h	2023-04-26 12:26:14.660132492 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android/sync.h	2023-04-23 12:05:43.547621600 +0100
@@ -14,14 +14,14 @@
 #define _LINUX_SYNC_H
 
 #include <linux/types.h>
-#ifdef __KERNEL__
-
 #include <linux/kref.h>
 #include <linux/ktime.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 
+#include "uapi/sync.h"
+
 struct sync_timeline;
 struct sync_pt;
 struct sync_fence;
@@ -341,86 +341,4 @@
  */
 int sync_fence_wait(struct sync_fence *fence, long timeout);
 
-#endif /* __KERNEL__ */
-
-/**
- * struct sync_merge_data - data passed to merge ioctl
- * @fd2:	file descriptor of second fence
- * @name:	name of new fence
- * @fence:	returns the fd of the new fence to userspace
- */
-struct sync_merge_data {
-	__s32	fd2; /* fd of second fence */
-	char	name[32]; /* name of new fence */
-	__s32	fence; /* fd on newly created fence */
-};
-
-/**
- * struct sync_pt_info - detailed sync_pt information
- * @len:		length of sync_pt_info including any driver_data
- * @obj_name:		name of parent sync_timeline
- * @driver_name:	name of driver implmenting the parent
- * @status:		status of the sync_pt 0:active 1:signaled <0:error
- * @timestamp_ns:	timestamp of status change in nanoseconds
- * @driver_data:	any driver dependant data
- */
-struct sync_pt_info {
-	__u32	len;
-	char	obj_name[32];
-	char	driver_name[32];
-	__s32	status;
-	__u64	timestamp_ns;
-
-	__u8	driver_data[0];
-};
-
-/**
- * struct sync_fence_info_data - data returned from fence info ioctl
- * @len:	ioctl caller writes the size of the buffer its passing in.
- *		ioctl returns length of sync_fence_data reutnred to userspace
- *		including pt_info.
- * @name:	name of fence
- * @status:	status of fence. 1: signaled 0:active <0:error
- * @pt_info:	a sync_pt_info struct for every sync_pt in the fence
- */
-struct sync_fence_info_data {
-	__u32	len;
-	char	name[32];
-	__s32	status;
-
-	__u8	pt_info[0];
-};
-
-#define SYNC_IOC_MAGIC		'>'
-
-/**
- * DOC: SYNC_IOC_WAIT - wait for a fence to signal
- *
- * pass timeout in milliseconds.  Waits indefinitely timeout < 0.
- */
-#define SYNC_IOC_WAIT		_IOW(SYNC_IOC_MAGIC, 0, __s32)
-
-/**
- * DOC: SYNC_IOC_MERGE - merge two fences
- *
- * Takes a struct sync_merge_data.  Creates a new fence containing copies of
- * the sync_pts in both the calling fd and sync_merge_data.fd2.  Returns the
- * new fence's fd in sync_merge_data.fence
- */
-#define SYNC_IOC_MERGE		_IOWR(SYNC_IOC_MAGIC, 1, struct sync_merge_data)
-
-/**
- * DOC: SYNC_IOC_FENCE_INFO - get detailed information on a fence
- *
- * Takes a struct sync_fence_info_data with extra space allocated for pt_info.
- * Caller should write the size of the buffer into len.  On return, len is
- * updated to reflect the total size of the sync_fence_info_data including
- * pt_info.
- *
- * pt_info is a buffer containing sync_pt_infos for every sync_pt in the fence.
- * To itterate over the sync_pt_infos, use the sync_pt_info.len field.
- */
-#define SYNC_IOC_FENCE_INFO	_IOWR(SYNC_IOC_MAGIC, 2,\
-	struct sync_fence_info_data)
-
 #endif /* _LINUX_SYNC_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/android: uapi
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging: octeon-usb
diff -ur ./drivers/staging/zram/zram_drv.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/zram/zram_drv.h
--- ./drivers/staging/zram/zram_drv.h	2023-04-26 12:56:07.550118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/staging/zram/zram_drv.h	2023-04-23 12:06:23.219786500 +0100
@@ -17,8 +17,7 @@
 
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
-
-#include "../zsmalloc/zsmalloc.h"
+#include <linux/zsmalloc.h>
 
 /*
  * Some arbitrary value. This is just to catch
Only in ./drivers/staging: zsmalloc
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers: switch
diff -ur ./drivers/tty/serial/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/Kconfig
--- ./drivers/tty/serial/Kconfig	2023-04-26 12:56:07.680118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/Kconfig	2023-04-23 12:06:27.070772500 +0100
@@ -224,7 +224,7 @@
 	help
 	  Select the number of available UART ports for the Samsung S3C
 	  serial driver
-	
+
 config SERIAL_SAMSUNG_DEBUG
 	bool "Samsung SoC serial debug"
 	depends on SERIAL_SAMSUNG && DEBUG_LL
@@ -661,8 +661,8 @@
 	depends on PARISC && !SERIAL_MUX && VT
 	default n
 	help
-	  Saying Y here will enable the software based PDC console to be 
-	  used as the system console.  This is useful for machines in 
+	  Saying Y here will enable the software based PDC console to be
+	  used as the system console.  This is useful for machines in
 	  which the hardware based console has not been written yet.  The
 	  following steps must be competed to use the PDC console:
 
@@ -853,7 +853,7 @@
 	depends on CPM2 || 8xx
 	select SERIAL_CORE
 	help
-	  This driver supports the SCC and SMC serial ports on Motorola 
+	  This driver supports the SCC and SMC serial ports on Motorola
 	  embedded PowerPC that contain a CPM1 (8xx) or CPM2 (8xxx)
 
 config SERIAL_CPM_CONSOLE
@@ -1484,6 +1484,81 @@
 	  If multiple cards are present, the default limit of 32 ports may
 	  need to be increased.
 
+config SERIAL_JZ47XX_UART
+	tristate "ingenic jz47xx serial port support"
+	select SERIAL_CORE
+	help
+	  If you have a machine based on a xbrust mips soc you can
+	  enable its onboard serial port by enabling this option.
+
+config SERIAL_JZ47XX_CONSOLE
+	bool "Console on jz47xx and compatible serial port"
+	depends on SERIAL_JZ47XX_UART=y
+	select SERIAL_CORE_CONSOLE
+	---help---
+	  If you say Y here, it will be possible to use a serial port as the
+	  system console (the system console is the device which receives all
+	  kernel messages and warnings and which allows logins in single user
+	  mode). This could be useful if some terminal or printer is connected
+	  to that serial port.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttyS1". (Try "man bootparam" or see the documentation of
+	  your boot loader (grub or lilo or loadlin) about how to pass options
+	  to the kernel at boot time.)
+
+	  If you don't have a VGA card installed and you say Y here, the
+	  kernel will automatically use the first serial line, /dev/ttyS0, as
+	  system console.
+
+	  If unsure, say N.
+
+config SERIAL_JZ47XX_UART0
+	bool "enable uart0"
+	depends on SERIAL_JZ47XX_UART=y
+config SERIAL_JZ47XX_UART0_DMA
+	bool "enable uart0 dma mode"
+	depends on SERIAL_JZ47XX_UART0
+
+config SERIAL_JZ47XX_UART1
+	bool "enable uart1"
+	depends on SERIAL_JZ47XX_UART=y
+config SERIAL_JZ47XX_UART1_DMA
+	bool "enable uart1 dma mode"
+	depends on SERIAL_JZ47XX_UART1
+
+config SERIAL_JZ47XX_UART2
+	bool "enable uart2"
+	depends on SERIAL_JZ47XX_UART=y
+config SERIAL_JZ47XX_UART2_DMA
+	bool "enable uart2 dma mode"
+	depends on SERIAL_JZ47XX_UART2
+
+config SERIAL_JZ47XX_UART3
+	bool "enable uart3"
+	depends on SERIAL_JZ47XX_UART=y
+config SERIAL_JZ47XX_UART3_DMA
+	bool "enable uart3 dma mode"
+	depends on SERIAL_JZ47XX_UART3
+
+config SERIAL_JZ47XX_UART4
+	bool "enable uart4"
+	depends on SERIAL_JZ47XX_UART=y
+config SERIAL_JZ47XX_UART4_DMA
+	bool "enable uart4 dma mode"
+	depends on SERIAL_JZ47XX_UART4
+choice
+	prompt "JZ SERIAL GPIO function pins select"
+	depends on SERIAL_JZ47XX_UART4
+	default SERIAL_JZ47XX_UART4_PB
+config SERIAL_JZ47XX_UART4_PB
+	bool "GPIO B"
+config SERIAL_JZ47XX_UART4_PF
+	bool "GPIO F"
+endchoice
+
 endmenu
 
 endif # TTY
diff -ur ./drivers/tty/serial/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/Makefile
--- ./drivers/tty/serial/Makefile	2023-04-26 12:56:07.680118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/Makefile	2023-04-23 12:06:27.070160600 +0100
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_SERIAL_CORE) += serial_core.o
 obj-$(CONFIG_SERIAL_21285) += 21285.o
+obj-$(CONFIG_SERIAL_JZ47XX_UART) += jz_uart.o
 
 # These Sparc drivers have to appear before others such as 8250
 # which share ttySx minor node space.  Otherwise console device
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial: jz_uart.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial: jz_uart.h
diff -ur ./drivers/tty/serial/serial_core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/serial_core.c
--- ./drivers/tty/serial/serial_core.c	2023-04-26 12:56:07.690118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/tty/serial/serial_core.c	2023-04-23 12:06:28.676517600 +0100
@@ -56,6 +56,16 @@
 #define uart_console(port)	(0)
 #endif
 
+//#define BT_BLUEDROID_SUPPORT
+
+//Add policy for broadcom bluetooth bluesleep by android4.3 begin
+#ifdef CONFIG_BT_BLUEDROID_SUPPORT
+extern void bluesleep_outgoing_data(void);
+extern void bluesleep_uart_open(struct uart_port *uport);
+extern void bluesleep_uart_close(struct uart_port *uport);
+extern int 	bluesleep_tty_strcmp(const char*);
+#endif
+//Add policy for broadcom bluetooth bluesleep by android4.3 end
 static void uart_change_speed(struct tty_struct *tty, struct uart_state *state,
 					struct ktermios *old_termios);
 static void uart_wait_until_sent(struct tty_struct *tty, int timeout);
@@ -95,6 +105,9 @@
 	struct uart_state *state = tty->driver_data;
 	struct uart_port *port = state->uart_port;
 
+	if (port->ops->wake_peer)
+		port->ops->wake_peer(port);
+
 	if (!uart_circ_empty(&state->xmit) && state->xmit.buf &&
 	    !tty->stopped && !tty->hw_stopped)
 		port->ops->start_tx(port);
@@ -511,6 +524,12 @@
 		return -EL3HLT;
 	}
 
+//Add policy for broadcom bluetooth bluesleep by android4.3 begin
+#ifdef CONFIG_BT_BLUEDROID_SUPPORT
+	if(!bluesleep_tty_strcmp(tty->name))
+		bluesleep_outgoing_data();
+#endif
+//Add policy for broadcom bluetooth bluesleep by android4.3 end
 	port = state->uart_port;
 	circ = &state->xmit;
 
@@ -1327,6 +1346,13 @@
 
 	pr_debug("uart_close(%d) called\n", uport->line);
 
+//Add policy for broadcom bluetooth bluesleep by android4.3 begin
+#ifdef CONFIG_BT_BLUEDROID_SUPPORT
+	if(!bluesleep_tty_strcmp(tty->name))
+		bluesleep_uart_close(state->uart_port);
+#endif
+//Add policy for broadcom bluetooth bluesleep by android4.3 end
+
 	if (tty_port_close_start(port, tty, filp) == 0)
 		return;
 
@@ -1593,6 +1619,14 @@
 	if (retval == 0)
 		retval = tty_port_block_til_ready(port, tty, filp);
 
+//Add policy for broadcom bluetooth bluesleep by android4.3 begin
+#ifdef CONFIG_BT_BLUEDROID_SUPPORT
+	if(!bluesleep_tty_strcmp(tty->name)){
+		bluesleep_uart_open(state->uart_port);
+	}
+#endif
+//Add policy for broadcom bluetooth bluesleep by android4.3 end
+//
 end:
 	return retval;
 err_dec_count:
diff -ur ./drivers/usb/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/Kconfig
--- ./drivers/usb/Kconfig	2023-04-26 12:56:07.720118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/Kconfig	2023-04-23 12:06:30.099990600 +0100
@@ -25,6 +25,7 @@
 	# MIPS:
 	default y if MIPS_ALCHEMY
 	default y if MACH_JZ4740
+	default y if MACH_XBURST
 	# more:
 	default PCI
 
@@ -96,7 +97,7 @@
 	  traditional PC serial port.  The bus supplies power to peripherals
 	  and allows for hot swapping.  Up to 127 USB peripherals can be
 	  connected to a single USB host in a tree structure.
-	  
+
 	  The USB host is the root of the tree, the peripherals are the
 	  leaves and the inner nodes are special USB devices called hubs.
 	  Most PCs now have USB host ports, used to connect peripherals
@@ -144,6 +145,8 @@
 
 endif
 
+source "drivers/usb/dwc2/Kconfig"
+
 source "drivers/usb/dwc3/Kconfig"
 
 source "drivers/usb/chipidea/Kconfig"
diff -ur ./drivers/usb/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/Makefile
--- ./drivers/usb/Makefile	2023-04-26 12:56:07.720118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/Makefile	2023-04-23 12:06:30.099591600 +0100
@@ -7,6 +7,7 @@
 obj-$(CONFIG_USB)		+= core/
 
 obj-$(CONFIG_USB_DWC3)		+= dwc3/
+obj-$(CONFIG_USB_JZ_DWC2)		+= dwc2/
 
 obj-$(CONFIG_USB_MON)		+= mon/
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb: dwc2
diff -ur ./drivers/usb/gadget/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/Kconfig
--- ./drivers/usb/gadget/Kconfig	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/Kconfig	2023-04-23 12:06:32.021493900 +0100
@@ -271,7 +271,7 @@
 
 config USB_S3C_HSOTG
 	tristate "S3C HS/OtG USB Device controller"
-	depends on S3C_DEV_USB_HSOTG
+	depends on PLAT_SAMSUNG
 	help
 	  The Samsung S3C64XX USB2.0 high-speed gadget controller
 	  integrated into the S3C64XX series SoC.
@@ -507,12 +507,39 @@
 config USB_U_SERIAL
 	tristate
 
+config USB_U_ETHER
+	tristate
+
 config USB_F_SERIAL
 	tristate
 
 config USB_F_OBEX
 	tristate
 
+config USB_F_NCM
+	tristate
+
+config USB_F_ECM
+	tristate
+
+config USB_F_PHONET
+	tristate
+
+config USB_F_EEM
+	tristate
+
+config USB_F_SUBSET
+	tristate
+
+config USB_F_RNDIS
+	tristate
+
+config USB_F_MASS_STORAGE
+	tristate
+
+config USB_F_FS
+	tristate
+
 choice
 	tristate "USB Gadget Drivers"
 	default USB_ETH
@@ -534,6 +561,157 @@
 
 # this first set of drivers all depend on bulk-capable hardware.
 
+config USB_CONFIGFS
+	tristate "USB functions configurable through configfs"
+	select USB_LIBCOMPOSITE
+	help
+	  A Linux USB "gadget" can be set up through configfs.
+	  If this is the case, the USB functions (which from the host's
+	  perspective are seen as interfaces) and configurations are
+	  specified simply by creating appropriate directories in configfs.
+	  Associating functions with configurations is done by creating
+	  appropriate symbolic links.
+	  For more information see Documentation/usb/gadget-configfs.txt.
+
+config USB_CONFIGFS_SERIAL
+	boolean "Generic serial bulk in/out"
+	depends on USB_CONFIGFS
+	depends on TTY
+	select USB_U_SERIAL
+	select USB_F_SERIAL
+	help
+	  The function talks to the Linux-USB generic serial driver.
+
+config USB_CONFIGFS_ACM
+	boolean "Abstract Control Model (CDC ACM)"
+	depends on USB_CONFIGFS
+	depends on TTY
+	select USB_U_SERIAL
+	select USB_F_ACM
+	help
+	  ACM serial link.  This function can be used to interoperate with
+	  MS-Windows hosts or with the Linux-USB "cdc-acm" driver.
+
+config USB_CONFIGFS_OBEX
+	boolean "Object Exchange Model (CDC OBEX)"
+	depends on USB_CONFIGFS
+	depends on TTY
+	select USB_U_SERIAL
+	select USB_F_OBEX
+	help
+	  You will need a user space OBEX server talking to /dev/ttyGS*,
+	  since the kernel itself doesn't implement the OBEX protocol.
+
+config USB_CONFIGFS_NCM
+	boolean "Network Control Model (CDC NCM)"
+	depends on USB_CONFIGFS
+	depends on NET
+	select USB_U_ETHER
+	select USB_F_NCM
+	help
+	  NCM is an advanced protocol for Ethernet encapsulation, allows
+	  grouping of several ethernet frames into one USB transfer and
+	  different alignment possibilities.
+
+config USB_CONFIGFS_ECM
+	boolean "Ethernet Control Model (CDC ECM)"
+	depends on USB_CONFIGFS
+	depends on NET
+	select USB_U_ETHER
+	select USB_F_ECM
+	help
+	  The "Communication Device Class" (CDC) Ethernet Control Model.
+	  That protocol is often avoided with pure Ethernet adapters, in
+	  favor of simpler vendor-specific hardware, but is widely
+	  supported by firmware for smart network devices.
+
+config USB_CONFIGFS_ECM_SUBSET
+	boolean "Ethernet Control Model (CDC ECM) subset"
+	depends on USB_CONFIGFS
+	depends on NET
+	select USB_U_ETHER
+	select USB_F_SUBSET
+	help
+	  On hardware that can't implement the full protocol,
+	  a simple CDC subset is used, placing fewer demands on USB.
+
+config USB_CONFIGFS_RNDIS
+	bool "RNDIS"
+	depends on USB_CONFIGFS
+	depends on NET
+	select USB_U_ETHER
+	select USB_F_RNDIS
+	help
+	   Microsoft Windows XP bundles the "Remote NDIS" (RNDIS) protocol,
+	   and Microsoft provides redistributable binary RNDIS drivers for
+	   older versions of Windows.
+
+	   To make MS-Windows work with this, use Documentation/usb/linux.inf
+	   as the "driver info file".  For versions of MS-Windows older than
+	   XP, you'll need to download drivers from Microsoft's website; a URL
+	   is given in comments found in that info file.
+
+config USB_CONFIGFS_EEM
+	bool "Ethernet Emulation Model (EEM)"
+	depends on USB_CONFIGFS
+	depends on NET
+	select USB_U_ETHER
+	select USB_F_EEM
+	help
+	  CDC EEM is a newer USB standard that is somewhat simpler than CDC ECM
+	  and therefore can be supported by more hardware.  Technically ECM and
+	  EEM are designed for different applications.  The ECM model extends
+	  the network interface to the target (e.g. a USB cable modem), and the
+	  EEM model is for mobile devices to communicate with hosts using
+	  ethernet over USB.  For Linux gadgets, however, the interface with
+	  the host is the same (a usbX device), so the differences are minimal.
+
+config USB_CONFIGFS_PHONET
+	boolean "Phonet protocol"
+	depends on USB_CONFIGFS
+	depends on NET
+	depends on PHONET
+	select USB_U_ETHER
+	select USB_F_PHONET
+	help
+	  The Phonet protocol implementation for USB device.
+
+config USB_CONFIGFS_MASS_STORAGE
+	boolean "Mass storage"
+	depends on USB_CONFIGFS
+	depends on BLOCK
+	select USB_F_MASS_STORAGE
+	help
+	  The Mass Storage Gadget acts as a USB Mass Storage disk drive.
+	  As its storage repository it can use a regular file or a block
+	  device (in much the same way as the "loop" device driver),
+	  specified as a module parameter or sysfs option.
+
+config USB_CONFIGFS_F_LB_SS
+	boolean "Loopback and sourcesink function (for testing)"
+	depends on USB_CONFIGFS
+	select USB_F_SS_LB
+	help
+	  Loopback function loops back a configurable number of transfers.
+	  Sourcesink function either sinks and sources bulk data.
+	  It also implements control requests, for "chapter 9" conformance.
+	  Make this be the first driver you try using on top of any new
+	  USB peripheral controller driver.  Then you can use host-side
+	  test software, like the "usbtest" driver, to put your hardware
+	  and its driver through a basic set of functional tests.
+
+config USB_CONFIGFS_F_FS
+	boolean "Function filesystem (FunctionFS)"
+	depends on USB_CONFIGFS
+	select USB_F_FS
+	help
+	  The Function Filesystem (FunctionFS) lets one create USB
+	  composite functions in user space in the same way GadgetFS
+	  lets one create USB gadgets in user space.  This allows creation
+	  of composite gadgets such that some of the functions are
+	  implemented in kernel space (for instance Ethernet, serial or
+	  mass storage) and other are implemented in user space.
+
 config USB_ZERO
 	tristate "Gadget Zero (DEVELOPMENT)"
 	select USB_LIBCOMPOSITE
@@ -603,11 +781,14 @@
 	tristate "Ethernet Gadget (with CDC Ethernet support)"
 	depends on NET
 	select USB_LIBCOMPOSITE
+	select USB_U_ETHER
+	select USB_F_ECM
+	select USB_F_SUBSET
 	select CRC32
 	help
 	  This driver implements Ethernet style communication, in one of
 	  several ways:
-	  
+
 	   - The "Communication Device Class" (CDC) Ethernet Control Model.
 	     That protocol is often avoided with pure Ethernet adapters, in
 	     favor of simpler vendor-specific hardware, but is widely
@@ -639,6 +820,7 @@
 	bool "RNDIS support"
 	depends on USB_ETH
 	select USB_LIBCOMPOSITE
+	select USB_F_RNDIS
 	default y
 	help
 	   Microsoft Windows XP bundles the "Remote NDIS" (RNDIS) protocol,
@@ -648,7 +830,7 @@
 	   If you say "y" here, the Ethernet gadget driver will try to provide
 	   a second device configuration, supporting RNDIS to talk to such
 	   Microsoft USB hosts.
-	   
+
 	   To make MS-Windows work with this, use Documentation/usb/linux.inf
 	   as the "driver info file".  For versions of MS-Windows older than
 	   XP, you'll need to download drivers from Microsoft's website; a URL
@@ -658,6 +840,7 @@
        bool "Ethernet Emulation Model (EEM) support"
        depends on USB_ETH
 	select USB_LIBCOMPOSITE
+	select USB_F_EEM
        default n
        help
          CDC EEM is a newer USB standard that is somewhat simpler than CDC ECM
@@ -675,6 +858,8 @@
 	tristate "Network Control Model (NCM) support"
 	depends on NET
 	select USB_LIBCOMPOSITE
+	select USB_U_ETHER
+	select USB_F_NCM
 	select CRC32
 	help
 	  This driver implements USB CDC NCM subclass standard. NCM is
@@ -700,6 +885,7 @@
 config USB_FUNCTIONFS
 	tristate "Function Filesystem"
 	select USB_LIBCOMPOSITE
+	select USB_F_FS
 	select USB_FUNCTIONFS_GENERIC if !(USB_FUNCTIONFS_ETH || USB_FUNCTIONFS_RNDIS)
 	help
 	  The Function Filesystem (FunctionFS) lets one create USB
@@ -718,6 +904,9 @@
 config USB_FUNCTIONFS_ETH
 	bool "Include configuration with CDC ECM (Ethernet)"
 	depends on USB_FUNCTIONFS && NET
+	select USB_U_ETHER
+	select USB_F_ECM
+	select USB_F_SUBSET
 	help
 	  Include a configuration with CDC ECM function (Ethernet) and the
 	  Function Filesystem.
@@ -725,6 +914,8 @@
 config USB_FUNCTIONFS_RNDIS
 	bool "Include configuration with RNDIS (Ethernet)"
 	depends on USB_FUNCTIONFS && NET
+	select USB_U_ETHER
+	select USB_F_RNDIS
 	help
 	  Include a configuration with RNDIS function (Ethernet) and the Filesystem.
 
@@ -739,6 +930,7 @@
 	tristate "Mass Storage Gadget"
 	depends on BLOCK
 	select USB_LIBCOMPOSITE
+	select USB_F_MASS_STORAGE
 	help
 	  The Mass Storage Gadget acts as a USB Mass Storage disk drive.
 	  As its storage repository it can use a regular file or a block
@@ -818,6 +1010,78 @@
 	  For more information, see Documentation/usb/gadget_printer.txt
 	  which includes sample code for accessing the device file.
 
+config USB_G_SLP
+	boolean "SLP Gadget based on Android"
+	select USB_F_ACM
+	select USB_LIBCOMPOSITE
+	select USB_U_SERIAL
+	help
+	  The SLP gadget driver supports multiple USB functions.
+	  The functions can be configured via a board file and may be
+	  enabled and disabled dynamically.
+	  Support functions: sdb, acm, mtp, mass storage, rndis,
+	  android accessory(AOA 1.0 only), diag.
+
+config USB_G_ANDROID
+	boolean "Android Composite Gadget"
+	select USB_F_ACM
+	select USB_LIBCOMPOSITE
+	select USB_U_SERIAL
+	select USB_U_ETHER
+	select USB_F_ECM
+
+	help
+	  The Android Composite Gadget supports multiple USB
+	  functions: adb, acm, mass storage, mtp, accessory
+	  and rndis.
+	  Each function can be configured and enabled/disabled
+	  dynamically from userspace through a sysfs interface.
+config USB_ANDROID_SAMSUNG_COMPOSITE
+	boolean "Samsung Composite function"
+	depends on USB_G_ANDROID
+	help
+	  Provides SAMSUNG composite driver.
+	  It also provides KIES connection and
+	  Multi Configuration.
+	  If you enable this option, android composite will be changed.
+
+config USB_ANDROID_SAMSUNG_MTP
+	boolean "Samsung MTP function"
+	depends on USB_G_ANDROID && !SEC_FACTORY
+	help
+	  Provides Media Transfer Protocol (MTP) support
+	  for samsung gadget driver.
+	  If you enable this option,
+	  google mtp will be changed to samsung mtp.
+
+config USB_DUN_SUPPORT
+	boolean "DUN support function"
+	depends on USB_G_ANDROID
+	help
+	  Provides USB modem serial driver.
+	  This function makes connection to acm from data router.
+	  It uses misc register.
+	  Support fops : open, close, release, read, poll, llseek, ioctl
+
+config USB_ANDROID_RNDIS_DWORD_ALIGNED
+	boolean "Use double word aligned"
+	depends on USB_G_ANDROID
+	help
+		Provides dword aligned for DMA controller.
+
+config USB_ANDROID_HID
+	boolean "Use hid in android"
+	depends on USB_G_ANDROID
+	help
+		Enable hid function in android
+
+config USB_ANDROID_WEBCAM
+	boolean "Use webcam in android"
+	depends on USB_G_ANDROID
+	help
+		Enable webcam function in android
+
+
 if TTY
 
 config USB_CDC_COMPOSITE
@@ -825,7 +1089,9 @@
 	depends on NET
 	select USB_LIBCOMPOSITE
 	select USB_U_SERIAL
+	select USB_U_ETHER
 	select USB_F_ACM
+	select USB_F_ECM
 	help
 	  This driver provides two functions in one configuration:
 	  a CDC Ethernet (ECM) link, and a CDC ACM (serial port) link.
@@ -842,7 +1108,11 @@
 	depends on PHONET
 	select USB_LIBCOMPOSITE
 	select USB_U_SERIAL
+	select USB_U_ETHER
 	select USB_F_ACM
+	select USB_F_OBEX
+	select USB_F_PHONET
+	select USB_F_ECM
 	help
 	  The Nokia composite gadget provides support for acm, obex
 	  and phonet in only one composite gadget driver.
@@ -856,6 +1126,7 @@
 	select USB_LIBCOMPOSITE
 	select USB_U_SERIAL
 	select USB_F_ACM
+	select USB_F_MASS_STORAGE
 	help
 	  This driver provides two functions in one configuration:
 	  a mass storage, and a CDC ACM (serial port) link.
@@ -869,7 +1140,9 @@
 	select USB_G_MULTI_CDC if !USB_G_MULTI_RNDIS
 	select USB_LIBCOMPOSITE
 	select USB_U_SERIAL
+	select USB_U_ETHER
 	select USB_F_ACM
+	select USB_F_MASS_STORAGE
 	help
 	  The Multifunction Composite Gadget provides Ethernet (RNDIS
 	  and/or CDC Ethernet), mass storage and ACM serial link
@@ -888,6 +1161,7 @@
 config USB_G_MULTI_RNDIS
 	bool "RNDIS + CDC Serial + Storage configuration"
 	depends on USB_G_MULTI
+	select USB_F_RNDIS
 	default y
 	help
 	  This option enables a configuration with RNDIS, CDC Serial and
@@ -901,6 +1175,7 @@
 	bool "CDC Ethernet + CDC Serial + Storage configuration"
 	depends on USB_G_MULTI
 	default n
+	select USB_F_ECM
 	help
 	  This option enables a configuration with CDC Ethernet (ECM), CDC
 	  Serial and Mass Storage functions available in the Multifunction
@@ -972,4 +1247,33 @@
 
 endchoice
 
+
+menu "USB audio choice"
+        depends on GADGET_UAC1
+
+config GADGET_UAC1_PLAY
+	tristate "USB audio play"
+	default y
+
+config GADGET_UAC1_CAP
+        default y
+	tristate "USB audio cap"
+
+
+choice
+        prompt "cap from"
+	default MIC
+	depends on GADGET_UAC1_CAP
+
+config GADGET_UAC1_CAP_USER
+        bool "cap from user"
+
+config GADGET_UAC1_CAP_MIC
+	bool "cap from mic"
+
+endchoice
+endmenu
+
+
+
 endif # USB_GADGET
diff -ur ./drivers/usb/gadget/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/Makefile
--- ./drivers/usb/gadget/Makefile	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/Makefile	2023-04-23 12:06:32.020726500 +0100
@@ -6,7 +6,7 @@
 obj-$(CONFIG_USB_GADGET)	+= udc-core.o
 obj-$(CONFIG_USB_LIBCOMPOSITE)	+= libcomposite.o
 libcomposite-y			:= usbstring.o config.o epautoconf.o
-libcomposite-y			+= composite.o functions.o configfs.o
+libcomposite-y			+= composite.o functions.o configfs.o u_f.o
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2272)	+= net2272.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
@@ -45,6 +45,23 @@
 obj-$(CONFIG_USB_F_SERIAL)	+= usb_f_serial.o
 usb_f_obex-y			:= f_obex.o
 obj-$(CONFIG_USB_F_OBEX)	+= usb_f_obex.o
+obj-$(CONFIG_USB_U_ETHER)	+= u_ether.o
+usb_f_ncm-y			:= f_ncm.o
+obj-$(CONFIG_USB_F_NCM)		+= usb_f_ncm.o
+usb_f_ecm-y			:= f_ecm.o
+obj-$(CONFIG_USB_F_ECM)		+= usb_f_ecm.o
+usb_f_phonet-y			:= f_phonet.o
+obj-$(CONFIG_USB_F_PHONET)	+= usb_f_phonet.o
+usb_f_eem-y			:= f_eem.o
+obj-$(CONFIG_USB_F_EEM)		+= usb_f_eem.o
+usb_f_ecm_subset-y		:= f_subset.o
+obj-$(CONFIG_USB_F_SUBSET)	+= usb_f_ecm_subset.o
+usb_f_rndis-y			:= f_rndis.o rndis.o
+obj-$(CONFIG_USB_F_RNDIS)	+= usb_f_rndis.o
+usb_f_mass_storage-y		:= f_mass_storage.o
+obj-$(CONFIG_USB_F_MASS_STORAGE)+= usb_f_mass_storage.o
+usb_f_fs-y			:= f_fs.o
+obj-$(CONFIG_USB_F_FS)		+= usb_f_fs.o
 
 #
 # USB gadget drivers
@@ -65,7 +82,9 @@
 g_webcam-y			:= webcam.o
 g_ncm-y				:= ncm.o
 g_acm_ms-y			:= acm_ms.o
+g_android-y			:= android.o
 g_tcm_usb_gadget-y		:= tcm_usb_gadget.o
+g_slp-y				:= slp.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
@@ -84,4 +103,7 @@
 obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
+obj-$(CONFIG_USB_G_ANDROID)	+= g_android.o
 obj-$(CONFIG_USB_GADGET_TARGET)	+= tcm_usb_gadget.o
+obj-$(CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE)	+= multi_config.o
+obj-$(CONFIG_USB_G_SLP)		+= g_slp.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: android.c
diff -ur ./drivers/usb/gadget/cdc2.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/cdc2.c
--- ./drivers/usb/gadget/cdc2.c	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/cdc2.c	2023-04-23 12:06:32.268297600 +0100
@@ -42,9 +42,6 @@
  * the runtime footprint, and giving us at least some parts of what
  * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
  */
-#include "f_ecm.c"
-#include "u_ether.c"
-
 /*-------------------------------------------------------------------------*/
 
 static struct usb_device_descriptor device_desc = {
@@ -102,12 +99,12 @@
 	NULL,
 };
 
-static u8 hostaddr[ETH_ALEN];
-static struct eth_dev *the_dev;
 /*-------------------------------------------------------------------------*/
+static struct usb_function *f_ecm;
+static struct usb_function_instance *fi_ethernet;
+
 static struct usb_function *f_acm;
 static struct usb_function_instance *fi_serial;
-
 /*
  * We _always_ have both CDC ECM and CDC ACM functions.
  */
@@ -120,28 +117,50 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	status = ecm_bind_config(c, hostaddr, the_dev);
-	if (status < 0)
-		return status;
+	fi_ethernet = usb_get_function_instance("ecm");
+	if (IS_ERR(fi_ethernet))
+		return PTR_ERR(fi_ethernet);
+
+	f_ecm = usb_get_function(fi_ethernet);
+	if (IS_ERR(f_ecm)) {
+		status = PTR_ERR(f_ecm);
+		goto err_ecm_func;
+	}
 
-	fi_serial = usb_get_function_instance("acm");
+	status = usb_add_function(c, f_ecm);
+	if (status)
+		goto err_ecm_conf;
+
+
+	/**********************ACM*************/
+	fi_serial=usb_get_function_instance("acm");
 	if (IS_ERR(fi_serial))
 		return PTR_ERR(fi_serial);
 
 	f_acm = usb_get_function(fi_serial);
 	if (IS_ERR(f_acm)) {
 		status = PTR_ERR(f_acm);
-		goto err_func_acm;
+		goto err_acm_func;
 	}
 
 	status = usb_add_function(c, f_acm);
 	if (status)
-		goto err_conf;
+		goto err_acm_conf;
+
 	return 0;
-err_conf:
+
+
+err_acm_conf:
 	usb_put_function(f_acm);
-err_func_acm:
+
+err_acm_func:
 	usb_put_function_instance(fi_serial);
+
+err_ecm_conf:
+	usb_put_function(f_ecm);
+
+err_ecm_func:
+	usb_put_function_instance(fi_ethernet);
 	return status;
 }
 
@@ -165,11 +184,6 @@
 		return -EINVAL;
 	}
 
-	/* set up network link layer */
-	the_dev = gether_setup(cdev->gadget, hostaddr);
-	if (IS_ERR(the_dev))
-		return PTR_ERR(the_dev);
-
 	/* Allocate string descriptor numbers ... note that string
 	 * contents can be overridden by the composite_dev glue.
 	 */
@@ -192,15 +206,17 @@
 	return 0;
 
 fail1:
-	gether_cleanup(the_dev);
 	return status;
 }
 
 static int __exit cdc_unbind(struct usb_composite_dev *cdev)
 {
+	usb_put_function(f_ecm);
+	usb_put_function_instance(fi_ethernet);
+
 	usb_put_function(f_acm);
 	usb_put_function_instance(fi_serial);
-	gether_cleanup(the_dev);
+
 	return 0;
 }
 
diff -ur ./drivers/usb/gadget/composite.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/composite.c
--- ./drivers/usb/gadget/composite.c	2023-04-26 12:26:20.640132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/composite.c	2023-04-23 12:06:32.342690500 +0100
@@ -125,7 +125,17 @@
 
 ep_found:
 	/* commit results */
-	_ep->maxpacket = usb_endpoint_maxp(chosen_desc);
+	switch (chosen_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_ISOC:
+	case USB_ENDPOINT_XFER_INT:
+		_ep->maxpacket = (usb_endpoint_maxp(chosen_desc) & 0x7ff) *
+			(((usb_endpoint_maxp(chosen_desc) >> 11) & 0x3) + 1);
+		if (!want_comp_desc)
+			break;
+	default:
+		_ep->maxpacket = (usb_endpoint_maxp(chosen_desc) & 0x7ff);
+		break;
+	}
 	_ep->desc = chosen_desc;
 	_ep->comp_desc = NULL;
 	_ep->maxburst = 0;
@@ -593,6 +603,7 @@
 		bitmap_zero(f->endpoints, 32);
 	}
 	cdev->config = NULL;
+	cdev->delayed_status = 0;
 }
 
 static int set_config(struct usb_composite_dev *cdev,
@@ -1451,8 +1462,22 @@
 			struct usb_configuration	*c;
 
 			c = cdev->config;
-			if (c && c->setup)
+			if (!c)
+				goto done;
+
+			/* try current config's setup */
+			if (c->setup) {
 				value = c->setup(c, ctrl);
+				goto done;
+			}
+
+			/* try the only function in the current config */
+			if (!list_is_singular(&c->functions))
+				goto done;
+			f = list_first_entry(&c->functions, struct usb_function,
+					     list);
+			if (f->setup)
+				value = f->setup(f, ctrl);
 		}
 
 		goto done;
@@ -1476,6 +1501,11 @@
 
 done:
 	/* device either stalls (value < 0) or reports success */
+	if (value < 0) {
+		printk("control error %d req%02x.%02x v%04x i%04x l%d\n", value,
+				ctrl->bRequestType, ctrl->bRequest,
+				w_value, w_index, w_length);
+	}
 	return value;
 }
 
@@ -1497,8 +1527,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-static ssize_t composite_show_suspended(struct device *dev,
-					struct device_attribute *attr,
+static ssize_t suspended_show(struct device *dev, struct device_attribute *attr,
 					char *buf)
 {
 	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
@@ -1506,8 +1535,7 @@
 
 	return sprintf(buf, "%d\n", cdev->suspended);
 }
-
-static DEVICE_ATTR(suspended, 0444, composite_show_suspended, NULL);
+static DEVICE_ATTR_RO(suspended);
 
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
@@ -1715,7 +1743,7 @@
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	struct usb_function		*f;
-	u8				maxpower;
+	u16				maxpower;
 
 	/* REVISIT:  should we have config level
 	 * suspend/resume callbacks?
diff -ur ./drivers/usb/gadget/configfs.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/configfs.c
--- ./drivers/usb/gadget/configfs.c	2023-04-26 12:26:20.640132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/configfs.c	2023-04-23 12:06:32.341702200 +0100
@@ -557,13 +557,20 @@
 
 	fi = usb_get_function_instance(func_name);
 	if (IS_ERR(fi))
-		return ERR_PTR(PTR_ERR(fi));
+		return ERR_CAST(fi);
 
 	ret = config_item_set_name(&fi->group.cg_item, name);
 	if (ret) {
 		usb_put_function_instance(fi);
 		return ERR_PTR(ret);
 	}
+	if (fi->set_inst_name) {
+		ret = fi->set_inst_name(fi, instance_name);
+		if (ret) {
+			usb_put_function_instance(fi);
+			return ERR_PTR(ret);
+		}
+	}
 
 	gi = container_of(group, struct gadget_info, functions_group);
 
@@ -859,8 +866,10 @@
 		list_for_each_entry_safe(f, tmp, &cfg->func_list, list) {
 			list_del(&f->list);
 			ret = usb_add_function(c, f);
-			if (ret)
+			if (ret) {
+				list_add(&f->list, &cfg->func_list);
 				goto err_purge_funcs;
+			}
 		}
 		usb_ep_autoconfig_reset(cdev->gadget);
 	}
@@ -989,6 +998,14 @@
 	.su_mutex = __MUTEX_INITIALIZER(gadget_subsys.su_mutex),
 };
 
+void unregister_gadget_item(struct config_item *item)
+{
+	struct gadget_info *gi = to_gadget_info(item);
+
+	unregister_gadget(gi);
+}
+EXPORT_SYMBOL(unregister_gadget_item);
+
 static int __init gadget_cfs_init(void)
 {
 	int ret;
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: configfs.h
diff -ur ./drivers/usb/gadget/epautoconf.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/epautoconf.c
--- ./drivers/usb/gadget/epautoconf.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/epautoconf.c	2023-04-23 12:06:32.420288000 +0100
@@ -129,7 +129,7 @@
 	 * and wants to know the maximum possible, provide the info.
 	 */
 	if (desc->wMaxPacketSize == 0)
-		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket);
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
 
 	/* endpoint maxpacket size is an input parameter, except for bulk
 	 * where it's an output parameter representing the full speed limit.
@@ -145,7 +145,7 @@
 
 	case USB_ENDPOINT_XFER_ISOC:
 		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
-		if (ep->maxpacket < max)
+		if ((ep->maxpacket_limit & 0x7ff) < max)
 			return 0;
 		if (!gadget_is_dualspeed(gadget) && max > 1023)
 			return 0;
@@ -157,6 +157,8 @@
 			/* configure your hardware with enough buffering!! */
 		}
 		break;
+	default:
+		desc->wMaxPacketSize &= ~cpu_to_le16((3 << 11));
 	}
 
 	/* MATCH!! */
@@ -176,10 +178,9 @@
 		desc->bEndpointAddress |= gadget->out_epnum;
 	}
 
-	/* report (variable) full speed bulk maxpacket */
+	/* report (variable) full speed bulk maxpacket_limit */
 	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
-		int size = ep->maxpacket;
-
+		int size = ep->maxpacket_limit & 0x7ff;
 		/* min() doesn't work on bitfields with gcc-3.5 */
 		if (size > 64)
 			size = 64;
@@ -301,6 +302,18 @@
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 #endif
+	} else if (gadget_is_dwc2(gadget) && (USB_ENDPOINT_XFER_ISOC == type)) {
+		if ((USB_DIR_IN & desc->bEndpointAddress) &&
+				((usb_endpoint_maxp(desc) >> 11) & 0x3) > 0) {
+			list_for_each_entry_reverse(ep, &gadget->ep_list, ep_list) {
+				if (ep_matches(gadget, ep, desc, ep_comp)) {
+					if (!(cpu_to_le16(ep->maxpacket_limit) & (0x3 << 11)))
+						desc->wMaxPacketSize &= ~(0x3 << 11);
+					goto found_ep;
+				}
+			}
+			return NULL;
+		}
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
diff -ur ./drivers/usb/gadget/ether.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/ether.c
--- ./drivers/usb/gadget/ether.c	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/ether.c	2023-04-23 12:06:32.419812600 +0100
@@ -14,6 +14,7 @@
 /* #define VERBOSE_DEBUG */
 
 #include <linux/kernel.h>
+#include <linux/netdevice.h>
 
 #if defined USB_ETH_RNDIS
 #  undef USB_ETH_RNDIS
@@ -91,27 +92,23 @@
 #endif
 }
 
-/*-------------------------------------------------------------------------*/
+#include <linux/module.h>
 
-/*
- * Kbuild is not very cooperative with respect to linking separately
- * compiled library objects into one module.  So for now we won't use
- * separate compilation ... ensuring init/exit sections work to shrink
- * the runtime footprint, and giving us at least some parts of what
- * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
- */
-#include "f_ecm.c"
-#include "f_subset.c"
+#include "u_ecm.h"
+#include "u_gether.h"
 #ifdef	USB_ETH_RNDIS
-#include "f_rndis.c"
-#include "rndis.c"
+#include "u_rndis.h"
+#include "rndis.h"
+#else
+#define rndis_borrow_net(...) do {} while (0)
 #endif
-#include "f_eem.c"
-#include "u_ether.c"
+#include "u_eem.h"
 
 /*-------------------------------------------------------------------------*/
 USB_GADGET_COMPOSITE_OPTIONS();
 
+USB_ETHERNET_MODULE_PARAMETERS();
+
 /* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
@@ -206,8 +203,18 @@
 	NULL,
 };
 
-static u8 hostaddr[ETH_ALEN];
-static struct eth_dev *the_dev;
+static struct usb_function_instance *fi_ecm;
+static struct usb_function *f_ecm;
+
+static struct usb_function_instance *fi_eem;
+static struct usb_function *f_eem;
+
+static struct usb_function_instance *fi_geth;
+static struct usb_function *f_geth;
+
+static struct usb_function_instance *fi_rndis;
+static struct usb_function *f_rndis;
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -217,6 +224,8 @@
  */
 static int __init rndis_do_config(struct usb_configuration *c)
 {
+	int status;
+
 	/* FIXME alloc iConfiguration string, set it in c->strings */
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -224,7 +233,15 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	return rndis_bind_config(c, hostaddr, the_dev);
+	f_rndis = usb_get_function(fi_rndis);
+	if (IS_ERR(f_rndis))
+		return PTR_ERR(f_rndis);
+
+	status = usb_add_function(c, f_rndis);
+	if (status < 0)
+		usb_put_function(f_rndis);
+
+	return status;
 }
 
 static struct usb_configuration rndis_config_driver = {
@@ -249,6 +266,8 @@
  */
 static int __init eth_do_config(struct usb_configuration *c)
 {
+	int status = 0;
+
 	/* FIXME alloc iConfiguration string, set it in c->strings */
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -256,12 +275,38 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	if (use_eem)
-		return eem_bind_config(c, the_dev);
-	else if (can_support_ecm(c->cdev->gadget))
-		return ecm_bind_config(c, hostaddr, the_dev);
-	else
-		return geth_bind_config(c, hostaddr, the_dev);
+	if (use_eem) {
+		f_eem = usb_get_function(fi_eem);
+		if (IS_ERR(f_eem))
+			return PTR_ERR(f_eem);
+
+		status = usb_add_function(c, f_eem);
+		if (status < 0)
+			usb_put_function(f_eem);
+
+		return status;
+	} else if (can_support_ecm(c->cdev->gadget)) {
+		f_ecm = usb_get_function(fi_ecm);
+		if (IS_ERR(f_ecm))
+			return PTR_ERR(f_ecm);
+
+		status = usb_add_function(c, f_ecm);
+		if (status < 0)
+			usb_put_function(f_ecm);
+
+		return status;
+	} else {
+		f_geth = usb_get_function(fi_geth);
+		if (IS_ERR(f_geth))
+			return PTR_ERR(f_geth);
+
+		status = usb_add_function(c, f_geth);
+		if (status < 0)
+			usb_put_function(f_geth);
+
+		return status;
+	}
+
 }
 
 static struct usb_configuration eth_config_driver = {
@@ -276,24 +321,50 @@
 static int __init eth_bind(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget	*gadget = cdev->gadget;
+	struct f_eem_opts	*eem_opts = NULL;
+	struct f_ecm_opts	*ecm_opts = NULL;
+	struct f_gether_opts	*geth_opts = NULL;
+	struct net_device	*net;
 	int			status;
 
-	/* set up network link layer */
-	the_dev = gether_setup(cdev->gadget, hostaddr);
-	if (IS_ERR(the_dev))
-		return PTR_ERR(the_dev);
-
 	/* set up main config label and device descriptor */
 	if (use_eem) {
 		/* EEM */
+		fi_eem = usb_get_function_instance("eem");
+		if (IS_ERR(fi_eem))
+			return PTR_ERR(fi_eem);
+
+		eem_opts = container_of(fi_eem, struct f_eem_opts, func_inst);
+
+		net = eem_opts->net;
+
 		eth_config_driver.label = "CDC Ethernet (EEM)";
 		device_desc.idVendor = cpu_to_le16(EEM_VENDOR_NUM);
 		device_desc.idProduct = cpu_to_le16(EEM_PRODUCT_NUM);
-	} else if (can_support_ecm(cdev->gadget)) {
+	} else if (can_support_ecm(gadget)) {
 		/* ECM */
+
+		fi_ecm = usb_get_function_instance("ecm");
+		if (IS_ERR(fi_ecm))
+			return PTR_ERR(fi_ecm);
+
+		ecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);
+
+		net = ecm_opts->net;
+
 		eth_config_driver.label = "CDC Ethernet (ECM)";
 	} else {
 		/* CDC Subset */
+
+		fi_geth = usb_get_function_instance("geth");
+		if (IS_ERR(fi_geth))
+			return PTR_ERR(fi_geth);
+
+		geth_opts = container_of(fi_geth, struct f_gether_opts,
+					 func_inst);
+
+		net = geth_opts->net;
+
 		eth_config_driver.label = "CDC Subset/SAFE";
 
 		device_desc.idVendor = cpu_to_le16(SIMPLE_VENDOR_NUM);
@@ -302,8 +373,34 @@
 			device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
 	}
 
+	gether_set_qmult(net, qmult);
+	if (!gether_set_host_addr(net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
+
 	if (has_rndis()) {
 		/* RNDIS plus ECM-or-Subset */
+		gether_set_gadget(net, cdev->gadget);
+		status = gether_register_netdev(net);
+		if (status)
+			goto fail;
+
+		if (use_eem)
+			eem_opts->bound = true;
+		else if (can_support_ecm(gadget))
+			ecm_opts->bound = true;
+		else
+			geth_opts->bound = true;
+
+		fi_rndis = usb_get_function_instance("rndis");
+		if (IS_ERR(fi_rndis)) {
+			status = PTR_ERR(fi_rndis);
+			goto fail;
+		}
+
+		rndis_borrow_net(fi_rndis, net);
+
 		device_desc.idVendor = cpu_to_le16(RNDIS_VENDOR_NUM);
 		device_desc.idProduct = cpu_to_le16(RNDIS_PRODUCT_NUM);
 		device_desc.bNumConfigurations = 2;
@@ -315,7 +412,7 @@
 
 	status = usb_string_ids_tab(cdev, strings_dev);
 	if (status < 0)
-		goto fail;
+		goto fail1;
 	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 
@@ -324,12 +421,12 @@
 		status = usb_add_config(cdev, &rndis_config_driver,
 				rndis_do_config);
 		if (status < 0)
-			goto fail;
+			goto fail1;
 	}
 
 	status = usb_add_config(cdev, &eth_config_driver, eth_do_config);
 	if (status < 0)
-		goto fail;
+		goto fail1;
 
 	usb_composite_overwrite_options(cdev, &coverwrite);
 	dev_info(&gadget->dev, "%s, version: " DRIVER_VERSION "\n",
@@ -337,14 +434,35 @@
 
 	return 0;
 
+fail1:
+	if (has_rndis())
+		usb_put_function_instance(fi_rndis);
 fail:
-	gether_cleanup(the_dev);
+	if (use_eem)
+		usb_put_function_instance(fi_eem);
+	else if (can_support_ecm(gadget))
+		usb_put_function_instance(fi_ecm);
+	else
+		usb_put_function_instance(fi_geth);
 	return status;
 }
 
 static int __exit eth_unbind(struct usb_composite_dev *cdev)
 {
-	gether_cleanup(the_dev);
+	if (has_rndis()) {
+		usb_put_function(f_rndis);
+		usb_put_function_instance(fi_rndis);
+	}
+	if (use_eem) {
+		usb_put_function(f_eem);
+		usb_put_function_instance(fi_eem);
+	} else if (can_support_ecm(cdev->gadget)) {
+		usb_put_function(f_ecm);
+		usb_put_function_instance(fi_ecm);
+	} else {
+		usb_put_function(f_geth);
+		usb_put_function_instance(fi_geth);
+	}
 	return 0;
 }
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_accessory.c
diff -ur ./drivers/usb/gadget/f_acm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_acm.c
--- ./drivers/usb/gadget/f_acm.c	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_acm.c	2023-04-23 12:06:32.506349400 +0100
@@ -430,11 +430,12 @@
 		if (acm->notify->driver_data) {
 			VDBG(cdev, "reset acm control interface %d\n", intf);
 			usb_ep_disable(acm->notify);
-		} else {
-			VDBG(cdev, "init acm ctrl interface %d\n", intf);
+		}
+
+		if (!acm->notify->desc)
 			if (config_ep_by_speed(cdev->gadget, f, acm->notify))
 				return -EINVAL;
-		}
+
 		usb_ep_enable(acm->notify);
 		acm->notify->driver_data = acm;
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_adb.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_audio_source.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_diag.c
diff -ur ./drivers/usb/gadget/f_ecm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_ecm.c
--- ./drivers/usb/gadget/f_ecm.c	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_ecm.c	2023-04-23 12:06:32.580822000 +0100
@@ -14,10 +14,13 @@
 
 #include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
 
 #include "u_ether.h"
+#include "u_ether_configfs.h"
+#include "u_ecm.h"
 
 
 /*
@@ -684,9 +687,43 @@
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_ecm		*ecm = func_to_ecm(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
 
+	struct f_ecm_opts	*ecm_opts;
+
+	if (!can_support_ecm(cdev->gadget))
+		return -EINVAL;
+
+	ecm_opts = container_of(f->fi, struct f_ecm_opts, func_inst);
+
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to ecm_opts->bound access
+	 */
+	if (!ecm_opts->bound) {
+		mutex_lock(&ecm_opts->lock);
+		gether_set_gadget(ecm_opts->net, cdev->gadget);
+		status = gether_register_netdev(ecm_opts->net);
+		mutex_unlock(&ecm_opts->lock);
+		if (status)
+			return status;
+		ecm_opts->bound = true;
+	}
+
+	us = usb_gstrings_attach(cdev, ecm_strings,
+				 ARRAY_SIZE(ecm_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	ecm_control_intf.iInterface = us[0].id;
+	ecm_data_intf.iInterface = us[2].id;
+	ecm_desc.iMACAddress = us[1].id;
+	ecm_iad_descriptor.iFunction = us[3].id;
+
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -796,69 +833,129 @@
 	return status;
 }
 
-static void
-ecm_unbind(struct usb_configuration *c, struct usb_function *f)
+static inline struct f_ecm_opts *to_f_ecm_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_ecm_opts,
+			    func_inst.group);
+}
+
+/* f_ecm_item_ops */
+USB_ETHERNET_CONFIGFS_ITEM(ecm);
+
+/* f_ecm_opts_dev_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(ecm);
+
+/* f_ecm_opts_host_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(ecm);
+
+/* f_ecm_opts_qmult */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(ecm);
+
+/* f_ecm_opts_ifname */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(ecm);
+
+static struct configfs_attribute *ecm_attrs[] = {
+	&f_ecm_opts_dev_addr.attr,
+	&f_ecm_opts_host_addr.attr,
+	&f_ecm_opts_qmult.attr,
+	&f_ecm_opts_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type ecm_func_type = {
+	.ct_item_ops	= &ecm_item_ops,
+	.ct_attrs	= ecm_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void ecm_free_inst(struct usb_function_instance *f)
+{
+	struct f_ecm_opts *opts;
+
+	opts = container_of(f, struct f_ecm_opts, func_inst);
+	if (opts->bound)
+		gether_cleanup(netdev_priv(opts->net));
+	else
+		free_netdev(opts->net);
+	kfree(opts);
+}
+
+static struct usb_function_instance *ecm_alloc_inst(void)
+{
+	struct f_ecm_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = ecm_free_inst;
+	opts->net = gether_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
+	}
+
+	config_group_init_type_name(&opts->func_inst.group, "", &ecm_func_type);
+
+	return &opts->func_inst;
+}
+
+static void ecm_free(struct usb_function *f)
+{
+	struct f_ecm *ecm;
+	struct f_ecm_opts *opts;
+
+	ecm = func_to_ecm(f);
+	opts = container_of(f->fi, struct f_ecm_opts, func_inst);
+	kfree(ecm);
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
+}
+
+static void ecm_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_ecm		*ecm = func_to_ecm(f);
 
 	DBG(c->cdev, "ecm unbind\n");
 
-	ecm_string_defs[0].id = 0;
 	usb_free_all_descriptors(f);
 
 	kfree(ecm->notify_req->buf);
 	usb_ep_free_request(ecm->notify, ecm->notify_req);
-	kfree(ecm);
 }
 
-/**
- * ecm_bind_config - add CDC Ethernet network link to a configuration
- * @c: the configuration to support the network link
- * @ethaddr: a buffer in which the ethernet address of the host side
- *	side of the link was recorded
- * @dev: eth_dev structure
- * Context: single threaded during gadget setup
- *
- * Returns zero on success, else negative errno.
- *
- * Caller must have called @gether_setup().  Caller is also responsible
- * for calling @gether_cleanup() before module unload.
- */
-int
-ecm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev)
+static struct usb_function *ecm_alloc(struct usb_function_instance *fi)
 {
 	struct f_ecm	*ecm;
-	int		status;
-
-	if (!can_support_ecm(c->cdev->gadget) || !ethaddr)
-		return -EINVAL;
-
-	if (ecm_string_defs[0].id == 0) {
-		status = usb_string_ids_tab(c->cdev, ecm_string_defs);
-		if (status)
-			return status;
-
-		ecm_control_intf.iInterface = ecm_string_defs[0].id;
-		ecm_data_intf.iInterface = ecm_string_defs[2].id;
-		ecm_desc.iMACAddress = ecm_string_defs[1].id;
-		ecm_iad_descriptor.iFunction = ecm_string_defs[3].id;
-	}
+	struct f_ecm_opts *opts;
+	int status;
 
 	/* allocate and initialize one new instance */
-	ecm = kzalloc(sizeof *ecm, GFP_KERNEL);
+	ecm = kzalloc(sizeof(*ecm), GFP_KERNEL);
 	if (!ecm)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
+
+	opts = container_of(fi, struct f_ecm_opts, func_inst);
+	mutex_lock(&opts->lock);
+	opts->refcnt++;
 
 	/* export host's Ethernet address in CDC format */
-	snprintf(ecm->ethaddr, sizeof ecm->ethaddr, "%pm", ethaddr);
+	status = gether_get_host_addr_cdc(opts->net, ecm->ethaddr,
+					  sizeof(ecm->ethaddr));
+	if (status < 12) {
+		kfree(ecm);
+		mutex_unlock(&opts->lock);
+		return ERR_PTR(-EINVAL);
+	}
 	ecm_string_defs[1].s = ecm->ethaddr;
 
-	ecm->port.ioport = dev;
+	ecm->port.ioport = netdev_priv(opts->net);
+	mutex_unlock(&opts->lock);
 	ecm->port.cdc_filter = DEFAULT_FILTER;
 
 	ecm->port.func.name = "cdc_ethernet";
-	ecm->port.func.strings = ecm_strings;
 	/* descriptors are per-instance copies */
 	ecm->port.func.bind = ecm_bind;
 	ecm->port.func.unbind = ecm_unbind;
@@ -866,9 +963,11 @@
 	ecm->port.func.get_alt = ecm_get_alt;
 	ecm->port.func.setup = ecm_setup;
 	ecm->port.func.disable = ecm_disable;
+	ecm->port.func.free_func = ecm_free;
 
-	status = usb_add_function(c, &ecm->port.func);
-	if (status)
-		kfree(ecm);
-	return status;
+	return &ecm->port.func;
 }
+
+DECLARE_USB_FUNCTION_INIT(ecm, ecm_alloc_inst, ecm_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
diff -ur ./drivers/usb/gadget/f_eem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_eem.c
--- ./drivers/usb/gadget/f_eem.c	2023-04-26 12:56:07.750118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_eem.c	2023-04-23 12:06:32.582457000 +0100
@@ -12,12 +12,15 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
 #include <linux/crc32.h>
 #include <linux/slab.h>
 
 #include "u_ether.h"
+#include "u_ether_configfs.h"
+#include "u_eem.h"
 
 #define EEM_HLEN 2
 
@@ -40,7 +43,7 @@
 
 /* interface descriptor: */
 
-static struct usb_interface_descriptor eem_intf __initdata = {
+static struct usb_interface_descriptor eem_intf = {
 	.bLength =		sizeof eem_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -54,7 +57,7 @@
 
 /* full speed support: */
 
-static struct usb_endpoint_descriptor eem_fs_in_desc __initdata = {
+static struct usb_endpoint_descriptor eem_fs_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -62,7 +65,7 @@
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor eem_fs_out_desc __initdata = {
+static struct usb_endpoint_descriptor eem_fs_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -70,7 +73,7 @@
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_descriptor_header *eem_fs_function[] __initdata = {
+static struct usb_descriptor_header *eem_fs_function[] = {
 	/* CDC EEM control descriptors */
 	(struct usb_descriptor_header *) &eem_intf,
 	(struct usb_descriptor_header *) &eem_fs_in_desc,
@@ -80,7 +83,7 @@
 
 /* high speed support: */
 
-static struct usb_endpoint_descriptor eem_hs_in_desc __initdata = {
+static struct usb_endpoint_descriptor eem_hs_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -89,7 +92,7 @@
 	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor eem_hs_out_desc __initdata = {
+static struct usb_endpoint_descriptor eem_hs_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -98,7 +101,7 @@
 	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
-static struct usb_descriptor_header *eem_hs_function[] __initdata = {
+static struct usb_descriptor_header *eem_hs_function[] = {
 	/* CDC EEM control descriptors */
 	(struct usb_descriptor_header *) &eem_intf,
 	(struct usb_descriptor_header *) &eem_hs_in_desc,
@@ -108,7 +111,7 @@
 
 /* super speed support: */
 
-static struct usb_endpoint_descriptor eem_ss_in_desc __initdata = {
+static struct usb_endpoint_descriptor eem_ss_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -117,7 +120,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_endpoint_descriptor eem_ss_out_desc __initdata = {
+static struct usb_endpoint_descriptor eem_ss_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -126,7 +129,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_ss_ep_comp_descriptor eem_ss_bulk_comp_desc __initdata = {
+static struct usb_ss_ep_comp_descriptor eem_ss_bulk_comp_desc = {
 	.bLength =		sizeof eem_ss_bulk_comp_desc,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 
@@ -135,7 +138,7 @@
 	/* .bmAttributes =	0, */
 };
 
-static struct usb_descriptor_header *eem_ss_function[] __initdata = {
+static struct usb_descriptor_header *eem_ss_function[] = {
 	/* CDC EEM control descriptors */
 	(struct usb_descriptor_header *) &eem_intf,
 	(struct usb_descriptor_header *) &eem_ss_in_desc,
@@ -242,14 +245,40 @@
 
 /* EEM function driver setup/binding */
 
-static int __init
-eem_bind(struct usb_configuration *c, struct usb_function *f)
+static int eem_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_eem		*eem = func_to_eem(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
 
+	struct f_eem_opts	*eem_opts;
+
+	eem_opts = container_of(f->fi, struct f_eem_opts, func_inst);
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to eem_opts->bound access
+	 */
+	if (!eem_opts->bound) {
+		mutex_lock(&eem_opts->lock);
+		gether_set_gadget(eem_opts->net, cdev->gadget);
+		status = gether_register_netdev(eem_opts->net);
+		mutex_unlock(&eem_opts->lock);
+		if (status)
+			return status;
+		eem_opts->bound = true;
+	}
+
+	us = usb_gstrings_attach(cdev, eem_strings,
+				 ARRAY_SIZE(eem_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	eem_intf.iInterface = us[0].id;
+
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -307,17 +336,6 @@
 	return status;
 }
 
-static void
-eem_unbind(struct usb_configuration *c, struct usb_function *f)
-{
-	struct f_eem	*eem = func_to_eem(f);
-
-	DBG(c->cdev, "eem unbind\n");
-
-	usb_free_all_descriptors(f);
-	kfree(eem);
-}
-
 static void eem_cmd_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct sk_buff *skb = (struct sk_buff *)req->context;
@@ -518,55 +536,127 @@
 	return status;
 }
 
-/**
- * eem_bind_config - add CDC Ethernet (EEM) network link to a configuration
- * @c: the configuration to support the network link
- * Context: single threaded during gadget setup
- *
- * Returns zero on success, else negative errno.
- *
- * Caller must have called @gether_setup().  Caller is also responsible
- * for calling @gether_cleanup() before module unload.
- */
-int __init eem_bind_config(struct usb_configuration *c, struct eth_dev *dev)
+static inline struct f_eem_opts *to_f_eem_opts(struct config_item *item)
 {
-	struct f_eem	*eem;
-	int		status;
+	return container_of(to_config_group(item), struct f_eem_opts,
+			    func_inst.group);
+}
 
-	/* maybe allocate device-global string IDs */
-	if (eem_string_defs[0].id == 0) {
+/* f_eem_item_ops */
+USB_ETHERNET_CONFIGFS_ITEM(eem);
 
-		/* control interface label */
-		status = usb_string_id(c->cdev);
-		if (status < 0)
-			return status;
-		eem_string_defs[0].id = status;
-		eem_intf.iInterface = status;
+/* f_eem_opts_dev_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(eem);
+
+/* f_eem_opts_host_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(eem);
+
+/* f_eem_opts_qmult */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(eem);
+
+/* f_eem_opts_ifname */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(eem);
+
+static struct configfs_attribute *eem_attrs[] = {
+	&f_eem_opts_dev_addr.attr,
+	&f_eem_opts_host_addr.attr,
+	&f_eem_opts_qmult.attr,
+	&f_eem_opts_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type eem_func_type = {
+	.ct_item_ops	= &eem_item_ops,
+	.ct_attrs	= eem_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void eem_free_inst(struct usb_function_instance *f)
+{
+	struct f_eem_opts *opts;
+
+	opts = container_of(f, struct f_eem_opts, func_inst);
+	if (opts->bound)
+		gether_cleanup(netdev_priv(opts->net));
+	else
+		free_netdev(opts->net);
+	kfree(opts);
+}
+
+static struct usb_function_instance *eem_alloc_inst(void)
+{
+	struct f_eem_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = eem_free_inst;
+	opts->net = gether_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
 	}
 
+	config_group_init_type_name(&opts->func_inst.group, "", &eem_func_type);
+
+	return &opts->func_inst;
+}
+
+static void eem_free(struct usb_function *f)
+{
+	struct f_eem *eem;
+	struct f_eem_opts *opts;
+
+	eem = func_to_eem(f);
+	opts = container_of(f->fi, struct f_eem_opts, func_inst);
+	kfree(eem);
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
+}
+
+static void eem_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	DBG(c->cdev, "eem unbind\n");
+
+	usb_free_all_descriptors(f);
+}
+
+static struct usb_function *eem_alloc(struct usb_function_instance *fi)
+{
+	struct f_eem	*eem;
+	struct f_eem_opts *opts;
+
 	/* allocate and initialize one new instance */
-	eem = kzalloc(sizeof *eem, GFP_KERNEL);
+	eem = kzalloc(sizeof(*eem), GFP_KERNEL);
 	if (!eem)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
-	eem->port.ioport = dev;
+	opts = container_of(fi, struct f_eem_opts, func_inst);
+	mutex_lock(&opts->lock);
+	opts->refcnt++;
+
+	eem->port.ioport = netdev_priv(opts->net);
+	mutex_unlock(&opts->lock);
 	eem->port.cdc_filter = DEFAULT_FILTER;
 
 	eem->port.func.name = "cdc_eem";
-	eem->port.func.strings = eem_strings;
 	/* descriptors are per-instance copies */
 	eem->port.func.bind = eem_bind;
 	eem->port.func.unbind = eem_unbind;
 	eem->port.func.set_alt = eem_set_alt;
 	eem->port.func.setup = eem_setup;
 	eem->port.func.disable = eem_disable;
+	eem->port.func.free_func = eem_free;
 	eem->port.wrap = eem_wrap;
 	eem->port.unwrap = eem_unwrap;
 	eem->port.header_len = EEM_HLEN;
 
-	status = usb_add_function(c, &eem->port.func);
-	if (status)
-		kfree(eem);
-	return status;
+	return &eem->port.func;
 }
 
+DECLARE_USB_FUNCTION_INIT(eem, eem_alloc_inst, eem_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
diff -ur ./drivers/usb/gadget/f_fs.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_fs.c
--- ./drivers/usb/gadget/f_fs.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_fs.c	2023-04-23 12:06:32.581976300 +0100
@@ -22,218 +22,46 @@
 #include <linux/pagemap.h>
 #include <linux/export.h>
 #include <linux/hid.h>
+#include <linux/module.h>
 #include <asm/unaligned.h>
 
 #include <linux/usb/composite.h>
 #include <linux/usb/functionfs.h>
 
+#include <linux/aio.h>
+#include <linux/mmu_context.h>
+#include <linux/poll.h>
 
-#define FUNCTIONFS_MAGIC	0xa647361 /* Chosen by a honest dice roll ;) */
-
-
-/* Debugging ****************************************************************/
-
-#ifdef VERBOSE_DEBUG
-#ifndef pr_vdebug
-#  define pr_vdebug pr_debug
-#endif /* pr_vdebug */
-#  define ffs_dump_mem(prefix, ptr, len) \
-	print_hex_dump_bytes(pr_fmt(prefix ": "), DUMP_PREFIX_NONE, ptr, len)
-#else
-#ifndef pr_vdebug
-#  define pr_vdebug(...)                 do { } while (0)
-#endif /* pr_vdebug */
-#  define ffs_dump_mem(prefix, ptr, len) do { } while (0)
-#endif /* VERBOSE_DEBUG */
-
-#define ENTER()    pr_vdebug("%s()\n", __func__)
-
-
-/* The data structure and setup file ****************************************/
-
-enum ffs_state {
-	/*
-	 * Waiting for descriptors and strings.
-	 *
-	 * In this state no open(2), read(2) or write(2) on epfiles
-	 * may succeed (which should not be the problem as there
-	 * should be no such files opened in the first place).
-	 */
-	FFS_READ_DESCRIPTORS,
-	FFS_READ_STRINGS,
-
-	/*
-	 * We've got descriptors and strings.  We are or have called
-	 * functionfs_ready_callback().  functionfs_bind() may have
-	 * been called but we don't know.
-	 *
-	 * This is the only state in which operations on epfiles may
-	 * succeed.
-	 */
-	FFS_ACTIVE,
-
-	/*
-	 * All endpoints have been closed.  This state is also set if
-	 * we encounter an unrecoverable error.  The only
-	 * unrecoverable error is situation when after reading strings
-	 * from user space we fail to initialise epfiles or
-	 * functionfs_ready_callback() returns with error (<0).
-	 *
-	 * In this state no open(2), read(2) or write(2) (both on ep0
-	 * as well as epfile) may succeed (at this point epfiles are
-	 * unlinked and all closed so this is not a problem; ep0 is
-	 * also closed but ep0 file exists and so open(2) on ep0 must
-	 * fail).
-	 */
-	FFS_CLOSING
-};
-
-
-enum ffs_setup_state {
-	/* There is no setup request pending. */
-	FFS_NO_SETUP,
-	/*
-	 * User has read events and there was a setup request event
-	 * there.  The next read/write on ep0 will handle the
-	 * request.
-	 */
-	FFS_SETUP_PENDING,
-	/*
-	 * There was event pending but before user space handled it
-	 * some other event was introduced which canceled existing
-	 * setup.  If this state is set read/write on ep0 return
-	 * -EIDRM.  This state is only set when adding event.
-	 */
-	FFS_SETUP_CANCELED
-};
-
-
+#include "u_fs.h"
+#include "configfs.h"
 
-struct ffs_epfile;
-struct ffs_function;
-
-struct ffs_data {
-	struct usb_gadget		*gadget;
-
-	/*
-	 * Protect access read/write operations, only one read/write
-	 * at a time.  As a consequence protects ep0req and company.
-	 * While setup request is being processed (queued) this is
-	 * held.
-	 */
-	struct mutex			mutex;
-
-	/*
-	 * Protect access to endpoint related structures (basically
-	 * usb_ep_queue(), usb_ep_dequeue(), etc. calls) except for
-	 * endpoint zero.
-	 */
-	spinlock_t			eps_lock;
-
-	/*
-	 * XXX REVISIT do we need our own request? Since we are not
-	 * handling setup requests immediately user space may be so
-	 * slow that another setup will be sent to the gadget but this
-	 * time not to us but another function and then there could be
-	 * a race.  Is that the case? Or maybe we can use cdev->req
-	 * after all, maybe we just need some spinlock for that?
-	 */
-	struct usb_request		*ep0req;		/* P: mutex */
-	struct completion		ep0req_completion;	/* P: mutex */
-	int				ep0req_status;		/* P: mutex */
-
-	/* reference counter */
-	atomic_t			ref;
-	/* how many files are opened (EP0 and others) */
-	atomic_t			opened;
-
-	/* EP0 state */
-	enum ffs_state			state;
-
-	/*
-	 * Possible transitions:
-	 * + FFS_NO_SETUP       -> FFS_SETUP_PENDING  -- P: ev.waitq.lock
-	 *               happens only in ep0 read which is P: mutex
-	 * + FFS_SETUP_PENDING  -> FFS_NO_SETUP       -- P: ev.waitq.lock
-	 *               happens only in ep0 i/o  which is P: mutex
-	 * + FFS_SETUP_PENDING  -> FFS_SETUP_CANCELED -- P: ev.waitq.lock
-	 * + FFS_SETUP_CANCELED -> FFS_NO_SETUP       -- cmpxchg
-	 */
-	enum ffs_setup_state		setup_state;
-
-#define FFS_SETUP_STATE(ffs)					\
-	((enum ffs_setup_state)cmpxchg(&(ffs)->setup_state,	\
-				       FFS_SETUP_CANCELED, FFS_NO_SETUP))
-
-	/* Events & such. */
-	struct {
-		u8				types[4];
-		unsigned short			count;
-		/* XXX REVISIT need to update it in some places, or do we? */
-		unsigned short			can_stall;
-		struct usb_ctrlrequest		setup;
-
-		wait_queue_head_t		waitq;
-	} ev; /* the whole structure, P: ev.waitq.lock */
-
-	/* Flags */
-	unsigned long			flags;
-#define FFS_FL_CALL_CLOSED_CALLBACK 0
-#define FFS_FL_BOUND                1
-
-	/* Active function */
-	struct ffs_function		*func;
-
-	/*
-	 * Device name, write once when file system is mounted.
-	 * Intended for user to read if she wants.
-	 */
-	const char			*dev_name;
-	/* Private data for our user (ie. gadget).  Managed by user. */
-	void				*private_data;
-
-	/* filled by __ffs_data_got_descs() */
-	/*
-	 * Real descriptors are 16 bytes after raw_descs (so you need
-	 * to skip 16 bytes (ie. ffs->raw_descs + 16) to get to the
-	 * first full speed descriptor).  raw_descs_length and
-	 * raw_fs_descs_length do not have those 16 bytes added.
-	 */
-	const void			*raw_descs;
-	unsigned			raw_descs_length;
-	unsigned			raw_fs_descs_length;
-	unsigned			fs_descs_count;
-	unsigned			hs_descs_count;
-
-	unsigned short			strings_count;
-	unsigned short			interfaces_count;
-	unsigned short			eps_count;
-	unsigned short			_pad1;
-
-	/* filled by __ffs_data_got_strings() */
-	/* ids in stringtabs are set in functionfs_bind() */
-	const void			*raw_strings;
-	struct usb_gadget_strings	**stringtabs;
+#define FUNCTIONFS_MAGIC	0xa647361 /* Chosen by a honest dice roll ;) */
 
-	/*
-	 * File system's super block, write once when file system is
-	 * mounted.
-	 */
-	struct super_block		*sb;
+/* Variable Length Array Macros **********************************************/
+#define vla_group(groupname) size_t groupname##__next = 0
+#define vla_group_size(groupname) groupname##__next
+
+#define vla_item(groupname, type, name, n) \
+	size_t groupname##_##name##__offset = ({			       \
+		size_t align_mask = __alignof__(type) - 1;		       \
+		size_t offset = (groupname##__next + align_mask) & ~align_mask;\
+		size_t size = (n) * sizeof(type);			       \
+		groupname##__next = offset + size;			       \
+		offset;							       \
+	})
+
+#define vla_item_with_sz(groupname, type, name, n) \
+	size_t groupname##_##name##__sz = (n) * sizeof(type);		       \
+	size_t groupname##_##name##__offset = ({			       \
+		size_t align_mask = __alignof__(type) - 1;		       \
+		size_t offset = (groupname##__next + align_mask) & ~align_mask;\
+		size_t size = groupname##_##name##__sz;			       \
+		groupname##__next = offset + size;			       \
+		offset;							       \
+	})
 
-	/* File permissions, written once when fs is mounted */
-	struct ffs_file_perms {
-		umode_t				mode;
-		kuid_t				uid;
-		kgid_t				gid;
-	}				file_perms;
-
-	/*
-	 * The endpoint files, filled by ffs_epfiles_create(),
-	 * destroyed by ffs_epfiles_destroy().
-	 */
-	struct ffs_epfile		*epfiles;
-};
+#define vla_ptr(ptr, groupname, name) \
+	((void *) ((char *)ptr + groupname##_##name##__offset))
 
 /* Reference counter handling */
 static void ffs_data_get(struct ffs_data *ffs);
@@ -274,15 +102,20 @@
 	return container_of(f, struct ffs_function, function);
 }
 
-static void ffs_func_free(struct ffs_function *func);
+
+static inline enum ffs_setup_state
+ffs_setup_state_clear_cancelled(struct ffs_data *ffs)
+{
+	return (enum ffs_setup_state)
+		cmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);
+}
+
 
 static void ffs_func_eps_disable(struct ffs_function *func);
 static int __must_check ffs_func_eps_enable(struct ffs_function *func);
 
 static int ffs_func_bind(struct usb_configuration *,
 			 struct usb_function *);
-static void ffs_func_unbind(struct usb_configuration *,
-			    struct usb_function *);
 static int ffs_func_set_alt(struct usb_function *, unsigned, unsigned);
 static void ffs_func_disable(struct usb_function *);
 static int ffs_func_setup(struct usb_function *,
@@ -301,8 +134,8 @@
 	struct usb_ep			*ep;	/* P: ffs->eps_lock */
 	struct usb_request		*req;	/* P: epfile->mutex */
 
-	/* [0]: full speed, [1]: high speed */
-	struct usb_endpoint_descriptor	*descs[2];
+	/* [0]: full speed, [1]: high speed, [2]: super speed */
+	struct usb_endpoint_descriptor	*descs[3];
 
 	u8				num;
 
@@ -327,6 +160,25 @@
 	unsigned char			_pad;
 };
 
+/*  ffs_io_data structure ***************************************************/
+
+struct ffs_io_data {
+	bool aio;
+	bool read;
+
+	struct kiocb *kiocb;
+	const struct iovec *iovec;
+	unsigned long nr_segs;
+	char __user *buf;
+	size_t len;
+
+	struct mm_struct *mm;
+	struct work_struct work;
+
+	struct usb_ep *ep;
+	struct usb_request *req;
+};
+
 static int  __must_check ffs_epfiles_create(struct ffs_data *ffs);
 static void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count);
 
@@ -335,6 +187,19 @@
 		   const struct file_operations *fops,
 		   struct dentry **dentry_p);
 
+/* Devices management *******************************************************/
+
+DEFINE_MUTEX(ffs_lock);
+EXPORT_SYMBOL(ffs_lock);
+
+static struct ffs_dev *_ffs_find_dev(const char *name);
+static struct ffs_dev *_ffs_alloc_dev(void);
+static int _ffs_name_dev(struct ffs_dev *dev, const char *name);
+static void _ffs_free_dev(struct ffs_dev *dev);
+static void *ffs_acquire_dev(const char *dev_name);
+static void ffs_release_dev(struct ffs_data *ffs_data);
+static int ffs_ready(struct ffs_data *ffs);
+static void ffs_closed(struct ffs_data *ffs);
 
 /* Misc helper functions ****************************************************/
 
@@ -386,7 +251,7 @@
 	}
 
 	ffs->setup_state = FFS_NO_SETUP;
-	return ffs->ep0req_status;
+	return req->status ? req->status : req->actual;
 }
 
 static int __ffs_ep0_stall(struct ffs_data *ffs)
@@ -412,7 +277,7 @@
 	ENTER();
 
 	/* Fast check if setup was canceled */
-	if (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED)
+	if (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)
 		return -EIDRM;
 
 	/* Acquire mutex */
@@ -460,7 +325,7 @@
 			ffs->state = FFS_ACTIVE;
 			mutex_unlock(&ffs->mutex);
 
-			ret = functionfs_ready_callback(ffs);
+			ret = ffs_ready(ffs);
 			if (unlikely(ret < 0)) {
 				ffs->state = FFS_CLOSING;
 				return ret;
@@ -478,8 +343,8 @@
 		 * rather then _irqsave
 		 */
 		spin_lock_irq(&ffs->ev.waitq.lock);
-		switch (FFS_SETUP_STATE(ffs)) {
-		case FFS_SETUP_CANCELED:
+		switch (ffs_setup_state_clear_cancelled(ffs)) {
+		case FFS_SETUP_CANCELLED:
 			ret = -EIDRM;
 			goto done_spin;
 
@@ -514,7 +379,7 @@
 		/*
 		 * We are guaranteed to be still in FFS_ACTIVE state
 		 * but the state of setup could have changed from
-		 * FFS_SETUP_PENDING to FFS_SETUP_CANCELED so we need
+		 * FFS_SETUP_PENDING to FFS_SETUP_CANCELLED so we need
 		 * to check for that.  If that happened we copied data
 		 * from user space in vain but it's unlikely.
 		 *
@@ -523,7 +388,8 @@
 		 * transition can be performed and it's protected by
 		 * mutex.
 		 */
-		if (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED) {
+		if (ffs_setup_state_clear_cancelled(ffs) ==
+		    FFS_SETUP_CANCELLED) {
 			ret = -EIDRM;
 done_spin:
 			spin_unlock_irq(&ffs->ev.waitq.lock);
@@ -589,7 +455,7 @@
 	ENTER();
 
 	/* Fast check if setup was canceled */
-	if (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED)
+	if (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)
 		return -EIDRM;
 
 	/* Acquire mutex */
@@ -609,8 +475,8 @@
 	 */
 	spin_lock_irq(&ffs->ev.waitq.lock);
 
-	switch (FFS_SETUP_STATE(ffs)) {
-	case FFS_SETUP_CANCELED:
+	switch (ffs_setup_state_clear_cancelled(ffs)) {
+	case FFS_SETUP_CANCELLED:
 		ret = -EIDRM;
 		break;
 
@@ -657,7 +523,8 @@
 		spin_lock_irq(&ffs->ev.waitq.lock);
 
 		/* See ffs_ep0_write() */
-		if (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED) {
+		if (ffs_setup_state_clear_cancelled(ffs) ==
+		    FFS_SETUP_CANCELLED) {
 			ret = -EIDRM;
 			break;
 		}
@@ -726,6 +593,45 @@
 	return ret;
 }
 
+static unsigned int ffs_ep0_poll(struct file *file, poll_table *wait)
+{
+	struct ffs_data *ffs = file->private_data;
+	unsigned int mask = POLLWRNORM;
+	int ret;
+
+	poll_wait(file, &ffs->ev.waitq, wait);
+
+	ret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);
+	if (unlikely(ret < 0))
+		return mask;
+
+	switch (ffs->state) {
+	case FFS_READ_DESCRIPTORS:
+	case FFS_READ_STRINGS:
+		mask |= POLLOUT;
+		break;
+
+	case FFS_ACTIVE:
+		switch (ffs->setup_state) {
+		case FFS_NO_SETUP:
+			if (ffs->ev.count)
+				mask |= POLLIN;
+			break;
+
+		case FFS_SETUP_PENDING:
+		case FFS_SETUP_CANCELLED:
+			mask |= (POLLIN | POLLOUT);
+			break;
+		}
+	case FFS_CLOSING:
+		break;
+	}
+
+	mutex_unlock(&ffs->mutex);
+
+	return mask;
+}
+
 static const struct file_operations ffs_ep0_operations = {
 	.llseek =	no_llseek,
 
@@ -734,6 +640,7 @@
 	.read =		ffs_ep0_read,
 	.release =	ffs_ep0_release,
 	.unlocked_ioctl =	ffs_ep0_ioctl,
+	.poll =		ffs_ep0_poll,
 };
 
 
@@ -749,114 +656,226 @@
 	}
 }
 
-static ssize_t ffs_epfile_io(struct file *file,
-			     char __user *buf, size_t len, int read)
+static void ffs_user_copy_worker(struct work_struct *work)
+{
+	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
+						   work);
+	int ret = io_data->req->status ? io_data->req->status :
+					 io_data->req->actual;
+
+	if (io_data->read && ret > 0) {
+		int i;
+		size_t pos = 0;
+		use_mm(io_data->mm);
+		for (i = 0; i < io_data->nr_segs; i++) {
+			if (unlikely(copy_to_user(io_data->iovec[i].iov_base,
+						 &io_data->buf[pos],
+						 io_data->iovec[i].iov_len))) {
+				ret = -EFAULT;
+				break;
+			}
+			pos += io_data->iovec[i].iov_len;
+		}
+		unuse_mm(io_data->mm);
+	}
+
+	aio_complete(io_data->kiocb, ret, ret);
+
+	usb_ep_free_request(io_data->ep, io_data->req);
+
+	io_data->kiocb->private = NULL;
+	if (io_data->read)
+		kfree(io_data->iovec);
+	kfree(io_data->buf);
+	kfree(io_data);
+}
+
+static void ffs_epfile_async_io_complete(struct usb_ep *_ep,
+					 struct usb_request *req)
+{
+	struct ffs_io_data *io_data = req->context;
+
+	ENTER();
+
+	INIT_WORK(&io_data->work, ffs_user_copy_worker);
+	schedule_work(&io_data->work);
+}
+
+static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)
 {
 	struct ffs_epfile *epfile = file->private_data;
 	struct ffs_ep *ep;
 	char *data = NULL;
-	ssize_t ret;
+	ssize_t ret, data_len;
 	int halt;
 
-	goto first_try;
-	do {
-		spin_unlock_irq(&epfile->ffs->eps_lock);
-		mutex_unlock(&epfile->mutex);
+	/* Are we still active? */
+	if (WARN_ON(epfile->ffs->state != FFS_ACTIVE)) {
+		ret = -ENODEV;
+		goto error;
+	}
 
-first_try:
-		/* Are we still active? */
-		if (WARN_ON(epfile->ffs->state != FFS_ACTIVE)) {
-			ret = -ENODEV;
+	/* Wait for endpoint to be enabled */
+	ep = epfile->ep;
+	if (!ep) {
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
 			goto error;
 		}
 
-		/* Wait for endpoint to be enabled */
-		ep = epfile->ep;
-		if (!ep) {
-			if (file->f_flags & O_NONBLOCK) {
-				ret = -EAGAIN;
-				goto error;
-			}
-
-			if (wait_event_interruptible(epfile->wait,
-						     (ep = epfile->ep))) {
-				ret = -EINTR;
-				goto error;
-			}
-		}
-
-		/* Do we halt? */
-		halt = !read == !epfile->in;
-		if (halt && epfile->isoc) {
-			ret = -EINVAL;
+		ret = wait_event_interruptible(epfile->wait, (ep = epfile->ep));
+		if (ret) {
+			ret = -EINTR;
 			goto error;
 		}
+	}
 
-		/* Allocate & copy */
-		if (!halt && !data) {
-			data = kzalloc(len, GFP_KERNEL);
-			if (unlikely(!data))
-				return -ENOMEM;
+	/* Do we halt? */
+	halt = (!io_data->read == !epfile->in);
+	if (halt && epfile->isoc) {
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* Allocate & copy */
+	if (!halt) {
+		/*
+		 * if we _do_ wait above, the epfile->ffs->gadget might be NULL
+		 * before the waiting completes, so do not assign to 'gadget' earlier
+		 */
+		struct usb_gadget *gadget = epfile->ffs->gadget;
+
+		spin_lock_irq(&epfile->ffs->eps_lock);
+		/* In the meantime, endpoint got disabled or changed. */
+		if (epfile->ep != ep) {
+			spin_unlock_irq(&epfile->ffs->eps_lock);
+			return -ESHUTDOWN;
+		}
+		/*
+		 * Controller may require buffer size to be aligned to
+		 * maxpacketsize of an out endpoint.
+		 */
+		data_len = io_data->read ?
+			   usb_ep_align_maybe(gadget, ep->ep, io_data->len) :
+			   io_data->len;
+		spin_unlock_irq(&epfile->ffs->eps_lock);
 
-			if (!read &&
-			    unlikely(__copy_from_user(data, buf, len))) {
+		data = kmalloc(data_len, GFP_KERNEL);
+		if (unlikely(!data))
+			return -ENOMEM;
+		if (io_data->aio && !io_data->read) {
+			int i;
+			size_t pos = 0;
+			for (i = 0; i < io_data->nr_segs; i++) {
+				if (unlikely(copy_from_user(&data[pos],
+					     io_data->iovec[i].iov_base,
+					     io_data->iovec[i].iov_len))) {
+					ret = -EFAULT;
+					goto error;
+				}
+				pos += io_data->iovec[i].iov_len;
+			}
+		} else {
+			if (!io_data->read &&
+			    unlikely(__copy_from_user(data, io_data->buf,
+						      io_data->len))) {
 				ret = -EFAULT;
 				goto error;
 			}
 		}
+	}
 
-		/* We will be using request */
-		ret = ffs_mutex_lock(&epfile->mutex,
-				     file->f_flags & O_NONBLOCK);
-		if (unlikely(ret))
-			goto error;
-
-		/*
-		 * We're called from user space, we can use _irq rather then
-		 * _irqsave
-		 */
-		spin_lock_irq(&epfile->ffs->eps_lock);
+	/* We will be using request */
+	ret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);
+	if (unlikely(ret))
+		goto error;
 
-		/*
-		 * While we were acquiring mutex endpoint got disabled
-		 * or changed?
-		 */
-	} while (unlikely(epfile->ep != ep));
+	spin_lock_irq(&epfile->ffs->eps_lock);
 
-	/* Halt */
-	if (unlikely(halt)) {
+	if (epfile->ep != ep) {
+		/* In the meantime, endpoint got disabled or changed. */
+		ret = -ESHUTDOWN;
+		spin_unlock_irq(&epfile->ffs->eps_lock);
+	} else if (halt) {
+		/* Halt */
 		if (likely(epfile->ep == ep) && !WARN_ON(!ep->ep))
 			usb_ep_set_halt(ep->ep);
 		spin_unlock_irq(&epfile->ffs->eps_lock);
 		ret = -EBADMSG;
 	} else {
 		/* Fire the request */
-		DECLARE_COMPLETION_ONSTACK(done);
+		struct usb_request *req;
 
-		struct usb_request *req = ep->req;
-		req->context  = &done;
-		req->complete = ffs_epfile_io_complete;
-		req->buf      = data;
-		req->length   = len;
+		if (io_data->aio) {
+			req = usb_ep_alloc_request(ep->ep, GFP_KERNEL);
+			if (unlikely(!req))
+				goto error_lock;
+
+			req->buf      = data;
+			req->length   = io_data->len;
+
+			io_data->buf = data;
+			io_data->ep = ep->ep;
+			io_data->req = req;
 
-		ret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);
+			req->context  = io_data;
+			req->complete = ffs_epfile_async_io_complete;
 
-		spin_unlock_irq(&epfile->ffs->eps_lock);
+			ret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);
+			if (unlikely(ret)) {
+				usb_ep_free_request(ep->ep, req);
+				goto error_lock;
+			}
+			ret = -EIOCBQUEUED;
 
-		if (unlikely(ret < 0)) {
-			/* nop */
-		} else if (unlikely(wait_for_completion_interruptible(&done))) {
-			ret = -EINTR;
-			usb_ep_dequeue(ep->ep, req);
+			spin_unlock_irq(&epfile->ffs->eps_lock);
 		} else {
-			ret = ep->status;
-			if (read && ret > 0 &&
-			    unlikely(copy_to_user(buf, data, ret)))
-				ret = -EFAULT;
+			DECLARE_COMPLETION_ONSTACK(done);
+
+			req = ep->req;
+			req->buf      = data;
+			req->length   = io_data->len;
+
+			req->context  = &done;
+			req->complete = ffs_epfile_io_complete;
+
+			ret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);
+
+			spin_unlock_irq(&epfile->ffs->eps_lock);
+
+			if (unlikely(ret < 0)) {
+				/* nop */
+			} else if (unlikely(
+				   wait_for_completion_interruptible(&done))) {
+				ret = -EINTR;
+				usb_ep_dequeue(ep->ep, req);
+			} else {
+				/*
+				 * XXX We may end up silently droping data
+				 * here.  Since data_len (i.e. req->length) may
+				 * be bigger than len (after being rounded up
+				 * to maxpacketsize), we may end up with more
+				 * data then user space has space for.
+				 */
+				ret = ep->status;
+				if (io_data->read && ret > 0) {
+					ret = min_t(size_t, ret, io_data->len);
+
+					if (unlikely(copy_to_user(io_data->buf,
+						data, ret)))
+						ret = -EFAULT;
+				}
+			}
+			kfree(data);
 		}
 	}
 
 	mutex_unlock(&epfile->mutex);
+	return ret;
+
+error_lock:
+	spin_unlock_irq(&epfile->ffs->eps_lock);
+	mutex_unlock(&epfile->mutex);
 error:
 	kfree(data);
 	return ret;
@@ -866,17 +885,31 @@
 ffs_epfile_write(struct file *file, const char __user *buf, size_t len,
 		 loff_t *ptr)
 {
+	struct ffs_io_data io_data;
+
 	ENTER();
 
-	return ffs_epfile_io(file, (char __user *)buf, len, 0);
+	io_data.aio = false;
+	io_data.read = false;
+	io_data.buf = (char * __user)buf;
+	io_data.len = len;
+
+	return ffs_epfile_io(file, &io_data);
 }
 
 static ssize_t
 ffs_epfile_read(struct file *file, char __user *buf, size_t len, loff_t *ptr)
 {
+	struct ffs_io_data io_data;
+
 	ENTER();
 
-	return ffs_epfile_io(file, buf, len, 1);
+	io_data.aio = false;
+	io_data.read = true;
+	io_data.buf = buf;
+	io_data.len = len;
+
+	return ffs_epfile_io(file, &io_data);
 }
 
 static int
@@ -895,6 +928,89 @@
 	return 0;
 }
 
+static int ffs_aio_cancel(struct kiocb *kiocb, struct io_event *e)
+{
+	struct ffs_io_data *io_data = kiocb->private;
+	struct ffs_epfile *epfile = kiocb->ki_filp->private_data;
+	int value;
+
+	ENTER();
+
+	spin_lock_irq(&epfile->ffs->eps_lock);
+
+	if (likely(io_data && io_data->ep && io_data->req))
+		value = usb_ep_dequeue(io_data->ep, io_data->req);
+	else
+		value = -EINVAL;
+
+	spin_unlock_irq(&epfile->ffs->eps_lock);
+
+	return value;
+}
+
+static ssize_t ffs_epfile_aio_write(struct kiocb *kiocb,
+				    const struct iovec *iovec,
+				    unsigned long nr_segs, loff_t loff)
+{
+	struct ffs_io_data *io_data;
+
+	ENTER();
+
+	io_data = kmalloc(sizeof(*io_data), GFP_KERNEL);
+	if (unlikely(!io_data))
+		return -ENOMEM;
+
+	io_data->aio = true;
+	io_data->read = false;
+	io_data->kiocb = kiocb;
+	io_data->iovec = iovec;
+	io_data->nr_segs = nr_segs;
+	io_data->len = kiocb->ki_nbytes;
+	io_data->mm = current->mm;
+
+	kiocb->private = io_data;
+
+	kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);
+
+	return ffs_epfile_io(kiocb->ki_filp, io_data);
+}
+
+static ssize_t ffs_epfile_aio_read(struct kiocb *kiocb,
+				   const struct iovec *iovec,
+				   unsigned long nr_segs, loff_t loff)
+{
+	struct ffs_io_data *io_data;
+	struct iovec *iovec_copy;
+
+	ENTER();
+
+	iovec_copy = kmalloc_array(nr_segs, sizeof(*iovec_copy), GFP_KERNEL);
+	if (unlikely(!iovec_copy))
+		return -ENOMEM;
+
+	memcpy(iovec_copy, iovec, sizeof(struct iovec)*nr_segs);
+
+	io_data = kmalloc(sizeof(*io_data), GFP_KERNEL);
+	if (unlikely(!io_data)) {
+		kfree(iovec_copy);
+		return -ENOMEM;
+	}
+
+	io_data->aio = true;
+	io_data->read = true;
+	io_data->kiocb = kiocb;
+	io_data->iovec = iovec_copy;
+	io_data->nr_segs = nr_segs;
+	io_data->len = kiocb->ki_nbytes;
+	io_data->mm = current->mm;
+
+	kiocb->private = io_data;
+
+	kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);
+
+	return ffs_epfile_io(kiocb->ki_filp, io_data);
+}
+
 static int
 ffs_epfile_release(struct inode *inode, struct file *file)
 {
@@ -951,6 +1067,8 @@
 	.open =		ffs_epfile_open,
 	.write =	ffs_epfile_write,
 	.read =		ffs_epfile_read,
+	.aio_write =	ffs_epfile_aio_write,
+	.aio_read =	ffs_epfile_aio_read,
 	.release =	ffs_epfile_release,
 	.unlocked_ioctl =	ffs_epfile_ioctl,
 };
@@ -1034,37 +1152,19 @@
 	struct ffs_file_perms perms;
 	umode_t root_mode;
 	const char *dev_name;
-	union {
-		/* set by ffs_fs_mount(), read by ffs_sb_fill() */
-		void *private_data;
-		/* set by ffs_sb_fill(), read by ffs_fs_mount */
-		struct ffs_data *ffs_data;
-	};
+	struct ffs_data *ffs_data;
 };
 
 static int ffs_sb_fill(struct super_block *sb, void *_data, int silent)
 {
 	struct ffs_sb_fill_data *data = _data;
 	struct inode	*inode;
-	struct ffs_data	*ffs;
+	struct ffs_data	*ffs = data->ffs_data;
 
 	ENTER();
 
-	/* Initialise data */
-	ffs = ffs_data_new();
-	if (unlikely(!ffs))
-		goto Enomem;
-
 	ffs->sb              = sb;
-	ffs->dev_name        = kstrdup(data->dev_name, GFP_KERNEL);
-	if (unlikely(!ffs->dev_name))
-		goto Enomem;
-	ffs->file_perms      = data->perms;
-	ffs->private_data    = data->private_data;
-
-	/* used by the caller of this function */
-	data->ffs_data       = ffs;
-
+	data->ffs_data       = NULL;
 	sb->s_fs_info        = ffs;
 	sb->s_blocksize      = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
@@ -1080,17 +1180,14 @@
 				  &data->perms);
 	sb->s_root = d_make_root(inode);
 	if (unlikely(!sb->s_root))
-		goto Enomem;
+		return -ENOMEM;
 
 	/* EP0 file */
 	if (unlikely(!ffs_sb_create_file(sb, "ep0", ffs,
 					 &ffs_ep0_operations, NULL)))
-		goto Enomem;
+		return -ENOMEM;
 
 	return 0;
-
-Enomem:
-	return -ENOMEM;
 }
 
 static int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)
@@ -1193,6 +1290,7 @@
 	struct dentry *rv;
 	int ret;
 	void *ffs_dev;
+	struct ffs_data	*ffs;
 
 	ENTER();
 
@@ -1200,18 +1298,30 @@
 	if (unlikely(ret < 0))
 		return ERR_PTR(ret);
 
-	ffs_dev = functionfs_acquire_dev_callback(dev_name);
-	if (IS_ERR(ffs_dev))
-		return ffs_dev;
+	ffs = ffs_data_new();
+	if (unlikely(!ffs))
+		return ERR_PTR(-ENOMEM);
+	ffs->file_perms = data.perms;
 
-	data.dev_name = dev_name;
-	data.private_data = ffs_dev;
-	rv = mount_nodev(t, flags, &data, ffs_sb_fill);
+	ffs->dev_name = kstrdup(dev_name, GFP_KERNEL);
+	if (unlikely(!ffs->dev_name)) {
+		ffs_data_put(ffs);
+		return ERR_PTR(-ENOMEM);
+	}
 
-	/* data.ffs_data is set by ffs_sb_fill */
-	if (IS_ERR(rv))
-		functionfs_release_dev_callback(data.ffs_data);
+	ffs_dev = ffs_acquire_dev(dev_name);
+	if (IS_ERR(ffs_dev)) {
+		ffs_data_put(ffs);
+		return ERR_CAST(ffs_dev);
+	}
+	ffs->private_data = ffs_dev;
+	data.ffs_data = ffs;
 
+	rv = mount_nodev(t, flags, &data, ffs_sb_fill);
+	if (IS_ERR(rv) && data.ffs_data) {
+		ffs_release_dev(data.ffs_data);
+		ffs_data_put(data.ffs_data);
+	}
 	return rv;
 }
 
@@ -1222,7 +1332,7 @@
 
 	kill_litter_super(sb);
 	if (sb->s_fs_info) {
-		functionfs_release_dev_callback(sb->s_fs_info);
+		ffs_release_dev(sb->s_fs_info);
 		ffs_data_put(sb->s_fs_info);
 	}
 }
@@ -1312,7 +1422,7 @@
 {
 	struct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);
 	if (unlikely(!ffs))
-		return 0;
+		return NULL;
 
 	ENTER();
 
@@ -1335,14 +1445,14 @@
 	ENTER();
 
 	if (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags))
-		functionfs_closed_callback(ffs);
+		ffs_closed(ffs);
 
 	BUG_ON(ffs->gadget);
 
 	if (ffs->epfiles)
 		ffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);
 
-	kfree(ffs->raw_descs);
+	kfree(ffs->raw_descs_data);
 	kfree(ffs->raw_strings);
 	kfree(ffs->stringtabs);
 }
@@ -1354,14 +1464,15 @@
 	ffs_data_clear(ffs);
 
 	ffs->epfiles = NULL;
+	ffs->raw_descs_data = NULL;
 	ffs->raw_descs = NULL;
 	ffs->raw_strings = NULL;
 	ffs->stringtabs = NULL;
 
 	ffs->raw_descs_length = 0;
-	ffs->raw_fs_descs_length = 0;
 	ffs->fs_descs_count = 0;
 	ffs->hs_descs_count = 0;
+	ffs->ss_descs_count = 0;
 
 	ffs->strings_count = 0;
 	ffs->interfaces_count = 0;
@@ -1397,11 +1508,13 @@
 	ffs->ep0req->context = ffs;
 
 	lang = ffs->stringtabs;
-	for (lang = ffs->stringtabs; *lang; ++lang) {
-		struct usb_string *str = (*lang)->strings;
-		int id = first_id;
-		for (; str->s; ++id, ++str)
-			str->id = id;
+	if (lang) {
+		for (; *lang; ++lang) {
+			struct usb_string *str = (*lang)->strings;
+			int id = first_id;
+			for (; str->s; ++id, ++str)
+				str->id = id;
+		}
 	}
 
 	ffs->gadget = cdev->gadget;
@@ -1417,8 +1530,8 @@
 		usb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);
 		ffs->ep0req = NULL;
 		ffs->gadget = NULL;
-		ffs_data_put(ffs);
 		clear_bit(FFS_FL_BOUND, &ffs->flags);
+		ffs_data_put(ffs);
 	}
 }
 
@@ -1471,71 +1584,6 @@
 	kfree(epfiles);
 }
 
-static int functionfs_bind_config(struct usb_composite_dev *cdev,
-				  struct usb_configuration *c,
-				  struct ffs_data *ffs)
-{
-	struct ffs_function *func;
-	int ret;
-
-	ENTER();
-
-	func = kzalloc(sizeof *func, GFP_KERNEL);
-	if (unlikely(!func))
-		return -ENOMEM;
-
-	func->function.name    = "Function FS Gadget";
-	func->function.strings = ffs->stringtabs;
-
-	func->function.bind    = ffs_func_bind;
-	func->function.unbind  = ffs_func_unbind;
-	func->function.set_alt = ffs_func_set_alt;
-	func->function.disable = ffs_func_disable;
-	func->function.setup   = ffs_func_setup;
-	func->function.suspend = ffs_func_suspend;
-	func->function.resume  = ffs_func_resume;
-
-	func->conf   = c;
-	func->gadget = cdev->gadget;
-	func->ffs = ffs;
-	ffs_data_get(ffs);
-
-	ret = usb_add_function(c, &func->function);
-	if (unlikely(ret))
-		ffs_func_free(func);
-
-	return ret;
-}
-
-static void ffs_func_free(struct ffs_function *func)
-{
-	struct ffs_ep *ep         = func->eps;
-	unsigned count            = func->ffs->eps_count;
-	unsigned long flags;
-
-	ENTER();
-
-	/* cleanup after autoconfig */
-	spin_lock_irqsave(&func->ffs->eps_lock, flags);
-	do {
-		if (ep->ep && ep->req)
-			usb_ep_free_request(ep->ep, ep->req);
-		ep->req = NULL;
-		++ep;
-	} while (--count);
-	spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
-
-	ffs_data_put(func->ffs);
-
-	kfree(func->eps);
-	/*
-	 * eps and interfaces_nums are allocated in the same chunk so
-	 * only one free is required.  Descriptors are also allocated
-	 * in the same chunk.
-	 */
-
-	kfree(func);
-}
 
 static void ffs_func_eps_disable(struct ffs_function *func)
 {
@@ -1569,7 +1617,24 @@
 	spin_lock_irqsave(&func->ffs->eps_lock, flags);
 	do {
 		struct usb_endpoint_descriptor *ds;
-		ds = ep->descs[ep->descs[1] ? 1 : 0];
+		int desc_idx;
+
+		if (ffs->gadget->speed == USB_SPEED_SUPER)
+			desc_idx = 2;
+		else if (ffs->gadget->speed == USB_SPEED_HIGH)
+			desc_idx = 1;
+		else
+			desc_idx = 0;
+
+		/* fall-back to lower speed if desc missing for current speed */
+		do {
+			ds = ep->descs[desc_idx];
+		} while (!ds && --desc_idx >= 0);
+
+		if (!ds) {
+			ret = -EINVAL;
+			break;
+		}
 
 		ep->ep->driver_data = ep;
 		ep->ep->desc = ds;
@@ -1704,6 +1769,12 @@
 	}
 		break;
 
+	case USB_DT_SS_ENDPOINT_COMP:
+		pr_vdebug("EP SS companion descriptor\n");
+		if (length != sizeof(struct usb_ss_ep_comp_descriptor))
+			goto inv_length;
+		break;
+
 	case USB_DT_OTHER_SPEED_CONFIG:
 	case USB_DT_INTERFACE_POWER:
 	case USB_DT_DEBUG:
@@ -1814,60 +1885,76 @@
 static int __ffs_data_got_descs(struct ffs_data *ffs,
 				char *const _data, size_t len)
 {
-	unsigned fs_count, hs_count;
-	int fs_len, ret = -EINVAL;
-	char *data = _data;
+	char *data = _data, *raw_descs;
+	unsigned counts[3], flags;
+	int ret = -EINVAL, i;
 
 	ENTER();
 
-	if (unlikely(get_unaligned_le32(data) != FUNCTIONFS_DESCRIPTORS_MAGIC ||
-		     get_unaligned_le32(data + 4) != len))
+	if (get_unaligned_le32(data + 4) != len)
 		goto error;
-	fs_count = get_unaligned_le32(data +  8);
-	hs_count = get_unaligned_le32(data + 12);
 
-	if (!fs_count && !hs_count)
-		goto einval;
-
-	data += 16;
-	len  -= 16;
-
-	if (likely(fs_count)) {
-		fs_len = ffs_do_descs(fs_count, data, len,
-				      __ffs_data_do_entity, ffs);
-		if (unlikely(fs_len < 0)) {
-			ret = fs_len;
+	switch (get_unaligned_le32(data)) {
+	case FUNCTIONFS_DESCRIPTORS_MAGIC:
+		flags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;
+		data += 8;
+		len  -= 8;
+		break;
+	case FUNCTIONFS_DESCRIPTORS_MAGIC_V2:
+		flags = get_unaligned_le32(data + 8);
+		if (flags & ~(FUNCTIONFS_HAS_FS_DESC |
+			      FUNCTIONFS_HAS_HS_DESC |
+			      FUNCTIONFS_HAS_SS_DESC)) {
+			ret = -ENOSYS;
 			goto error;
 		}
+		data += 12;
+		len  -= 12;
+		break;
+	default:
+		goto error;
+	}
 
-		data += fs_len;
-		len  -= fs_len;
-	} else {
-		fs_len = 0;
+	/* Read fs_count, hs_count and ss_count (if present) */
+	for (i = 0; i < 3; ++i) {
+		if (!(flags & (1 << i))) {
+			counts[i] = 0;
+		} else if (len < 4) {
+			goto error;
+		} else {
+			counts[i] = get_unaligned_le32(data);
+			data += 4;
+			len  -= 4;
+		}
 	}
 
-	if (likely(hs_count)) {
-		ret = ffs_do_descs(hs_count, data, len,
+	/* Read descriptors */
+	raw_descs = data;
+	for (i = 0; i < 3; ++i) {
+		if (!counts[i])
+			continue;
+		ret = ffs_do_descs(counts[i], data, len,
 				   __ffs_data_do_entity, ffs);
-		if (unlikely(ret < 0))
+		if (ret < 0)
 			goto error;
-	} else {
-		ret = 0;
+		data += ret;
+		len  -= ret;
 	}
 
-	if (unlikely(len != ret))
-		goto einval;
+	if (raw_descs == data || len) {
+		ret = -EINVAL;
+		goto error;
+	}
 
-	ffs->raw_fs_descs_length = fs_len;
-	ffs->raw_descs_length    = fs_len + ret;
-	ffs->raw_descs           = _data;
-	ffs->fs_descs_count      = fs_count;
-	ffs->hs_descs_count      = hs_count;
+	ffs->raw_descs_data	= _data;
+	ffs->raw_descs		= raw_descs;
+	ffs->raw_descs_length	= data - raw_descs;
+	ffs->fs_descs_count	= counts[0];
+	ffs->hs_descs_count	= counts[1];
+	ffs->ss_descs_count	= counts[2];
 
 	return 0;
 
-einval:
-	ret = -EINVAL;
 error:
 	kfree(_data);
 	return ret;
@@ -1909,30 +1996,34 @@
 
 	/* Allocate everything in one chunk so there's less maintenance. */
 	{
-		struct {
-			struct usb_gadget_strings *stringtabs[lang_count + 1];
-			struct usb_gadget_strings stringtab[lang_count];
-			struct usb_string strings[lang_count*(needed_count+1)];
-		} *d;
 		unsigned i = 0;
+		vla_group(d);
+		vla_item(d, struct usb_gadget_strings *, stringtabs,
+			lang_count + 1);
+		vla_item(d, struct usb_gadget_strings, stringtab, lang_count);
+		vla_item(d, struct usb_string, strings,
+			lang_count*(needed_count+1));
 
-		d = kmalloc(sizeof *d, GFP_KERNEL);
-		if (unlikely(!d)) {
+		char *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);
+
+		if (unlikely(!vlabuf)) {
 			kfree(_data);
 			return -ENOMEM;
 		}
 
-		stringtabs = d->stringtabs;
-		t = d->stringtab;
+		/* Initialize the VLA pointers */
+		stringtabs = vla_ptr(vlabuf, d, stringtabs);
+		t = vla_ptr(vlabuf, d, stringtab);
 		i = lang_count;
 		do {
 			*stringtabs++ = t++;
 		} while (--i);
 		*stringtabs = NULL;
 
-		stringtabs = d->stringtabs;
-		t = d->stringtab;
-		s = d->strings;
+		/* stringtabs = vlabuf = d_stringtabs for later kfree */
+		stringtabs = vla_ptr(vlabuf, d, stringtabs);
+		t = vla_ptr(vlabuf, d, stringtab);
+		s = vla_ptr(vlabuf, d, strings);
 		strings = s;
 	}
 
@@ -2020,7 +2111,7 @@
 	 * the source does nothing.
 	 */
 	if (ffs->setup_state == FFS_SETUP_PENDING)
-		ffs->setup_state = FFS_SETUP_CANCELED;
+		ffs->setup_state = FFS_SETUP_CANCELLED;
 
 	switch (type) {
 	case FUNCTIONFS_RESUME:
@@ -2081,21 +2172,28 @@
 	struct usb_endpoint_descriptor *ds = (void *)desc;
 	struct ffs_function *func = priv;
 	struct ffs_ep *ffs_ep;
-
-	/*
-	 * If hs_descriptors is not NULL then we are reading hs
-	 * descriptors now
-	 */
-	const int isHS = func->function.hs_descriptors != NULL;
-	unsigned idx;
+	unsigned ep_desc_id, idx;
+	static const char *speed_names[] = { "full", "high", "super" };
 
 	if (type != FFS_DESCRIPTOR)
 		return 0;
 
-	if (isHS)
+	/*
+	 * If ss_descriptors is not NULL, we are reading super speed
+	 * descriptors; if hs_descriptors is not NULL, we are reading high
+	 * speed descriptors; otherwise, we are reading full speed
+	 * descriptors.
+	 */
+	if (func->function.ss_descriptors) {
+		ep_desc_id = 2;
+		func->function.ss_descriptors[(long)valuep] = desc;
+	} else if (func->function.hs_descriptors) {
+		ep_desc_id = 1;
 		func->function.hs_descriptors[(long)valuep] = desc;
-	else
+	} else {
+		ep_desc_id = 0;
 		func->function.fs_descriptors[(long)valuep]    = desc;
+	}
 
 	if (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)
 		return 0;
@@ -2103,13 +2201,13 @@
 	idx = (ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) - 1;
 	ffs_ep = func->eps + idx;
 
-	if (unlikely(ffs_ep->descs[isHS])) {
-		pr_vdebug("two %sspeed descriptors for EP %d\n",
-			  isHS ? "high" : "full",
+	if (unlikely(ffs_ep->descs[ep_desc_id])) {
+		pr_err("two %sspeed descriptors for EP %d\n",
+			  speed_names[ep_desc_id],
 			  ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
 		return -EINVAL;
 	}
-	ffs_ep->descs[isHS] = ds;
+	ffs_ep->descs[ep_desc_id] = ds;
 
 	ffs_dump_mem(": Original  ep desc", ds, ds->bLength);
 	if (ffs_ep->ep) {
@@ -2195,8 +2293,57 @@
 	return 0;
 }
 
-static int ffs_func_bind(struct usb_configuration *c,
-			 struct usb_function *f)
+static inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,
+						struct usb_configuration *c)
+{
+	struct ffs_function *func = ffs_func_from_usb(f);
+	struct f_fs_opts *ffs_opts =
+		container_of(f->fi, struct f_fs_opts, func_inst);
+	int ret;
+
+	ENTER();
+
+	/*
+	 * Legacy gadget triggers binding in functionfs_ready_callback,
+	 * which already uses locking; taking the same lock here would
+	 * cause a deadlock.
+	 *
+	 * Configfs-enabled gadgets however do need ffs_dev_lock.
+	 */
+	if (!ffs_opts->no_configfs)
+		ffs_dev_lock();
+	ret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;
+	func->ffs = ffs_opts->dev->ffs_data;
+	if (!ffs_opts->no_configfs)
+		ffs_dev_unlock();
+	if (ret)
+		return ERR_PTR(ret);
+
+	func->conf = c;
+	func->gadget = c->cdev->gadget;
+
+	ffs_data_get(func->ffs);
+
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to ffs_opts->bound access
+	 */
+	if (!ffs_opts->refcnt) {
+		ret = functionfs_bind(func->ffs, c->cdev);
+		if (ret)
+			return ERR_PTR(ret);
+	}
+	ffs_opts->refcnt++;
+	func->function.strings = func->ffs->stringtabs;
+
+	return ffs_opts;
+}
+
+static int _ffs_func_bind(struct usb_configuration *c,
+			  struct usb_function *f)
 {
 	struct ffs_function *func = ffs_func_from_usb(f);
 	struct ffs_data *ffs = func->ffs;
@@ -2204,42 +2351,54 @@
 	const int full = !!func->ffs->fs_descs_count;
 	const int high = gadget_is_dualspeed(func->gadget) &&
 		func->ffs->hs_descs_count;
+	const int super = gadget_is_superspeed(func->gadget) &&
+		func->ffs->ss_descs_count;
 
-	int ret;
+	int fs_len, hs_len, ret;
 
 	/* Make it a single chunk, less management later on */
-	struct {
-		struct ffs_ep eps[ffs->eps_count];
-		struct usb_descriptor_header
-			*fs_descs[full ? ffs->fs_descs_count + 1 : 0];
-		struct usb_descriptor_header
-			*hs_descs[high ? ffs->hs_descs_count + 1 : 0];
-		short inums[ffs->interfaces_count];
-		char raw_descs[high ? ffs->raw_descs_length
-				    : ffs->raw_fs_descs_length];
-	} *data;
+	vla_group(d);
+	vla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);
+	vla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,
+		full ? ffs->fs_descs_count + 1 : 0);
+	vla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,
+		high ? ffs->hs_descs_count + 1 : 0);
+	vla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,
+		super ? ffs->ss_descs_count + 1 : 0);
+	vla_item_with_sz(d, short, inums, ffs->interfaces_count);
+	vla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);
+	char *vlabuf;
 
 	ENTER();
 
-	/* Only high speed but not supported by gadget? */
-	if (unlikely(!(full | high)))
+	/* Has descriptors only for speeds gadget does not support */
+	if (unlikely(!(full | high | super)))
 		return -ENOTSUPP;
 
-	/* Allocate */
-	data = kmalloc(sizeof *data, GFP_KERNEL);
-	if (unlikely(!data))
+	/* Allocate a single chunk, less management later on */
+	vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);
+	if (unlikely(!vlabuf))
 		return -ENOMEM;
 
 	/* Zero */
-	memset(data->eps, 0, sizeof data->eps);
-	memcpy(data->raw_descs, ffs->raw_descs + 16, sizeof data->raw_descs);
-	memset(data->inums, 0xff, sizeof data->inums);
-	for (ret = ffs->eps_count; ret; --ret)
-		data->eps[ret].num = -1;
-
-	/* Save pointers */
-	func->eps             = data->eps;
-	func->interfaces_nums = data->inums;
+	memset(vla_ptr(vlabuf, d, eps), 0, d_eps__sz);
+	/* Copy descriptors  */
+	memcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs,
+	       ffs->raw_descs_length);
+
+	memset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);
+	for (ret = ffs->eps_count; ret; --ret) {
+		struct ffs_ep *ptr;
+
+		ptr = vla_ptr(vlabuf, d, eps);
+		ptr[ret].num = -1;
+	}
+
+	/* Save pointers
+	 * d_eps == vlabuf, func->eps used to kfree vlabuf later
+	*/
+	func->eps             = vla_ptr(vlabuf, d, eps);
+	func->interfaces_nums = vla_ptr(vlabuf, d, inums);
 
 	/*
 	 * Go through all the endpoint descriptors and allocate
@@ -2247,23 +2406,41 @@
 	 * numbers without worrying that it may be described later on.
 	 */
 	if (likely(full)) {
-		func->function.fs_descriptors = data->fs_descs;
-		ret = ffs_do_descs(ffs->fs_descs_count,
-				   data->raw_descs,
-				   sizeof data->raw_descs,
-				   __ffs_func_bind_do_descs, func);
-		if (unlikely(ret < 0))
+		func->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);
+		fs_len = ffs_do_descs(ffs->fs_descs_count,
+				      vla_ptr(vlabuf, d, raw_descs),
+				      d_raw_descs__sz,
+				      __ffs_func_bind_do_descs, func);
+		if (unlikely(fs_len < 0)) {
+			ret = fs_len;
 			goto error;
+		}
 	} else {
-		ret = 0;
+		fs_len = 0;
 	}
 
 	if (likely(high)) {
-		func->function.hs_descriptors = data->hs_descs;
-		ret = ffs_do_descs(ffs->hs_descs_count,
-				   data->raw_descs + ret,
-				   (sizeof data->raw_descs) - ret,
-				   __ffs_func_bind_do_descs, func);
+		func->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);
+		hs_len = ffs_do_descs(ffs->hs_descs_count,
+				      vla_ptr(vlabuf, d, raw_descs) + fs_len,
+				      d_raw_descs__sz - fs_len,
+				      __ffs_func_bind_do_descs, func);
+		if (unlikely(hs_len < 0)) {
+			ret = hs_len;
+			goto error;
+		}
+	} else {
+		hs_len = 0;
+	}
+
+	if (likely(super)) {
+		func->function.ss_descriptors = vla_ptr(vlabuf, d, ss_descs);
+		ret = ffs_do_descs(ffs->ss_descs_count,
+				vla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,
+				d_raw_descs__sz - fs_len - hs_len,
+				__ffs_func_bind_do_descs, func);
+		if (unlikely(ret < 0))
+			goto error;
 	}
 
 	/*
@@ -2272,8 +2449,9 @@
 	 * now.
 	 */
 	ret = ffs_do_descs(ffs->fs_descs_count +
-			   (high ? ffs->hs_descs_count : 0),
-			   data->raw_descs, sizeof data->raw_descs,
+			   (high ? ffs->hs_descs_count : 0) +
+			   (super ? ffs->ss_descs_count : 0),
+			   vla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,
 			   __ffs_func_bind_do_nums, func);
 	if (unlikely(ret < 0))
 		goto error;
@@ -2287,26 +2465,19 @@
 	return ret;
 }
 
-
-/* Other USB function hooks *************************************************/
-
-static void ffs_func_unbind(struct usb_configuration *c,
-			    struct usb_function *f)
+static int ffs_func_bind(struct usb_configuration *c,
+			 struct usb_function *f)
 {
-	struct ffs_function *func = ffs_func_from_usb(f);
-	struct ffs_data *ffs = func->ffs;
+	struct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);
 
-	ENTER();
+	if (IS_ERR(ffs_opts))
+		return PTR_ERR(ffs_opts);
 
-	if (ffs->func == func) {
-		ffs_func_eps_disable(func);
-		ffs->func = NULL;
-	}
+	return _ffs_func_bind(c, f);
+}
 
-	ffs_event_add(ffs, FUNCTIONFS_UNBIND);
 
-	ffs_func_free(func);
-}
+/* Other USB function hooks *************************************************/
 
 static int ffs_func_set_alt(struct usb_function *f,
 			    unsigned interface, unsigned alt)
@@ -2434,6 +2605,413 @@
 }
 
 
+/* Devices management *******************************************************/
+
+static LIST_HEAD(ffs_devices);
+
+static struct ffs_dev *_ffs_do_find_dev(const char *name)
+{
+	struct ffs_dev *dev;
+
+	list_for_each_entry(dev, &ffs_devices, entry) {
+		if (!dev->name || !name)
+			continue;
+		if (strcmp(dev->name, name) == 0)
+			return dev;
+	}
+
+	return NULL;
+}
+
+/*
+ * ffs_lock must be taken by the caller of this function
+ */
+static struct ffs_dev *_ffs_get_single_dev(void)
+{
+	struct ffs_dev *dev;
+
+	if (list_is_singular(&ffs_devices)) {
+		dev = list_first_entry(&ffs_devices, struct ffs_dev, entry);
+		if (dev->single)
+			return dev;
+	}
+
+	return NULL;
+}
+
+/*
+ * ffs_lock must be taken by the caller of this function
+ */
+static struct ffs_dev *_ffs_find_dev(const char *name)
+{
+	struct ffs_dev *dev;
+
+	dev = _ffs_get_single_dev();
+	if (dev)
+		return dev;
+
+	return _ffs_do_find_dev(name);
+}
+
+/* Configfs support *********************************************************/
+
+static inline struct f_fs_opts *to_ffs_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_fs_opts,
+			    func_inst.group);
+}
+
+static void ffs_attr_release(struct config_item *item)
+{
+	struct f_fs_opts *opts = to_ffs_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations ffs_item_ops = {
+	.release	= ffs_attr_release,
+};
+
+static struct config_item_type ffs_func_type = {
+	.ct_item_ops	= &ffs_item_ops,
+	.ct_owner	= THIS_MODULE,
+};
+
+
+/* Function registration interface ******************************************/
+
+static void ffs_free_inst(struct usb_function_instance *f)
+{
+	struct f_fs_opts *opts;
+
+	opts = to_f_fs_opts(f);
+	ffs_dev_lock();
+	_ffs_free_dev(opts->dev);
+	ffs_dev_unlock();
+	kfree(opts);
+}
+
+#define MAX_INST_NAME_LEN	40
+
+static int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)
+{
+	struct f_fs_opts *opts;
+	char *ptr;
+	const char *tmp;
+	int name_len, ret;
+
+	name_len = strlen(name) + 1;
+	if (name_len > MAX_INST_NAME_LEN)
+		return -ENAMETOOLONG;
+
+	ptr = kstrndup(name, name_len, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	opts = to_f_fs_opts(fi);
+	tmp = NULL;
+
+	ffs_dev_lock();
+
+	tmp = opts->dev->name_allocated ? opts->dev->name : NULL;
+	ret = _ffs_name_dev(opts->dev, ptr);
+	if (ret) {
+		kfree(ptr);
+		ffs_dev_unlock();
+		return ret;
+	}
+	opts->dev->name_allocated = true;
+
+	ffs_dev_unlock();
+
+	kfree(tmp);
+
+	return 0;
+}
+
+static struct usb_function_instance *ffs_alloc_inst(void)
+{
+	struct f_fs_opts *opts;
+	struct ffs_dev *dev;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+
+	opts->func_inst.set_inst_name = ffs_set_inst_name;
+	opts->func_inst.free_func_inst = ffs_free_inst;
+	ffs_dev_lock();
+	dev = _ffs_alloc_dev();
+	ffs_dev_unlock();
+	if (IS_ERR(dev)) {
+		kfree(opts);
+		return ERR_CAST(dev);
+	}
+	opts->dev = dev;
+	dev->opts = opts;
+
+	config_group_init_type_name(&opts->func_inst.group, "",
+				    &ffs_func_type);
+	return &opts->func_inst;
+}
+
+static void ffs_free(struct usb_function *f)
+{
+	kfree(ffs_func_from_usb(f));
+}
+
+static void ffs_func_unbind(struct usb_configuration *c,
+			    struct usb_function *f)
+{
+	struct ffs_function *func = ffs_func_from_usb(f);
+	struct ffs_data *ffs = func->ffs;
+	struct f_fs_opts *opts =
+		container_of(f->fi, struct f_fs_opts, func_inst);
+	struct ffs_ep *ep = func->eps;
+	unsigned count = ffs->eps_count;
+	unsigned long flags;
+
+	ENTER();
+	if (ffs->func == func) {
+		ffs_func_eps_disable(func);
+		ffs->func = NULL;
+	}
+
+	if (!--opts->refcnt)
+		functionfs_unbind(ffs);
+
+	/* cleanup after autoconfig */
+	spin_lock_irqsave(&func->ffs->eps_lock, flags);
+	do {
+		if (ep->ep && ep->req)
+			usb_ep_free_request(ep->ep, ep->req);
+		ep->req = NULL;
+		++ep;
+	} while (--count);
+	spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
+	kfree(func->eps);
+	func->eps = NULL;
+	/*
+	 * eps, descriptors and interfaces_nums are allocated in the
+	 * same chunk so only one free is required.
+	 */
+	func->function.fs_descriptors = NULL;
+	func->function.hs_descriptors = NULL;
+	func->function.ss_descriptors = NULL;
+	func->interfaces_nums = NULL;
+
+	ffs_event_add(ffs, FUNCTIONFS_UNBIND);
+}
+
+static struct usb_function *ffs_alloc(struct usb_function_instance *fi)
+{
+	struct ffs_function *func;
+
+	ENTER();
+
+	func = kzalloc(sizeof(*func), GFP_KERNEL);
+	if (unlikely(!func))
+		return ERR_PTR(-ENOMEM);
+
+	func->function.name    = "Function FS Gadget";
+
+	func->function.bind    = ffs_func_bind;
+	func->function.unbind  = ffs_func_unbind;
+	func->function.set_alt = ffs_func_set_alt;
+	func->function.disable = ffs_func_disable;
+	func->function.setup   = ffs_func_setup;
+	func->function.suspend = ffs_func_suspend;
+	func->function.resume  = ffs_func_resume;
+	func->function.free_func = ffs_free;
+
+	return &func->function;
+}
+
+/*
+ * ffs_lock must be taken by the caller of this function
+ */
+static struct ffs_dev *_ffs_alloc_dev(void)
+{
+	struct ffs_dev *dev;
+	int ret;
+
+	if (_ffs_get_single_dev())
+			return ERR_PTR(-EBUSY);
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	if (list_empty(&ffs_devices)) {
+		ret = functionfs_init();
+		if (ret) {
+			kfree(dev);
+			return ERR_PTR(ret);
+		}
+	}
+
+	list_add(&dev->entry, &ffs_devices);
+
+	return dev;
+}
+
+/*
+ * ffs_lock must be taken by the caller of this function
+ * The caller is responsible for "name" being available whenever f_fs needs it
+ */
+static int _ffs_name_dev(struct ffs_dev *dev, const char *name)
+{
+	struct ffs_dev *existing;
+
+	existing = _ffs_do_find_dev(name);
+	if (existing)
+		return -EBUSY;
+
+	dev->name = name;
+
+	return 0;
+}
+
+/*
+ * The caller is responsible for "name" being available whenever f_fs needs it
+ */
+int ffs_name_dev(struct ffs_dev *dev, const char *name)
+{
+	int ret;
+
+	ffs_dev_lock();
+	ret = _ffs_name_dev(dev, name);
+	ffs_dev_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL(ffs_name_dev);
+
+int ffs_single_dev(struct ffs_dev *dev)
+{
+	int ret;
+
+	ret = 0;
+	ffs_dev_lock();
+
+	if (!list_is_singular(&ffs_devices))
+		ret = -EBUSY;
+	else
+		dev->single = true;
+
+	ffs_dev_unlock();
+	return ret;
+}
+EXPORT_SYMBOL(ffs_single_dev);
+
+/*
+ * ffs_lock must be taken by the caller of this function
+ */
+static void _ffs_free_dev(struct ffs_dev *dev)
+{
+	list_del(&dev->entry);
+	if (dev->name_allocated)
+		kfree(dev->name);
+	kfree(dev);
+	if (list_empty(&ffs_devices))
+		functionfs_cleanup();
+}
+
+static void *ffs_acquire_dev(const char *dev_name)
+{
+	struct ffs_dev *ffs_dev;
+
+	ENTER();
+	ffs_dev_lock();
+
+	ffs_dev = _ffs_find_dev(dev_name);
+	if (!ffs_dev)
+		ffs_dev = ERR_PTR(-ENODEV);
+	else if (ffs_dev->mounted)
+		ffs_dev = ERR_PTR(-EBUSY);
+	else if (ffs_dev->ffs_acquire_dev_callback &&
+	    ffs_dev->ffs_acquire_dev_callback(ffs_dev))
+		ffs_dev = ERR_PTR(-ENODEV);
+	else
+		ffs_dev->mounted = true;
+
+	ffs_dev_unlock();
+	return ffs_dev;
+}
+
+static void ffs_release_dev(struct ffs_data *ffs_data)
+{
+	struct ffs_dev *ffs_dev;
+
+	ENTER();
+	ffs_dev_lock();
+
+	ffs_dev = ffs_data->private_data;
+	if (ffs_dev) {
+		ffs_dev->mounted = false;
+
+		if (ffs_dev->ffs_release_dev_callback)
+			ffs_dev->ffs_release_dev_callback(ffs_dev);
+	}
+
+	ffs_dev_unlock();
+}
+
+static int ffs_ready(struct ffs_data *ffs)
+{
+	struct ffs_dev *ffs_obj;
+	int ret = 0;
+
+	ENTER();
+	ffs_dev_lock();
+
+	ffs_obj = ffs->private_data;
+	if (!ffs_obj) {
+		ret = -EINVAL;
+		goto done;
+	}
+	if (WARN_ON(ffs_obj->desc_ready)) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ffs_obj->desc_ready = true;
+	ffs_obj->ffs_data = ffs;
+
+	if (ffs_obj->ffs_ready_callback)
+		ret = ffs_obj->ffs_ready_callback(ffs);
+
+done:
+	ffs_dev_unlock();
+	return ret;
+}
+
+static void ffs_closed(struct ffs_data *ffs)
+{
+	struct ffs_dev *ffs_obj;
+
+	ENTER();
+	ffs_dev_lock();
+
+	ffs_obj = ffs->private_data;
+	if (!ffs_obj)
+		goto done;
+
+	ffs_obj->desc_ready = false;
+
+	if (ffs_obj->ffs_closed_callback)
+		ffs_obj->ffs_closed_callback(ffs);
+
+	if (!ffs_obj->opts || ffs_obj->opts->no_configfs
+	    || !ffs_obj->opts->func_inst.group.cg_item.ci_parent)
+		goto done;
+
+	unregister_gadget_item(ffs_obj->opts->
+			       func_inst.group.cg_item.ci_parent->ci_parent);
+done:
+	ffs_dev_unlock();
+}
+
 /* Misc helper functions ****************************************************/
 
 static int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)
@@ -2464,3 +3042,7 @@
 
 	return data;
 }
+
+DECLARE_USB_FUNCTION_INIT(ffs, ffs_alloc_inst, ffs_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Nazarewicz");
diff -ur ./drivers/usb/gadget/f_hid.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_hid.c
--- ./drivers/usb/gadget/f_hid.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_hid.c	2023-04-23 12:06:32.667404200 +0100
@@ -20,9 +20,10 @@
 #include <linux/sched.h>
 #include <linux/usb/g_hid.h>
 
+#include "u_f.h"
+
 static int major, minors;
 static struct class *hidg_class;
-
 /*-------------------------------------------------------------------------*/
 /*                            HID gadget struct                            */
 
@@ -160,6 +161,7 @@
 
 /*-------------------------------------------------------------------------*/
 /*                              Char Device                                */
+static inline void hidg_free_ep_req(struct usb_ep *ep, struct usb_request *req);
 
 static ssize_t f_hidg_read(struct file *file, char __user *buffer,
 			size_t count, loff_t *ptr)
@@ -217,8 +219,11 @@
 
 		req->length = hidg->report_length;
 		ret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);
-		if (ret < 0)
-			return ret;
+		if (ret < 0) {
+			ERROR(hidg->func.config->cdev, "hidg out ep queue failed ret %d\n", ret);
+			hidg_free_ep_req(hidg->out_ep, req);
+			return -ENODEV;
+		}
 	}
 
 	return count;
@@ -263,6 +268,7 @@
 		mutex_lock(&hidg->lock);
 	}
 
+
 	count  = min_t(unsigned, count, hidg->report_length);
 	status = copy_from_user(hidg->req->buf, buffer, count);
 
@@ -327,27 +333,26 @@
 		container_of(inode->i_cdev, struct f_hidg, cdev);
 
 	fd->private_data = hidg;
-
 	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
 /*                                usb_function                             */
 
-static struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep, unsigned length)
+static inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,
+						    unsigned length)
 {
-	struct usb_request *req;
+	return alloc_ep_req(ep, length, length);
+}
 
-	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
-	if (req) {
-		req->length = length;
-		req->buf = kmalloc(length, GFP_ATOMIC);
-		if (!req->buf) {
-			usb_ep_free_request(ep, req);
-			req = NULL;
-		}
+static inline void hidg_free_ep_req(struct usb_ep *ep, struct usb_request *req)
+{
+	if (req && req->buf) {
+		kfree(req->buf);
+		req->buf = NULL;
 	}
-	return req;
+	if (req && ep)
+		usb_ep_free_request(ep, req);
 }
 
 static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
@@ -463,6 +468,7 @@
 {
 	struct f_hidg *hidg = func_to_hidg(f);
 	struct f_hidg_req_list *list, *next;
+	unsigned long flags;
 
 	usb_ep_disable(hidg->in_ep);
 	hidg->in_ep->driver_data = NULL;
@@ -470,10 +476,13 @@
 	usb_ep_disable(hidg->out_ep);
 	hidg->out_ep->driver_data = NULL;
 
+	spin_lock_irqsave(&hidg->spinlock, flags);
 	list_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {
+		hidg_free_ep_req(hidg->out_ep, list->req);
 		list_del(&list->list);
 		kfree(list);
 	}
+	spin_unlock_irqrestore(&hidg->spinlock, flags);
 }
 
 static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
@@ -534,9 +543,11 @@
 				req->context  = hidg;
 				status = usb_ep_queue(hidg->out_ep, req,
 						      GFP_ATOMIC);
-				if (status)
+				if (status) {
 					ERROR(cdev, "%s queue req --> %d\n",
-						hidg->out_ep->name, status);
+							hidg->out_ep->name, status);
+					hidg_free_ep_req(hidg->out_ep, req);
+				}
 			} else {
 				usb_ep_disable(hidg->out_ep);
 				hidg->out_ep->driver_data = NULL;
@@ -560,7 +571,11 @@
 	.llseek		= noop_llseek,
 };
 
+#ifdef CONFIG_USB_ANDROID_HID
+static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
+#else
 static int __init hidg_bind(struct usb_configuration *c, struct usb_function *f)
+#endif
 {
 	struct usb_ep		*ep;
 	struct f_hidg		*hidg = func_to_hidg(f);
@@ -656,7 +671,8 @@
 
 	/* disable/free request and end point */
 	usb_ep_disable(hidg->in_ep);
-	usb_ep_dequeue(hidg->in_ep, hidg->req);
+	usb_ep_disable(hidg->out_ep);
+
 	kfree(hidg->req->buf);
 	usb_ep_free_request(hidg->in_ep, hidg->req);
 
@@ -688,9 +704,13 @@
 
 /*-------------------------------------------------------------------------*/
 /*                             usb_configuration                           */
-
+#ifdef CONFIG_USB_ANDROID_HID
+int hidg_bind_config(struct usb_configuration *c,
+			    struct hidg_func_descriptor *fdesc, int index)
+#else
 int __init hidg_bind_config(struct usb_configuration *c,
 			    struct hidg_func_descriptor *fdesc, int index)
+#endif
 {
 	struct f_hidg *hidg;
 	int status;
@@ -739,11 +759,14 @@
 	status = usb_add_function(c, &hidg->func);
 	if (status)
 		kfree(hidg);
-
 	return status;
 }
 
+#ifdef CONFIG_USB_ANDROID_HID
+int ghid_setup(struct usb_gadget *g, int count)
+#else
 int __init ghid_setup(struct usb_gadget *g, int count)
+#endif
 {
 	int status;
 	dev_t dev;
@@ -755,7 +778,6 @@
 		major = MAJOR(dev);
 		minors = count;
 	}
-
 	return status;
 }
 
diff -ur ./drivers/usb/gadget/f_loopback.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_loopback.c
--- ./drivers/usb/gadget/f_loopback.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_loopback.c	2023-04-23 12:06:32.666679200 +0100
@@ -20,6 +20,7 @@
 #include <linux/usb/composite.h>
 
 #include "g_zero.h"
+#include "u_f.h"
 
 /*
  * LOOPBACK FUNCTION ... a testing vehicle for USB peripherals,
@@ -119,7 +120,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 	.bMaxBurst =		0,
@@ -135,7 +136,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 	.bMaxBurst =		0,
@@ -230,6 +231,14 @@
 
 static void lb_free_func(struct usb_function *f)
 {
+	struct f_lb_opts *opts;
+
+	opts = container_of(f->fi, struct f_lb_opts, func_inst);
+
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
+
 	usb_free_all_descriptors(f);
 	kfree(func_to_loop(f));
 }
@@ -293,6 +302,11 @@
 	VDBG(cdev, "%s disabled\n", loop->function.name);
 }
 
+static inline struct usb_request *lb_alloc_ep_req(struct usb_ep *ep, int len)
+{
+	return alloc_ep_req(ep, len, buflen);
+}
+
 static int
 enable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)
 {
@@ -332,7 +346,7 @@
 	 * than 'buflen' bytes each.
 	 */
 	for (i = 0; i < qlen && result == 0; i++) {
-		req = alloc_ep_req(ep, 0);
+		req = lb_alloc_ep_req(ep, 0);
 		if (req) {
 			req->complete = loopback_complete;
 			result = usb_ep_queue(ep, req, GFP_ATOMIC);
@@ -380,6 +394,11 @@
 		return ERR_PTR(-ENOMEM);
 
 	lb_opts = container_of(fi, struct f_lb_opts, func_inst);
+
+	mutex_lock(&lb_opts->lock);
+	lb_opts->refcnt++;
+	mutex_unlock(&lb_opts->lock);
+
 	buflen = lb_opts->bulk_buflen;
 	qlen = lb_opts->qlen;
 	if (!qlen)
@@ -396,6 +415,118 @@
 	return &loop->function;
 }
 
+static inline struct f_lb_opts *to_f_lb_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_lb_opts,
+			    func_inst.group);
+}
+
+CONFIGFS_ATTR_STRUCT(f_lb_opts);
+CONFIGFS_ATTR_OPS(f_lb_opts);
+
+static void lb_attr_release(struct config_item *item)
+{
+	struct f_lb_opts *lb_opts = to_f_lb_opts(item);
+
+	usb_put_function_instance(&lb_opts->func_inst);
+}
+
+static struct configfs_item_operations lb_item_ops = {
+	.release		= lb_attr_release,
+	.show_attribute		= f_lb_opts_attr_show,
+	.store_attribute	= f_lb_opts_attr_store,
+};
+
+static ssize_t f_lb_opts_qlen_show(struct f_lb_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->qlen);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_lb_opts_qlen_store(struct f_lb_opts *opts,
+				    const char *page, size_t len)
+{
+	int ret;
+	u32 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou32(page, 0, &num);
+	if (ret)
+		goto end;
+
+	opts->qlen = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_lb_opts_attribute f_lb_opts_qlen =
+	__CONFIGFS_ATTR(qlen, S_IRUGO | S_IWUSR,
+			f_lb_opts_qlen_show,
+			f_lb_opts_qlen_store);
+
+static ssize_t f_lb_opts_bulk_buflen_show(struct f_lb_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->bulk_buflen);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_lb_opts_bulk_buflen_store(struct f_lb_opts *opts,
+				    const char *page, size_t len)
+{
+	int ret;
+	u32 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou32(page, 0, &num);
+	if (ret)
+		goto end;
+
+	opts->bulk_buflen = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_lb_opts_attribute f_lb_opts_bulk_buflen =
+	__CONFIGFS_ATTR(buflen, S_IRUGO | S_IWUSR,
+			f_lb_opts_bulk_buflen_show,
+			f_lb_opts_bulk_buflen_store);
+
+static struct configfs_attribute *lb_attrs[] = {
+	&f_lb_opts_qlen.attr,
+	&f_lb_opts_bulk_buflen.attr,
+	NULL,
+};
+
+static struct config_item_type lb_func_type = {
+	.ct_item_ops    = &lb_item_ops,
+	.ct_attrs	= lb_attrs,
+	.ct_owner       = THIS_MODULE,
+};
+
 static void lb_free_instance(struct usb_function_instance *fi)
 {
 	struct f_lb_opts *lb_opts;
@@ -411,7 +542,14 @@
 	lb_opts = kzalloc(sizeof(*lb_opts), GFP_KERNEL);
 	if (!lb_opts)
 		return ERR_PTR(-ENOMEM);
+	mutex_init(&lb_opts->lock);
 	lb_opts->func_inst.free_func_inst = lb_free_instance;
+	lb_opts->bulk_buflen = GZERO_BULK_BUFLEN;
+	lb_opts->qlen = GZERO_QLEN;
+
+	config_group_init_type_name(&lb_opts->func_inst.group, "",
+				    &lb_func_type);
+
 	return  &lb_opts->func_inst;
 }
 DECLARE_USB_FUNCTION(Loopback, loopback_alloc_instance, loopback_alloc);
diff -ur ./drivers/usb/gadget/f_mass_storage.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_mass_storage.c
--- ./drivers/usb/gadget/f_mass_storage.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_mass_storage.c	2023-04-23 12:06:32.665854600 +0100
@@ -536,7 +536,7 @@
 		 */
 		DBG(fsg, "bulk reset request\n");
 		raise_exception(fsg->common, FSG_STATE_RESET);
-		return DELAYED_STATUS;
+		return USB_GADGET_DELAYED_STATUS;
 
 	case US_BULK_GET_MAX_LUN:
 		if (ctrl->bRequestType !=
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_mass_storage.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_mtp.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_mtp_slp.c
diff -ur ./drivers/usb/gadget/f_ncm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_ncm.c
--- ./drivers/usb/gadget/f_ncm.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_ncm.c	2023-04-23 12:06:32.741080100 +0100
@@ -16,6 +16,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
 #include <linux/crc32.h>
@@ -23,6 +24,8 @@
 #include <linux/usb/cdc.h>
 
 #include "u_ether.h"
+#include "u_ether_configfs.h"
+#include "u_ncm.h"
 
 /*
  * This function is a "CDC Network Control Model" (CDC NCM) Ethernet link.
@@ -125,7 +128,7 @@
 #define NCM_STATUS_INTERVAL_MS		32
 #define NCM_STATUS_BYTECOUNT		16	/* 8 byte header + data */
 
-static struct usb_interface_assoc_descriptor ncm_iad_desc __initdata = {
+static struct usb_interface_assoc_descriptor ncm_iad_desc = {
 	.bLength =		sizeof ncm_iad_desc,
 	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
 
@@ -139,7 +142,7 @@
 
 /* interface descriptor: */
 
-static struct usb_interface_descriptor ncm_control_intf __initdata = {
+static struct usb_interface_descriptor ncm_control_intf = {
 	.bLength =		sizeof ncm_control_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -151,7 +154,7 @@
 	/* .iInterface = DYNAMIC */
 };
 
-static struct usb_cdc_header_desc ncm_header_desc __initdata = {
+static struct usb_cdc_header_desc ncm_header_desc = {
 	.bLength =		sizeof ncm_header_desc,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
@@ -159,7 +162,7 @@
 	.bcdCDC =		cpu_to_le16(0x0110),
 };
 
-static struct usb_cdc_union_desc ncm_union_desc __initdata = {
+static struct usb_cdc_union_desc ncm_union_desc = {
 	.bLength =		sizeof(ncm_union_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_UNION_TYPE,
@@ -167,7 +170,7 @@
 	/* .bSlaveInterface0 =	DYNAMIC */
 };
 
-static struct usb_cdc_ether_desc ecm_desc __initdata = {
+static struct usb_cdc_ether_desc ecm_desc = {
 	.bLength =		sizeof ecm_desc,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_ETHERNET_TYPE,
@@ -182,7 +185,7 @@
 
 #define NCAPS	(USB_CDC_NCM_NCAP_ETH_FILTER | USB_CDC_NCM_NCAP_CRC_MODE)
 
-static struct usb_cdc_ncm_desc ncm_desc __initdata = {
+static struct usb_cdc_ncm_desc ncm_desc = {
 	.bLength =		sizeof ncm_desc,
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_NCM_TYPE,
@@ -194,7 +197,7 @@
 
 /* the default data interface has no endpoints ... */
 
-static struct usb_interface_descriptor ncm_data_nop_intf __initdata = {
+static struct usb_interface_descriptor ncm_data_nop_intf = {
 	.bLength =		sizeof ncm_data_nop_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -209,7 +212,7 @@
 
 /* ... but the "real" data interface has two bulk endpoints */
 
-static struct usb_interface_descriptor ncm_data_intf __initdata = {
+static struct usb_interface_descriptor ncm_data_intf = {
 	.bLength =		sizeof ncm_data_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
@@ -224,7 +227,7 @@
 
 /* full speed support: */
 
-static struct usb_endpoint_descriptor fs_ncm_notify_desc __initdata = {
+static struct usb_endpoint_descriptor fs_ncm_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -234,7 +237,7 @@
 	.bInterval =		NCM_STATUS_INTERVAL_MS,
 };
 
-static struct usb_endpoint_descriptor fs_ncm_in_desc __initdata = {
+static struct usb_endpoint_descriptor fs_ncm_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -242,7 +245,7 @@
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor fs_ncm_out_desc __initdata = {
+static struct usb_endpoint_descriptor fs_ncm_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -250,7 +253,7 @@
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_descriptor_header *ncm_fs_function[] __initdata = {
+static struct usb_descriptor_header *ncm_fs_function[] = {
 	(struct usb_descriptor_header *) &ncm_iad_desc,
 	/* CDC NCM control descriptors */
 	(struct usb_descriptor_header *) &ncm_control_intf,
@@ -269,7 +272,7 @@
 
 /* high speed support: */
 
-static struct usb_endpoint_descriptor hs_ncm_notify_desc __initdata = {
+static struct usb_endpoint_descriptor hs_ncm_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -278,7 +281,7 @@
 	.wMaxPacketSize =	cpu_to_le16(NCM_STATUS_BYTECOUNT),
 	.bInterval =		USB_MS_TO_HS_INTERVAL(NCM_STATUS_INTERVAL_MS),
 };
-static struct usb_endpoint_descriptor hs_ncm_in_desc __initdata = {
+static struct usb_endpoint_descriptor hs_ncm_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -287,7 +290,7 @@
 	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor hs_ncm_out_desc __initdata = {
+static struct usb_endpoint_descriptor hs_ncm_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -296,7 +299,7 @@
 	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
-static struct usb_descriptor_header *ncm_hs_function[] __initdata = {
+static struct usb_descriptor_header *ncm_hs_function[] = {
 	(struct usb_descriptor_header *) &ncm_iad_desc,
 	/* CDC NCM control descriptors */
 	(struct usb_descriptor_header *) &ncm_control_intf,
@@ -1152,13 +1155,44 @@
 
 /* ethernet function driver setup/binding */
 
-static int __init
-ncm_bind(struct usb_configuration *c, struct usb_function *f)
+static int ncm_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_ncm		*ncm = func_to_ncm(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
+	struct f_ncm_opts	*ncm_opts;
+
+	if (!can_support_ecm(cdev->gadget))
+		return -EINVAL;
+
+	ncm_opts = container_of(f->fi, struct f_ncm_opts, func_inst);
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to ncm_opts->bound access
+	 */
+	if (!ncm_opts->bound) {
+		mutex_lock(&ncm_opts->lock);
+		gether_set_gadget(ncm_opts->net, cdev->gadget);
+		status = gether_register_netdev(ncm_opts->net);
+		mutex_unlock(&ncm_opts->lock);
+		if (status)
+			return status;
+		ncm_opts->bound = true;
+	}
+	us = usb_gstrings_attach(cdev, ncm_strings,
+				 ARRAY_SIZE(ncm_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	ncm_control_intf.iInterface = us[STRING_CTRL_IDX].id;
+	ncm_data_nop_intf.iInterface = us[STRING_DATA_IDX].id;
+	ncm_data_intf.iInterface = us[STRING_DATA_IDX].id;
+	ecm_desc.iMACAddress = us[STRING_MAC_IDX].id;
+	ncm_iad_desc.iFunction = us[STRING_IAD_IDX].id;
 
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
@@ -1259,74 +1293,131 @@
 	return status;
 }
 
-static void
-ncm_unbind(struct usb_configuration *c, struct usb_function *f)
+static inline struct f_ncm_opts *to_f_ncm_opts(struct config_item *item)
 {
-	struct f_ncm		*ncm = func_to_ncm(f);
+	return container_of(to_config_group(item), struct f_ncm_opts,
+			    func_inst.group);
+}
 
-	DBG(c->cdev, "ncm unbind\n");
+/* f_ncm_item_ops */
+USB_ETHERNET_CONFIGFS_ITEM(ncm);
 
-	ncm_string_defs[0].id = 0;
-	usb_free_all_descriptors(f);
+/* f_ncm_opts_dev_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(ncm);
 
-	kfree(ncm->notify_req->buf);
-	usb_ep_free_request(ncm->notify, ncm->notify_req);
+/* f_ncm_opts_host_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(ncm);
+
+/* f_ncm_opts_qmult */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(ncm);
+
+/* f_ncm_opts_ifname */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(ncm);
+
+static struct configfs_attribute *ncm_attrs[] = {
+	&f_ncm_opts_dev_addr.attr,
+	&f_ncm_opts_host_addr.attr,
+	&f_ncm_opts_qmult.attr,
+	&f_ncm_opts_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type ncm_func_type = {
+	.ct_item_ops	= &ncm_item_ops,
+	.ct_attrs	= ncm_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void ncm_free_inst(struct usb_function_instance *f)
+{
+	struct f_ncm_opts *opts;
+
+	opts = container_of(f, struct f_ncm_opts, func_inst);
+	if (opts->bound)
+		gether_cleanup(netdev_priv(opts->net));
+	else
+		free_netdev(opts->net);
+	kfree(opts);
+}
+
+static struct usb_function_instance *ncm_alloc_inst(void)
+{
+	struct f_ncm_opts *opts;
 
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = ncm_free_inst;
+	opts->net = gether_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
+	}
+
+	config_group_init_type_name(&opts->func_inst.group, "", &ncm_func_type);
+
+	return &opts->func_inst;
+}
+
+static void ncm_free(struct usb_function *f)
+{
+	struct f_ncm *ncm;
+	struct f_ncm_opts *opts;
+
+	ncm = func_to_ncm(f);
+	opts = container_of(f->fi, struct f_ncm_opts, func_inst);
 	kfree(ncm);
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
 }
 
-/**
- * ncm_bind_config - add CDC Network link to a configuration
- * @c: the configuration to support the network link
- * @ethaddr: a buffer in which the ethernet address of the host side
- *	side of the link was recorded
- * Context: single threaded during gadget setup
- *
- * Returns zero on success, else negative errno.
- *
- * Caller must have called @gether_setup().  Caller is also responsible
- * for calling @gether_cleanup() before module unload.
- */
-int __init ncm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev)
+static void ncm_unbind(struct usb_configuration *c, struct usb_function *f)
 {
-	struct f_ncm	*ncm;
-	int		status;
+	struct f_ncm *ncm = func_to_ncm(f);
 
-	if (!can_support_ecm(c->cdev->gadget) || !ethaddr)
-		return -EINVAL;
+	DBG(c->cdev, "ncm unbind\n");
 
-	if (ncm_string_defs[0].id == 0) {
-		status = usb_string_ids_tab(c->cdev, ncm_string_defs);
-		if (status < 0)
-			return status;
-		ncm_control_intf.iInterface =
-			ncm_string_defs[STRING_CTRL_IDX].id;
+	usb_free_all_descriptors(f);
 
-		status = ncm_string_defs[STRING_DATA_IDX].id;
-		ncm_data_nop_intf.iInterface = status;
-		ncm_data_intf.iInterface = status;
+	kfree(ncm->notify_req->buf);
+	usb_ep_free_request(ncm->notify, ncm->notify_req);
+}
 
-		ecm_desc.iMACAddress = ncm_string_defs[STRING_MAC_IDX].id;
-		ncm_iad_desc.iFunction = ncm_string_defs[STRING_IAD_IDX].id;
-	}
+static struct usb_function *ncm_alloc(struct usb_function_instance *fi)
+{
+	struct f_ncm		*ncm;
+	struct f_ncm_opts	*opts;
+	int status;
 
 	/* allocate and initialize one new instance */
-	ncm = kzalloc(sizeof *ncm, GFP_KERNEL);
+	ncm = kzalloc(sizeof(*ncm), GFP_KERNEL);
 	if (!ncm)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
+
+	opts = container_of(fi, struct f_ncm_opts, func_inst);
+	mutex_lock(&opts->lock);
+	opts->refcnt++;
 
 	/* export host's Ethernet address in CDC format */
-	snprintf(ncm->ethaddr, sizeof ncm->ethaddr, "%pm", ethaddr);
+	status = gether_get_host_addr_cdc(opts->net, ncm->ethaddr,
+				      sizeof(ncm->ethaddr));
+	if (status < 12) { /* strlen("01234567890a") */
+		kfree(ncm);
+		mutex_unlock(&opts->lock);
+		return ERR_PTR(-EINVAL);
+	}
 	ncm_string_defs[STRING_MAC_IDX].s = ncm->ethaddr;
 
 	spin_lock_init(&ncm->lock);
 	ncm_reset_values(ncm);
-	ncm->port.ioport = dev;
+	ncm->port.ioport = netdev_priv(opts->net);
+	mutex_unlock(&opts->lock);
 	ncm->port.is_fixed = true;
 
 	ncm->port.func.name = "cdc_network";
-	ncm->port.func.strings = ncm_strings;
 	/* descriptors are per-instance copies */
 	ncm->port.func.bind = ncm_bind;
 	ncm->port.func.unbind = ncm_unbind;
@@ -1334,12 +1425,14 @@
 	ncm->port.func.get_alt = ncm_get_alt;
 	ncm->port.func.setup = ncm_setup;
 	ncm->port.func.disable = ncm_disable;
+	ncm->port.func.free_func = ncm_free;
 
 	ncm->port.wrap = ncm_wrap_ntb;
 	ncm->port.unwrap = ncm_unwrap_ntb;
 
-	status = usb_add_function(c, &ncm->port.func);
-	if (status)
-		kfree(ncm);
-	return status;
+	return &ncm->port.func;
 }
+
+DECLARE_USB_FUNCTION_INIT(ncm, ncm_alloc_inst, ncm_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yauheni Kaliuta");
diff -ur ./drivers/usb/gadget/f_obex.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_obex.c
--- ./drivers/usb/gadget/f_obex.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_obex.c	2023-04-23 12:06:32.825017900 +0100
@@ -309,23 +309,20 @@
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_obex		*obex = func_to_obex(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
 
 	if (!can_support_obex(c))
 		return -EINVAL;
 
-	if (obex_string_defs[OBEX_CTRL_IDX].id == 0) {
-		status = usb_string_ids_tab(c->cdev, obex_string_defs);
-		if (status < 0)
-			return status;
-		obex_control_intf.iInterface =
-			obex_string_defs[OBEX_CTRL_IDX].id;
-
-		status = obex_string_defs[OBEX_DATA_IDX].id;
-		obex_data_nop_intf.iInterface = status;
-		obex_data_intf.iInterface = status;
-	}
+	us = usb_gstrings_attach(cdev, obex_strings,
+				 ARRAY_SIZE(obex_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	obex_control_intf.iInterface = us[OBEX_CTRL_IDX].id;
+	obex_data_nop_intf.iInterface = us[OBEX_DATA_IDX].id;
+	obex_data_intf.iInterface = us[OBEX_DATA_IDX].id;
 
 	/* allocate instance-specific interface IDs, and patch descriptors */
 
@@ -554,7 +551,7 @@
 	usb_free_all_descriptors(f);
 }
 
-struct usb_function *obex_alloc(struct usb_function_instance *fi)
+static struct usb_function *obex_alloc(struct usb_function_instance *fi)
 {
 	struct f_obex	*obex;
 	struct f_serial_opts *opts;
diff -ur ./drivers/usb/gadget/f_phonet.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_phonet.c
--- ./drivers/usb/gadget/f_phonet.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_phonet.c	2023-04-23 12:06:32.824372000 +0100
@@ -13,6 +13,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 
 #include <linux/netdevice.h>
@@ -25,6 +26,7 @@
 #include <linux/usb/composite.h>
 
 #include "u_phonet.h"
+#include "u_ether.h"
 
 #define PN_MEDIA_USB	0x1B
 #define MAXPACKET	512
@@ -478,8 +480,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-static __init
-int pn_bind(struct usb_configuration *c, struct usb_function *f)
+static int pn_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct usb_gadget *gadget = cdev->gadget;
@@ -487,6 +488,25 @@
 	struct usb_ep *ep;
 	int status, i;
 
+	struct f_phonet_opts *phonet_opts;
+
+	phonet_opts = container_of(f->fi, struct f_phonet_opts, func_inst);
+
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to phonet_opts->bound access
+	 */
+	if (!phonet_opts->bound) {
+		gphonet_set_gadget(phonet_opts->net, gadget);
+		status = gphonet_register_netdev(phonet_opts->net);
+		if (status)
+			return status;
+		phonet_opts->bound = true;
+	}
+
 	/* Reserve interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -560,8 +580,101 @@
 	return status;
 }
 
-static void
-pn_unbind(struct usb_configuration *c, struct usb_function *f)
+static inline struct f_phonet_opts *to_f_phonet_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_phonet_opts,
+			func_inst.group);
+}
+
+CONFIGFS_ATTR_STRUCT(f_phonet_opts);
+static ssize_t f_phonet_attr_show(struct config_item *item,
+				struct configfs_attribute *attr,
+				char *page)
+{
+	struct f_phonet_opts *opts = to_f_phonet_opts(item);
+	struct f_phonet_opts_attribute *f_phonet_opts_attr =
+		container_of(attr, struct f_phonet_opts_attribute, attr);
+	ssize_t ret = 0;
+
+	if (f_phonet_opts_attr->show)
+		ret = f_phonet_opts_attr->show(opts, page);
+	return ret;
+}
+
+static void phonet_attr_release(struct config_item *item)
+{
+	struct f_phonet_opts *opts = to_f_phonet_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations phonet_item_ops = {
+	.release		= phonet_attr_release,
+	.show_attribute		= f_phonet_attr_show,
+};
+
+static ssize_t f_phonet_ifname_show(struct f_phonet_opts *opts, char *page)
+{
+	return gether_get_ifname(opts->net, page, PAGE_SIZE);
+}
+
+static struct f_phonet_opts_attribute f_phonet_ifname =
+	__CONFIGFS_ATTR_RO(ifname, f_phonet_ifname_show);
+
+static struct configfs_attribute *phonet_attrs[] = {
+	&f_phonet_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type phonet_func_type = {
+	.ct_item_ops	= &phonet_item_ops,
+	.ct_attrs	= phonet_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void phonet_free_inst(struct usb_function_instance *f)
+{
+	struct f_phonet_opts *opts;
+
+	opts = container_of(f, struct f_phonet_opts, func_inst);
+	if (opts->bound)
+		gphonet_cleanup(opts->net);
+	else
+		free_netdev(opts->net);
+	kfree(opts);
+}
+
+static struct usb_function_instance *phonet_alloc_inst(void)
+{
+	struct f_phonet_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+
+	opts->func_inst.free_func_inst = phonet_free_inst;
+	opts->net = gphonet_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
+	}
+
+	config_group_init_type_name(&opts->func_inst.group, "",
+			&phonet_func_type);
+
+	return &opts->func_inst;
+}
+
+static void phonet_free(struct usb_function *f)
+{
+	struct f_phonet *phonet;
+
+	phonet = func_to_pn(f);
+	kfree(phonet);
+}
+
+static void pn_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_phonet *fp = func_to_pn(f);
 	int i;
@@ -574,61 +687,72 @@
 			usb_ep_free_request(fp->out_ep, fp->out_reqv[i]);
 
 	usb_free_all_descriptors(f);
-	kfree(fp);
 }
 
-/*-------------------------------------------------------------------------*/
-
-static struct net_device *dev;
-
-int __init phonet_bind_config(struct usb_configuration *c)
+static struct usb_function *phonet_alloc(struct usb_function_instance *fi)
 {
 	struct f_phonet *fp;
-	int err, size;
+	struct f_phonet_opts *opts;
+	int size;
 
 	size = sizeof(*fp) + (phonet_rxq_size * sizeof(struct usb_request *));
 	fp = kzalloc(size, GFP_KERNEL);
 	if (!fp)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
+
+	opts = container_of(fi, struct f_phonet_opts, func_inst);
 
-	fp->dev = dev;
+	fp->dev = opts->net;
 	fp->function.name = "phonet";
 	fp->function.bind = pn_bind;
 	fp->function.unbind = pn_unbind;
 	fp->function.set_alt = pn_set_alt;
 	fp->function.get_alt = pn_get_alt;
 	fp->function.disable = pn_disconnect;
+	fp->function.free_func = phonet_free;
 	spin_lock_init(&fp->rx.lock);
 
-	err = usb_add_function(c, &fp->function);
-	if (err)
-		kfree(fp);
-	return err;
+	return &fp->function;
 }
 
-int __init gphonet_setup(struct usb_gadget *gadget)
+struct net_device *gphonet_setup_default(void)
 {
+	struct net_device *dev;
 	struct phonet_port *port;
-	int err;
 
 	/* Create net device */
-	BUG_ON(dev);
 	dev = alloc_netdev(sizeof(*port), "upnlink%d", pn_net_setup);
 	if (!dev)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
 	port = netdev_priv(dev);
 	spin_lock_init(&port->lock);
 	netif_carrier_off(dev);
-	SET_NETDEV_DEV(dev, &gadget->dev);
 
-	err = register_netdev(dev);
-	if (err)
-		free_netdev(dev);
-	return err;
+	return dev;
 }
 
-void gphonet_cleanup(void)
+void gphonet_set_gadget(struct net_device *net, struct usb_gadget *g)
+{
+	SET_NETDEV_DEV(net, &g->dev);
+}
+
+int gphonet_register_netdev(struct net_device *net)
+{
+	int status;
+
+	status = register_netdev(net);
+	if (status)
+		free_netdev(net);
+
+	return status;
+}
+
+void gphonet_cleanup(struct net_device *dev)
 {
 	unregister_netdev(dev);
 }
+
+DECLARE_USB_FUNCTION_INIT(phonet, phonet_alloc_inst, phonet_alloc);
+MODULE_AUTHOR("Rémi Denis-Courmont");
+MODULE_LICENSE("GPL");
diff -ur ./drivers/usb/gadget/f_rndis.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_rndis.c
--- ./drivers/usb/gadget/f_rndis.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_rndis.c	2023-04-23 12:06:32.823715400 +0100
@@ -17,15 +17,17 @@
 
 #include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
 
 #include <linux/atomic.h>
 
 #include "u_ether.h"
+#include "u_ether_configfs.h"
+#include "u_rndis.h"
 #include "rndis.h"
 
-
 /*
  * This function is an RNDIS Ethernet port -- a Microsoft protocol that's
  * been promoted instead of the standard CDC Ethernet.  The published RNDIS
@@ -655,6 +657,13 @@
 
 /*-------------------------------------------------------------------------*/
 
+/* Some controllers can't support RNDIS ... */
+static inline bool can_support_rndis(struct usb_configuration *c)
+{
+	/* everything else is *presumably* fine */
+	return true;
+}
+
 /* ethernet function driver setup/binding */
 
 static int
@@ -662,9 +671,40 @@
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_rndis		*rndis = func_to_rndis(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
 
+	struct f_rndis_opts *rndis_opts;
+
+	if (!can_support_rndis(c))
+		return -EINVAL;
+
+	rndis_opts = container_of(f->fi, struct f_rndis_opts, func_inst);
+
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to rndis_opts->bound access
+	 */
+	if (!rndis_opts->bound) {
+		gether_set_gadget(rndis_opts->net, cdev->gadget);
+		status = gether_register_netdev(rndis_opts->net);
+		if (status)
+			return status;
+		rndis_opts->bound = true;
+	}
+
+	us = usb_gstrings_attach(cdev, rndis_strings,
+				 ARRAY_SIZE(rndis_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	rndis_control_intf.iInterface = us[0].id;
+	rndis_data_intf.iInterface = us[1].id;
+	rndis_iad_descriptor.iFunction = us[2].id;
+
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -741,11 +781,6 @@
 	rndis->port.open = rndis_open;
 	rndis->port.close = rndis_close;
 
-	status = rndis_register(rndis_response_available, rndis);
-	if (status < 0)
-		goto fail;
-	rndis->config = status;
-
 	rndis_set_param_medium(rndis->config, RNDIS_MEDIUM_802_3, 0);
 	rndis_set_host_mac(rndis->config, rndis->ethaddr);
 
@@ -787,66 +822,136 @@
 	return status;
 }
 
-static void
-rndis_unbind(struct usb_configuration *c, struct usb_function *f)
+void rndis_borrow_net(struct usb_function_instance *f, struct net_device *net)
 {
-	struct f_rndis		*rndis = func_to_rndis(f);
+	struct f_rndis_opts *opts;
 
-	rndis_deregister(rndis->config);
-	rndis_exit();
+	opts = container_of(f, struct f_rndis_opts, func_inst);
+	if (opts->bound)
+		gether_cleanup(netdev_priv(opts->net));
+	else
+		free_netdev(opts->net);
+	opts->borrowed_net = opts->bound = true;
+	opts->net = net;
+}
+EXPORT_SYMBOL(rndis_borrow_net);
 
-	rndis_string_defs[0].id = 0;
-	usb_free_all_descriptors(f);
+static inline struct f_rndis_opts *to_f_rndis_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_rndis_opts,
+			    func_inst.group);
+}
 
-	kfree(rndis->notify_req->buf);
-	usb_ep_free_request(rndis->notify, rndis->notify_req);
+/* f_rndis_item_ops */
+USB_ETHERNET_CONFIGFS_ITEM(rndis);
 
-	kfree(rndis);
+/* f_rndis_opts_dev_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(rndis);
+
+/* f_rndis_opts_host_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(rndis);
+
+/* f_rndis_opts_qmult */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(rndis);
+
+/* f_rndis_opts_ifname */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(rndis);
+
+static struct configfs_attribute *rndis_attrs[] = {
+	&f_rndis_opts_dev_addr.attr,
+	&f_rndis_opts_host_addr.attr,
+	&f_rndis_opts_qmult.attr,
+	&f_rndis_opts_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type rndis_func_type = {
+	.ct_item_ops	= &rndis_item_ops,
+	.ct_attrs	= rndis_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void rndis_free_inst(struct usb_function_instance *f)
+{
+	struct f_rndis_opts *opts;
+
+	opts = container_of(f, struct f_rndis_opts, func_inst);
+	if (!opts->borrowed_net) {
+		if (opts->bound)
+			gether_cleanup(netdev_priv(opts->net));
+		else
+			free_netdev(opts->net);
+	}
+	kfree(opts);
 }
 
-/* Some controllers can't support RNDIS ... */
-static inline bool can_support_rndis(struct usb_configuration *c)
+static struct usb_function_instance *rndis_alloc_inst(void)
 {
-	/* everything else is *presumably* fine */
-	return true;
+	struct f_rndis_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = rndis_free_inst;
+	opts->net = gether_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
+	}
+
+	config_group_init_type_name(&opts->func_inst.group, "",
+				    &rndis_func_type);
+
+	return &opts->func_inst;
 }
 
-int
-rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		u32 vendorID, const char *manufacturer, struct eth_dev *dev)
+static void rndis_free(struct usb_function *f)
 {
-	struct f_rndis	*rndis;
-	int		status;
+	struct f_rndis *rndis;
+	struct f_rndis_opts *opts;
 
-	if (!can_support_rndis(c) || !ethaddr)
-		return -EINVAL;
+	rndis = func_to_rndis(f);
+	rndis_deregister(rndis->config);
+	opts = container_of(f->fi, struct f_rndis_opts, func_inst);
+	kfree(rndis);
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
+}
 
-	if (rndis_string_defs[0].id == 0) {
-		/* ... and setup RNDIS itself */
-		status = rndis_init();
-		if (status < 0)
-			return status;
+static void rndis_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_rndis		*rndis = func_to_rndis(f);
 
-		status = usb_string_ids_tab(c->cdev, rndis_string_defs);
-		if (status)
-			return status;
+	usb_free_all_descriptors(f);
 
-		rndis_control_intf.iInterface = rndis_string_defs[0].id;
-		rndis_data_intf.iInterface = rndis_string_defs[1].id;
-		rndis_iad_descriptor.iFunction = rndis_string_defs[2].id;
-	}
+	kfree(rndis->notify_req->buf);
+	usb_ep_free_request(rndis->notify, rndis->notify_req);
+}
+
+static struct usb_function *rndis_alloc(struct usb_function_instance *fi)
+{
+	struct f_rndis	*rndis;
+	struct f_rndis_opts *opts;
+	int status;
 
 	/* allocate and initialize one new instance */
-	status = -ENOMEM;
-	rndis = kzalloc(sizeof *rndis, GFP_KERNEL);
+	rndis = kzalloc(sizeof(*rndis), GFP_KERNEL);
 	if (!rndis)
-		goto fail;
+		return ERR_PTR(-ENOMEM);
 
-	memcpy(rndis->ethaddr, ethaddr, ETH_ALEN);
-	rndis->vendorID = vendorID;
-	rndis->manufacturer = manufacturer;
+	opts = container_of(fi, struct f_rndis_opts, func_inst);
+	mutex_lock(&opts->lock);
+	opts->refcnt++;
+
+	gether_get_host_addr_u8(opts->net, rndis->ethaddr);
+	rndis->vendorID = opts->vendor_id;
+	rndis->manufacturer = opts->manufacturer;
 
-	rndis->port.ioport = dev;
+	rndis->port.ioport = netdev_priv(opts->net);
+	mutex_unlock(&opts->lock);
 	/* RNDIS activates when the host changes this filter */
 	rndis->port.cdc_filter = 0;
 
@@ -856,19 +961,44 @@
 	rndis->port.unwrap = rndis_rm_hdr;
 
 	rndis->port.func.name = "rndis";
-	rndis->port.func.strings = rndis_strings;
 	/* descriptors are per-instance copies */
 	rndis->port.func.bind = rndis_bind;
 	rndis->port.func.unbind = rndis_unbind;
 	rndis->port.func.set_alt = rndis_set_alt;
 	rndis->port.func.setup = rndis_setup;
 	rndis->port.func.disable = rndis_disable;
+	rndis->port.func.free_func = rndis_free;
 
-	status = usb_add_function(c, &rndis->port.func);
-	if (status) {
+	status = rndis_register(rndis_response_available, rndis);
+	if (status < 0) {
 		kfree(rndis);
-fail:
-		rndis_exit();
+		return ERR_PTR(status);
 	}
-	return status;
+	rndis->config = status;
+
+	return &rndis->port.func;
 }
+
+DECLARE_USB_FUNCTION(rndis, rndis_alloc_inst, rndis_alloc);
+
+static int __init rndis_mod_init(void)
+{
+	int ret;
+
+	ret = rndis_init();
+	if (ret)
+		return ret;
+
+	return usb_function_register(&rndisusb_func);
+}
+module_init(rndis_mod_init);
+
+static void __exit rndis_mod_exit(void)
+{
+	usb_function_unregister(&rndisusb_func);
+	rndis_exit();
+}
+module_exit(rndis_mod_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: f_sdb.c
diff -ur ./drivers/usb/gadget/f_serial.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_serial.c
--- ./drivers/usb/gadget/f_serial.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_serial.c	2023-04-23 12:06:32.822305800 +0100
@@ -354,7 +354,7 @@
 	usb_free_all_descriptors(f);
 }
 
-struct usb_function *gser_alloc(struct usb_function_instance *fi)
+static struct usb_function *gser_alloc(struct usb_function_instance *fi)
 {
 	struct f_gser	*gser;
 	struct f_serial_opts *opts;
diff -ur ./drivers/usb/gadget/f_sourcesink.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_sourcesink.c
--- ./drivers/usb/gadget/f_sourcesink.c	2023-04-26 12:26:20.650132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_sourcesink.c	2023-04-23 12:06:32.909230000 +0100
@@ -21,6 +21,7 @@
 
 #include "g_zero.h"
 #include "gadget_chips.h"
+#include "u_f.h"
 
 /*
  * SOURCE/SINK FUNCTION ... a primary testing vehicle for USB peripheral
@@ -201,7 +202,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 
@@ -218,7 +219,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 
@@ -236,7 +237,7 @@
 	.bInterval =		4,
 };
 
-struct usb_ss_ep_comp_descriptor ss_iso_source_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_iso_source_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 
@@ -254,7 +255,7 @@
 	.bInterval =		4,
 };
 
-struct usb_ss_ep_comp_descriptor ss_iso_sink_comp_desc = {
+static struct usb_ss_ep_comp_descriptor ss_iso_sink_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 
@@ -301,23 +302,9 @@
 
 /*-------------------------------------------------------------------------*/
 
-struct usb_request *alloc_ep_req(struct usb_ep *ep, int len)
+static inline struct usb_request *ss_alloc_ep_req(struct usb_ep *ep, int len)
 {
-	struct usb_request      *req;
-
-	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
-	if (req) {
-		if (len)
-			req->length = len;
-		else
-			req->length = buflen;
-		req->buf = kmalloc(req->length, GFP_ATOMIC);
-		if (!req->buf) {
-			usb_ep_free_request(ep, req);
-			req = NULL;
-		}
-	}
-	return req;
+	return alloc_ep_req(ep, len, buflen);
 }
 
 void free_ep_req(struct usb_ep *ep, struct usb_request *req)
@@ -490,6 +477,14 @@
 static void
 sourcesink_free_func(struct usb_function *f)
 {
+	struct f_ss_opts *opts;
+
+	opts = container_of(f->fi, struct f_ss_opts, func_inst);
+
+	mutex_lock(&opts->lock);
+	opts->refcnt--;
+	mutex_unlock(&opts->lock);
+
 	usb_free_all_descriptors(f);
 	kfree(func_to_ss(f));
 }
@@ -628,10 +623,10 @@
 				break;
 			}
 			ep = is_in ? ss->iso_in_ep : ss->iso_out_ep;
-			req = alloc_ep_req(ep, size);
+			req = ss_alloc_ep_req(ep, size);
 		} else {
 			ep = is_in ? ss->in_ep : ss->out_ep;
-			req = alloc_ep_req(ep, 0);
+			req = ss_alloc_ep_req(ep, 0);
 		}
 
 		if (!req)
@@ -878,6 +873,11 @@
 		return NULL;
 
 	ss_opts =  container_of(fi, struct f_ss_opts, func_inst);
+
+	mutex_lock(&ss_opts->lock);
+	ss_opts->refcnt++;
+	mutex_unlock(&ss_opts->lock);
+
 	pattern = ss_opts->pattern;
 	isoc_interval = ss_opts->isoc_interval;
 	isoc_maxpacket = ss_opts->isoc_maxpacket;
@@ -898,6 +898,303 @@
 	return &ss->function;
 }
 
+static inline struct f_ss_opts *to_f_ss_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_ss_opts,
+			    func_inst.group);
+}
+
+CONFIGFS_ATTR_STRUCT(f_ss_opts);
+CONFIGFS_ATTR_OPS(f_ss_opts);
+
+static void ss_attr_release(struct config_item *item)
+{
+	struct f_ss_opts *ss_opts = to_f_ss_opts(item);
+
+	usb_put_function_instance(&ss_opts->func_inst);
+}
+
+static struct configfs_item_operations ss_item_ops = {
+	.release		= ss_attr_release,
+	.show_attribute		= f_ss_opts_attr_show,
+	.store_attribute	= f_ss_opts_attr_store,
+};
+
+static ssize_t f_ss_opts_pattern_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->pattern);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_pattern_store(struct f_ss_opts *opts,
+				       const char *page, size_t len)
+{
+	int ret;
+	u8 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou8(page, 0, &num);
+	if (ret)
+		goto end;
+
+	if (num != 0 && num != 1 && num != 2) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	opts->pattern = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_pattern =
+	__CONFIGFS_ATTR(pattern, S_IRUGO | S_IWUSR,
+			f_ss_opts_pattern_show,
+			f_ss_opts_pattern_store);
+
+static ssize_t f_ss_opts_isoc_interval_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->isoc_interval);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_isoc_interval_store(struct f_ss_opts *opts,
+				       const char *page, size_t len)
+{
+	int ret;
+	u8 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou8(page, 0, &num);
+	if (ret)
+		goto end;
+
+	if (num > 16) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	opts->isoc_interval = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_isoc_interval =
+	__CONFIGFS_ATTR(isoc_interval, S_IRUGO | S_IWUSR,
+			f_ss_opts_isoc_interval_show,
+			f_ss_opts_isoc_interval_store);
+
+static ssize_t f_ss_opts_isoc_maxpacket_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->isoc_maxpacket);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_isoc_maxpacket_store(struct f_ss_opts *opts,
+				       const char *page, size_t len)
+{
+	int ret;
+	u16 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou16(page, 0, &num);
+	if (ret)
+		goto end;
+
+	if (num > 1024) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	opts->isoc_maxpacket = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_isoc_maxpacket =
+	__CONFIGFS_ATTR(isoc_maxpacket, S_IRUGO | S_IWUSR,
+			f_ss_opts_isoc_maxpacket_show,
+			f_ss_opts_isoc_maxpacket_store);
+
+static ssize_t f_ss_opts_isoc_mult_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->isoc_mult);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_isoc_mult_store(struct f_ss_opts *opts,
+				       const char *page, size_t len)
+{
+	int ret;
+	u8 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou8(page, 0, &num);
+	if (ret)
+		goto end;
+
+	if (num > 2) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	opts->isoc_mult = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_isoc_mult =
+	__CONFIGFS_ATTR(isoc_mult, S_IRUGO | S_IWUSR,
+			f_ss_opts_isoc_mult_show,
+			f_ss_opts_isoc_mult_store);
+
+static ssize_t f_ss_opts_isoc_maxburst_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->isoc_maxburst);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_isoc_maxburst_store(struct f_ss_opts *opts,
+				       const char *page, size_t len)
+{
+	int ret;
+	u8 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou8(page, 0, &num);
+	if (ret)
+		goto end;
+
+	if (num > 15) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	opts->isoc_maxburst = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_isoc_maxburst =
+	__CONFIGFS_ATTR(isoc_maxburst, S_IRUGO | S_IWUSR,
+			f_ss_opts_isoc_maxburst_show,
+			f_ss_opts_isoc_maxburst_store);
+
+static ssize_t f_ss_opts_bulk_buflen_show(struct f_ss_opts *opts, char *page)
+{
+	int result;
+
+	mutex_lock(&opts->lock);
+	result = sprintf(page, "%d", opts->bulk_buflen);
+	mutex_unlock(&opts->lock);
+
+	return result;
+}
+
+static ssize_t f_ss_opts_bulk_buflen_store(struct f_ss_opts *opts,
+					   const char *page, size_t len)
+{
+	int ret;
+	u32 num;
+
+	mutex_lock(&opts->lock);
+	if (opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = kstrtou32(page, 0, &num);
+	if (ret)
+		goto end;
+
+	opts->bulk_buflen = num;
+	ret = len;
+end:
+	mutex_unlock(&opts->lock);
+	return ret;
+}
+
+static struct f_ss_opts_attribute f_ss_opts_bulk_buflen =
+	__CONFIGFS_ATTR(buflen, S_IRUGO | S_IWUSR,
+			f_ss_opts_bulk_buflen_show,
+			f_ss_opts_bulk_buflen_store);
+
+static struct configfs_attribute *ss_attrs[] = {
+	&f_ss_opts_pattern.attr,
+	&f_ss_opts_isoc_interval.attr,
+	&f_ss_opts_isoc_maxpacket.attr,
+	&f_ss_opts_isoc_mult.attr,
+	&f_ss_opts_isoc_maxburst.attr,
+	&f_ss_opts_bulk_buflen.attr,
+	NULL,
+};
+
+static struct config_item_type ss_func_type = {
+	.ct_item_ops    = &ss_item_ops,
+	.ct_attrs	= ss_attrs,
+	.ct_owner       = THIS_MODULE,
+};
+
 static void source_sink_free_instance(struct usb_function_instance *fi)
 {
 	struct f_ss_opts *ss_opts;
@@ -913,7 +1210,15 @@
 	ss_opts = kzalloc(sizeof(*ss_opts), GFP_KERNEL);
 	if (!ss_opts)
 		return ERR_PTR(-ENOMEM);
+	mutex_init(&ss_opts->lock);
 	ss_opts->func_inst.free_func_inst = source_sink_free_instance;
+	ss_opts->isoc_interval = GZERO_ISOC_INTERVAL;
+	ss_opts->isoc_maxpacket = GZERO_ISOC_MAXPACKET;
+	ss_opts->bulk_buflen = GZERO_BULK_BUFLEN;
+
+	config_group_init_type_name(&ss_opts->func_inst.group, "",
+				    &ss_func_type);
+
 	return &ss_opts->func_inst;
 }
 DECLARE_USB_FUNCTION(SourceSink, source_sink_alloc_inst,
diff -ur ./drivers/usb/gadget/f_subset.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_subset.c
--- ./drivers/usb/gadget/f_subset.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/f_subset.c	2023-04-23 12:06:32.908831400 +0100
@@ -12,11 +12,13 @@
 
 #include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/etherdevice.h>
 
 #include "u_ether.h"
-
+#include "u_ether_configfs.h"
+#include "u_gether.h"
 
 /*
  * This function packages a simple "CDC Subset" Ethernet port with no real
@@ -295,9 +297,39 @@
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_gether		*geth = func_to_geth(f);
+	struct usb_string	*us;
 	int			status;
 	struct usb_ep		*ep;
 
+	struct f_gether_opts	*gether_opts;
+
+	gether_opts = container_of(f->fi, struct f_gether_opts, func_inst);
+
+	/*
+	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
+	 * configurations are bound in sequence with list_for_each_entry,
+	 * in each configuration its functions are bound in sequence
+	 * with list_for_each_entry, so we assume no race condition
+	 * with regard to gether_opts->bound access
+	 */
+	if (!gether_opts->bound) {
+		mutex_lock(&gether_opts->lock);
+		gether_set_gadget(gether_opts->net, cdev->gadget);
+		status = gether_register_netdev(gether_opts->net);
+		mutex_unlock(&gether_opts->lock);
+		if (status)
+			return status;
+		gether_opts->bound = true;
+	}
+
+	us = usb_gstrings_attach(cdev, geth_strings,
+				 ARRAY_SIZE(geth_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+
+	subset_data_intf.iInterface = us[0].id;
+	ether_desc.iMACAddress = us[1].id;
+
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -360,66 +392,128 @@
 	return status;
 }
 
-static void
-geth_unbind(struct usb_configuration *c, struct usb_function *f)
+static inline struct f_gether_opts *to_f_gether_opts(struct config_item *item)
 {
-	geth_string_defs[0].id = 0;
-	usb_free_all_descriptors(f);
-	kfree(func_to_geth(f));
+	return container_of(to_config_group(item), struct f_gether_opts,
+			    func_inst.group);
 }
 
-/**
- * geth_bind_config - add CDC Subset network link to a configuration
- * @c: the configuration to support the network link
- * @ethaddr: a buffer in which the ethernet address of the host side
- *	side of the link was recorded
- * @dev: eth_dev structure
- * Context: single threaded during gadget setup
- *
- * Returns zero on success, else negative errno.
- *
- * Caller must have called @gether_setup().  Caller is also responsible
- * for calling @gether_cleanup() before module unload.
- */
-int geth_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev)
+/* f_gether_item_ops */
+USB_ETHERNET_CONFIGFS_ITEM(gether);
+
+/* f_gether_opts_dev_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(gether);
+
+/* f_gether_opts_host_addr */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(gether);
+
+/* f_gether_opts_qmult */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(gether);
+
+/* f_gether_opts_ifname */
+USB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(gether);
+
+static struct configfs_attribute *gether_attrs[] = {
+	&f_gether_opts_dev_addr.attr,
+	&f_gether_opts_host_addr.attr,
+	&f_gether_opts_qmult.attr,
+	&f_gether_opts_ifname.attr,
+	NULL,
+};
+
+static struct config_item_type gether_func_type = {
+	.ct_item_ops	= &gether_item_ops,
+	.ct_attrs	= gether_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void geth_free_inst(struct usb_function_instance *f)
 {
-	struct f_gether	*geth;
-	int		status;
+	struct f_gether_opts *opts;
 
-	if (!ethaddr)
-		return -EINVAL;
+	opts = container_of(f, struct f_gether_opts, func_inst);
+	if (opts->bound)
+		gether_cleanup(netdev_priv(opts->net));
+	else
+		free_netdev(opts->net);
+	kfree(opts);
+}
 
-	/* maybe allocate device-global string IDs */
-	if (geth_string_defs[0].id == 0) {
-		status = usb_string_ids_tab(c->cdev, geth_string_defs);
-		if (status < 0)
-			return status;
-		subset_data_intf.iInterface = geth_string_defs[0].id;
-		ether_desc.iMACAddress = geth_string_defs[1].id;
+static struct usb_function_instance *geth_alloc_inst(void)
+{
+	struct f_gether_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = geth_free_inst;
+	opts->net = gether_setup_default();
+	if (IS_ERR(opts->net)) {
+		struct net_device *net = opts->net;
+		kfree(opts);
+		return ERR_CAST(net);
 	}
 
+	config_group_init_type_name(&opts->func_inst.group, "",
+				    &gether_func_type);
+
+	return &opts->func_inst;
+}
+
+static void geth_free(struct usb_function *f)
+{
+	struct f_gether *eth;
+
+	eth = func_to_geth(f);
+	kfree(eth);
+}
+
+static void geth_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	geth_string_defs[0].id = 0;
+	usb_free_all_descriptors(f);
+}
+
+static struct usb_function *geth_alloc(struct usb_function_instance *fi)
+{
+	struct f_gether	*geth;
+	struct f_gether_opts *opts;
+	int status;
+
 	/* allocate and initialize one new instance */
-	geth = kzalloc(sizeof *geth, GFP_KERNEL);
+	geth = kzalloc(sizeof(*geth), GFP_KERNEL);
 	if (!geth)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
+
+	opts = container_of(fi, struct f_gether_opts, func_inst);
 
+	mutex_lock(&opts->lock);
+	opts->refcnt++;
 	/* export host's Ethernet address in CDC format */
-	snprintf(geth->ethaddr, sizeof geth->ethaddr, "%pm", ethaddr);
+	status = gether_get_host_addr_cdc(opts->net, geth->ethaddr,
+					  sizeof(geth->ethaddr));
+	if (status < 12) {
+		kfree(geth);
+		mutex_unlock(&opts->lock);
+		return ERR_PTR(-EINVAL);
+	}
 	geth_string_defs[1].s = geth->ethaddr;
 
-	geth->port.ioport = dev;
+	geth->port.ioport = netdev_priv(opts->net);
+	mutex_unlock(&opts->lock);
 	geth->port.cdc_filter = DEFAULT_FILTER;
 
 	geth->port.func.name = "cdc_subset";
-	geth->port.func.strings = geth_strings;
 	geth->port.func.bind = geth_bind;
 	geth->port.func.unbind = geth_unbind;
 	geth->port.func.set_alt = geth_set_alt;
 	geth->port.func.disable = geth_disable;
+	geth->port.func.free_func = geth_free;
 
-	status = usb_add_function(c, &geth->port.func);
-	if (status)
-		kfree(geth);
-	return status;
+	return &geth->port.func;
 }
+
+DECLARE_USB_FUNCTION_INIT(geth, geth_alloc_inst, geth_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
diff -ur ./drivers/usb/gadget/gadget_chips.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/gadget_chips.h
--- ./drivers/usb/gadget/gadget_chips.h	2023-04-26 12:26:20.660132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/gadget_chips.h	2023-04-23 12:06:33.151513400 +0100
@@ -33,6 +33,7 @@
 #define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
 #define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
 #define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
+#define gadget_is_dwc2(g)		(!strcmp("dwc2-gadget", (g)->name))
 
 /**
  * gadget_supports_altsettings - return true if altsettings work
diff -ur ./drivers/usb/gadget/multi.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/multi.c
--- ./drivers/usb/gadget/multi.c	2023-04-26 12:56:07.760118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/multi.c	2023-04-23 12:06:33.460713700 +0100
@@ -15,6 +15,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/netdevice.h>
 
 #include "u_serial.h"
 #if defined USB_ETH_RNDIS
@@ -32,27 +33,19 @@
 MODULE_LICENSE("GPL");
 
 
-/***************************** All the files... *****************************/
+#include "f_mass_storage.h"
 
-/*
- * kbuild is not very cooperative with respect to linking separately
- * compiled library objects into one module.  So for now we won't use
- * separate compilation ... ensuring init/exit sections work to shrink
- * the runtime footprint, and giving us at least some parts of what
- * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
- */
-#include "f_mass_storage.c"
-
-#include "f_ecm.c"
-#include "f_subset.c"
+#include "u_ecm.h"
 #ifdef USB_ETH_RNDIS
-#  include "f_rndis.c"
-#  include "rndis.c"
+#  include "u_rndis.h"
+#  include "rndis.h"
 #endif
-#include "u_ether.c"
+#include "u_ether.h"
 
 USB_GADGET_COMPOSITE_OPTIONS();
 
+USB_ETHERNET_MODULE_PARAMETERS();
+
 /***************************** Device Descriptor ****************************/
 
 #define MULTI_VENDOR_NUM	0x1d6b	/* Linux Foundation */
@@ -129,22 +122,36 @@
 /****************************** Configurations ******************************/
 
 static struct fsg_module_parameters fsg_mod_data = { .stall = 1 };
-FSG_MODULE_PARAMETERS(/* no prefix */, fsg_mod_data);
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;
+
+#else
 
-static struct fsg_common fsg_common;
+/*
+ * Number of buffers we will use.
+ * 2 is usually enough for good buffering pipeline
+ */
+#define fsg_num_buffers	CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS
 
-static u8 hostaddr[ETH_ALEN];
+#endif /* CONFIG_USB_GADGET_DEBUG_FILES */
+
+FSG_MODULE_PARAMETERS(/* no prefix */, fsg_mod_data);
 
 static struct usb_function_instance *fi_acm;
-static struct eth_dev *the_dev;
+static struct usb_function_instance *fi_msg;
 
 /********** RNDIS **********/
 
 #ifdef USB_ETH_RNDIS
+static struct usb_function_instance *fi_rndis;
 static struct usb_function *f_acm_rndis;
+static struct usb_function *f_rndis;
+static struct usb_function *f_msg_rndis;
 
 static __init int rndis_do_config(struct usb_configuration *c)
 {
+	struct fsg_opts *fsg_opts;
 	int ret;
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -152,9 +159,13 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	ret = rndis_bind_config(c, hostaddr, the_dev);
+	f_rndis = usb_get_function(fi_rndis);
+	if (IS_ERR(f_rndis))
+		return PTR_ERR(f_rndis);
+
+	ret = usb_add_function(c, f_rndis);
 	if (ret < 0)
-		return ret;
+		goto err_func_rndis;
 
 	f_acm_rndis = usb_get_function(fi_acm);
 	if (IS_ERR(f_acm_rndis)) {
@@ -166,20 +177,36 @@
 	if (ret)
 		goto err_conf;
 
-	ret = fsg_bind_config(c->cdev, c, &fsg_common);
-	if (ret < 0)
+	f_msg_rndis = usb_get_function(fi_msg);
+	if (IS_ERR(f_msg_rndis)) {
+		ret = PTR_ERR(f_msg_rndis);
 		goto err_fsg;
+	}
+
+	fsg_opts = fsg_opts_from_func_inst(fi_msg);
+	ret = fsg_common_run_thread(fsg_opts->common);
+	if (ret)
+		goto err_run;
+
+	ret = usb_add_function(c, f_msg_rndis);
+	if (ret)
+		goto err_run;
 
 	return 0;
+err_run:
+	usb_put_function(f_msg_rndis);
 err_fsg:
 	usb_remove_function(c, f_acm_rndis);
 err_conf:
 	usb_put_function(f_acm_rndis);
 err_func_acm:
+	usb_remove_function(c, f_rndis);
+err_func_rndis:
+	usb_put_function(f_rndis);
 	return ret;
 }
 
-static int rndis_config_register(struct usb_composite_dev *cdev)
+static __ref int rndis_config_register(struct usb_composite_dev *cdev)
 {
 	static struct usb_configuration config = {
 		.bConfigurationValue	= MULTI_RNDIS_CONFIG_NUM,
@@ -194,7 +221,7 @@
 
 #else
 
-static int rndis_config_register(struct usb_composite_dev *cdev)
+static __ref int rndis_config_register(struct usb_composite_dev *cdev)
 {
 	return 0;
 }
@@ -205,10 +232,14 @@
 /********** CDC ECM **********/
 
 #ifdef CONFIG_USB_G_MULTI_CDC
+static struct usb_function_instance *fi_ecm;
 static struct usb_function *f_acm_multi;
+static struct usb_function *f_ecm;
+static struct usb_function *f_msg_multi;
 
 static __init int cdc_do_config(struct usb_configuration *c)
 {
+	struct fsg_opts *fsg_opts;
 	int ret;
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -216,33 +247,55 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	ret = ecm_bind_config(c, hostaddr, the_dev);
+	f_ecm = usb_get_function(fi_ecm);
+	if (IS_ERR(f_ecm))
+		return PTR_ERR(f_ecm);
+
+	ret = usb_add_function(c, f_ecm);
 	if (ret < 0)
-		return ret;
+		goto err_func_ecm;
 
 	/* implicit port_num is zero */
 	f_acm_multi = usb_get_function(fi_acm);
-	if (IS_ERR(f_acm_multi))
+	if (IS_ERR(f_acm_multi)) {
+		ret = PTR_ERR(f_acm_multi);
 		goto err_func_acm;
+	}
 
 	ret = usb_add_function(c, f_acm_multi);
 	if (ret)
 		goto err_conf;
 
-	ret = fsg_bind_config(c->cdev, c, &fsg_common);
-	if (ret < 0)
+	f_msg_multi = usb_get_function(fi_msg);
+	if (IS_ERR(f_msg_multi)) {
+		ret = PTR_ERR(f_msg_multi);
 		goto err_fsg;
+	}
+
+	fsg_opts = fsg_opts_from_func_inst(fi_msg);
+	ret = fsg_common_run_thread(fsg_opts->common);
+	if (ret)
+		goto err_run;
+
+	ret = usb_add_function(c, f_msg_multi);
+	if (ret)
+		goto err_run;
 
 	return 0;
+err_run:
+	usb_put_function(f_msg_multi);
 err_fsg:
 	usb_remove_function(c, f_acm_multi);
 err_conf:
 	usb_put_function(f_acm_multi);
 err_func_acm:
+	usb_remove_function(c, f_ecm);
+err_func_ecm:
+	usb_put_function(f_ecm);
 	return ret;
 }
 
-static int cdc_config_register(struct usb_composite_dev *cdev)
+static __ref int cdc_config_register(struct usb_composite_dev *cdev)
 {
 	static struct usb_configuration config = {
 		.bConfigurationValue	= MULTI_CDC_CONFIG_NUM,
@@ -257,7 +310,7 @@
 
 #else
 
-static int cdc_config_register(struct usb_composite_dev *cdev)
+static __ref int cdc_config_register(struct usb_composite_dev *cdev)
 {
 	return 0;
 }
@@ -271,18 +324,67 @@
 static int __ref multi_bind(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget *gadget = cdev->gadget;
+#ifdef CONFIG_USB_G_MULTI_CDC
+	struct f_ecm_opts *ecm_opts;
+#endif
+#ifdef USB_ETH_RNDIS
+	struct f_rndis_opts *rndis_opts;
+#endif
+	struct fsg_opts *fsg_opts;
+	struct fsg_config config;
 	int status;
 
 	if (!can_support_ecm(cdev->gadget)) {
 		dev_err(&gadget->dev, "controller '%s' not usable\n",
-		        gadget->name);
+			gadget->name);
 		return -EINVAL;
 	}
 
-	/* set up network link layer */
-	the_dev = gether_setup(cdev->gadget, hostaddr);
-	if (IS_ERR(the_dev))
-		return PTR_ERR(the_dev);
+#ifdef CONFIG_USB_G_MULTI_CDC
+	fi_ecm = usb_get_function_instance("ecm");
+	if (IS_ERR(fi_ecm))
+		return PTR_ERR(fi_ecm);
+
+	ecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);
+
+	gether_set_qmult(ecm_opts->net, qmult);
+	if (!gether_set_host_addr(ecm_opts->net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(ecm_opts->net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
+#endif
+
+#ifdef USB_ETH_RNDIS
+	fi_rndis = usb_get_function_instance("rndis");
+	if (IS_ERR(fi_rndis)) {
+		status = PTR_ERR(fi_rndis);
+		goto fail;
+	}
+
+	rndis_opts = container_of(fi_rndis, struct f_rndis_opts, func_inst);
+
+	gether_set_qmult(rndis_opts->net, qmult);
+	if (!gether_set_host_addr(rndis_opts->net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(rndis_opts->net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
+#endif
+
+#if (defined CONFIG_USB_G_MULTI_CDC && defined USB_ETH_RNDIS)
+	/*
+	 * If both ecm and rndis are selected then:
+	 *	1) rndis borrows the net interface from ecm
+	 *	2) since the interface is shared it must not be bound
+	 *	twice - in ecm's _and_ rndis' binds, so do it here.
+	 */
+	gether_set_gadget(ecm_opts->net, cdev->gadget);
+	status = gether_register_netdev(ecm_opts->net);
+	if (status)
+		goto fail0;
+
+	rndis_borrow_net(fi_rndis, ecm_opts->net);
+	ecm_opts->bound = true;
+#endif
 
 	/* set up serial link layer */
 	fi_acm = usb_get_function_instance("acm");
@@ -292,57 +394,102 @@
 	}
 
 	/* set up mass storage function */
-	{
-		void *retp;
-		retp = fsg_common_from_params(&fsg_common, cdev, &fsg_mod_data);
-		if (IS_ERR(retp)) {
-			status = PTR_ERR(retp);
-			goto fail1;
-		}
+	fi_msg = usb_get_function_instance("mass_storage");
+	if (IS_ERR(fi_msg)) {
+		status = PTR_ERR(fi_msg);
+		goto fail1;
 	}
+	fsg_config_from_params(&config, &fsg_mod_data, fsg_num_buffers);
+	fsg_opts = fsg_opts_from_func_inst(fi_msg);
+
+	fsg_opts->no_configfs = true;
+	status = fsg_common_set_num_buffers(fsg_opts->common, fsg_num_buffers);
+	if (status)
+		goto fail2;
+
+	status = fsg_common_set_nluns(fsg_opts->common, config.nluns);
+	if (status)
+		goto fail_set_nluns;
+
+	status = fsg_common_set_cdev(fsg_opts->common, cdev, config.can_stall);
+	if (status)
+		goto fail_set_cdev;
+
+	fsg_common_set_sysfs(fsg_opts->common, true);
+	status = fsg_common_create_luns(fsg_opts->common, &config);
+	if (status)
+		goto fail_set_cdev;
+
+	fsg_common_set_inquiry_string(fsg_opts->common, config.vendor_name,
+				      config.product_name);
 
 	/* allocate string IDs */
 	status = usb_string_ids_tab(cdev, strings_dev);
 	if (unlikely(status < 0))
-		goto fail2;
+		goto fail_string_ids;
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 
 	/* register configurations */
 	status = rndis_config_register(cdev);
 	if (unlikely(status < 0))
-		goto fail2;
+		goto fail_string_ids;
 
 	status = cdc_config_register(cdev);
 	if (unlikely(status < 0))
-		goto fail2;
+		goto fail_string_ids;
 	usb_composite_overwrite_options(cdev, &coverwrite);
 
 	/* we're done */
 	dev_info(&gadget->dev, DRIVER_DESC "\n");
-	fsg_common_put(&fsg_common);
 	return 0;
 
 
 	/* error recovery */
+fail_string_ids:
+	fsg_common_remove_luns(fsg_opts->common);
+fail_set_cdev:
+	fsg_common_free_luns(fsg_opts->common);
+fail_set_nluns:
+	fsg_common_free_buffers(fsg_opts->common);
 fail2:
-	fsg_common_put(&fsg_common);
+	usb_put_function_instance(fi_msg);
 fail1:
 	usb_put_function_instance(fi_acm);
 fail0:
-	gether_cleanup(the_dev);
+#ifdef USB_ETH_RNDIS
+	usb_put_function_instance(fi_rndis);
+fail:
+#endif
+#ifdef CONFIG_USB_G_MULTI_CDC
+	usb_put_function_instance(fi_ecm);
+#endif
 	return status;
 }
 
 static int __exit multi_unbind(struct usb_composite_dev *cdev)
 {
 #ifdef CONFIG_USB_G_MULTI_CDC
+	usb_put_function(f_msg_multi);
+#endif
+#ifdef USB_ETH_RNDIS
+	usb_put_function(f_msg_rndis);
+#endif
+	usb_put_function_instance(fi_msg);
+#ifdef CONFIG_USB_G_MULTI_CDC
 	usb_put_function(f_acm_multi);
 #endif
 #ifdef USB_ETH_RNDIS
 	usb_put_function(f_acm_rndis);
 #endif
 	usb_put_function_instance(fi_acm);
-	gether_cleanup(the_dev);
+#ifdef USB_ETH_RNDIS
+	usb_put_function(f_rndis);
+	usb_put_function_instance(fi_rndis);
+#endif
+#ifdef CONFIG_USB_G_MULTI_CDC
+	usb_put_function(f_ecm);
+	usb_put_function_instance(fi_ecm);
+#endif
 	return 0;
 }
 
diff -ur ./drivers/usb/gadget/ncm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/ncm.c
--- ./drivers/usb/gadget/ncm.c	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/ncm.c	2023-04-23 12:06:33.540276100 +0100
@@ -24,23 +24,12 @@
 #include <linux/usb/composite.h>
 
 #include "u_ether.h"
+#include "u_ncm.h"
 
 #define DRIVER_DESC		"NCM Gadget"
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * Kbuild is not very cooperative with respect to linking separately
- * compiled library objects into one module.  So for now we won't use
- * separate compilation ... ensuring init/exit sections work to shrink
- * the runtime footprint, and giving us at least some parts of what
- * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
- */
-#include "f_ncm.c"
-#include "u_ether.c"
-
-/*-------------------------------------------------------------------------*/
-
 /* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
@@ -54,6 +43,8 @@
 /*-------------------------------------------------------------------------*/
 USB_GADGET_COMPOSITE_OPTIONS();
 
+USB_ETHERNET_MODULE_PARAMETERS();
+
 static struct usb_device_descriptor device_desc = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
@@ -111,13 +102,15 @@
 	NULL,
 };
 
-struct eth_dev *the_dev;
-static u8 hostaddr[ETH_ALEN];
+static struct usb_function_instance *f_ncm_inst;
+static struct usb_function *f_ncm;
 
 /*-------------------------------------------------------------------------*/
 
 static int __init ncm_do_config(struct usb_configuration *c)
 {
+	int status;
+
 	/* FIXME alloc iConfiguration string, set it in c->strings */
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -125,7 +118,19 @@
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	return ncm_bind_config(c, hostaddr, the_dev);
+	f_ncm = usb_get_function(f_ncm_inst);
+	if (IS_ERR(f_ncm)) {
+		status = PTR_ERR(f_ncm);
+		return status;
+	}
+
+	status = usb_add_function(c, f_ncm);
+	if (status < 0) {
+		usb_put_function(f_ncm);
+		return status;
+	}
+
+	return 0;
 }
 
 static struct usb_configuration ncm_config_driver = {
@@ -141,12 +146,20 @@
 static int __init gncm_bind(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget	*gadget = cdev->gadget;
+	struct f_ncm_opts	*ncm_opts;
 	int			status;
 
-	/* set up network link layer */
-	the_dev = gether_setup(cdev->gadget, hostaddr);
-	if (IS_ERR(the_dev))
-		return PTR_ERR(the_dev);
+	f_ncm_inst = usb_get_function_instance("ncm");
+	if (IS_ERR(f_ncm_inst))
+		return PTR_ERR(f_ncm_inst);
+
+	ncm_opts = container_of(f_ncm_inst, struct f_ncm_opts, func_inst);
+
+	gether_set_qmult(ncm_opts->net, qmult);
+	if (!gether_set_host_addr(ncm_opts->net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(ncm_opts->net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
 
 	/* Allocate string descriptor numbers ... note that string
 	 * contents can be overridden by the composite_dev glue.
@@ -169,13 +182,16 @@
 	return 0;
 
 fail:
-	gether_cleanup(the_dev);
+	usb_put_function_instance(f_ncm_inst);
 	return status;
 }
 
 static int __exit gncm_unbind(struct usb_composite_dev *cdev)
 {
-	gether_cleanup(the_dev);
+	if (!IS_ERR_OR_NULL(f_ncm))
+		usb_put_function(f_ncm);
+	if (!IS_ERR_OR_NULL(f_ncm_inst))
+		usb_put_function_instance(f_ncm_inst);
 	return 0;
 }
 
diff -ur ./drivers/usb/gadget/rndis.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/rndis.c
--- ./drivers/usb/gadget/rndis.c	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/rndis.c	2023-04-23 12:06:33.945483200 +0100
@@ -761,6 +761,7 @@
 	return rndis_indicate_status_msg(configNr,
 					  RNDIS_STATUS_MEDIA_CONNECT);
 }
+EXPORT_SYMBOL(rndis_signal_connect);
 
 int rndis_signal_disconnect(int configNr)
 {
@@ -769,6 +770,7 @@
 	return rndis_indicate_status_msg(configNr,
 					  RNDIS_STATUS_MEDIA_DISCONNECT);
 }
+EXPORT_SYMBOL(rndis_signal_disconnect);
 
 void rndis_uninit(int configNr)
 {
@@ -783,11 +785,13 @@
 	while ((buf = rndis_get_next_response(configNr, &length)))
 		rndis_free_response(configNr, buf);
 }
+EXPORT_SYMBOL(rndis_uninit);
 
 void rndis_set_host_mac(int configNr, const u8 *addr)
 {
 	rndis_per_dev_params[configNr].host_mac = addr;
 }
+EXPORT_SYMBOL(rndis_set_host_mac);
 
 /*
  * Message Parser
@@ -870,6 +874,7 @@
 
 	return -ENOTSUPP;
 }
+EXPORT_SYMBOL(rndis_msg_parser);
 
 int rndis_register(void (*resp_avail)(void *v), void *v)
 {
@@ -891,6 +896,7 @@
 
 	return -ENODEV;
 }
+EXPORT_SYMBOL(rndis_register);
 
 void rndis_deregister(int configNr)
 {
@@ -899,6 +905,7 @@
 	if (configNr >= RNDIS_MAX_CONFIGS) return;
 	rndis_per_dev_params[configNr].used = 0;
 }
+EXPORT_SYMBOL(rndis_deregister);
 
 int rndis_set_param_dev(u8 configNr, struct net_device *dev, u16 *cdc_filter)
 {
@@ -912,6 +919,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(rndis_set_param_dev);
 
 int rndis_set_param_vendor(u8 configNr, u32 vendorID, const char *vendorDescr)
 {
@@ -924,6 +932,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(rndis_set_param_vendor);
 
 int rndis_set_param_medium(u8 configNr, u32 medium, u32 speed)
 {
@@ -935,6 +944,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(rndis_set_param_medium);
 
 void rndis_add_hdr(struct sk_buff *skb)
 {
@@ -949,6 +959,7 @@
 	header->DataOffset = cpu_to_le32(36);
 	header->DataLength = cpu_to_le32(skb->len - sizeof(*header));
 }
+EXPORT_SYMBOL(rndis_add_hdr);
 
 void rndis_free_response(int configNr, u8 *buf)
 {
@@ -965,6 +976,7 @@
 		}
 	}
 }
+EXPORT_SYMBOL(rndis_free_response);
 
 u8 *rndis_get_next_response(int configNr, u32 *length)
 {
@@ -986,6 +998,7 @@
 
 	return NULL;
 }
+EXPORT_SYMBOL(rndis_get_next_response);
 
 static rndis_resp_t *rndis_add_response(int configNr, u32 length)
 {
@@ -1029,6 +1042,7 @@
 	skb_queue_tail(list, skb);
 	return 0;
 }
+EXPORT_SYMBOL(rndis_rm_hdr);
 
 #ifdef CONFIG_USB_GADGET_DEBUG_FILES
 
@@ -1173,3 +1187,4 @@
 	}
 #endif
 }
+
diff -ur ./drivers/usb/gadget/rndis.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/rndis.h
--- ./drivers/usb/gadget/rndis.h	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/rndis.h	2023-04-23 12:06:33.940115800 +0100
@@ -16,6 +16,7 @@
 #define _LINUX_RNDIS_H
 
 #include <linux/rndis.h>
+#include "u_ether.h"
 #include "ndis.h"
 
 #define RNDIS_MAXIMUM_FRAME_SIZE	1518
@@ -216,7 +217,4 @@
 int  rndis_state (int configNr);
 extern void rndis_set_host_mac (int configNr, const u8 *addr);
 
-int rndis_init(void);
-void rndis_exit (void);
-
 #endif  /* _LINUX_RNDIS_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: slp.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: storage_common.h
diff -ur ./drivers/usb/gadget/tcm_usb_gadget.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/tcm_usb_gadget.c
--- ./drivers/usb/gadget/tcm_usb_gadget.c	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/tcm_usb_gadget.c	2023-04-23 12:06:34.264120100 +0100
@@ -1614,7 +1614,7 @@
 		return ERR_PTR(-ENOMEM);
 	}
 	tport->tport_wwpn = wwpn;
-	snprintf(tport->tport_name, sizeof(tport->tport_name), wnn_name);
+	snprintf(tport->tport_name, sizeof(tport->tport_name), "%s", wnn_name);
 	return &tport->tport_wwn;
 }
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_ecm.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_eem.h
diff -ur ./drivers/usb/gadget/u_ether.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_ether.c
--- ./drivers/usb/gadget/u_ether.c	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_ether.c	2023-04-23 12:06:34.341129100 +0100
@@ -48,35 +48,6 @@
 
 #define UETH__VERSION	"29-May-2008"
 
-struct eth_dev {
-	/* lock is held while accessing port_usb
-	 */
-	spinlock_t		lock;
-	struct gether		*port_usb;
-
-	struct net_device	*net;
-	struct usb_gadget	*gadget;
-
-	spinlock_t		req_lock;	/* guard {rx,tx}_reqs */
-	struct list_head	tx_reqs, rx_reqs;
-	atomic_t		tx_qlen;
-
-	struct sk_buff_head	rx_frames;
-
-	unsigned		header_len;
-	struct sk_buff		*(*wrap)(struct gether *, struct sk_buff *skb);
-	int			(*unwrap)(struct gether *,
-						struct sk_buff *skb,
-						struct sk_buff_head *list);
-
-	struct work_struct	work;
-
-	unsigned long		todo;
-#define	WORK_RX_MEMORY		0
-
-	bool			zlp;
-	u8			host_mac[ETH_ALEN];
-};
 
 /*-------------------------------------------------------------------------*/
 
@@ -84,12 +55,8 @@
 
 #define DEFAULT_QLEN	2	/* double buffering by default */
 
-static unsigned qmult = 5;
-module_param(qmult, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(qmult, "queue length multiplier at high/super speed");
-
 /* for dual-speed hardware, use deeper queues at high/super speed */
-static inline int qlen(struct usb_gadget *gadget)
+static inline int qlen(struct usb_gadget *gadget, unsigned qmult)
 {
 	if (gadget_is_dualspeed(gadget) && (gadget->speed == USB_SPEED_HIGH ||
 					    gadget->speed == USB_SPEED_SUPER))
@@ -588,7 +555,7 @@
 	if (gadget_is_dualspeed(dev->gadget))
 		req->no_interrupt = (dev->gadget->speed == USB_SPEED_HIGH ||
 				     dev->gadget->speed == USB_SPEED_SUPER)
-			? ((atomic_read(&dev->tx_qlen) % qmult) != 0)
+			? ((atomic_read(&dev->tx_qlen) % dev->qmult) != 0)
 			: 0;
 
 	retval = usb_ep_queue(in, req, GFP_ATOMIC);
@@ -697,16 +664,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* initial value, changed by "ifconfig usb0 hw ether xx:xx:xx:xx:xx:xx" */
-static char *dev_addr;
-module_param(dev_addr, charp, S_IRUGO);
-MODULE_PARM_DESC(dev_addr, "Device Ethernet Address");
-
-/* this address is invisible to ifconfig */
-static char *host_addr;
-module_param(host_addr, charp, S_IRUGO);
-MODULE_PARM_DESC(host_addr, "Host Ethernet Address");
-
 static int get_ether_addr(const char *str, u8 *dev_addr)
 {
 	if (str) {
@@ -728,6 +685,17 @@
 	return 1;
 }
 
+static int get_ether_addr_str(u8 dev_addr[ETH_ALEN], char *str, int len)
+{
+	if (len < 18)
+		return -EINVAL;
+
+	snprintf(str, len, "%02x:%02x:%02x:%02x:%02x:%02x",
+		 dev_addr[0], dev_addr[1], dev_addr[2],
+		 dev_addr[3], dev_addr[4], dev_addr[5]);
+	return 18;
+}
+
 static const struct net_device_ops eth_netdev_ops = {
 	.ndo_open		= eth_open,
 	.ndo_stop		= eth_stop,
@@ -753,10 +721,11 @@
  * gadget driver using this framework.  The link layer addresses are
  * set up using module parameters.
  *
- * Returns negative errno, or zero on success
+ * Returns an eth_dev pointer on success, or an ERR_PTR on failure.
  */
-struct eth_dev *gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
-		const char *netname)
+struct eth_dev *gether_setup_name(struct usb_gadget *g,
+		const char *dev_addr, const char *host_addr,
+		u8 ethaddr[ETH_ALEN], unsigned qmult, const char *netname)
 {
 	struct eth_dev		*dev;
 	struct net_device	*net;
@@ -777,6 +746,7 @@
 
 	/* network device setup */
 	dev->net = net;
+	dev->qmult = qmult;
 	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
 
 	if (get_ether_addr(dev_addr, net->dev_addr))
@@ -806,7 +776,8 @@
 		INFO(dev, "MAC %pM\n", net->dev_addr);
 		INFO(dev, "HOST MAC %pM\n", dev->host_mac);
 
-		/* two kinds of host-initiated state changes:
+		/*
+		 * two kinds of host-initiated state changes:
 		 *  - iff DATA transfer is active, carrier is "on"
 		 *  - tx queueing enabled if open *and* carrier is "on"
 		 */
@@ -815,6 +786,186 @@
 
 	return dev;
 }
+EXPORT_SYMBOL(gether_setup_name);
+
+struct net_device *gether_setup_name_default(const char *netname)
+{
+	struct net_device	*net;
+	struct eth_dev		*dev;
+
+	net = alloc_etherdev(sizeof(*dev));
+	if (!net)
+		return ERR_PTR(-ENOMEM);
+
+	dev = netdev_priv(net);
+	spin_lock_init(&dev->lock);
+	spin_lock_init(&dev->req_lock);
+	INIT_WORK(&dev->work, eth_work);
+	INIT_LIST_HEAD(&dev->tx_reqs);
+	INIT_LIST_HEAD(&dev->rx_reqs);
+
+	skb_queue_head_init(&dev->rx_frames);
+
+	/* network device setup */
+	dev->net = net;
+	dev->qmult = QMULT_DEFAULT;
+	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
+
+	eth_random_addr(dev->dev_mac);
+	pr_warn("using random %s ethernet address\n", "self");
+	eth_random_addr(dev->host_mac);
+	pr_warn("using random %s ethernet address\n", "host");
+
+	net->netdev_ops = &eth_netdev_ops;
+
+	SET_ETHTOOL_OPS(net, &ops);
+	SET_NETDEV_DEVTYPE(net, &gadget_type);
+
+	return net;
+}
+EXPORT_SYMBOL(gether_setup_name_default);
+
+int gether_register_netdev(struct net_device *net)
+{
+	struct eth_dev *dev;
+	struct usb_gadget *g;
+	struct sockaddr sa;
+	int status;
+
+	if (!net->dev.parent)
+		return -EINVAL;
+	dev = netdev_priv(net);
+	g = dev->gadget;
+	status = register_netdev(net);
+	if (status < 0) {
+		dev_dbg(&g->dev, "register_netdev failed, %d\n", status);
+		return status;
+	} else {
+		INFO(dev, "HOST MAC %pM\n", dev->host_mac);
+
+		/* two kinds of host-initiated state changes:
+		 *  - iff DATA transfer is active, carrier is "on"
+		 *  - tx queueing enabled if open *and* carrier is "on"
+		 */
+		netif_carrier_off(net);
+	}
+	sa.sa_family = net->type;
+	memcpy(sa.sa_data, dev->dev_mac, ETH_ALEN);
+	rtnl_lock();
+	status = dev_set_mac_address(net, &sa);
+	rtnl_unlock();
+	if (status)
+		pr_warn("cannot set self ethernet address: %d\n", status);
+	else
+		INFO(dev, "MAC %pM\n", dev->dev_mac);
+
+	return status;
+}
+EXPORT_SYMBOL(gether_register_netdev);
+
+void gether_set_gadget(struct net_device *net, struct usb_gadget *g)
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	dev->gadget = g;
+	SET_NETDEV_DEV(net, &g->dev);
+}
+EXPORT_SYMBOL(gether_set_gadget);
+
+int gether_set_dev_addr(struct net_device *net, const char *dev_addr)
+{
+	struct eth_dev *dev;
+	u8 new_addr[ETH_ALEN];
+
+	dev = netdev_priv(net);
+	if (get_ether_addr(dev_addr, new_addr))
+		return -EINVAL;
+	memcpy(dev->dev_mac, new_addr, ETH_ALEN);
+	return 0;
+}
+EXPORT_SYMBOL(gether_set_dev_addr);
+
+int gether_get_dev_addr(struct net_device *net, char *dev_addr, int len)
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	return get_ether_addr_str(dev->dev_mac, dev_addr, len);
+}
+EXPORT_SYMBOL(gether_get_dev_addr);
+
+int gether_set_host_addr(struct net_device *net, const char *host_addr)
+{
+	struct eth_dev *dev;
+	u8 new_addr[ETH_ALEN];
+
+	dev = netdev_priv(net);
+	if (get_ether_addr(host_addr, new_addr))
+		return -EINVAL;
+	memcpy(dev->host_mac, new_addr, ETH_ALEN);
+	return 0;
+}
+EXPORT_SYMBOL(gether_set_host_addr);
+
+int gether_get_host_addr(struct net_device *net, char *host_addr, int len)
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	return get_ether_addr_str(dev->host_mac, host_addr, len);
+}
+EXPORT_SYMBOL(gether_get_host_addr);
+
+int gether_get_host_addr_cdc(struct net_device *net, char *host_addr, int len)
+{
+	struct eth_dev *dev;
+
+	if (len < 13)
+		return -EINVAL;
+
+	dev = netdev_priv(net);
+	snprintf(host_addr, len, "%pm", dev->host_mac);
+
+	return strlen(host_addr);
+}
+EXPORT_SYMBOL(gether_get_host_addr_cdc);
+
+void gether_get_host_addr_u8(struct net_device *net, u8 host_mac[ETH_ALEN])
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	memcpy(host_mac, dev->host_mac, ETH_ALEN);
+}
+EXPORT_SYMBOL(gether_get_host_addr_u8);
+
+void gether_set_qmult(struct net_device *net, unsigned qmult)
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	dev->qmult = qmult;
+}
+EXPORT_SYMBOL(gether_set_qmult);
+
+unsigned gether_get_qmult(struct net_device *net)
+{
+	struct eth_dev *dev;
+
+	dev = netdev_priv(net);
+	return dev->qmult;
+}
+EXPORT_SYMBOL(gether_get_qmult);
+
+int gether_get_ifname(struct net_device *net, char *name, int len)
+{
+	rtnl_lock();
+	strlcpy(name, netdev_name(net), len);
+	rtnl_unlock();
+	return strlen(name);
+}
+EXPORT_SYMBOL(gether_get_ifname);
 
 /**
  * gether_cleanup - remove Ethernet-over-USB device
@@ -831,6 +982,7 @@
 	flush_work(&dev->work);
 	free_netdev(dev->net);
 }
+EXPORT_SYMBOL(gether_cleanup);
 
 /**
  * gether_connect - notify network layer that USB link is active
@@ -873,11 +1025,12 @@
 	}
 
 	if (result == 0)
-		result = alloc_requests(dev, link, qlen(dev->gadget));
+		result = alloc_requests(dev, link, qlen(dev->gadget,
+					dev->qmult));
 
 	if (result == 0) {
 		dev->zlp = link->is_zlp_ok;
-		DBG(dev, "qlen %d\n", qlen(dev->gadget));
+		DBG(dev, "qlen %d\n", qlen(dev->gadget, dev->qmult));
 
 		dev->header_len = link->header_len;
 		dev->unwrap = link->unwrap;
@@ -910,6 +1063,7 @@
 		return ERR_PTR(result);
 	return dev->net;
 }
+EXPORT_SYMBOL(gether_connect);
 
 /**
  * gether_disconnect - notify network layer that USB link is inactive
@@ -980,3 +1134,7 @@
 	dev->port_usb = NULL;
 	spin_unlock(&dev->lock);
 }
+EXPORT_SYMBOL(gether_disconnect);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Brownell");
diff -ur ./drivers/usb/gadget/u_ether.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_ether.h
--- ./drivers/usb/gadget/u_ether.h	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_ether.h	2023-04-23 12:06:34.340626500 +0100
@@ -21,6 +21,58 @@
 
 #include "gadget_chips.h"
 
+#define QMULT_DEFAULT 5
+struct eth_dev {
+	/* lock is held while accessing port_usb
+	 */
+	spinlock_t		lock;
+	struct gether		*port_usb;
+
+	struct net_device	*net;
+	struct usb_gadget	*gadget;
+
+	spinlock_t		req_lock;	/* guard {rx,tx}_reqs */
+	struct list_head	tx_reqs, rx_reqs;
+	atomic_t		tx_qlen;
+
+	struct sk_buff_head	rx_frames;
+
+	unsigned		qmult;
+
+	unsigned		header_len;
+	struct sk_buff		*(*wrap)(struct gether *, struct sk_buff *skb);
+	int			(*unwrap)(struct gether *,
+						struct sk_buff *skb,
+						struct sk_buff_head *list);
+
+	struct work_struct	work;
+
+	unsigned long		todo;
+#define	WORK_RX_MEMORY		0
+
+	bool			zlp;
+	u8			host_mac[ETH_ALEN];
+	u8			dev_mac[ETH_ALEN];
+};
+
+/*
+ * dev_addr: initial value
+ * changed by "ifconfig usb0 hw ether xx:xx:xx:xx:xx:xx"
+ * host_addr: this address is invisible to ifconfig
+ */
+#define USB_ETHERNET_MODULE_PARAMETERS() \
+	static unsigned qmult = QMULT_DEFAULT;				\
+	module_param(qmult, uint, S_IRUGO|S_IWUSR);			\
+	MODULE_PARM_DESC(qmult, "queue length multiplier at high/super speed");\
+									\
+	static char *dev_addr;						\
+	module_param(dev_addr, charp, S_IRUGO);				\
+	MODULE_PARM_DESC(dev_addr, "Device Ethernet Address");		\
+									\
+	static char *host_addr;						\
+	module_param(host_addr, charp, S_IRUGO);			\
+	MODULE_PARM_DESC(host_addr, "Host Ethernet Address")
+
 struct eth_dev;
 
 /*
@@ -71,8 +123,9 @@
 			|USB_CDC_PACKET_TYPE_DIRECTED)
 
 /* variant of gether_setup that allows customizing network device name */
-struct eth_dev *gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
-		const char *netname);
+struct eth_dev *gether_setup_name(struct usb_gadget *g,
+		const char *dev_addr, const char *host_addr,
+		u8 ethaddr[ETH_ALEN], unsigned qmult, const char *netname);
 
 /* netdev setup/teardown as directed by the gadget driver */
 /* gether_setup - initialize one ethernet-over-usb link
@@ -85,14 +138,148 @@
  * gadget driver using this framework.  The link layer addresses are
  * set up using module parameters.
  *
- * Returns negative errno, or zero on success
+ * Returns a eth_dev pointer on success, or an ERR_PTR on failure
  */
 static inline struct eth_dev *gether_setup(struct usb_gadget *g,
-		u8 ethaddr[ETH_ALEN])
+		const char *dev_addr, const char *host_addr,
+		u8 ethaddr[ETH_ALEN], unsigned qmult)
+{
+	return gether_setup_name(g, dev_addr, host_addr, ethaddr, qmult, "usb");
+}
+
+/*
+ * variant of gether_setup_default that allows customizing
+ * network device name
+ */
+struct net_device *gether_setup_name_default(const char *netname);
+
+/*
+ * gether_register_netdev - register the net device
+ * @net: net device to register
+ *
+ * Registers the net device associated with this ethernet-over-usb link
+ *
+ */
+int gether_register_netdev(struct net_device *net);
+
+/* gether_setup_default - initialize one ethernet-over-usb link
+ * Context: may sleep
+ *
+ * This sets up the single network link that may be exported by a
+ * gadget driver using this framework.  The link layer addresses
+ * are set to random values.
+ *
+ * Returns negative errno, or zero on success
+ */
+static inline struct net_device *gether_setup_default(void)
 {
-	return gether_setup_name(g, ethaddr, "usb");
+	return gether_setup_name_default("usb");
 }
 
+/**
+ * gether_set_gadget - initialize one ethernet-over-usb link with a gadget
+ * @net: device representing this link
+ * @g: the gadget to initialize with
+ *
+ * This associates one ethernet-over-usb link with a gadget.
+ */
+void gether_set_gadget(struct net_device *net, struct usb_gadget *g);
+
+/**
+ * gether_set_dev_addr - initialize an ethernet-over-usb link with eth address
+ * @net: device representing this link
+ * @dev_addr: eth address of this device
+ *
+ * This sets the device-side Ethernet address of this ethernet-over-usb link
+ * if dev_addr is correct.
+ * Returns negative errno if the new address is incorrect.
+ */
+int gether_set_dev_addr(struct net_device *net, const char *dev_addr);
+
+/**
+ * gether_get_dev_addr - get an ethernet-over-usb link eth address
+ * @net: device representing this link
+ * @dev_addr: place to store device's eth address
+ * @len: length of the @dev_addr buffer
+ *
+ * This gets the device-side Ethernet address of this ethernet-over-usb link.
+ * Returns zero on success, else negative errno.
+ */
+int gether_get_dev_addr(struct net_device *net, char *dev_addr, int len);
+
+/**
+ * gether_set_host_addr - initialize an ethernet-over-usb link with host address
+ * @net: device representing this link
+ * @host_addr: eth address of the host
+ *
+ * This sets the host-side Ethernet address of this ethernet-over-usb link
+ * if host_addr is correct.
+ * Returns negative errno if the new address is incorrect.
+ */
+int gether_set_host_addr(struct net_device *net, const char *host_addr);
+
+/**
+ * gether_get_host_addr - get an ethernet-over-usb link host address
+ * @net: device representing this link
+ * @host_addr: place to store eth address of the host
+ * @len: length of the @host_addr buffer
+ *
+ * This gets the host-side Ethernet address of this ethernet-over-usb link.
+ * Returns zero on success, else negative errno.
+ */
+int gether_get_host_addr(struct net_device *net, char *host_addr, int len);
+
+/**
+ * gether_get_host_addr_cdc - get an ethernet-over-usb link host address
+ * @net: device representing this link
+ * @host_addr: place to store eth address of the host
+ * @len: length of the @host_addr buffer
+ *
+ * This gets the CDC formatted host-side Ethernet address of this
+ * ethernet-over-usb link.
+ * Returns zero on success, else negative errno.
+ */
+int gether_get_host_addr_cdc(struct net_device *net, char *host_addr, int len);
+
+/**
+ * gether_get_host_addr_u8 - get an ethernet-over-usb link host address
+ * @net: device representing this link
+ * @host_mac: place to store the eth address of the host
+ *
+ * This gets the binary formatted host-side Ethernet address of this
+ * ethernet-over-usb link.
+ */
+void gether_get_host_addr_u8(struct net_device *net, u8 host_mac[ETH_ALEN]);
+
+/**
+ * gether_set_qmult - initialize an ethernet-over-usb link with a multiplier
+ * @net: device representing this link
+ * @qmult: queue multiplier
+ *
+ * This sets the queue length multiplier of this ethernet-over-usb link.
+ * For higher speeds use longer queues.
+ */
+void gether_set_qmult(struct net_device *net, unsigned qmult);
+
+/**
+ * gether_get_qmult - get an ethernet-over-usb link multiplier
+ * @net: device representing this link
+ *
+ * This gets the queue length multiplier of this ethernet-over-usb link.
+ */
+unsigned gether_get_qmult(struct net_device *net);
+
+/**
+ * gether_get_ifname - get an ethernet-over-usb link interface name
+ * @net: device representing this link
+ * @name: place to store the interface name
+ * @len: length of the @name buffer
+ *
+ * This gets the interface name of this ethernet-over-usb link.
+ * Returns zero on success, else negative errno.
+ */
+int gether_get_ifname(struct net_device *net, char *name, int len);
+
 void gether_cleanup(struct eth_dev *dev);
 
 /* connect/disconnect is handled by individual functions */
@@ -112,48 +299,4 @@
 	return true;
 }
 
-/* each configuration may bind one instance of an ethernet link */
-int geth_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev);
-int ecm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev);
-int ncm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		struct eth_dev *dev);
-int eem_bind_config(struct usb_configuration *c, struct eth_dev *dev);
-
-#ifdef USB_ETH_RNDIS
-
-int rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		u32 vendorID, const char *manufacturer, struct eth_dev *dev);
-
-#else
-
-static inline int
-rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
-		u32 vendorID, const char *manufacturer, struct eth_dev *dev)
-{
-	return 0;
-}
-
-#endif
-
-/**
- * rndis_bind_config - add RNDIS network link to a configuration
- * @c: the configuration to support the network link
- * @ethaddr: a buffer in which the ethernet address of the host side
- *	side of the link was recorded
- * Context: single threaded during gadget setup
- *
- * Returns zero on success, else negative errno.
- *
- * Caller must have called @gether_setup().  Caller is also responsible
- * for calling @gether_cleanup() before module unload.
- */
-static inline int rndis_bind_config(struct usb_configuration *c,
-		u8 ethaddr[ETH_ALEN], struct eth_dev *dev)
-{
-	return rndis_bind_config_vendor(c, ethaddr, 0, NULL, dev);
-}
-
-
 #endif /* __U_ETHER_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_ether_configfs.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_f.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_f.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_fs.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_gether.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_ncm.h
diff -ur ./drivers/usb/gadget/u_phonet.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_phonet.h
--- ./drivers/usb/gadget/u_phonet.h	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/u_phonet.h	2023-04-23 12:06:34.520124100 +0100
@@ -14,8 +14,16 @@
 #include <linux/usb/composite.h>
 #include <linux/usb/cdc.h>
 
-int gphonet_setup(struct usb_gadget *gadget);
-int phonet_bind_config(struct usb_configuration *c);
-void gphonet_cleanup(void);
+struct f_phonet_opts {
+	struct usb_function_instance func_inst;
+	bool bound;
+	struct net_device *net;
+};
+
+struct net_device *gphonet_setup_default(void);
+void gphonet_set_gadget(struct net_device *net, struct usb_gadget *g);
+int gphonet_register_netdev(struct net_device *net);
+int phonet_bind_config(struct usb_configuration *c, struct net_device *dev);
+void gphonet_cleanup(struct net_device *dev);
 
 #endif /* __U_PHONET_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget: u_rndis.h
diff -ur ./drivers/usb/gadget/udc-core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/udc-core.c
--- ./drivers/usb/gadget/udc-core.c	2023-04-26 12:56:07.770118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/udc-core.c	2023-04-23 12:06:34.583249100 +0100
@@ -27,6 +27,10 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
+#include <linux/of.h>
+#include <linux/extcon.h>
+#include <linux/workqueue.h>
+
 /**
  * struct usb_udc - describes one usb device controller
  * @driver - the gadget driver pointer. For use by the class code
@@ -42,6 +46,12 @@
 	struct usb_gadget		*gadget;
 	struct device			dev;
 	struct list_head		list;
+	struct extcon_specific_cable_nb extcon_usb_dev;
+	struct notifier_block		extcon_nb;
+	struct workqueue_struct		*pwr_workqueue;
+	struct work_struct		pwr_work;
+	char				cable_state;
+	char				enabled;
 };
 
 static struct class *udc_class;
@@ -266,6 +276,10 @@
 	dev_dbg(&udc->dev, "unregistering UDC driver [%s]\n",
 			udc->gadget->name);
 
+	if (udc->extcon_usb_dev.edev)
+		extcon_unregister_notifier(udc->extcon_usb_dev.edev,
+							&udc->extcon_nb);
+
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 
 	usb_gadget_disconnect(udc->gadget);
@@ -314,10 +328,44 @@
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
+static void udc_pwr_worker(struct work_struct * work)
+{
+	struct usb_udc *udc = container_of(work, struct usb_udc, pwr_work);
+
+	dev_dbg(&udc->dev, "UDC power worker, cable_state=%d, enabled=%d\n",
+						udc->cable_state, udc->enabled);
+
+	if (udc->cable_state && !udc->enabled) {
+		usb_gadget_udc_start(udc->gadget, udc->driver);
+		usb_gadget_connect(udc->gadget);
+		udc->enabled = 1;
+	} else if (!udc->cable_state && udc->enabled) {
+		usb_gadget_disconnect(udc->gadget);
+		usb_gadget_udc_stop(udc->gadget, udc->driver);
+		udc->enabled = 0;
+	}
+}
+
+static int udc_extcon_notifier(struct notifier_block *nb, unsigned long event,
+								void *ptr)
+{
+	struct usb_udc *udc = container_of(nb, struct usb_udc, extcon_nb);
+
+	dev_dbg(&udc->dev, "extcon notifier, cable state=%lu\n", event);
+	udc->cable_state = event;
+
+	queue_work(udc->pwr_workqueue, &udc->pwr_work);
+
+	return NOTIFY_OK;
+}
+
+
 /* ------------------------------------------------------------------------- */
 
 static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
 {
+	const struct device_node *node;
+	struct extcon_dev *edev = 0;
 	int ret;
 
 	dev_dbg(&udc->dev, "registering UDC driver [%s]\n",
@@ -327,18 +375,61 @@
 	udc->dev.driver = &driver->driver;
 	udc->gadget->dev.driver = &driver->driver;
 
+	node = udc->gadget->dev.of_node;
+
+	edev = 0;
+	/* Check if we have an extcon associated with the UDC driver */
+	if (node && of_property_read_bool(node, "extcon")) {
+		edev = extcon_get_edev_by_phandle(&udc->gadget->dev, 0);
+
+		if(IS_ERR(edev)) {
+			dev_dbg(&udc->dev, "couldn't get extcon device\n");
+			ret = -EINVAL;
+			goto err1;
+		}
+
+		udc->pwr_workqueue = create_singlethread_workqueue("udc");
+		INIT_WORK(&udc->pwr_work, udc_pwr_worker);
+		udc->extcon_nb.notifier_call = udc_extcon_notifier;
+		ret = extcon_register_interest(&udc->extcon_usb_dev, edev->name,
+							"USB", &udc->extcon_nb);
+
+		if (ret) {
+			dev_err(&udc->dev, "failed to register notifier for USB\n");
+			goto err1;
+		}
+
+	}
+
 	ret = driver->bind(udc->gadget, driver);
 	if (ret)
-		goto err1;
-	ret = usb_gadget_udc_start(udc->gadget, driver);
-	if (ret) {
-		driver->unbind(udc->gadget);
-		goto err1;
+		goto err2;
+
+	if (udc->extcon_usb_dev.edev) {
+		udc->enabled = 0;
+		udc->cable_state = extcon_get_cable_state_(
+					udc->extcon_usb_dev.edev,
+					udc->extcon_usb_dev.cable_index);
+	} else {
+		udc->cable_state = 1;
+	}
+
+	if (udc->cable_state) {
+		ret = usb_gadget_udc_start(udc->gadget, driver);
+		if (ret) {
+			driver->unbind(udc->gadget);
+			goto err2;
+		}
+
+		usb_gadget_connect(udc->gadget);
+		udc->enabled = 1;
 	}
-	usb_gadget_connect(udc->gadget);
 
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 	return 0;
+err2:
+	if (udc->extcon_usb_dev.edev)
+		extcon_unregister_notifier(edev, &udc->extcon_nb);
 err1:
 	dev_err(&udc->dev, "failed to start %s: %d\n",
 			udc->driver->function, ret);
@@ -439,6 +530,11 @@
 {
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
 
+	if (!udc->driver) {
+		dev_err(dev, "soft-connect without a gadget driver\n");
+		return -EOPNOTSUPP;
+	}
+
 	if (sysfs_streq(buf, "connect")) {
 		usb_gadget_udc_start(udc->gadget, udc->driver);
 		usb_gadget_connect(udc->gadget);
@@ -454,31 +550,31 @@
 }
 static DEVICE_ATTR(soft_connect, S_IWUSR, NULL, usb_udc_softconn_store);
 
-static ssize_t usb_gadget_state_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+static ssize_t state_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
 {
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
 	struct usb_gadget	*gadget = udc->gadget;
 
 	return sprintf(buf, "%s\n", usb_state_string(gadget->state));
 }
-static DEVICE_ATTR(state, S_IRUGO, usb_gadget_state_show, NULL);
+static DEVICE_ATTR_RO(state);
 
 #define USB_UDC_SPEED_ATTR(name, param)					\
-ssize_t usb_udc_##param##_show(struct device *dev,			\
+ssize_t name##_show(struct device *dev,					\
 		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_udc *udc = container_of(dev, struct usb_udc, dev);	\
 	return snprintf(buf, PAGE_SIZE, "%s\n",				\
 			usb_speed_string(udc->gadget->param));		\
 }									\
-static DEVICE_ATTR(name, S_IRUGO, usb_udc_##param##_show, NULL)
+static DEVICE_ATTR_RO(name)
 
 static USB_UDC_SPEED_ATTR(current_speed, speed);
 static USB_UDC_SPEED_ATTR(maximum_speed, max_speed);
 
 #define USB_UDC_ATTR(name)					\
-ssize_t usb_udc_##name##_show(struct device *dev,		\
+ssize_t name##_show(struct device *dev,				\
 		struct device_attribute *attr, char *buf)	\
 {								\
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev); \
@@ -486,7 +582,7 @@
 								\
 	return snprintf(buf, PAGE_SIZE, "%d\n", gadget->name);	\
 }								\
-static DEVICE_ATTR(name, S_IRUGO, usb_udc_##name##_show, NULL)
+static DEVICE_ATTR_RO(name)
 
 static USB_UDC_ATTR(is_otg);
 static USB_UDC_ATTR(is_a_peripheral);
@@ -551,6 +647,7 @@
 	}
 
 	udc_class->dev_uevent = usb_udc_uevent;
+
 	return 0;
 }
 subsys_initcall(usb_udc_init);
diff -ur ./drivers/usb/gadget/zero.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/zero.c
--- ./drivers/usb/gadget/zero.c	2023-04-26 12:26:20.710132369 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/gadget/zero.c	2023-04-23 12:06:34.739334200 +0100
@@ -64,10 +64,10 @@
 module_param(loopdefault, bool, S_IRUGO|S_IWUSR);
 
 static struct usb_zero_options gzero_options = {
-	.isoc_interval = 4,
-	.isoc_maxpacket = 1024,
-	.bulk_buflen = 4096,
-	.qlen = 32,
+	.isoc_interval = GZERO_ISOC_INTERVAL,
+	.isoc_maxpacket = GZERO_ISOC_MAXPACKET,
+	.bulk_buflen = GZERO_BULK_BUFLEN,
+	.qlen = GZERO_QLEN,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -91,10 +91,22 @@
  * functional coverage for the "USBCV" test harness from USB-IF.
  * It's always set if OTG mode is enabled.
  */
-unsigned autoresume = DEFAULT_AUTORESUME;
+static unsigned autoresume = DEFAULT_AUTORESUME;
 module_param(autoresume, uint, S_IRUGO);
 MODULE_PARM_DESC(autoresume, "zero, or seconds before remote wakeup");
 
+/* Maximum Autoresume time */
+static unsigned max_autoresume;
+module_param(max_autoresume, uint, S_IRUGO);
+MODULE_PARM_DESC(max_autoresume, "maximum seconds before remote wakeup");
+
+/* Interval between two remote wakeups */
+static unsigned autoresume_interval_ms;
+module_param(autoresume_interval_ms, uint, S_IRUGO);
+MODULE_PARM_DESC(autoresume_interval_ms,
+		"milliseconds to increase successive wakeup delays");
+
+static unsigned autoresume_step_ms;
 /*-------------------------------------------------------------------------*/
 
 static struct usb_device_descriptor device_desc = {
@@ -183,8 +195,16 @@
 		return;
 
 	if (autoresume) {
-		mod_timer(&autoresume_timer, jiffies + (HZ * autoresume));
-		DBG(cdev, "suspend, wakeup in %d seconds\n", autoresume);
+		if (max_autoresume &&
+			(autoresume_step_ms > max_autoresume * 1000))
+				autoresume_step_ms = autoresume * 1000;
+
+		mod_timer(&autoresume_timer, jiffies +
+			msecs_to_jiffies(autoresume_step_ms));
+		DBG(cdev, "suspend, wakeup in %d milliseconds\n",
+			autoresume_step_ms);
+
+		autoresume_step_ms += autoresume_interval_ms;
 	} else
 		DBG(cdev, "%s\n", __func__);
 }
@@ -280,7 +300,7 @@
 	ss_opts->isoc_interval = gzero_options.isoc_interval;
 	ss_opts->isoc_maxpacket = gzero_options.isoc_maxpacket;
 	ss_opts->isoc_mult = gzero_options.isoc_mult;
-	ss_opts->isoc_maxburst = gzero_options.isoc_maxpacket;
+	ss_opts->isoc_maxburst = gzero_options.isoc_maxburst;
 	ss_opts->bulk_buflen = gzero_options.bulk_buflen;
 
 	func_ss = usb_get_function(func_inst_ss);
@@ -316,6 +336,7 @@
 	if (autoresume) {
 		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 		loopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+		autoresume_step_ms = autoresume * 1000;
 	}
 
 	/* support OTG systems */
diff -ur ./drivers/usb/host/ehci-sead3.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/host/ehci-sead3.c
--- ./drivers/usb/host/ehci-sead3.c	2023-04-26 12:56:07.780118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/host/ehci-sead3.c	2023-04-23 12:06:35.299745700 +0100
@@ -140,7 +140,6 @@
 
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
-	platform_set_drvdata(pdev, NULL);
 
 	return 0;
 }
diff -ur ./drivers/usb/host/ohci-hcd.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/host/ohci-hcd.c
--- ./drivers/usb/host/ohci-hcd.c	2023-04-26 12:56:07.790118955 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/host/ohci-hcd.c	2023-04-23 12:06:36.021052700 +0100
@@ -1099,6 +1099,12 @@
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
+#ifdef CONFIG_MACH_XBURST
+#include "ohci-jz.c"
+#define PLATFORM_DRIVER     ohci_hcd_jz_driver
+#endif
+
+
 #if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)
 #include "ohci-sa1111.c"
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/host: ohci-jz.c
diff -ur ./drivers/usb/phy/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/phy/Kconfig
--- ./drivers/usb/phy/Kconfig	2023-04-26 12:56:07.820118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/phy/Kconfig	2023-04-23 12:06:39.789682800 +0100
@@ -16,6 +16,14 @@
 	  If you're not sure if this applies to you, it probably doesn't;
 	  say N here.
 
+config USB_OTG_WAKELOCK
+	bool "Hold a wakelock when USB connected"
+	depends on WAKELOCK
+	select USB_OTG_UTILS
+	help
+	  Select this to automatically hold a wakelock when USB is
+	  connected, preventing suspend.
+
 if USB_PHY
 
 #
diff -ur ./drivers/usb/phy/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/phy/Makefile
--- ./drivers/usb/phy/Makefile	2023-04-26 12:56:07.820118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/phy/Makefile	2023-04-23 12:06:39.789220800 +0100
@@ -5,6 +5,7 @@
 ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
 
 obj-$(CONFIG_USB_PHY)			+= phy.o
+obj-$(CONFIG_USB_OTG_WAKELOCK)		+= otg-wakelock.o
 
 # transceiver drivers, keep the list sorted
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/usb/phy: otg-wakelock.c
diff -ur ./drivers/video/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/Kconfig
--- ./drivers/video/Kconfig	2023-04-26 12:56:07.860118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/Kconfig	2023-04-23 12:06:45.143000500 +0100
@@ -23,6 +23,10 @@
 
 source "drivers/gpu/host1x/Kconfig"
 
+source "drivers/gpu/vivante/Kconfig"
+
+source "drivers/video/jz_ipu/Kconfig"
+
 config VGASTATE
        tristate
        default n
@@ -30,7 +34,7 @@
 config VIDEO_OUTPUT_CONTROL
 	tristate "Lowlevel video output switch controls"
 	help
-	  This framework adds support for low-level control of the video 
+	  This framework adds support for low-level control of the video
 	  output switch.
 
 config VIDEOMODE_HELPERS
@@ -689,7 +693,7 @@
 	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
 	  Enabling this option will implement the linux framebuffer device
 	  using calls to the STI BIOS routines for initialisation.
-	
+
 	  If you enable this option, you will get a planar framebuffer device
 	  /dev/fb which will work on the most common HP graphic cards of the
 	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
@@ -1130,36 +1134,36 @@
 	select FB_CFB_IMAGEBLIT
 	select VGASTATE
 	help
-	  This driver supports the on-board graphics built in to the Intel 810 
+	  This driver supports the on-board graphics built in to the Intel 810
           and 815 chipsets.  Say Y if you have and plan to use such a board.
 
           To compile this driver as a module, choose M here: the
 	  module will be called i810fb.
 
-          For more information, please read 
+          For more information, please read
 	  <file:Documentation/fb/intel810.txt>
 
 config FB_I810_GTF
 	bool "use VESA Generalized Timing Formula"
 	depends on FB_I810
 	help
-	  If you say Y, then the VESA standard, Generalized Timing Formula 
+	  If you say Y, then the VESA standard, Generalized Timing Formula
           or GTF, will be used to calculate the required video timing values
-	  per video mode.  Since the GTF allows nondiscrete timings 
+	  per video mode.  Since the GTF allows nondiscrete timings
           (nondiscrete being a range of values as opposed to discrete being a
-          set of values), you'll be able to use any combination of horizontal 
+          set of values), you'll be able to use any combination of horizontal
 	  and vertical resolutions, and vertical refresh rates without having
 	  to specify your own timing parameters.  This is especially useful
-	  to maximize the performance of an aging display, or if you just 
-          have a display with nonstandard dimensions. A VESA compliant 
+	  to maximize the performance of an aging display, or if you just
+          have a display with nonstandard dimensions. A VESA compliant
 	  monitor is recommended, but can still work with non-compliant ones.
-	  If you need or want this, then select this option. The timings may 
-	  not be compliant with Intel's recommended values. Use at your own 
+	  If you need or want this, then select this option. The timings may
+	  not be compliant with Intel's recommended values. Use at your own
 	  risk.
 
-          If you say N, the driver will revert to discrete video timings 
+          If you say N, the driver will revert to discrete video timings
 	  using a set recommended by Intel in their documentation.
-  
+
           If unsure, say N.
 
 config FB_I810_I2C
@@ -1277,10 +1281,10 @@
 	  G450/G550 secondary head and digital output are supported without
 	  additional modules.
 
-	  The driver starts in monitor mode. You must use the matroxset tool 
-	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
-	  swap primary and secondary head outputs, or to change output mode.  
-	  Secondary head driver always start in 640x480 resolution and you 
+	  The driver starts in monitor mode. You must use the matroxset tool
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
+	  swap primary and secondary head outputs, or to change output mode.
+	  Secondary head driver always start in 640x480 resolution and you
 	  must use fbset to change it.
 
 	  Do not forget that second head supports only 16 and 32 bpp
@@ -1363,7 +1367,7 @@
 	select FB_DDC
 	default y
 	help
-	  Say Y here if you want DDC/I2C support for your Radeon board. 
+	  Say Y here if you want DDC/I2C support for your Radeon board.
 
 config FB_RADEON_BACKLIGHT
 	bool "Support for backlight control"
@@ -1597,7 +1601,7 @@
 	select VGASTATE
 	help
 	  This driver supports notebooks with NeoMagic PCI chips.
-	  Say Y if you have such a graphics card. 
+	  Say Y if you have such a graphics card.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called neofb.
@@ -1652,7 +1656,7 @@
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	---help---
-	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
 	  Voodoo2 (cvg) based graphics card.
 
 	  To compile this driver as a module, choose M here: the
@@ -2475,6 +2479,7 @@
 source "drivers/video/exynos/Kconfig"
 source "drivers/video/mmp/Kconfig"
 source "drivers/video/backlight/Kconfig"
+source "drivers/video/adf/Kconfig"
 
 if VT
 	source "drivers/video/console/Kconfig"
@@ -2511,4 +2516,42 @@
 	  This driver implements support for the Solomon SSD1307
 	  OLED controller over I2C.
 
+source "drivers/video/jz_fb_v12/Kconfig"
+source "drivers/video/jz_fb_v14/Kconfig"
+config FB_VSYNC_SKIP
+        int "Vsync skip ratio[0..9]"
+        depends on FB
+        default 9
+        help
+          Vsync skip ratio
+
+choice
+	depends on FB && (SOC_4780 || SOC_4775 || SOC_M200)
+	prompt "allocation frame buffer"
+	default THREE_FRAME_BUFFERS
+
+config ONE_FRAME_BUFFERS
+       bool "alloc 1 frame buffers"
+       help
+	one frame buffer
+
+config TWO_FRAME_BUFFERS
+       bool "alloc 2 frame buffers"
+       help
+	double frame buffer
+
+config THREE_FRAME_BUFFERS
+       bool "alloc 3 frame buffers"
+       help
+	treble frame buffer
+endchoice
+
+config JZ_VPU_IRQ_TEST
+    depends on !JZ_VPU
+bool "VPU IRQ test used by fpga case"
+default n
+
+source "drivers/video/jz_vpu/Kconfig"
+source "drivers/video/soc_vpu/Kconfig"
+source "drivers/video/avpu/Kconfig"
 endmenu
diff -ur ./drivers/video/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/Makefile
--- ./drivers/video/Makefile	2023-04-26 12:26:21.100132368 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/Makefile	2023-04-23 12:06:45.142379000 +0100
@@ -12,6 +12,7 @@
                                      modedb.o fbcvt.o
 fb-objs                           := $(fb-y)
 
+obj-$(CONFIG_ADF)		  += adf/
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
 obj-y				  += backlight/
@@ -167,6 +168,13 @@
 obj-$(CONFIG_FB_MXS)		  += mxsfb.o
 obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.o
 obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
+obj-$(CONFIG_FB_JZ_V12)     	  += jz_fb_v12/
+obj-$(CONFIG_FB_JZ_V14)           += jz_fb_v14/
+obj-$(CONFIG_JZ_VPU)             += jz_vpu/
+obj-$(CONFIG_JZ_VPU_IRQ_TEST) += jz_vpu_irq_test.o
+obj-$(CONFIG_JZ_IPU)		  += jz_ipu/
+obj-$(CONFIG_SOC_VPU)          += soc_vpu/
+obj-$(CONFIG_AVPU_DRIVER)          += avpu/
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: adf
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: avpu
diff -ur ./drivers/video/backlight/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/Kconfig
--- ./drivers/video/backlight/Kconfig	2023-04-26 12:26:21.110132368 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/Kconfig	2023-04-23 12:06:46.904180500 +0100
@@ -148,6 +148,45 @@
 	  If you have a HX-8357 LCD panel, say Y to enable its LCD control
 	  driver.
 
+config LCD_BYD_8991FTGF
+	tristate "BYD 8991FTGF panel(480x800)"
+	depends on BACKLIGHT_CLASS_DEVICE
+	default n
+config LCD_BYD_9177AA
+	tristate "byd 9177aa  mipi-dsi panel(540x960)"
+	depends on FB && JZ_MIPI_DSI
+	help
+	   jz mipi dsi.dpi TFT display panel  support
+config LCD_X163
+   tristate "X163 smart mipi-dsi panel(320x320)"
+   depends on FB && JZ_MIPI_DSI
+   help
+	   jz mipi dsi.dbi smart display panel support
+config AUO_X163_ROTATION_180
+	bool "AUO X163 rotation 180"
+	depends on LCD_X163
+	default n
+	help
+	  If your board is needed rotation 180, select this option.
+
+choice
+        prompt "lcd type"
+        depends on SOC_T30
+        default T30_FPGA_SLCD_TRULY_240_240
+
+config T30_FPGA_SLCD_TRULY_240_240
+        bool "Truly 240*240 8bit SLCD"
+
+config T30_FPGA_SLCD_KFM701A21
+        bool "KFM701A21 400*240 16 bit SLCD"
+
+config T30_FPGA_TFT_BM8766
+        bool "BM8766 800*480 18 bit TFT"
+
+config T30_FPGA_SLCD_SPI_BYD9158B
+        bool "BYD9158B 128*160 SPI 3 or 4 bit SLCD"
+
+endchoice
 endif # LCD_CLASS_DEVICE
 
 #
@@ -261,10 +300,10 @@
 
 config BACKLIGHT_PWM
 	tristate "Generic PWM based Backlight Driver"
-	depends on PWM
+	depends on PWM && JZ_PWM
 	help
 	  If you have a LCD backlight adjustable by PWM, say Y to enable
-	  this driver.
+	  this driver. Choice JZ PWM driver and the PWM channel.
 
 config BACKLIGHT_DA903X
 	tristate "Backlight Driver for DA9030/DA9034 using WLED"
diff -ur ./drivers/video/backlight/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/Makefile
--- ./drivers/video/backlight/Makefile	2023-04-26 12:26:21.120132368 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/Makefile	2023-04-23 12:06:46.903677700 +0100
@@ -17,6 +17,9 @@
 obj-$(CONFIG_LCD_TDO24M)		+= tdo24m.o
 obj-$(CONFIG_LCD_TOSA)			+= tosa_lcd.o
 obj-$(CONFIG_LCD_VGG2432A4)		+= vgg2432a4.o
+obj-$(CONFIG_LCD_BYD_8991FTGF)	+= byd_8991.o byd_8991_init.o
+obj-$(CONFIG_LCD_BYD_9177AA)	+= byd_9177aa.o
+obj-$(CONFIG_LCD_X163)             += auo_x163.o
 
 obj-$(CONFIG_BACKLIGHT_88PM860X)	+= 88pm860x_bl.o
 obj-$(CONFIG_BACKLIGHT_AAT2870)		+= aat2870_bl.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight: auo_x163.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight: byd_8991.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight: byd_8991_init.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight: byd_9177aa.c
diff -ur ./drivers/video/backlight/pwm_bl.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/pwm_bl.c
--- ./drivers/video/backlight/pwm_bl.c	2023-04-26 12:26:21.140132368 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video/backlight/pwm_bl.c	2023-04-23 12:06:47.782963800 +0100
@@ -62,6 +62,7 @@
 			duty_cycle = brightness;
 		}
 
+		pwm_disable(pb->pwm);
 		duty_cycle = pb->lth_brightness +
 		     (duty_cycle * (pb->period - pb->lth_brightness) / max);
 		pwm_config(pb->pwm, duty_cycle, pb->period);
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: jz_fb_v12
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: jz_fb_v14
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: jz_ipu
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: jz_vpu
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: jz_vpu_irq_test.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/video: soc_vpu
diff -ur ./drivers/w1/masters/ds2482.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/w1/masters/ds2482.c
--- ./drivers/w1/masters/ds2482.c	2023-04-26 12:26:21.650132367 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/w1/masters/ds2482.c	2023-04-23 12:07:01.707361200 +0100
@@ -18,6 +18,8 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/ds2482.h>
 #include <asm/delay.h>
 
 #include "../w1.h"
@@ -84,7 +86,8 @@
 static int ds2482_probe(struct i2c_client *client,
 			const struct i2c_device_id *id);
 static int ds2482_remove(struct i2c_client *client);
-
+static int ds2482_suspend(struct device *dev);
+static int ds2482_resume(struct device *dev);
 
 /**
  * Driver data (common to all clients)
@@ -94,10 +97,16 @@
 	{ }
 };
 
+static const struct dev_pm_ops ds2482_pm_ops = {
+	.suspend = ds2482_suspend,
+	.resume = ds2482_resume,
+};
+
 static struct i2c_driver ds2482_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "ds2482",
+		.pm = &ds2482_pm_ops,
 	},
 	.probe		= ds2482_probe,
 	.remove		= ds2482_remove,
@@ -119,6 +128,7 @@
 struct ds2482_data {
 	struct i2c_client	*client;
 	struct mutex		access_lock;
+	int			slpz_gpio;
 
 	/* 1-wire interface(s) */
 	int			w1_count;	/* 1 or 8 */
@@ -444,11 +454,31 @@
 	return retval;
 }
 
+static int ds2482_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ds2482_data *data = i2c_get_clientdata(client);
+
+	if (data->slpz_gpio >= 0)
+		gpio_set_value(data->slpz_gpio, 0);
+	return 0;
+}
+
+static int ds2482_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ds2482_data *data = i2c_get_clientdata(client);
+
+	if (data->slpz_gpio >= 0)
+		gpio_set_value(data->slpz_gpio, 1);
+	return 0;
+}
 
 static int ds2482_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
 	struct ds2482_data *data;
+	struct ds2482_platform_data *pdata;
 	int err = -ENODEV;
 	int temp1;
 	int idx;
@@ -515,6 +545,16 @@
 		}
 	}
 
+	pdata = client->dev.platform_data;
+	data->slpz_gpio = pdata ? pdata->slpz_gpio : -1;
+
+	if (data->slpz_gpio >= 0) {
+		err = gpio_request_one(data->slpz_gpio, GPIOF_OUT_INIT_HIGH,
+				       "ds2482.slpz");
+		if (err < 0)
+			goto exit_w1_remove;
+	}
+
 	return 0;
 
 exit_w1_remove:
@@ -539,6 +579,11 @@
 			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
 	}
 
+	if (data->slpz_gpio >= 0) {
+		gpio_set_value(data->slpz_gpio, 0);
+		gpio_free(data->slpz_gpio);
+	}
+
 	/* Free the memory */
 	kfree(data);
 	return 0;
diff -ur ./drivers/watchdog/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/watchdog/Kconfig
--- ./drivers/watchdog/Kconfig	2023-04-26 12:56:07.950118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/watchdog/Kconfig	2023-04-23 12:07:02.427621000 +0100
@@ -1028,6 +1028,13 @@
 	help
 	  Hardware driver for the built-in watchdog timer on Ingenic jz4740 SoCs.
 
+config JZ_WDT
+	tristate "Ingenic jz SoC hardware watchdog"
+	depends on MACH_XBURST
+	select WATCHDOG_CORE
+	help
+	  Hardware driver for the built-in watchdog timer on Ingenic jz SoCs.
+
 config WDT_MTX1
 	tristate "MTX-1 Hardware Watchdog"
 	depends on MIPS_MTX1
diff -ur ./drivers/watchdog/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/watchdog/Makefile
--- ./drivers/watchdog/Makefile	2023-04-26 12:56:07.950118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/watchdog/Makefile	2023-04-23 12:07:02.427132500 +0100
@@ -126,6 +126,7 @@
 obj-$(CONFIG_RC32434_WDT) += rc32434_wdt.o
 obj-$(CONFIG_INDYDOG) += indydog.o
 obj-$(CONFIG_JZ4740_WDT) += jz4740_wdt.o
+obj-$(CONFIG_JZ_WDT) += jz_wdt.o
 obj-$(CONFIG_WDT_MTX1) += mtx-1_wdt.o
 obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/drivers/watchdog: jz_wdt.c
diff -ur ./fs/binfmt_elf.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/binfmt_elf.c
--- ./fs/binfmt_elf.c	2023-04-26 12:56:08.000118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/binfmt_elf.c	2023-04-23 12:07:13.979647600 +0100
@@ -1032,6 +1032,8 @@
 	if (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||
 	    !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)
 		goto out;
+	if (!elf_lib_check_arch(&elf_ex))
+		goto out;
 
 	/* Now read in all of the header information */
 
diff -ur ./fs/cifs/transport.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/cifs/transport.c
--- ./fs/cifs/transport.c	2023-04-26 12:56:08.090118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/cifs/transport.c	2023-04-23 12:07:18.188569700 +0100
@@ -447,7 +447,7 @@
 {
 	int error;
 
-	error = wait_event_freezekillable(server->response_q,
+	error = wait_event_freezekillable_unsafe(server->response_q,
 				    midQ->mid_state != MID_REQUEST_SUBMITTED);
 	if (error < 0)
 		return -ERESTARTSYS;
diff -ur ./fs/dcache.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/dcache.c
--- ./fs/dcache.c	2023-04-26 12:56:08.100118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/dcache.c	2023-04-23 12:07:18.980576800 +0100
@@ -2710,7 +2710,7 @@
 			const char *fmt, ...)
 {
 	va_list args;
-	char temp[64];
+	char temp[128];
 	int sz;
 
 	va_start(args, fmt);
diff -ur ./fs/eventpoll.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/eventpoll.c
--- ./fs/eventpoll.c	2023-04-26 12:56:08.130118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/eventpoll.c	2023-04-23 12:07:20.828885600 +0100
@@ -34,6 +34,7 @@
 #include <linux/mutex.h>
 #include <linux/anon_inodes.h>
 #include <linux/device.h>
+#include <linux/freezer.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/mman.h>
@@ -1602,7 +1603,8 @@
 			}
 
 			spin_unlock_irqrestore(&ep->lock, flags);
-			if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))
+			if (!freezable_schedule_hrtimeout_range(to, slack,
+								HRTIMER_MODE_ABS))
 				timed_out = 1;
 
 			spin_lock_irqsave(&ep->lock, flags);
diff -ur ./fs/fat/dir.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/dir.c
--- ./fs/fat/dir.c	2023-04-26 12:56:08.180118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/dir.c	2023-04-23 12:07:23.628355700 +0100
@@ -776,6 +776,13 @@
 	return ret;
 }
 
+static int fat_ioctl_volume_id(struct inode *dir)
+{
+	struct super_block *sb = dir->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	return sbi->vol_id;
+}
+
 static long fat_dir_ioctl(struct file *filp, unsigned int cmd,
 			  unsigned long arg)
 {
@@ -792,6 +799,8 @@
 		short_only = 0;
 		both = 1;
 		break;
+	case VFAT_IOCTL_GET_VOLUME_ID:
+		return fat_ioctl_volume_id(inode);
 	default:
 		return fat_generic_ioctl(filp, cmd, arg);
 	}
@@ -832,6 +841,8 @@
 		short_only = 0;
 		both = 1;
 		break;
+	case VFAT_IOCTL_GET_VOLUME_ID:
+		return fat_ioctl_volume_id(inode);
 	default:
 		return fat_generic_ioctl(filp, cmd, (unsigned long)arg);
 	}
diff -ur ./fs/fat/fat.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/fat.h
--- ./fs/fat/fat.h	2023-04-26 12:56:08.180118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/fat.h	2023-04-23 12:07:23.627790000 +0100
@@ -86,6 +86,7 @@
 	const void *dir_ops;	      /* Opaque; default directory operations */
 	int dir_per_block;	      /* dir entries per block */
 	int dir_per_block_bits;	      /* log2(dir_per_block) */
+	unsigned long vol_id;         /* volume ID */
 
 	int fatent_shift;
 	struct fatent_operations *fatent_ops;
diff -ur ./fs/fat/inode.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/inode.c
--- ./fs/fat/inode.c	2023-04-26 12:56:08.180118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fat/inode.c	2023-04-23 12:07:23.703016500 +0100
@@ -1252,6 +1252,7 @@
 	struct inode *fsinfo_inode = NULL;
 	struct buffer_head *bh;
 	struct fat_boot_sector *b;
+	struct fat_boot_bsx *bsx;
 	struct msdos_sb_info *sbi;
 	u16 logical_sector_size;
 	u32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;
@@ -1398,6 +1399,8 @@
 			goto out_fail;
 		}
 
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT32_BSX_OFFSET);
+
 		fsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;
 		if (!IS_FSINFO(fsinfo)) {
 			fat_msg(sb, KERN_WARNING, "Invalid FSINFO signature: "
@@ -1413,8 +1416,14 @@
 		}
 
 		brelse(fsinfo_bh);
+	} else {
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT16_BSX_OFFSET);
 	}
 
+	/* interpret volume ID as a little endian 32 bit integer */
+	sbi->vol_id = (((u32)bsx->vol_id[0]) | ((u32)bsx->vol_id[1] << 8) |
+		((u32)bsx->vol_id[2] << 16) | ((u32)bsx->vol_id[3] << 24));
+
 	sbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);
 	sbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;
 
diff -ur ./fs/fs-writeback.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fs-writeback.c
--- ./fs/fs-writeback.c	2023-04-26 12:56:08.190118954 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fs-writeback.c	2023-04-23 12:07:24.101118800 +0100
@@ -1139,7 +1139,7 @@
 	if ((inode->i_state & flags) == flags)
 		return;
 
-	if (unlikely(block_dump))
+	if (unlikely(block_dump > 1))
 		block_dump___mark_inode_dirty(inode);
 
 	spin_lock(&inode->i_lock);
diff -ur ./fs/fuse/dev.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fuse/dev.c
--- ./fs/fuse/dev.c	2023-04-26 12:26:23.280132364 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/fuse/dev.c	2023-04-23 12:07:24.659788100 +0100
@@ -20,6 +20,7 @@
 #include <linux/swap.h>
 #include <linux/splice.h>
 #include <linux/aio.h>
+#include <linux/freezer.h>
 
 MODULE_ALIAS_MISCDEV(FUSE_MINOR);
 MODULE_ALIAS("devname:fuse");
@@ -464,7 +465,10 @@
 	 * Wait it out.
 	 */
 	spin_unlock(&fc->lock);
-	wait_event(req->waitq, req->state == FUSE_REQ_FINISHED);
+
+	while (req->state != FUSE_REQ_FINISHED)
+		wait_event_freezable(req->waitq,
+				     req->state == FUSE_REQ_FINISHED);
 	spin_lock(&fc->lock);
 
 	if (!req->aborted)
diff -ur ./fs/nfs/inode.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/inode.c
--- ./fs/nfs/inode.c	2023-04-26 12:56:08.270118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/inode.c	2023-04-23 12:07:31.141324700 +0100
@@ -79,7 +79,7 @@
 {
 	if (fatal_signal_pending(current))
 		return -ERESTARTSYS;
-	freezable_schedule();
+	freezable_schedule_unsafe();
 	return 0;
 }
 EXPORT_SYMBOL_GPL(nfs_wait_bit_killable);
diff -ur ./fs/nfs/nfs3proc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/nfs3proc.c
--- ./fs/nfs/nfs3proc.c	2023-04-26 12:56:08.270118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/nfs3proc.c	2023-04-23 12:07:31.301251800 +0100
@@ -33,7 +33,7 @@
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EJUKEBOX)
 			break;
-		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		freezable_schedule_timeout_killable_unsafe(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
diff -ur ./fs/nfs/nfs4proc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/nfs4proc.c
--- ./fs/nfs/nfs4proc.c	2023-04-26 12:56:08.280118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nfs/nfs4proc.c	2023-04-23 12:07:31.539854900 +0100
@@ -268,7 +268,7 @@
 		*timeout = NFS4_POLL_RETRY_MIN;
 	if (*timeout > NFS4_POLL_RETRY_MAX)
 		*timeout = NFS4_POLL_RETRY_MAX;
-	freezable_schedule_timeout_killable(*timeout);
+	freezable_schedule_timeout_killable_unsafe(*timeout);
 	if (fatal_signal_pending(current))
 		res = -ERESTARTSYS;
 	*timeout <<= 1;
@@ -4528,7 +4528,7 @@
 static unsigned long
 nfs4_set_lock_task_retry(unsigned long timeout)
 {
-	freezable_schedule_timeout_killable(timeout);
+	freezable_schedule_timeout_killable_unsafe(timeout);
 	timeout <<= 1;
 	if (timeout > NFS4_LOCK_MAXTIMEOUT)
 		return NFS4_LOCK_MAXTIMEOUT;
diff -ur ./fs/nls/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nls/Kconfig
--- ./fs/nls/Kconfig	2023-04-26 12:26:23.740132363 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/nls/Kconfig	2023-04-23 12:07:33.614466900 +0100
@@ -395,7 +395,7 @@
 	  correctly on the screen, you need to include the appropriate
 	  input/output character sets. Say Y here for the Latin 5 character
 	  set, and it replaces the rarely needed Icelandic letters in Latin 1
-	  with the Turkish ones. Useful in Turkey.
+	  with the Turkish ones. Useful in Swan.
 
 config NLS_ISO8859_13
 	tristate "NLS ISO 8859-13 (Latin 7; Baltic)"
diff -ur ./fs/proc/base.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/proc/base.c
--- ./fs/proc/base.c	2023-04-26 12:56:08.380118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/proc/base.c	2023-04-23 12:07:38.982916500 +0100
@@ -139,6 +139,12 @@
 		NULL, &proc_single_file_operations,	\
 		{ .proc_show = show } )
 
+/* ANDROID is for special files in /proc. */
+#define ANDROID(NAME, MODE, OTYPE)			\
+	NOD(NAME, (S_IFREG|(MODE)),			\
+		&proc_##OTYPE##_inode_operations,	\
+		&proc_##OTYPE##_operations, {})
+
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -1000,6 +1006,35 @@
 	return err < 0 ? err : count;
 }
 
+static int oom_adjust_permission(struct inode *inode, int mask)
+{
+	uid_t uid;
+	struct task_struct *p;
+
+	p = get_proc_task(inode);
+	if(p) {
+		uid = task_uid(p);
+		put_task_struct(p);
+	}
+
+	/*
+	 * System Server (uid == 1000) is granted access to oom_adj of all 
+	 * android applications (uid > 10000) as and services (uid >= 1000)
+	 */
+	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
+		if (inode->i_mode >> 6 & mask) {
+			return 0;
+		}
+	}
+
+	/* Fall back to default. */
+	return generic_permission(inode, mask);
+}
+
+static const struct inode_operations proc_oom_adj_inode_operations = {
+	.permission	= oom_adjust_permission,
+};
+
 static const struct file_operations proc_oom_adj_operations = {
 	.read		= oom_adj_read,
 	.write		= oom_adj_write,
@@ -2697,7 +2732,7 @@
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),
+	ANDROID("oom_adj", S_IRUGO|S_IWUSR, oom_adj),
 	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
diff -ur ./fs/proc/task_mmu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/proc/task_mmu.c
--- ./fs/proc/task_mmu.c	2023-04-26 12:56:08.390118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/proc/task_mmu.c	2023-04-23 12:07:39.298026600 +0100
@@ -134,6 +134,56 @@
 }
 #endif
 
+static void seq_print_vma_name(struct seq_file *m, struct vm_area_struct *vma)
+{
+	const char __user *name = vma_get_anon_name(vma);
+	struct mm_struct *mm = vma->vm_mm;
+
+	unsigned long page_start_vaddr;
+	unsigned long page_offset;
+	unsigned long num_pages;
+	unsigned long max_len = NAME_MAX;
+	int i;
+
+	page_start_vaddr = (unsigned long)name & PAGE_MASK;
+	page_offset = (unsigned long)name - page_start_vaddr;
+	num_pages = DIV_ROUND_UP(page_offset + max_len, PAGE_SIZE);
+
+	seq_puts(m, "[anon:");
+
+	for (i = 0; i < num_pages; i++) {
+		int len;
+		int write_len;
+		const char *kaddr;
+		long pages_pinned;
+		struct page *page;
+
+		pages_pinned = get_user_pages(current, mm, page_start_vaddr,
+				1, 0, 0, &page, NULL);
+		if (pages_pinned < 1) {
+			seq_puts(m, "<fault>]");
+			return;
+		}
+
+		kaddr = (const char *)kmap(page);
+		len = min(max_len, PAGE_SIZE - page_offset);
+		write_len = strnlen(kaddr + page_offset, len);
+		seq_write(m, kaddr + page_offset, write_len);
+		kunmap(page);
+		put_page(page);
+
+		/* if strnlen hit a null terminator then we're done */
+		if (write_len != len)
+			break;
+
+		max_len -= len;
+		page_offset = 0;
+		page_start_vaddr += PAGE_SIZE;
+	}
+
+	seq_putc(m, ']');
+}
+
 static void vma_stop(struct proc_maps_private *priv, struct vm_area_struct *vma)
 {
 	if (vma && vma != priv->tail_vma) {
@@ -335,6 +385,12 @@
 				pad_len_spaces(m, len);
 				seq_printf(m, "[stack:%d]", tid);
 			}
+			goto done;
+		}
+
+		if (vma_get_anon_name(vma)) {
+			pad_len_spaces(m, len);
+			seq_print_vma_name(m, vma);
 		}
 	}
 
@@ -634,6 +690,12 @@
 
 	show_smap_vma_flags(m, vma);
 
+	if (vma_get_anon_name(vma)) {
+		seq_puts(m, "Name:           ");
+		seq_print_vma_name(m, vma);
+		seq_putc(m, '\n');
+	}
+
 	if (m->count < m->size)  /* vma is copied successfully */
 		m->version = (vma != get_gate_vma(task->mm))
 			? vma->vm_start : 0;
diff -ur ./fs/select.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/select.c
--- ./fs/select.c	2023-04-26 12:56:08.410118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/select.c	2023-04-23 12:07:41.138491600 +0100
@@ -27,6 +27,7 @@
 #include <linux/rcupdate.h>
 #include <linux/hrtimer.h>
 #include <linux/sched/rt.h>
+#include <linux/freezer.h>
 
 #include <asm/uaccess.h>
 
@@ -236,7 +237,8 @@
 
 	set_current_state(state);
 	if (!pwq->triggered)
-		rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);
+		rc = freezable_schedule_hrtimeout_range(expires, slack,
+							HRTIMER_MODE_ABS);
 	__set_current_state(TASK_RUNNING);
 
 	/*
diff -ur ./fs/timerfd.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/timerfd.c
--- ./fs/timerfd.c	2023-04-26 12:56:08.420118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/fs/timerfd.c	2023-04-23 12:07:42.179720600 +0100
@@ -8,6 +8,7 @@
  *
  */
 
+#include <linux/alarmtimer.h>
 #include <linux/file.h>
 #include <linux/poll.h>
 #include <linux/init.h>
@@ -26,7 +27,10 @@
 #include <linux/rcupdate.h>
 
 struct timerfd_ctx {
-	struct hrtimer tmr;
+	union {
+		struct hrtimer tmr;
+		struct alarm alarm;
+	} t;
 	ktime_t tintv;
 	ktime_t moffs;
 	wait_queue_head_t wqh;
@@ -41,14 +45,19 @@
 static LIST_HEAD(cancel_list);
 static DEFINE_SPINLOCK(cancel_lock);
 
+static inline bool isalarm(struct timerfd_ctx *ctx)
+{
+	return ctx->clockid == CLOCK_REALTIME_ALARM ||
+		ctx->clockid == CLOCK_BOOTTIME_ALARM;
+}
+
 /*
  * This gets called when the timer event triggers. We set the "expired"
  * flag, but we do not re-arm the timer (in case it's necessary,
  * tintv.tv64 != 0) until the timer is accessed.
  */
-static enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)
+static void timerfd_triggered(struct timerfd_ctx *ctx)
 {
-	struct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx, tmr);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctx->wqh.lock, flags);
@@ -56,10 +65,25 @@
 	ctx->ticks++;
 	wake_up_locked(&ctx->wqh);
 	spin_unlock_irqrestore(&ctx->wqh.lock, flags);
+}
 
+static enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)
+{
+	struct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx,
+					       t.tmr);
+	timerfd_triggered(ctx);
 	return HRTIMER_NORESTART;
 }
 
+static enum alarmtimer_restart timerfd_alarmproc(struct alarm *alarm,
+	ktime_t now)
+{
+	struct timerfd_ctx *ctx = container_of(alarm, struct timerfd_ctx,
+					       t.alarm);
+	timerfd_triggered(ctx);
+	return ALARMTIMER_NORESTART;
+}
+
 /*
  * Called when the clock was set to cancel the timers in the cancel
  * list. This will wake up processes waiting on these timers. The
@@ -107,8 +131,9 @@
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
-	if (ctx->clockid == CLOCK_REALTIME && (flags & TFD_TIMER_ABSTIME) &&
-	    (flags & TFD_TIMER_CANCEL_ON_SET)) {
+	if ((ctx->clockid == CLOCK_REALTIME ||
+	     ctx->clockid == CLOCK_REALTIME_ALARM) &&
+	    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {
 		if (!ctx->might_cancel) {
 			ctx->might_cancel = true;
 			spin_lock(&cancel_lock);
@@ -124,7 +149,11 @@
 {
 	ktime_t remaining;
 
-	remaining = hrtimer_expires_remaining(&ctx->tmr);
+	if (isalarm(ctx))
+		remaining = alarm_expires_remaining(&ctx->t.alarm);
+	else
+		remaining = hrtimer_expires_remaining(&ctx->t.tmr);
+
 	return remaining.tv64 < 0 ? ktime_set(0, 0): remaining;
 }
 
@@ -142,11 +171,28 @@
 	ctx->expired = 0;
 	ctx->ticks = 0;
 	ctx->tintv = timespec_to_ktime(ktmr->it_interval);
-	hrtimer_init(&ctx->tmr, clockid, htmode);
-	hrtimer_set_expires(&ctx->tmr, texp);
-	ctx->tmr.function = timerfd_tmrproc;
+
+	if (isalarm(ctx)) {
+		alarm_init(&ctx->t.alarm,
+			   ctx->clockid == CLOCK_REALTIME_ALARM ?
+			   ALARM_REALTIME : ALARM_BOOTTIME,
+			   timerfd_alarmproc);
+	} else {
+		hrtimer_init(&ctx->t.tmr, clockid, htmode);
+		hrtimer_set_expires(&ctx->t.tmr, texp);
+		ctx->t.tmr.function = timerfd_tmrproc;
+	}
+
 	if (texp.tv64 != 0) {
-		hrtimer_start(&ctx->tmr, texp, htmode);
+		if (isalarm(ctx)) {
+			if (flags & TFD_TIMER_ABSTIME)
+				alarm_start(&ctx->t.alarm, texp);
+			else
+				alarm_start_relative(&ctx->t.alarm, texp);
+		} else {
+			hrtimer_start(&ctx->t.tmr, texp, htmode);
+		}
+
 		if (timerfd_canceled(ctx))
 			return -ECANCELED;
 	}
@@ -158,7 +204,11 @@
 	struct timerfd_ctx *ctx = file->private_data;
 
 	timerfd_remove_cancel(ctx);
-	hrtimer_cancel(&ctx->tmr);
+
+	if (isalarm(ctx))
+		alarm_cancel(&ctx->t.alarm);
+	else
+		hrtimer_cancel(&ctx->t.tmr);
 	kfree_rcu(ctx, rcu);
 	return 0;
 }
@@ -215,9 +265,15 @@
 			 * callback to avoid DoS attacks specifying a very
 			 * short timer period.
 			 */
-			ticks += hrtimer_forward_now(&ctx->tmr,
-						     ctx->tintv) - 1;
-			hrtimer_restart(&ctx->tmr);
+			if (isalarm(ctx)) {
+				ticks += alarm_forward_now(
+					&ctx->t.alarm, ctx->tintv) - 1;
+				alarm_restart(&ctx->t.alarm);
+			} else {
+				ticks += hrtimer_forward_now(&ctx->t.tmr,
+							     ctx->tintv) - 1;
+				hrtimer_restart(&ctx->t.tmr);
+			}
 		}
 		ctx->expired = 0;
 		ctx->ticks = 0;
@@ -259,7 +315,10 @@
 
 	if ((flags & ~TFD_CREATE_FLAGS) ||
 	    (clockid != CLOCK_MONOTONIC &&
-	     clockid != CLOCK_REALTIME))
+	     clockid != CLOCK_REALTIME &&
+	     clockid != CLOCK_REALTIME_ALARM &&
+	     clockid != CLOCK_BOOTTIME &&
+	     clockid != CLOCK_BOOTTIME_ALARM))
 		return -EINVAL;
 
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
@@ -268,7 +327,15 @@
 
 	init_waitqueue_head(&ctx->wqh);
 	ctx->clockid = clockid;
-	hrtimer_init(&ctx->tmr, clockid, HRTIMER_MODE_ABS);
+
+	if (isalarm(ctx))
+		alarm_init(&ctx->t.alarm,
+			   ctx->clockid == CLOCK_REALTIME_ALARM ?
+			   ALARM_REALTIME : ALARM_BOOTTIME,
+			   timerfd_alarmproc);
+	else
+		hrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);
+
 	ctx->moffs = ktime_get_monotonic_offset();
 
 	ufd = anon_inode_getfd("[timerfd]", &timerfd_fops, ctx,
@@ -305,8 +372,14 @@
 	 */
 	for (;;) {
 		spin_lock_irq(&ctx->wqh.lock);
-		if (hrtimer_try_to_cancel(&ctx->tmr) >= 0)
-			break;
+
+		if (isalarm(ctx)) {
+			if (alarm_try_to_cancel(&ctx->t.alarm) >= 0)
+				break;
+		} else {
+			if (hrtimer_try_to_cancel(&ctx->t.tmr) >= 0)
+				break;
+		}
 		spin_unlock_irq(&ctx->wqh.lock);
 		cpu_relax();
 	}
@@ -317,8 +390,12 @@
 	 * We do not update "ticks" and "expired" since the timer will be
 	 * re-programmed again in the following timerfd_setup() call.
 	 */
-	if (ctx->expired && ctx->tintv.tv64)
-		hrtimer_forward_now(&ctx->tmr, ctx->tintv);
+	if (ctx->expired && ctx->tintv.tv64) {
+		if (isalarm(ctx))
+			alarm_forward_now(&ctx->t.alarm, ctx->tintv);
+		else
+			hrtimer_forward_now(&ctx->t.tmr, ctx->tintv);
+	}
 
 	old->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));
 	old->it_interval = ktime_to_timespec(ctx->tintv);
@@ -345,9 +422,18 @@
 	spin_lock_irq(&ctx->wqh.lock);
 	if (ctx->expired && ctx->tintv.tv64) {
 		ctx->expired = 0;
-		ctx->ticks +=
-			hrtimer_forward_now(&ctx->tmr, ctx->tintv) - 1;
-		hrtimer_restart(&ctx->tmr);
+
+		if (isalarm(ctx)) {
+			ctx->ticks +=
+				alarm_forward_now(
+					&ctx->t.alarm, ctx->tintv) - 1;
+			alarm_restart(&ctx->t.alarm);
+		} else {
+			ctx->ticks +=
+				hrtimer_forward_now(&ctx->t.tmr, ctx->tintv)
+				- 1;
+			hrtimer_restart(&ctx->t.tmr);
+		}
 	}
 	t->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));
 	t->it_interval = ktime_to_timespec(ctx->tintv);
diff -ur ./include/asm-generic/gpio.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/asm-generic/gpio.h
--- ./include/asm-generic/gpio.h	2023-04-26 12:26:24.360132093 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/asm-generic/gpio.h	2023-04-23 12:07:48.418463500 +0100
@@ -118,6 +118,9 @@
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset, unsigned debounce);
 
+	int			(*set_pull)(struct gpio_chip *chip,
+						unsigned offset, unsigned pull);
+
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: Kbuild
diff -ur ./include/linux/alarmtimer.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/alarmtimer.h
--- ./include/linux/alarmtimer.h	2023-04-26 12:56:08.500118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/alarmtimer.h	2023-04-23 12:07:52.339476900 +0100
@@ -44,10 +44,14 @@
 void alarm_init(struct alarm *alarm, enum alarmtimer_type type,
 		enum alarmtimer_restart (*function)(struct alarm *, ktime_t));
 int alarm_start(struct alarm *alarm, ktime_t start);
+int alarm_start_relative(struct alarm *alarm, ktime_t start);
+void alarm_restart(struct alarm *alarm);
 int alarm_try_to_cancel(struct alarm *alarm);
 int alarm_cancel(struct alarm *alarm);
 
 u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval);
+u64 alarm_forward_now(struct alarm *alarm, ktime_t interval);
+ktime_t alarm_expires_remaining(const struct alarm *alarm);
 
 /* Provide way to access the rtc device being used by alarmtimers */
 struct rtc_device *alarmtimer_get_rtcdev(void);
diff -ur ./include/linux/amba/mmci.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/amba/mmci.h
--- ./include/linux/amba/mmci.h	2023-04-26 12:26:24.440132055 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/amba/mmci.h	2023-04-23 12:07:52.499913700 +0100
@@ -5,6 +5,15 @@
 #define AMBA_MMCI_H
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+struct embedded_sdio_data {
+        struct sdio_cis cis;
+        struct sdio_cccr cccr;
+        struct sdio_embedded_func *funcs;
+        int num_funcs;
+};
 
 
 /*
@@ -73,6 +82,9 @@
 	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
 	void *dma_rx_param;
 	void *dma_tx_param;
+	unsigned int status_irq;
+	struct embedded_sdio_data *embedded_sdio;
+	int (*register_status_notify)(void (*callback)(int card_present, void *dev_id), void *dev_id);
 };
 
 #endif
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: android_aid.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: bcm_pm_core.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: bt-rfkill.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: byd_8991.h
diff -ur ./include/linux/cgroup.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cgroup.h
--- ./include/linux/cgroup.h	2023-04-26 12:56:08.510118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cgroup.h	2023-04-23 12:07:55.217237800 +0100
@@ -578,6 +578,7 @@
 	void (*css_offline)(struct cgroup *cgrp);
 	void (*css_free)(struct cgroup *cgrp);
 
+	int (*allow_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	int (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
diff -ur ./include/linux/clk.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/clk.h
--- ./include/linux/clk.h	2023-04-26 12:26:24.500132025 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/clk.h	2023-04-23 12:07:55.382771000 +0100
@@ -171,6 +171,14 @@
 int clk_enable(struct clk *clk);
 
 /**
+ * clk_is_enable - indicate that whether the clock source is enabled.
+ * @clk: clock source
+ *
+ * Returns 1 if clock source is enabled, or 0 if disabled.
+ */
+int clk_is_enabled(struct clk *clk);
+
+/**
  * clk_disable - inform the system when the clock source is no longer required.
  * @clk: clock source
  *
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: compiler-gcc5.h
diff -ur ./include/linux/cpu.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cpu.h
--- ./include/linux/cpu.h	2023-04-26 12:56:08.510118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cpu.h	2023-04-23 12:07:56.021295500 +0100
@@ -232,4 +232,11 @@
 void arch_cpu_idle_exit(void);
 void arch_cpu_idle_dead(void);
 
+#define IDLE_START 1
+#define IDLE_END 2
+
+void idle_notifier_register(struct notifier_block *n);
+void idle_notifier_unregister(struct notifier_block *n);
+void idle_notifier_call_chain(unsigned long val);
+
 #endif /* _LINUX_CPU_H_ */
diff -ur ./include/linux/cpufreq.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cpufreq.h
--- ./include/linux/cpufreq.h	2023-04-26 12:56:08.520118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/cpufreq.h	2023-04-23 12:07:56.103597700 +0100
@@ -107,6 +107,7 @@
 	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
+	bool			governor_enabled; /* governor start/stop flag */
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
diff -ur ./include/linux/debug_locks.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/debug_locks.h
--- ./include/linux/debug_locks.h	2023-04-26 12:56:08.520118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/debug_locks.h	2023-04-23 12:07:56.658663300 +0100
@@ -51,7 +51,7 @@
 extern void debug_show_all_locks(void);
 extern void debug_show_held_locks(struct task_struct *task);
 extern void debug_check_no_locks_freed(const void *from, unsigned long len);
-extern void debug_check_no_locks_held(struct task_struct *task);
+extern void debug_check_no_locks_held(void);
 #else
 static inline void debug_show_all_locks(void)
 {
@@ -67,7 +67,7 @@
 }
 
 static inline void
-debug_check_no_locks_held(struct task_struct *task)
+debug_check_no_locks_held(void)
 {
 }
 #endif
diff -ur ./include/linux/device.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/device.h
--- ./include/linux/device.h	2023-04-26 12:56:08.520118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/device.h	2023-04-23 12:07:56.983842500 +0100
@@ -48,6 +48,10 @@
 
 #define BUS_ATTR(_name, _mode, _show, _store)	\
 struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
+#define BUS_ATTR_RW(_name) \
+	struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)
+#define BUS_ATTR_RO(_name) \
+	struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)
 
 extern int __must_check bus_create_file(struct bus_type *,
 					struct bus_attribute *);
@@ -174,6 +178,8 @@
 						      unbound */
 #define BUS_NOTIFY_UNBOUND_DRIVER	0x00000006 /* driver is unbound
 						      from the device */
+#define BUS_NOTIFY_BIND_FAILED		0x00000007 /* driver failed to bind
+						      to device */
 
 extern struct kset *bus_get_kset(struct bus_type *bus);
 extern struct klist *bus_get_device_klist(struct bus_type *bus);
@@ -254,8 +260,11 @@
 };
 
 #define DRIVER_ATTR(_name, _mode, _show, _store)	\
-struct driver_attribute driver_attr_##_name =		\
-	__ATTR(_name, _mode, _show, _store)
+	struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)
+#define DRIVER_ATTR_RW(_name) \
+	struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)
+#define DRIVER_ATTR_RO(_name) \
+	struct driver_attribute driver_attr_##_name = __ATTR_RO(_name)
 
 extern int __must_check driver_create_file(struct device_driver *driver,
 					const struct driver_attribute *attr);
@@ -408,6 +417,10 @@
 
 #define CLASS_ATTR(_name, _mode, _show, _store)			\
 struct class_attribute class_attr_##_name = __ATTR(_name, _mode, _show, _store)
+#define CLASS_ATTR_RW(_name) \
+	struct class_attribute class_attr_##_name = __ATTR_RW(_name)
+#define CLASS_ATTR_RO(_name) \
+	struct class_attribute class_attr_##_name = __ATTR_RO(_name)
 
 extern int __must_check class_create_file(struct class *class,
 					  const struct class_attribute *attr);
@@ -504,6 +517,10 @@
 
 #define DEVICE_ATTR(_name, _mode, _show, _store) \
 	struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
+#define DEVICE_ATTR_RW(_name) \
+	struct device_attribute dev_attr_##_name = __ATTR_RW(_name)
+#define DEVICE_ATTR_RO(_name) \
+	struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
 #define DEVICE_ULONG_ATTR(_name, _mode, _var) \
 	struct dev_ext_attribute dev_attr_##_name = \
 		{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &(_var) }
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: digital_pulse_backlight.h
diff -ur ./include/linux/dmaengine.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/dmaengine.h
--- ./include/linux/dmaengine.h	2023-04-26 12:56:08.520118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/dmaengine.h	2023-04-23 12:07:57.304810600 +0100
@@ -482,6 +482,8 @@
 }
 #endif
 
+
+
 /**
  * struct dma_tx_state - filled in to report the status of
  * a transfer.
@@ -495,6 +497,7 @@
 	dma_cookie_t last;
 	dma_cookie_t used;
 	u32 residue;
+
 };
 
 /**
@@ -556,6 +559,15 @@
 	int (*device_alloc_chan_resources)(struct dma_chan *chan);
 	void (*device_free_chan_resources)(struct dma_chan *chan);
 
+	/*device_add_desc added by ingenic to use in i2c
+	 * if DMA_TO_DEVICE flag=0 dst srt&addr increment ,flag=1 src increment */
+	struct dma_async_tx_descriptor *(*device_add_desc)(
+		struct dma_chan *chan, dma_addr_t src,dma_addr_t dst,
+		unsigned cnt,enum dma_transfer_direction direction,int flag);
+        dma_addr_t (*get_current_trans_addr)(
+		struct dma_chan *chan,dma_addr_t *dst_addr,
+	        dma_addr_t *src_addr,enum dma_transfer_direction direction);
+
 	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
 		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 		size_t len, unsigned long flags);
diff -ur ./include/linux/elf.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/elf.h
--- ./include/linux/elf.h	2023-04-26 12:26:24.560131996 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/elf.h	2023-04-23 12:07:57.939265400 +0100
@@ -37,6 +37,10 @@
 
 #endif
 
+#ifndef elf_lib_check_arch
+#define elf_lib_check_arch(a)   (1)
+#endif
+
 /* Optional callbacks to write extra ELF notes. */
 struct file;
 
diff -ur ./include/linux/extcon.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/extcon.h
--- ./include/linux/extcon.h	2023-04-26 12:26:24.570131992 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/extcon.h	2023-04-23 12:07:58.257921500 +0100
@@ -237,6 +237,12 @@
 				    struct notifier_block *nb);
 extern int extcon_unregister_notifier(struct extcon_dev *edev,
 				      struct notifier_block *nb);
+
+/*
+ * Following API get the extcon device from devicetree.
+ * This function use phandle of devicetree to get extcon device directly.
+ */
+extern struct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index);
 #else /* CONFIG_EXTCON */
 static inline int extcon_dev_register(struct extcon_dev *edev,
 				      struct device *dev)
@@ -322,5 +328,11 @@
 {
 	return 0;
 }
+
+static inline struct extcon_dev *extcon_get_edev_by_phandle(struct device *dev,
+							    int index)
+{
+	return ERR_PTR(-ENODEV);
+}
 #endif /* CONFIG_EXTCON */
 #endif /* __LINUX_EXTCON_H__ */
diff -ur ./include/linux/freezer.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/freezer.h
--- ./include/linux/freezer.h	2023-04-26 12:56:08.520118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/freezer.h	2023-04-23 12:07:58.821869800 +0100
@@ -3,6 +3,7 @@
 #ifndef FREEZER_H_INCLUDED
 #define FREEZER_H_INCLUDED
 
+#include <linux/debug_locks.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/atomic.h>
@@ -46,7 +47,11 @@
 extern void thaw_processes(void);
 extern void thaw_kernel_threads(void);
 
-static inline bool try_to_freeze(void)
+/*
+ * DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION
+ * If try_to_freeze causes a lockdep warning it means the caller may deadlock
+ */
+static inline bool try_to_freeze_unsafe(void)
 {
 	might_sleep();
 	if (likely(!freezing(current)))
@@ -54,6 +59,13 @@
 	return __refrigerator(false);
 }
 
+static inline bool try_to_freeze(void)
+{
+	if (!(current->flags & PF_NOFREEZE))
+		debug_check_no_locks_held();
+	return try_to_freeze_unsafe();
+}
+
 extern bool freeze_task(struct task_struct *p);
 extern bool set_freezable(void);
 
@@ -115,6 +127,14 @@
 	try_to_freeze();
 }
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+static inline void freezer_count_unsafe(void)
+{
+	current->flags &= ~PF_FREEZER_SKIP;
+	smp_mb();
+	try_to_freeze_unsafe();
+}
+
 /**
  * freezer_should_skip - whether to skip a task when determining frozen
  *			 state is reached
@@ -139,28 +159,86 @@
 }
 
 /*
- * These macros are intended to be used whenever you want allow a sleeping
+ * These functions are intended to be used whenever you want allow a sleeping
  * task to be frozen. Note that neither return any clear indication of
  * whether a freeze event happened while in this function.
  */
 
 /* Like schedule(), but should not block the freezer. */
-#define freezable_schedule()						\
-({									\
-	freezer_do_not_count();						\
-	schedule();							\
-	freezer_count();						\
-})
+static inline void freezable_schedule(void)
+{
+	freezer_do_not_count();
+	schedule();
+	freezer_count();
+}
+
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+static inline void freezable_schedule_unsafe(void)
+{
+	freezer_do_not_count();
+	schedule();
+	freezer_count_unsafe();
+}
+
+/*
+ * Like freezable_schedule_timeout(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline long freezable_schedule_timeout(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout(timeout);
+	freezer_count();
+	return __retval;
+}
+
+/*
+ * Like schedule_timeout_interruptible(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline long freezable_schedule_timeout_interruptible(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_interruptible(timeout);
+	freezer_count();
+	return __retval;
+}
 
 /* Like schedule_timeout_killable(), but should not block the freezer. */
-#define freezable_schedule_timeout_killable(timeout)			\
-({									\
-	long __retval;							\
-	freezer_do_not_count();						\
-	__retval = schedule_timeout_killable(timeout);			\
-	freezer_count();						\
-	__retval;							\
-})
+static inline long freezable_schedule_timeout_killable(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_killable(timeout);
+	freezer_count();
+	return __retval;
+}
+
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+static inline long freezable_schedule_timeout_killable_unsafe(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_killable(timeout);
+	freezer_count_unsafe();
+	return __retval;
+}
+
+/*
+ * Like schedule_hrtimeout_range(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
+		unsigned long delta, const enum hrtimer_mode mode)
+{
+	int __retval;
+	freezer_do_not_count();
+	__retval = schedule_hrtimeout_range(expires, delta, mode);
+	freezer_count();
+	return __retval;
+}
 
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),
@@ -177,33 +255,45 @@
 	__retval;							\
 })
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+#define wait_event_freezekillable_unsafe(wq, condition)			\
+({									\
+	int __retval;							\
+	freezer_do_not_count();						\
+	__retval = wait_event_killable(wq, (condition));		\
+	freezer_count_unsafe();						\
+	__retval;							\
+})
+
 #define wait_event_freezable(wq, condition)				\
 ({									\
 	int __retval;							\
-	for (;;) {							\
-		__retval = wait_event_interruptible(wq, 		\
-				(condition) || freezing(current));	\
-		if (__retval || (condition))				\
-			break;						\
-		try_to_freeze();					\
-	}								\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible(wq, (condition));		\
+	freezer_count();						\
 	__retval;							\
 })
 
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 ({									\
 	long __retval = timeout;					\
-	for (;;) {							\
-		__retval = wait_event_interruptible_timeout(wq,		\
-				(condition) || freezing(current),	\
-				__retval); 				\
-		if (__retval <= 0 || (condition))			\
-			break;						\
-		try_to_freeze();					\
-	}								\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible_timeout(wq,	(condition),	\
+				__retval);				\
+	freezer_count();						\
 	__retval;							\
 })
 
+#define wait_event_freezable_exclusive(wq, condition)			\
+({									\
+	int __retval;							\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible_exclusive(wq, condition);	\
+	freezer_count();						\
+	__retval;							\
+})
+
+
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
@@ -225,18 +315,37 @@
 
 #define freezable_schedule()  schedule()
 
+#define freezable_schedule_unsafe()  schedule()
+
+#define freezable_schedule_timeout(timeout)  schedule_timeout(timeout)
+
+#define freezable_schedule_timeout_interruptible(timeout)		\
+	schedule_timeout_interruptible(timeout)
+
 #define freezable_schedule_timeout_killable(timeout)			\
 	schedule_timeout_killable(timeout)
 
+#define freezable_schedule_timeout_killable_unsafe(timeout)		\
+	schedule_timeout_killable(timeout)
+
+#define freezable_schedule_hrtimeout_range(expires, delta, mode)	\
+	schedule_hrtimeout_range(expires, delta, mode)
+
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)
 
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 		wait_event_interruptible_timeout(wq, condition, timeout)
 
+#define wait_event_freezable_exclusive(wq, condition)			\
+		wait_event_interruptible_exclusive(wq, condition)
+
 #define wait_event_freezekillable(wq, condition)		\
 		wait_event_killable(wq, condition)
 
+#define wait_event_freezekillable_unsafe(wq, condition)			\
+		wait_event_killable(wq, condition)
+
 #endif /* !CONFIG_FREEZER */
 
 #endif	/* FREEZER_H_INCLUDED */
diff -ur ./include/linux/gpio.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/gpio.h
--- ./include/linux/gpio.h	2023-04-26 12:26:24.600131977 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/gpio.h	2023-04-23 12:07:59.621469500 +0100
@@ -136,6 +136,12 @@
 	return -ENOSYS;
 }
 
+static inline int gpio_set_pull(unsigned gpio, unsigned pull)
+{
+	return -ENOSYS;
+}
+
+
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: gpio_event.h
diff -ur ./include/linux/hid.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/hid.h
--- ./include/linux/hid.h	2023-04-26 12:56:08.530118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/hid.h	2023-04-23 12:07:59.939795900 +0100
@@ -649,8 +649,8 @@
 	int (*input_mapped)(struct hid_device *hdev,
 			struct hid_input *hidinput, struct hid_field *field,
 			struct hid_usage *usage, unsigned long **bit, int *max);
-	void (*input_configured)(struct hid_device *hdev,
-				 struct hid_input *hidinput);
+	int (*input_configured)(struct hid_device *hdev,
+				struct hid_input *hidinput);
 	void (*feature_mapping)(struct hid_device *hdev,
 			struct hid_field *field,
 			struct hid_usage *usage);
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/i2c: ft5336_ts.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/i2c: ite7258_tsc.h
diff -ur ./include/linux/i2c/pca953x.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/i2c/pca953x.h
--- ./include/linux/i2c/pca953x.h	2023-04-26 12:26:24.620131967 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/i2c/pca953x.h	2023-04-23 12:08:01.220651900 +0100
@@ -13,6 +13,12 @@
 	/* initial polarity inversion setting */
 	u32		invert;
 
+        /*reset pin */
+	unsigned	reset_n;
+
+	/*irq pin */
+	unsigned	irq_n;
+
 	/* interrupt base */
 	int		irq_base;
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: if_pppolac.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: if_pppopns.h
diff -ur ./include/linux/if_pppox.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/if_pppox.h
--- ./include/linux/if_pppox.h	2023-04-26 12:26:24.650131953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/if_pppox.h	2023-04-23 12:08:01.953345000 +0100
@@ -41,6 +41,25 @@
 	u32 seq_sent, seq_recv;
 	int ppp_flags;
 };
+
+struct pppolac_opt {
+	__u32		local;
+	__u32		remote;
+	__u32		recv_sequence;
+	__u32		xmit_sequence;
+	atomic_t	sequencing;
+	int		(*backlog_rcv)(struct sock *sk_udp, struct sk_buff *skb);
+};
+
+struct pppopns_opt {
+	__u16		local;
+	__u16		remote;
+	__u32		recv_sequence;
+	__u32		xmit_sequence;
+	void		(*data_ready)(struct sock *sk_raw, int length);
+	int		(*backlog_rcv)(struct sock *sk_raw, struct sk_buff *skb);
+};
+
 #include <net/sock.h>
 
 struct pppox_sock {
@@ -51,6 +70,8 @@
 	union {
 		struct pppoe_opt pppoe;
 		struct pptp_opt  pptp;
+		struct pppolac_opt lac;
+		struct pppopns_opt pns;
 	} proto;
 	__be16			num;
 };
diff -ur ./include/linux/iio/buffer.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/buffer.h
--- ./include/linux/iio/buffer.h	2023-04-26 12:26:24.650131953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/buffer.h	2023-04-23 12:08:02.102483600 +0100
@@ -74,6 +74,7 @@
 	struct attribute_group			*scan_el_attrs;
 	long					*scan_mask;
 	bool					scan_timestamp;
+	unsigned				scan_index_timestamp;
 	const struct iio_buffer_access_funcs	*access;
 	struct list_head			scan_el_dev_attr_list;
 	struct attribute_group			scan_el_group;
diff -ur ./include/linux/iio/iio.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/iio.h
--- ./include/linux/iio/iio.h	2023-04-26 12:36:34.660089230 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/iio.h	2023-04-23 12:08:02.497102100 +0100
@@ -19,10 +19,16 @@
  * Currently assumes nano seconds.
  */
 
+enum iio_data_type {
+	IIO_RAW,
+	IIO_PROCESSED,
+};
+
+/* Could add the raw attributes as well - allowing buffer only devices */
 enum iio_chan_info_enum {
 	IIO_CHAN_INFO_RAW = 0,
 	IIO_CHAN_INFO_PROCESSED,
-	IIO_CHAN_INFO_SCALE,
+	IIO_CHAN_INFO_SCALE = 1,
 	IIO_CHAN_INFO_OFFSET,
 	IIO_CHAN_INFO_CALIBSCALE,
 	IIO_CHAN_INFO_CALIBBIAS,
@@ -38,6 +44,50 @@
 	IIO_CHAN_INFO_HYSTERESIS,
 };
 
+#define IIO_CHAN_INFO_SHARED_BIT(type) BIT(type*2)
+#define IIO_CHAN_INFO_SEPARATE_BIT(type) BIT(type*2 + 1)
+
+#define IIO_CHAN_INFO_SCALE_SEPARATE_BIT		\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_SCALE)
+#define IIO_CHAN_INFO_SCALE_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_SCALE)
+#define IIO_CHAN_INFO_OFFSET_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_OFFSET)
+#define IIO_CHAN_INFO_OFFSET_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_OFFSET)
+#define IIO_CHAN_INFO_CALIBSCALE_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_CALIBSCALE)
+#define IIO_CHAN_INFO_CALIBSCALE_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_CALIBSCALE)
+#define IIO_CHAN_INFO_CALIBBIAS_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_CALIBBIAS)
+#define IIO_CHAN_INFO_CALIBBIAS_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_CALIBBIAS)
+#define IIO_CHAN_INFO_PEAK_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PEAK)
+#define IIO_CHAN_INFO_PEAK_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_PEAK)
+#define IIO_CHAN_INFO_PEAKSCALE_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PEAKSCALE)
+#define IIO_CHAN_INFO_PEAKSCALE_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_PEAKSCALE)
+#define IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW_SEPARATE_BIT	\
+	IIO_CHAN_INFO_SEPARATE_BIT(				\
+		IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW)
+#define IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW_SHARED_BIT	\
+	IIO_CHAN_INFO_SHARED_BIT(				\
+		IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW)
+#define IIO_CHAN_INFO_AVERAGE_RAW_SEPARATE_BIT			\
+	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_AVERAGE_RAW)
+#define IIO_CHAN_INFO_AVERAGE_RAW_SHARED_BIT			\
+	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_AVERAGE_RAW)
+#define IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY_SHARED_BIT \
+	IIO_CHAN_INFO_SHARED_BIT(			       \
+		IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)
+#define IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY_SEPARATE_BIT \
+	IIO_CHAN_INFO_SEPARATE_BIT(			       \
+		IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)
+
 enum iio_endian {
 	IIO_CPU,
 	IIO_BE,
diff -ur ./include/linux/iio/trigger.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/trigger.h
--- ./include/linux/iio/trigger.h	2023-04-26 12:56:08.540118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/trigger.h	2023-04-23 12:08:02.665698900 +0100
@@ -59,6 +59,7 @@
 	const char			*name;
 	struct device			dev;
 
+	void				*private_data;
 	struct list_head		list;
 	struct list_head		alloc_list;
 	int use_count;
diff -ur ./include/linux/iio/types.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/types.h
--- ./include/linux/iio/types.h	2023-04-26 12:26:24.650131953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/iio/types.h	2023-04-23 12:08:02.742710400 +0100
@@ -26,6 +26,7 @@
 	IIO_ANGL,
 	IIO_TIMESTAMP,
 	IIO_CAPACITANCE,
+	IIO_QUATERNION,
 	IIO_ALTVOLTAGE,
 	IIO_CCT,
 	IIO_PRESSURE,
@@ -46,6 +47,7 @@
 	IIO_MOD_X_OR_Y_OR_Z,
 	IIO_MOD_LIGHT_BOTH,
 	IIO_MOD_LIGHT_IR,
+	IIO_MOD_R,
 	IIO_MOD_ROOT_SUM_SQUARED_X_Y,
 	IIO_MOD_SUM_SQUARED_X_Y_Z,
 	IIO_MOD_LIGHT_CLEAR,
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/input: ft6x06_ts.h
diff -ur ./include/linux/input.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/input.h
--- ./include/linux/input.h	2023-04-26 12:26:24.660131948 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/input.h	2023-04-23 12:08:02.977250700 +0100
@@ -11,6 +11,7 @@
 #include <linux/time.h>
 #include <linux/list.h>
 #include <uapi/linux/input.h>
+#include <linux/notifier.h>
 /* Implementation details, userspace should not care about these */
 #define ABS_MT_FIRST		ABS_MT_TOUCH_MAJOR
 #define ABS_MT_LAST		ABS_MT_TOOL_Y
@@ -187,6 +188,10 @@
 	struct input_value *vals;
 
 	bool devres_managed;
+
+#ifdef CONFIG_FBBLANK_SUSPEND_TS
+	struct notifier_block fb_notif;
+#endif
 };
 #define to_input_dev(d) container_of(d, struct input_dev, dev)
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: inv_mpu.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: jz_adc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: jz_dwc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: jzlcd_pdata.h
diff -ur ./include/linux/kernel.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/kernel.h
--- ./include/linux/kernel.h	2023-04-26 12:56:08.550118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/kernel.h	2023-04-23 12:08:05.058168400 +0100
@@ -792,4 +792,7 @@
 # define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD
 #endif
 
+/* To identify board information in panic logs, set this */
+extern char *mach_panic_string;
+
 #endif
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: keychord.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: keyreset.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: linux_pmem.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: lz4.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mfd: jz_tcu.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mfd: pmu-common.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mfd: ricoh619.h
diff -ur ./include/linux/mm.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mm.h
--- ./include/linux/mm.h	2023-04-26 12:56:08.580118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mm.h	2023-04-23 12:08:09.938220000 +0100
@@ -908,6 +908,7 @@
 extern void show_free_areas(unsigned int flags);
 extern bool skip_free_areas_node(unsigned int flags, int nid);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 extern int can_do_mlock(void);
@@ -1485,7 +1486,7 @@
 extern struct vm_area_struct *vma_merge(struct mm_struct *,
 	struct vm_area_struct *prev, unsigned long addr, unsigned long end,
 	unsigned long vm_flags, struct anon_vma *, struct file *, pgoff_t,
-	struct mempolicy *);
+	struct mempolicy *, const char __user *);
 extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);
 extern int split_vma(struct mm_struct *,
 	struct vm_area_struct *, unsigned long addr, int new_below);
diff -ur ./include/linux/mm_types.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mm_types.h
--- ./include/linux/mm_types.h	2023-04-26 12:56:08.580118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mm_types.h	2023-04-23 12:08:10.019125500 +0100
@@ -255,6 +255,10 @@
 	 * For areas with an address space and backing store,
 	 * linkage into the address_space->i_mmap interval tree, or
 	 * linkage of vma in the address_space->i_mmap_nonlinear list.
+	 *
+	 * For private anonymous mappings, a pointer to a null terminated string
+	 * in the user process containing the name given to the vma, or NULL
+	 * if unnamed.
 	 */
 	union {
 		struct {
@@ -262,6 +266,7 @@
 			unsigned long rb_subtree_last;
 		} linear;
 		struct list_head nonlinear;
+		const char __user *anon_name;
 	} shared;
 
 	/*
@@ -457,4 +462,14 @@
 	return mm->cpu_vm_mask_var;
 }
 
+
+/* Return the name for an anonymous mapping or NULL for a file-backed mapping */
+static inline const char __user *vma_get_anon_name(struct vm_area_struct *vma)
+{
+	if (vma->vm_file)
+		return NULL;
+
+	return vma->shared.anon_name;
+}
+
 #endif /* _LINUX_MM_TYPES_H */
diff -ur ./include/linux/mmc/host.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/host.h
--- ./include/linux/mmc/host.h	2023-04-26 12:56:08.590118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/host.h	2023-04-23 12:08:10.176468300 +0100
@@ -15,6 +15,7 @@
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/pm.h>
@@ -329,12 +330,17 @@
 	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
+	struct wake_lock	detect_wake_lock;
 	int			detect_change;	/* card detect flag */
 	struct mmc_slot		slot;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
+	unsigned int		bus_resume_flags;
+#define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
+#define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
+
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
 	bool			sdio_irq_pending;
@@ -362,6 +368,15 @@
 
 	unsigned int		slotno;	/* used for sdio acpi binding */
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	struct {
+		struct sdio_cis			*cis;
+		struct sdio_cccr		*cccr;
+		struct sdio_embedded_func	*funcs;
+		int				num_funcs;
+	} embedded_sdio_data;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -371,6 +386,14 @@
 void mmc_free_host(struct mmc_host *);
 void mmc_of_parse(struct mmc_host *host);
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				       struct sdio_cis *cis,
+				       struct sdio_cccr *cccr,
+				       struct sdio_embedded_func *funcs,
+				       int num_funcs);
+#endif
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -381,6 +404,18 @@
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
+#define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
+#define mmc_bus_manual_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME)
+
+static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
+{
+	if (manual)
+		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
+	else
+		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
+}
+
+extern int mmc_resume_bus(struct mmc_host *host);
 
 int mmc_suspend_host(struct mmc_host *);
 int mmc_resume_host(struct mmc_host *);
diff -ur ./include/linux/mmc/pm.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/pm.h
--- ./include/linux/mmc/pm.h	2023-04-26 12:26:24.830131866 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/pm.h	2023-04-23 12:08:10.259299200 +0100
@@ -26,5 +26,6 @@
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
 
 #endif /* LINUX_MMC_PM_H */
diff -ur ./include/linux/mmc/sdio_func.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/sdio_func.h
--- ./include/linux/mmc/sdio_func.h	2023-04-26 12:26:24.830131866 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/mmc/sdio_func.h	2023-04-23 12:08:10.339657100 +0100
@@ -23,6 +23,14 @@
 typedef void (sdio_irq_handler_t)(struct sdio_func *);
 
 /*
+ * Structure used to hold embedded SDIO device data from platform layer
+ */
+struct sdio_embedded_func {
+	uint8_t f_class;
+	uint32_t f_maxblksize;
+};
+
+/*
  * SDIO function CIS tuple (unknown to the core)
  */
 struct sdio_func_tuple {
@@ -130,6 +138,8 @@
 extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
 
 extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u8 sdio_readb_ext(struct sdio_func *func, unsigned int addr, int *err_ret,
+	unsigned in);
 extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
 extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/netfilter: xt_qtaguid.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/netfilter: xt_quota2.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: nfc
diff -ur ./include/linux/nmi.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/nmi.h
--- ./include/linux/nmi.h	2023-04-26 12:56:08.600118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/nmi.h	2023-04-23 12:08:13.061395200 +0100
@@ -14,8 +14,11 @@
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR_NMI)
 #include <asm/nmi.h>
+#endif
+
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
 extern void touch_nmi_watchdog(void);
 #else
 static inline void touch_nmi_watchdog(void)
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/platform_data: ds2482.h
diff -ur ./include/linux/pm_wakeup.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/pm_wakeup.h
--- ./include/linux/pm_wakeup.h	2023-04-26 12:56:08.610118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/pm_wakeup.h	2023-04-23 12:08:19.463049900 +0100
@@ -99,6 +99,7 @@
 extern void pm_relax(struct device *dev);
 extern void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec);
 extern void pm_wakeup_event(struct device *dev, unsigned int msec);
+extern int get_active_wakeup_sources(char *buf);
 
 #else /* !CONFIG_PM_SLEEP */
 
@@ -112,6 +113,12 @@
 	return dev->power.can_wakeup;
 }
 
+#ifdef CONFIG_PM
+static int get_active_wakeup_sources(char *buf)
+{
+}
+#endif
+
 static inline void wakeup_source_prepare(struct wakeup_source *ws,
 					 const char *name) {}
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/power: ricoh619_battery.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/power: ricoh61x_battery_init.h
diff -ur ./include/linux/power_supply.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/power_supply.h
--- ./include/linux/power_supply.h	2023-04-26 12:56:08.610118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/power_supply.h	2023-04-23 12:08:20.180988100 +0100
@@ -140,6 +140,10 @@
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
 	POWER_SUPPLY_PROP_SCOPE,
+	/* Local extensions */
+	POWER_SUPPLY_PROP_USB_HC,
+	POWER_SUPPLY_PROP_USB_OTG,
+	POWER_SUPPLY_PROP_CHARGE_ENABLED,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
@@ -194,6 +198,8 @@
 	/* private */
 	struct device *dev;
 	struct work_struct changed_work;
+	spinlock_t changed_lock;
+	bool changed;
 #ifdef CONFIG_THERMAL
 	struct thermal_zone_device *tzd;
 	struct thermal_cooling_device *tcd;
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/regulator: ricoh618-regulator.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/regulator: ricoh619-regulator.h
diff -ur ./include/linux/sched.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/sched.h
--- ./include/linux/sched.h	2023-04-26 12:56:08.620118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/sched.h	2023-04-23 12:08:22.256103200 +0100
@@ -1606,6 +1606,9 @@
 extern void task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st);
 extern void thread_group_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st);
 
+extern int task_free_register(struct notifier_block *n);
+extern int task_free_unregister(struct notifier_block *n);
+
 /*
  * Per process flags
  */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: second_refresh.h
diff -ur ./include/linux/security.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/security.h
--- ./include/linux/security.h	2023-04-26 12:56:08.630118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/security.h	2023-04-23 12:08:22.502261300 +0100
@@ -1402,6 +1402,11 @@
 struct security_operations {
 	char name[SECURITY_NAME_MAX + 1];
 
+	int (*binder_set_context_mgr) (struct task_struct *mgr);
+	int (*binder_transaction) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_binder) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_file) (struct task_struct *from, struct task_struct *to, struct file *file);
+
 	int (*ptrace_access_check) (struct task_struct *child, unsigned int mode);
 	int (*ptrace_traceme) (struct task_struct *parent);
 	int (*capget) (struct task_struct *target,
@@ -1690,6 +1695,10 @@
 
 
 /* Security operations */
+int security_binder_set_context_mgr(struct task_struct *mgr);
+int security_binder_transaction(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file);
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode);
 int security_ptrace_traceme(struct task_struct *parent);
 int security_capget(struct task_struct *target,
@@ -1868,6 +1877,26 @@
 {
 	return 0;
 }
+
+static inline int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static inline int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return 0;
+}
 
 static inline int security_ptrace_access_check(struct task_struct *child,
 					     unsigned int mode)
diff -ur ./include/linux/serial_core.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/serial_core.h
--- ./include/linux/serial_core.h	2023-04-26 12:56:08.630118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/serial_core.h	2023-04-23 12:08:22.662335600 +0100
@@ -60,6 +60,7 @@
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
+	void		(*wake_peer)(struct uart_port *);
 
 	/*
 	 * Return a string describing the type of the port
diff -ur ./include/linux/soundcard.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/soundcard.h
--- ./include/linux/soundcard.h	2023-04-26 12:16:41.440123927 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/soundcard.h	2023-04-23 12:08:23.298149100 +0100
@@ -24,7 +24,7 @@
 #ifndef SOUNDCARD_H
 #define SOUNDCARD_H
 
-#  include <asm/byteorder.h>
+#include <asm/byteorder.h>
 #include <uapi/linux/soundcard.h>
 
 #  if defined(__BIG_ENDIAN)
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: switch.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: uid_stat.h
diff -ur ./include/linux/usb/composite.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb/composite.h
--- ./include/linux/usb/composite.h	2023-04-26 12:26:25.160131706 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb/composite.h	2023-04-23 12:08:26.819091100 +0100
@@ -468,6 +468,8 @@
 	struct config_group group;
 	struct list_head cfs_list;
 	struct usb_function_driver *fd;
+	int (*set_inst_name)(struct usb_function_instance *inst,
+			      const char *name);
 	void (*free_func_inst)(struct usb_function_instance *inst);
 };
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb: f_accessory.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb: f_mtp.h
diff -ur ./include/linux/usb/gadget.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb/gadget.h
--- ./include/linux/usb/gadget.h	2023-04-26 12:26:25.170131701 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux/usb/gadget.h	2023-04-23 12:08:26.980585800 +0100
@@ -170,6 +170,7 @@
 	const struct usb_ep_ops	*ops;
 	struct list_head	ep_list;
 	unsigned		maxpacket:16;
+	unsigned		maxpacket_limit:16;
 	unsigned		max_streams:16;
 	unsigned		mult:2;
 	unsigned		maxburst:5;
@@ -483,6 +484,11 @@
  * @max_speed: Maximal speed the UDC can handle.  UDC must support this
  *      and all slower speeds.
  * @state: the state we are now (attached, suspended, configured, etc)
+ * @name: Identifies the controller hardware type.  Used in diagnostics
+ *	and sometimes configuration.
+ * @dev: Driver model state for this abstract device.
+ * @out_epnum: last used out ep number
+ * @in_epnum: last used in ep number
  * @sg_supported: true if we can handle scatter-gather
  * @is_otg: True if the USB device port uses a Mini-AB jack, so that the
  *	gadget driver must provide a USB OTG descriptor.
@@ -495,11 +501,8 @@
  *	only supports HNP on a different root port.
  * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
  *	enabled HNP support.
- * @name: Identifies the controller hardware type.  Used in diagnostics
- *	and sometimes configuration.
- * @dev: Driver model state for this abstract device.
- * @out_epnum: last used out ep number
- * @in_epnum: last used in ep number
+ * @quirk_ep_out_aligned_size: epout requires buffer size to be aligned to
+ *	MaxPacketSize.
  *
  * Gadgets have a mostly-portable "gadget driver" implementing device
  * functions, handling all usb configurations and interfaces.  Gadget
@@ -527,16 +530,19 @@
 	enum usb_device_speed		speed;
 	enum usb_device_speed		max_speed;
 	enum usb_device_state		state;
+	const char			*name;
+	struct device			dev;
+	unsigned			out_epnum;
+	unsigned			in_epnum;
+
 	unsigned			sg_supported:1;
 	unsigned			is_otg:1;
 	unsigned			is_a_peripheral:1;
 	unsigned			b_hnp_enable:1;
 	unsigned			a_hnp_support:1;
 	unsigned			a_alt_hnp_support:1;
-	const char			*name;
-	struct device			dev;
-	unsigned			out_epnum;
-	unsigned			in_epnum;
+	atomic_t                        connect_count;
+	unsigned			quirk_ep_out_aligned_size:1;
 };
 
 static inline void set_gadget_data(struct usb_gadget *gadget, void *data)
@@ -554,6 +560,23 @@
 
 
 /**
+ * usb_ep_align_maybe - returns @len aligned to ep's maxpacketsize if gadget
+ *	requires quirk_ep_out_aligned_size, otherwise reguens len.
+ * @g: controller to check for quirk
+ * @ep: the endpoint whose maxpacketsize is used to align @len
+ * @len: buffer size's length to align to @ep's maxpacketsize
+ *
+ * This helper is used in case it's required for any reason to check and maybe
+ * align buffer's size to an ep's maxpacketsize.
+ */
+static inline size_t
+usb_ep_align_maybe(struct usb_gadget *g, struct usb_ep *ep, size_t len)
+{
+	return !g->quirk_ep_out_aligned_size ? len :
+			round_up(len, (size_t)ep->desc->wMaxPacketSize);
+}
+
+/**
  * gadget_is_dualspeed - return true iff the hardware handles high speed
  * @g: controller that might support both high and full speeds
  */
@@ -724,7 +747,11 @@
 {
 	if (!gadget->ops->pullup)
 		return -EOPNOTSUPP;
+
+	if (atomic_inc_return(&gadget->connect_count) == 1)
 	return gadget->ops->pullup(gadget, 1);
+
+	return 0;
 }
 
 /**
@@ -746,7 +773,11 @@
 {
 	if (!gadget->ops->pullup)
 		return -EOPNOTSUPP;
+
+	if (atomic_dec_and_test(&gadget->connect_count))
 	return gadget->ops->pullup(gadget, 0);
+
+	return 0;
 }
 
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: voice_wakeup_module.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: wakelock.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: wifi_tiwlan.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: wlan_plat.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/linux: zsmalloc.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net: activity_stats.h
diff -ur ./include/net/bluetooth/hci.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/hci.h
--- ./include/net/bluetooth/hci.h	2023-04-26 12:56:08.670118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/hci.h	2023-04-23 12:08:31.541055700 +0100
@@ -198,8 +198,10 @@
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
-#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
-#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
+			EDR_ESCO_MASK)
 
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
@@ -1628,6 +1630,9 @@
 	__u8     out;
 	__u16    state;
 	__u32    link_mode;
+	__u32    mtu;
+	__u32    cnt;
+	__u32    pkts;
 };
 
 struct hci_dev_req {
diff -ur ./include/net/bluetooth/hci_core.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/hci_core.h
--- ./include/net/bluetooth/hci_core.h	2023-04-26 12:56:08.670118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/hci_core.h	2023-04-23 12:08:31.540555500 +0100
@@ -581,7 +581,8 @@
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
@@ -591,7 +592,8 @@
 void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+			     __u16 pkt_type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
@@ -654,7 +656,7 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = conn->disc_timeout;
 				if (!conn->out)
-					timeo *= 2;
+					timeo *= 20;
 			} else {
 				timeo = msecs_to_jiffies(10);
 			}
diff -ur ./include/net/bluetooth/sco.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/sco.h
--- ./include/net/bluetooth/sco.h	2023-04-26 12:26:25.250131662 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/bluetooth/sco.h	2023-04-23 12:08:31.621827500 +0100
@@ -37,6 +37,7 @@
 struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
+	__u16		sco_pkt_type;
 };
 
 /* SCO socket options */
@@ -72,7 +73,8 @@
 
 struct sco_pinfo {
 	struct bt_sock	bt;
-	__u32		flags;
+	__u16		pkt_type;
+
 	struct sco_conn	*conn;
 };
 
diff -ur ./include/net/ipv6.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/ipv6.h
--- ./include/net/ipv6.h	2023-04-26 12:56:08.680118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/ipv6.h	2023-04-23 12:08:32.741192600 +0100
@@ -260,6 +260,12 @@
 
 extern void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);
 
+int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
+			       struct icmp6hdr *thdr, int len);
+
+struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,
+				      struct sock *sk, struct flowi6 *fl6);
+
 extern int 			ip6_ra_control(struct sock *sk, int sel);
 
 extern int			ipv6_parse_hopopts(struct sk_buff *skb);
diff -ur ./include/net/ping.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/ping.h
--- ./include/net/ping.h	2023-04-26 12:56:08.680118953 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/ping.h	2023-04-23 12:08:35.319195200 +0100
@@ -13,6 +13,7 @@
 #ifndef _PING_H
 #define _PING_H
 
+#include <net/icmp.h>
 #include <net/netns/hash.h>
 
 /* PING_HTABLE_SIZE must be power of 2 */
@@ -28,6 +29,18 @@
  */
 #define GID_T_MAX (((gid_t)~0U) >> 1)
 
+/* Compatibility glue so we can support IPv6 when it's compiled as a module */
+struct pingv6_ops {
+	int (*ipv6_recv_error)(struct sock *sk, struct msghdr *msg, int len);
+	int (*ip6_datagram_recv_ctl)(struct sock *sk, struct msghdr *msg,
+				     struct sk_buff *skb);
+	int (*icmpv6_err_convert)(u8 type, u8 code, int *err);
+	void (*ipv6_icmp_error)(struct sock *sk, struct sk_buff *skb, int err,
+				__be16 port, u32 info, u8 *payload);
+	int (*ipv6_chk_addr)(struct net *net, const struct in6_addr *addr,
+			     struct net_device *dev, int strict);
+};
+
 struct ping_table {
 	struct hlist_nulls_head	hash[PING_HTABLE_SIZE];
 	rwlock_t		lock;
@@ -39,10 +52,39 @@
 };
 
 extern struct proto ping_prot;
+extern struct ping_table ping_table;
+#if IS_ENABLED(CONFIG_IPV6)
+extern struct pingv6_ops pingv6_ops;
+#endif
 
+struct pingfakehdr {
+	struct icmphdr icmph;
+	struct iovec *iov;
+	sa_family_t family;
+	__wsum wcheck;
+};
 
-extern void ping_rcv(struct sk_buff *);
-extern void ping_err(struct sk_buff *, u32 info);
+int  ping_get_port(struct sock *sk, unsigned short ident);
+void ping_hash(struct sock *sk);
+void ping_unhash(struct sock *sk);
+
+int  ping_init_sock(struct sock *sk);
+void ping_close(struct sock *sk, long timeout);
+int  ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len);
+void ping_err(struct sk_buff *skb, int offset, u32 info);
+int  ping_getfrag(void *from, char *to, int offset, int fraglen, int odd,
+		  struct sk_buff *);
+
+int  ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		  size_t len, int noblock, int flags, int *addr_len);
+int  ping_common_sendmsg(int family, struct msghdr *msg, size_t len,
+			 void *user_icmph, size_t icmph_len);
+int  ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		     size_t len);
+int  ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		     size_t len);
+int  ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
+void ping_rcv(struct sk_buff *skb);
 
 #ifdef CONFIG_PROC_FS
 extern int __init ping_proc_init(void);
@@ -50,6 +92,7 @@
 #endif
 
 void __init ping_init(void);
-
+int  __init pingv6_init(void);
+void pingv6_exit(void);
 
 #endif /* _PING_H */
diff -ur ./include/net/tcp.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/tcp.h
--- ./include/net/tcp.h	2023-04-26 12:56:08.690118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/tcp.h	2023-04-23 12:08:35.882656400 +0100
@@ -1550,6 +1550,8 @@
 extern int tcp_gro_complete(struct sk_buff *skb);
 extern int tcp4_gro_complete(struct sk_buff *skb);
 
+extern int tcp_nuke_addr(struct net *net, struct sockaddr *addr);
+
 #ifdef CONFIG_PROC_FS
 extern int tcp4_proc_init(void);
 extern void tcp4_proc_exit(void);
diff -ur ./include/net/transp_v6.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/transp_v6.h
--- ./include/net/transp_v6.h	2023-04-26 12:56:08.690118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/net/transp_v6.h	2023-04-23 12:08:35.881333900 +0100
@@ -11,6 +11,7 @@
 extern struct proto udpv6_prot;
 extern struct proto udplitev6_prot;
 extern struct proto tcpv6_prot;
+extern struct proto pingv6_prot;
 
 struct flowi6;
 
@@ -21,6 +22,8 @@
 extern void				ipv6_frag_exit(void);
 
 /* transport protocols */
+extern int				pingv6_init(void);
+extern void				pingv6_exit(void);
 extern int				rawv6_init(void);
 extern void				rawv6_exit(void);
 extern int				udpv6_init(void);
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/trace/events: cpufreq_interactive.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/trace/events: gpu.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/trace/events: mmc.h
diff -ur ./include/trace/events/power.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/trace/events/power.h
--- ./include/trace/events/power.h	2023-04-26 12:56:08.700118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/trace/events/power.h	2023-04-23 12:08:41.857182800 +0100
@@ -146,6 +146,25 @@
 	TP_ARGS(name, state, cpu_id)
 );
 
+TRACE_EVENT(clock_set_parent,
+
+	TP_PROTO(const char *name, const char *parent_name),
+
+	TP_ARGS(name, parent_name),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__string(       parent_name,    parent_name     )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__assign_str(parent_name, parent_name);
+	),
+
+	TP_printk("%s parent=%s", __get_str(name), __get_str(parent_name))
+);
+
 /*
  * The power domain events are used for power domains transitions
  */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux: if_pppolac.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux: if_pppopns.h
diff -ur ./include/uapi/linux/if_pppox.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/if_pppox.h
--- ./include/uapi/linux/if_pppox.h	2023-04-26 12:36:34.910089173 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/if_pppox.h	2023-04-23 12:08:46.900834900 +0100
@@ -23,6 +23,8 @@
 #include <linux/socket.h>
 #include <linux/if_ether.h>
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppolac.h>
+#include <linux/if_pppopns.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -56,7 +58,9 @@
 #define PX_PROTO_OE    0 /* Currently just PPPoE */
 #define PX_PROTO_OL2TP 1 /* Now L2TP also */
 #define PX_PROTO_PPTP  2
-#define PX_MAX_PROTO   3
+#define PX_PROTO_OLAC  3
+#define PX_PROTO_OPNS  4
+#define PX_MAX_PROTO   5
 
 struct sockaddr_pppox {
 	__kernel_sa_family_t sa_family;       /* address family, AF_PPPOX */
diff -ur ./include/uapi/linux/input.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/input.h
--- ./include/uapi/linux/input.h	2023-04-26 12:56:08.720118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/input.h	2023-04-23 12:08:47.142070100 +0100
@@ -153,6 +153,9 @@
 
 #define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
 
+#define EVIOCGSUSPENDBLOCK	_IOR('E', 0x91, int)			/* get suspend block enable */
+#define EVIOCSSUSPENDBLOCK	_IOW('E', 0x91, int)			/* set suspend block enable */
+
 #define EVIOCSCLOCKID		_IOW('E', 0xa0, int)			/* Set clockid to be used for timestamps */
 
 /*
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux: keychord.h
diff -ur ./include/uapi/linux/msdos_fs.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/msdos_fs.h
--- ./include/uapi/linux/msdos_fs.h	2023-04-26 12:56:08.720118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/msdos_fs.h	2023-04-23 12:08:48.432426700 +0100
@@ -104,6 +104,7 @@
 /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
 #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+#define VFAT_IOCTL_GET_VOLUME_ID	_IOR('r', 0x12, __u32)
 
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
@@ -161,6 +162,17 @@
 	__le32   reserved2[4];
 };
 
+struct fat_boot_bsx {
+	__u8     drive;		/* drive number */
+	__u8     reserved1;
+	__u8     signature;	/* extended boot signature */
+	__u8     vol_id[4];	/* volume ID */
+	__u8     vol_label[11];	/* volume label */
+	__u8     type[8];	/* file system type */
+};
+#define FAT16_BSX_OFFSET 36 /* offset of fat_boot_bsx in FAT12 and FAT16 */
+#define FAT32_BSX_OFFSET 64 /* offset of fat_boot_bsx in FAT32 */
+
 struct msdos_dir_entry {
 	__u8	name[MSDOS_NAME];/* name and extension */
 	__u8	attr;		/* attribute bits */
Only in ./include/uapi/linux/netfilter: xt_CONNMARK.h
Only in ./include/uapi/linux/netfilter: xt_DSCP.h
diff -ur ./include/uapi/linux/netfilter/xt_IDLETIMER.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/netfilter/xt_IDLETIMER.h
--- ./include/uapi/linux/netfilter/xt_IDLETIMER.h	2023-04-26 12:26:25.680131454 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/netfilter/xt_IDLETIMER.h	2023-04-23 12:08:49.216446000 +0100
@@ -4,6 +4,7 @@
  * Header file for Xtables timer target module.
  *
  * Copyright (C) 2004, 2010 Nokia Corporation
+ *
  * Written by Timo Teras <ext-timo.teras@nokia.com>
  *
  * Converted to x_tables and forward-ported to 2.6.34
@@ -32,12 +33,19 @@
 #include <linux/types.h>
 
 #define MAX_IDLETIMER_LABEL_SIZE 28
+#define NLMSG_MAX_SIZE 64
+
+#define NL_EVENT_TYPE_INACTIVE 0
+#define NL_EVENT_TYPE_ACTIVE 1
 
 struct idletimer_tg_info {
 	__u32 timeout;
 
 	char label[MAX_IDLETIMER_LABEL_SIZE];
 
+	/* Use netlink messages for notification in addition to sysfs */
+	__u8 send_nl_msg;
+
 	/* for kernel module internal use only */
 	struct idletimer_tg *timer __attribute__((aligned(8)));
 };
Only in ./include/uapi/linux/netfilter: xt_MARK.h
Only in ./include/uapi/linux/netfilter: xt_RATEEST.h
Only in ./include/uapi/linux/netfilter: xt_TCPMSS.h
Only in ./include/uapi/linux/netfilter: xt_connmark.h
Only in ./include/uapi/linux/netfilter: xt_dscp.h
Only in ./include/uapi/linux/netfilter: xt_mark.h
Only in ./include/uapi/linux/netfilter: xt_rateest.h
diff -ur ./include/uapi/linux/netfilter/xt_socket.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/netfilter/xt_socket.h
--- ./include/uapi/linux/netfilter/xt_socket.h	2023-04-26 12:56:08.720118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/netfilter/xt_socket.h	2023-04-23 12:08:50.184427100 +0100
@@ -11,4 +11,10 @@
 	__u8 flags;
 };
 
+void xt_socket_put_sk(struct sock *sk);
+struct sock *xt_socket_get4_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+struct sock *xt_socket_get6_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+
 #endif /* _XT_SOCKET_H */
Only in ./include/uapi/linux/netfilter: xt_tcpmss.h
Only in ./include/uapi/linux/netfilter_ipv4: ipt_ECN.h
Only in ./include/uapi/linux/netfilter_ipv4: ipt_TTL.h
Only in ./include/uapi/linux/netfilter_ipv4: ipt_ecn.h
Only in ./include/uapi/linux/netfilter_ipv4: ipt_ttl.h
Only in ./include/uapi/linux/netfilter_ipv6: ip6t_HL.h
Only in ./include/uapi/linux/netfilter_ipv6: ip6t_hl.h
diff -ur ./include/uapi/linux/prctl.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/prctl.h
--- ./include/uapi/linux/prctl.h	2023-04-26 12:26:25.740131425 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/prctl.h	2023-04-23 12:08:52.259168200 +0100
@@ -149,4 +149,7 @@
 
 #define PR_GET_TID_ADDRESS	40
 
+#define PR_SET_VMA		0x53564d41
+# define PR_SET_VMA_ANON_NAME		0
+
 #endif /* _LINUX_PRCTL_H */
diff -ur ./include/uapi/linux/serial_core.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/serial_core.h
--- ./include/uapi/linux/serial_core.h	2023-04-26 12:56:08.730118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/serial_core.h	2023-04-23 12:08:52.745031800 +0100
@@ -226,4 +226,7 @@
 /* Rocketport EXPRESS/INFINITY */
 #define PORT_RP2	102
 
+/* Ingenic uart */
+#define PORT_JZ47XX     103
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
diff -ur ./include/uapi/linux/sockios.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/sockios.h
--- ./include/uapi/linux/sockios.h	2023-04-26 12:26:25.760131415 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/sockios.h	2023-04-23 12:08:52.896210400 +0100
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff -ur ./include/uapi/linux/soundcard.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/soundcard.h
--- ./include/uapi/linux/soundcard.h	2023-04-26 12:26:25.770131410 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/soundcard.h	2023-04-23 12:08:53.057522800 +0100
@@ -566,6 +566,11 @@
 #	define AFMT_MPEG		0x00000200	/* MPEG (2) audio */
 #	define AFMT_AC3		0x00000400	/* Dolby Digital AC3 */
 
+#define AFMT_S24_LE              0x00000800      /* Little endian signed 24*/
+#define AFMT_S24_BE              0x00001000      /* Big endian signed 24 */
+#define AFMT_U24_LE              0x00002000      /* Little endian unsigned 24 */
+#define AFMT_U24_BE              0x00004000      /* Big endian unsigned 24 */
+
 /*
  * Buffer status queries.
  */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/usb: f_accessory.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/usb: f_mtp.h
diff -ur ./include/uapi/linux/videodev2.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/videodev2.h
--- ./include/uapi/linux/videodev2.h	2023-04-26 12:56:08.730118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/linux/videodev2.h	2023-04-23 12:08:54.658020600 +0100
@@ -282,6 +282,12 @@
 	__u32          		sizeimage;
 	__u32			colorspace;	/* enum v4l2_colorspace */
 	__u32			priv;		/* private data, depends on pixelformat */
+#if GCC_VERSION == 50400
+	__u32			flags;		/* format flags (V4L2_PIX_FMT_FLAG_*) */
+	__u32			ycbcr_enc;	/* enum v4l2_ycbcr_encoding */
+	__u32			quantization;	/* enum v4l2_quantization */
+	__u32			xfer_func;	/* enum v4l2_xfer_func */
+#endif
 };
 
 /*      Pixel format         FOURCC                          depth  Description  */
@@ -1961,5 +1967,9 @@
    drivers/media/video/v4l2-compat-ioctl32.c as well! */
 
 #define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
-
+#if 1
+/* Additional, the command is used for monitoring whether the v4l2-buffer is ready.
+   The command is added by xhshen, who is from ingenic company. */
+#define VIDIOC_DEFAULT_CMD_LISTEN_BUF	 _IOR('V', BASE_VIDIOC_PRIVATE - 1, int)
+#endif
 #endif /* _UAPI__LINUX_VIDEODEV2_H */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/uapi/video: adf.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/video: adf.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/video: adf_client.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/video: adf_fbdev.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/video: adf_format.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/include/video: adf_memblock.h
diff -ur ./init/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/init/Kconfig
--- ./init/Kconfig	2023-04-26 12:56:08.740118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/init/Kconfig	2023-04-23 12:08:58.513132300 +0100
@@ -1251,6 +1251,12 @@
 config HAVE_PCSPKR_PLATFORM
 	bool
 
+config PANIC_TIMEOUT
+	int "Default panic timeout"
+	default 0
+	help
+	  Set default panic timeout.
+
 menuconfig EXPERT
 	bool "Configure standard kernel features (expert users)"
 	# Unhide debug options, to make the on-by-default options visible
diff -ur ./kernel/cgroup.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/cgroup.c
--- ./kernel/cgroup.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/cgroup.c	2023-04-23 12:08:59.538613800 +0100
@@ -2098,6 +2098,24 @@
 	return retval;
 }
 
+static int cgroup_allow_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)
+{
+	struct cgroup_subsys *ss;
+	int ret;
+
+	for_each_subsys(cgrp->root, ss) {
+		if (ss->allow_attach) {
+			ret = ss->allow_attach(cgrp, tset);
+			if (ret)
+				return ret;
+		} else {
+			return -EACCES;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * Find the task_struct of the task to attach by vpid and pass it along to the
  * function to attach either it or all tasks in its threadgroup. Will lock
@@ -2129,9 +2147,18 @@
 		if (!uid_eq(cred->euid, GLOBAL_ROOT_UID) &&
 		    !uid_eq(cred->euid, tcred->uid) &&
 		    !uid_eq(cred->euid, tcred->suid)) {
-			rcu_read_unlock();
-			ret = -EACCES;
-			goto out_unlock_cgroup;
+			/*
+			 * if the default permission check fails, give each
+			 * cgroup a chance to extend the permission check
+			 */
+			struct cgroup_taskset tset = { };
+			tset.single.task = tsk;
+			tset.single.cgrp = cgrp;
+			ret = cgroup_allow_attach(cgrp, &tset);
+			if (ret) {
+				rcu_read_unlock();
+				goto out_unlock_cgroup;
+			}
 		}
 	} else
 		tsk = current;
diff -ur ./kernel/cpu.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/cpu.c
--- ./kernel/cpu.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/cpu.c	2023-04-23 12:08:59.717344400 +0100
@@ -726,3 +726,23 @@
 {
 	cpumask_copy(to_cpumask(cpu_online_bits), src);
 }
+
+static ATOMIC_NOTIFIER_HEAD(idle_notifier);
+
+void idle_notifier_register(struct notifier_block *n)
+{
+	atomic_notifier_chain_register(&idle_notifier, n);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_register);
+
+void idle_notifier_unregister(struct notifier_block *n)
+{
+	atomic_notifier_chain_unregister(&idle_notifier, n);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_unregister);
+
+void idle_notifier_call_chain(unsigned long val)
+{
+	atomic_notifier_call_chain(&idle_notifier, val, NULL);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_call_chain);
diff -ur ./kernel/debug/debug_core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/debug/debug_core.c
--- ./kernel/debug/debug_core.c	2023-04-26 12:26:25.910131342 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/debug/debug_core.c	2023-04-23 12:08:59.939461500 +0100
@@ -86,6 +86,10 @@
 bool dbg_is_early = true;
 /* Next cpu to become the master debug core */
 int dbg_switch_cpu;
+/* Flag for entering kdb when a panic occurs */
+static bool break_on_panic = true;
+/* Flag for entering kdb when an exception occurs */
+static bool break_on_exception = true;
 
 /* Use kdb or gdbserver mode */
 int dbg_kdb_mode = 1;
@@ -100,6 +104,8 @@
 
 module_param(kgdb_use_con, int, 0644);
 module_param(kgdbreboot, int, 0644);
+module_param(break_on_panic, bool, 0644);
+module_param(break_on_exception, bool, 0644);
 
 /*
  * Holds information about breakpoints in a kernel. These breakpoints are
@@ -678,6 +684,9 @@
 	if (arch_kgdb_ops.enable_nmi)
 		arch_kgdb_ops.enable_nmi(0);
 
+	if (unlikely(signo != SIGTRAP && !break_on_exception))
+		return 1;
+
 	ks->cpu			= raw_smp_processor_id();
 	ks->ex_vector		= evector;
 	ks->signo		= signo;
@@ -784,6 +793,9 @@
 			    unsigned long val,
 			    void *data)
 {
+	if (!break_on_panic)
+		return NOTIFY_DONE;
+
 	if (dbg_kdb_mode)
 		kdb_printf("PANIC: %s\n", (char *)data);
 	kgdb_breakpoint();
diff -ur ./kernel/debug/kdb/kdb_io.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/debug/kdb/kdb_io.c
--- ./kernel/debug/kdb/kdb_io.c	2023-04-26 12:26:25.930131333 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/debug/kdb/kdb_io.c	2023-04-23 12:09:00.180758100 +0100
@@ -216,7 +216,7 @@
 	int i;
 	int diag, dtab_count;
 	int key;
-
+	static int last_crlf;
 
 	diag = kdbgetintenv("DTABCOUNT", &dtab_count);
 	if (diag)
@@ -237,6 +237,9 @@
 		return buffer;
 	if (key != 9)
 		tab = 0;
+	if (key != 10 && key != 13)
+		last_crlf = 0;
+
 	switch (key) {
 	case 8: /* backspace */
 		if (cp > buffer) {
@@ -254,7 +257,12 @@
 			*cp = tmp;
 		}
 		break;
-	case 13: /* enter */
+	case 10: /* new line */
+	case 13: /* carriage return */
+		/* handle \n after \r */
+		if (last_crlf && last_crlf != key)
+			break;
+		last_crlf = key;
 		*lastchar++ = '\n';
 		*lastchar++ = '\0';
 		if (!KDB_STATE(KGDB_TRANS)) {
diff -ur ./kernel/exit.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/exit.c
--- ./kernel/exit.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/exit.c	2023-04-23 12:09:00.658828100 +0100
@@ -835,7 +835,7 @@
 	/*
 	 * Make sure we are holding no locks:
 	 */
-	debug_check_no_locks_held(tsk);
+	debug_check_no_locks_held();
 	/*
 	 * We can do this unlocked here. The futex code uses this flag
 	 * just to verify whether the pi state cleanup has been done
diff -ur ./kernel/fork.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/fork.c
--- ./kernel/fork.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/fork.c	2023-04-23 12:09:00.745375300 +0100
@@ -198,6 +198,9 @@
 /* SLAB cache for mm_struct structures (tsk->mm) */
 static struct kmem_cache *mm_cachep;
 
+/* Notifier list called when a task struct is freed */
+static ATOMIC_NOTIFIER_HEAD(task_free_notifier);
+
 static void account_kernel_stack(struct thread_info *ti, int account)
 {
 	struct zone *zone = page_zone(virt_to_page(ti));
@@ -231,6 +234,18 @@
 		free_signal_struct(sig);
 }
 
+int task_free_register(struct notifier_block *n)
+{
+	return atomic_notifier_chain_register(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_register);
+
+int task_free_unregister(struct notifier_block *n)
+{
+	return atomic_notifier_chain_unregister(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_unregister);
+
 void __put_task_struct(struct task_struct *tsk)
 {
 	WARN_ON(!tsk->exit_state);
@@ -242,6 +257,7 @@
 	delayacct_tsk_free(tsk);
 	put_signal_struct(tsk->signal);
 
+	atomic_notifier_call_chain(&task_free_notifier, 0, tsk);
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
@@ -696,7 +712,8 @@
 
 	mm = get_task_mm(task);
 	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode)) {
+			!ptrace_may_access(task, mode) &&
+			!capable(CAP_SYS_RESOURCE)) {
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
diff -ur ./kernel/freezer.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/freezer.c
--- ./kernel/freezer.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/freezer.c	2023-04-23 12:09:00.744742100 +0100
@@ -110,6 +110,18 @@
 {
 	unsigned long flags;
 
+	/*
+	 * This check can race with freezer_do_not_count, but worst case that
+	 * will result in an extra wakeup being sent to the task.  It does not
+	 * race with freezer_count(), the barriers in freezer_count() and
+	 * freezer_should_skip() ensure that either freezer_count() sees
+	 * freezing == true in try_to_freeze() and freezes, or
+	 * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task
+	 * normally.
+	 */
+	if (freezer_should_skip(p))
+		return false;
+
 	spin_lock_irqsave(&freezer_lock, flags);
 	if (!freezing(p) || frozen(p)) {
 		spin_unlock_irqrestore(&freezer_lock, flags);
diff -ur ./kernel/futex.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/futex.c
--- ./kernel/futex.c	2023-04-26 12:56:08.760118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/futex.c	2023-04-23 12:09:00.744004300 +0100
@@ -62,7 +62,7 @@
 #include <linux/ptrace.h>
 #include <linux/sched/rt.h>
 #include <linux/hugetlb.h>
-
+#include <linux/freezer.h>
 #include <asm/futex.h>
 
 #include "rtmutex_common.h"
@@ -1808,7 +1808,7 @@
 		 * is no timeout, or if it has yet to expire.
 		 */
 		if (!timeout || timeout->task)
-			schedule();
+			freezable_schedule();
 	}
 	__set_current_state(TASK_RUNNING);
 }
diff -ur ./kernel/hrtimer.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/hrtimer.c
--- ./kernel/hrtimer.c	2023-04-26 12:56:08.770118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/hrtimer.c	2023-04-23 12:09:00.981310600 +0100
@@ -47,6 +47,7 @@
 #include <linux/sched/sysctl.h>
 #include <linux/sched/rt.h>
 #include <linux/timer.h>
+#include <linux/freezer.h>
 
 #include <asm/uaccess.h>
 
@@ -1543,7 +1544,7 @@
 			t->task = NULL;
 
 		if (likely(t->task))
-			schedule();
+			freezable_schedule();
 
 		hrtimer_cancel(&t->timer);
 		mode = HRTIMER_MODE_ABS;
diff -ur ./kernel/irq/pm.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/irq/pm.c
--- ./kernel/irq/pm.c	2023-04-26 12:26:26.000131299 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/irq/pm.c	2023-04-23 12:09:01.379585300 +0100
@@ -103,14 +103,14 @@
 	int irq;
 
 	for_each_irq_desc(irq, desc) {
-		/*
-		 * Only interrupts which are marked as wakeup source
-		 * and have not been disabled before the suspend check
-		 * can abort suspend.
-		 */
 		if (irqd_is_wakeup_set(&desc->irq_data)) {
-			if (desc->depth == 1 && desc->istate & IRQS_PENDING)
+			if (desc->istate & IRQS_PENDING) {
+				pr_info("Wakeup IRQ %d %s pending, suspend aborted\n",
+					irq,
+					desc->action && desc->action->name ?
+					desc->action->name : "");
 				return -EBUSY;
+			}
 			continue;
 		}
 		/*
diff -ur ./kernel/lockdep.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/lockdep.c
--- ./kernel/lockdep.c	2023-04-26 12:56:08.770118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/lockdep.c	2023-04-23 12:09:01.779703200 +0100
@@ -4090,7 +4090,7 @@
 }
 EXPORT_SYMBOL_GPL(debug_check_no_locks_freed);
 
-static void print_held_locks_bug(struct task_struct *curr)
+static void print_held_locks_bug(void)
 {
 	if (!debug_locks_off())
 		return;
@@ -4099,22 +4099,21 @@
 
 	printk("\n");
 	printk("=====================================\n");
-	printk("[ BUG: lock held at task exit time! ]\n");
+	printk("[ BUG: %s/%d still has locks held! ]\n",
+	       current->comm, task_pid_nr(current));
 	print_kernel_ident();
 	printk("-------------------------------------\n");
-	printk("%s/%d is exiting with locks still held!\n",
-		curr->comm, task_pid_nr(curr));
-	lockdep_print_held_locks(curr);
-
+	lockdep_print_held_locks(current);
 	printk("\nstack backtrace:\n");
 	dump_stack();
 }
 
-void debug_check_no_locks_held(struct task_struct *task)
+void debug_check_no_locks_held(void)
 {
-	if (unlikely(task->lockdep_depth > 0))
-		print_held_locks_bug(task);
+	if (unlikely(current->lockdep_depth > 0))
+		print_held_locks_bug();
 }
+EXPORT_SYMBOL_GPL(debug_check_no_locks_held);
 
 void debug_show_all_locks(void)
 {
diff -ur ./kernel/panic.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/panic.c
--- ./kernel/panic.c	2023-04-26 12:56:08.770118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/panic.c	2023-04-23 12:09:02.099828400 +0100
@@ -26,13 +26,19 @@
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
 
+/* Machine specific panic information string */
+char *mach_panic_string;
+
 int panic_on_oops = CONFIG_PANIC_ON_OOPS_VALUE;
 static unsigned long tainted_mask;
 static int pause_on_oops;
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+#ifndef CONFIG_PANIC_TIMEOUT
+#define CONFIG_PANIC_TIMEOUT 0
+#endif
+int panic_timeout = CONFIG_PANIC_TIMEOUT;
 EXPORT_SYMBOL_GPL(panic_timeout);
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
@@ -375,6 +381,11 @@
 void print_oops_end_marker(void)
 {
 	init_oops_id();
+
+	if (mach_panic_string)
+		printk(KERN_WARNING "Board Information: %s\n",
+		       mach_panic_string);
+
 	printk(KERN_WARNING "---[ end trace %016llx ]---\n",
 		(unsigned long long)oops_id);
 }
diff -ur ./kernel/power/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/Kconfig
--- ./kernel/power/Kconfig	2023-04-26 12:56:08.780118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/Kconfig	2023-04-23 12:09:02.264015700 +0100
@@ -18,6 +18,14 @@
 
 	  Turning OFF this setting is NOT recommended! If in doubt, say Y.
 
+config HAS_WAKELOCK
+	bool
+	default y
+
+config WAKELOCK
+	bool
+	default y
+
 config HIBERNATE_CALLBACKS
 	bool
 
@@ -274,3 +282,10 @@
 config CPU_PM
 	bool
 	depends on SUSPEND || CPU_IDLE
+
+config SUSPEND_TIME
+	bool "Log time spent in suspend"
+	---help---
+	  Prints the time spent in suspend in the kernel log, and
+	  keeps statistics on the time spent in suspend in
+	  /sys/kernel/debug/suspend_time
diff -ur ./kernel/power/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/Makefile
--- ./kernel/power/Makefile	2023-04-26 12:26:26.040131279 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/Makefile	2023-04-23 12:09:02.338745700 +0100
@@ -11,5 +11,6 @@
 				   block_io.o
 obj-$(CONFIG_PM_AUTOSLEEP)	+= autosleep.o
 obj-$(CONFIG_PM_WAKELOCKS)	+= wakelock.o
+obj-$(CONFIG_SUSPEND_TIME)	+= suspend_time.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff -ur ./kernel/power/main.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/main.c
--- ./kernel/power/main.c	2023-04-26 12:56:08.780118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/main.c	2023-04-23 12:09:02.427115400 +0100
@@ -433,6 +433,22 @@
 
 power_attr(wakeup_count);
 
+static ssize_t locked_show(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				char *buf)
+{
+	return get_active_wakeup_sources(buf);
+}
+
+static ssize_t locked_store(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				const char *buf, size_t n)
+{
+	return 0;
+}	
+
+power_attr(locked);
+
 #ifdef CONFIG_PM_AUTOSLEEP
 static ssize_t autosleep_show(struct kobject *kobj,
 			      struct kobj_attribute *attr,
@@ -586,6 +602,7 @@
 #ifdef CONFIG_PM_SLEEP
 	&pm_async_attr.attr,
 	&wakeup_count_attr.attr,
+	&locked_attr.attr,
 #ifdef CONFIG_PM_AUTOSLEEP
 	&autosleep_attr.attr,
 #endif
diff -ur ./kernel/power/process.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/process.c
--- ./kernel/power/process.c	2023-04-26 12:56:08.780118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/process.c	2023-04-23 12:09:02.509591100 +0100
@@ -30,9 +30,10 @@
 	unsigned int todo;
 	bool wq_busy = false;
 	struct timeval start, end;
-	u64 elapsed_csecs64;
-	unsigned int elapsed_csecs;
+	u64 elapsed_msecs64;
+	unsigned int elapsed_msecs;
 	bool wakeup = false;
+	int sleep_usecs = USEC_PER_MSEC;
 
 	do_gettimeofday(&start);
 
@@ -68,22 +69,25 @@
 
 		/*
 		 * We need to retry, but first give the freezing tasks some
-		 * time to enter the refrigerator.
+		 * time to enter the refrigerator.  Start with an initial
+		 * 1 ms sleep followed by exponential backoff until 8 ms.
 		 */
-		msleep(10);
+		usleep_range(sleep_usecs / 2, sleep_usecs);
+		if (sleep_usecs < 8 * USEC_PER_MSEC)
+			sleep_usecs *= 2;
 	}
 
 	do_gettimeofday(&end);
-	elapsed_csecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);
-	do_div(elapsed_csecs64, NSEC_PER_SEC / 100);
-	elapsed_csecs = elapsed_csecs64;
+	elapsed_msecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);
+	do_div(elapsed_msecs64, NSEC_PER_MSEC);
+	elapsed_msecs = elapsed_msecs64;
 
 	if (todo) {
 		printk("\n");
-		printk(KERN_ERR "Freezing of tasks %s after %d.%02d seconds "
+		printk(KERN_ERR "Freezing of tasks %s after %d.%03d seconds "
 		       "(%d tasks refusing to freeze, wq_busy=%d):\n",
 		       wakeup ? "aborted" : "failed",
-		       elapsed_csecs / 100, elapsed_csecs % 100,
+		       elapsed_msecs / 1000, elapsed_msecs % 1000,
 		       todo - wq_busy, wq_busy);
 
 		if (!wakeup) {
@@ -96,8 +100,8 @@
 			read_unlock(&tasklist_lock);
 		}
 	} else {
-		printk("(elapsed %d.%02d seconds) ", elapsed_csecs / 100,
-			elapsed_csecs % 100);
+		printk("(elapsed %d.%03d seconds) ", elapsed_msecs / 1000,
+			elapsed_msecs % 1000);
 	}
 
 	return todo ? -EBUSY : 0;
diff -ur ./kernel/power/suspend.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/suspend.c
--- ./kernel/power/suspend.c	2023-04-26 12:56:08.780118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power/suspend.c	2023-04-23 12:09:02.589146400 +0100
@@ -25,6 +25,7 @@
 #include <linux/suspend.h>
 #include <linux/syscore_ops.h>
 #include <linux/ftrace.h>
+#include <linux/rtc.h>
 #include <trace/events/power.h>
 
 #include "power.h"
@@ -358,6 +359,18 @@
 	return error;
 }
 
+static void pm_suspend_marker(char *annotation)
+{
+	struct timespec ts;
+	struct rtc_time tm;
+
+	getnstimeofday(&ts);
+	rtc_time_to_tm(ts.tv_sec, &tm);
+	pr_info("PM: suspend %s %d-%02d-%02d %02d:%02d:%02d.%09lu UTC\n",
+		annotation, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+}
+
 /**
  * pm_suspend - Externally visible function for suspending the system.
  * @state: System sleep state to enter.
@@ -372,6 +385,7 @@
 	if (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)
 		return -EINVAL;
 
+	pm_suspend_marker("entry");
 	error = enter_state(state);
 	if (error) {
 		suspend_stats.fail++;
@@ -379,6 +393,7 @@
 	} else {
 		suspend_stats.success++;
 	}
+	pm_suspend_marker("exit");
 	return error;
 }
 EXPORT_SYMBOL(pm_suspend);
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/power: suspend_time.c
diff -ur ./kernel/printk.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/printk.c
--- ./kernel/printk.c	2023-04-26 12:56:08.780118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/printk.c	2023-04-23 12:09:02.759280000 +0100
@@ -51,6 +51,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
 
+#ifdef CONFIG_EARLY_PRINTK_DIRECT
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
 
@@ -1578,6 +1582,10 @@
 		}
 	}
 
+#ifdef CONFIG_EARLY_PRINTK_DIRECT
+	printascii(text);
+#endif
+
 	if (level == -1)
 		level = default_message_loglevel;
 
diff -ur ./kernel/sched/core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sched/core.c
--- ./kernel/sched/core.c	2023-04-26 12:56:08.810118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sched/core.c	2023-04-23 12:09:03.467054600 +0100
@@ -7093,13 +7093,24 @@
 	return (nested == preempt_offset);
 }
 
+static int __might_sleep_init_called;
+int __init __might_sleep_init(void)
+{
+	__might_sleep_init_called = 1;
+	return 0;
+}
+early_initcall(__might_sleep_init);
+
 void __might_sleep(const char *file, int line, int preempt_offset)
 {
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */
 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||
-	    system_state != SYSTEM_RUNNING || oops_in_progress)
+	    oops_in_progress)
+		return;
+	if (system_state != SYSTEM_RUNNING &&
+	    (!__might_sleep_init_called || system_state != SYSTEM_BOOTING))
 		return;
 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
 		return;
@@ -7705,6 +7716,23 @@
 	sched_offline_group(tg);
 }
 
+static int
+cpu_cgroup_allow_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)
+{
+	const struct cred *cred = current_cred(), *tcred;
+	struct task_struct *task;
+
+	cgroup_taskset_for_each(task, cgrp, tset) {
+		tcred = __task_cred(task);
+
+		if ((current != task) && !capable(CAP_SYS_NICE) &&
+		    cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EACCES;
+	}
+
+	return 0;
+}
+
 static int cpu_cgroup_can_attach(struct cgroup *cgrp,
 				 struct cgroup_taskset *tset)
 {
@@ -8064,6 +8092,7 @@
 	.css_offline	= cpu_cgroup_css_offline,
 	.can_attach	= cpu_cgroup_can_attach,
 	.attach		= cpu_cgroup_attach,
+	.allow_attach	= cpu_cgroup_allow_attach,
 	.exit		= cpu_cgroup_exit,
 	.subsys_id	= cpu_cgroup_subsys_id,
 	.base_cftypes	= cpu_files,
diff -ur ./kernel/signal.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/signal.c
--- ./kernel/signal.c	2023-04-26 12:56:08.820118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/signal.c	2023-04-23 12:09:03.857348300 +0100
@@ -2848,7 +2848,7 @@
 		recalc_sigpending();
 		spin_unlock_irq(&tsk->sighand->siglock);
 
-		timeout = schedule_timeout_interruptible(timeout);
+		timeout = freezable_schedule_timeout_interruptible(timeout);
 
 		spin_lock_irq(&tsk->sighand->siglock);
 		__set_task_blocked(tsk, &tsk->real_blocked);
diff -ur ./kernel/sys.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sys.c
--- ./kernel/sys.c	2023-04-26 12:56:08.820118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sys.c	2023-04-23 12:09:04.103757100 +0100
@@ -42,6 +42,8 @@
 #include <linux/syscore_ops.h>
 #include <linux/version.h>
 #include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/mempolicy.h>
 
 #include <linux/compat.h>
 #include <linux/syscalls.h>
@@ -2099,6 +2101,153 @@
 }
 #endif
 
+#ifdef CONFIG_MMU
+static int prctl_update_vma_anon_name(struct vm_area_struct *vma,
+		struct vm_area_struct **prev,
+		unsigned long start, unsigned long end,
+		const char __user *name_addr)
+{
+	struct mm_struct * mm = vma->vm_mm;
+	int error = 0;
+	pgoff_t pgoff;
+
+	if (name_addr == vma_get_anon_name(vma)) {
+		*prev = vma;
+		goto out;
+	}
+
+	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
+	*prev = vma_merge(mm, *prev, start, end, vma->vm_flags, vma->anon_vma,
+				vma->vm_file, pgoff, vma_policy(vma),
+				name_addr);
+	if (*prev) {
+		vma = *prev;
+		goto success;
+	}
+
+	*prev = vma;
+
+	if (start != vma->vm_start) {
+		error = split_vma(mm, vma, start, 1);
+		if (error)
+			goto out;
+	}
+
+	if (end != vma->vm_end) {
+		error = split_vma(mm, vma, end, 0);
+		if (error)
+			goto out;
+	}
+
+success:
+	if (!vma->vm_file)
+		vma->shared.anon_name = name_addr;
+
+out:
+	if (error == -ENOMEM)
+		error = -EAGAIN;
+	return error;
+}
+
+static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
+			unsigned long arg)
+{
+	unsigned long tmp;
+	struct vm_area_struct * vma, *prev;
+	int unmapped_error = 0;
+	int error = -EINVAL;
+
+	/*
+	 * If the interval [start,end) covers some unmapped address
+	 * ranges, just ignore them, but return -ENOMEM at the end.
+	 * - this matches the handling in madvise.
+	 */
+	vma = find_vma_prev(current->mm, start, &prev);
+	if (vma && start > vma->vm_start)
+		prev = vma;
+
+	for (;;) {
+		/* Still start < end. */
+		error = -ENOMEM;
+		if (!vma)
+			return error;
+
+		/* Here start < (end|vma->vm_end). */
+		if (start < vma->vm_start) {
+			unmapped_error = -ENOMEM;
+			start = vma->vm_start;
+			if (start >= end)
+				return error;
+		}
+
+		/* Here vma->vm_start <= start < (end|vma->vm_end) */
+		tmp = vma->vm_end;
+		if (end < tmp)
+			tmp = end;
+
+		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
+		error = prctl_update_vma_anon_name(vma, &prev, start, end,
+				(const char __user *)arg);
+		if (error)
+			return error;
+		start = tmp;
+		if (prev && start < prev->vm_end)
+			start = prev->vm_end;
+		error = unmapped_error;
+		if (start >= end)
+			return error;
+		if (prev)
+			vma = prev->vm_next;
+		else	/* madvise_remove dropped mmap_sem */
+			vma = find_vma(current->mm, start);
+	}
+}
+
+static int prctl_set_vma(unsigned long opt, unsigned long start,
+		unsigned long len_in, unsigned long arg)
+{
+	struct mm_struct *mm = current->mm;
+	int error;
+	unsigned long len;
+	unsigned long end;
+
+	if (start & ~PAGE_MASK)
+		return -EINVAL;
+	len = (len_in + ~PAGE_MASK) & PAGE_MASK;
+
+	/* Check to see whether len was rounded up from small -ve to zero */
+	if (len_in && !len)
+		return -EINVAL;
+
+	end = start + len;
+	if (end < start)
+		return -EINVAL;
+
+	if (end == start)
+		return 0;
+
+	down_write(&mm->mmap_sem);
+
+	switch (opt) {
+	case PR_SET_VMA_ANON_NAME:
+		error = prctl_set_vma_anon_name(start, end, arg);
+		break;
+	default:
+		error = -EINVAL;
+	}
+
+	up_write(&mm->mmap_sem);
+
+	return error;
+}
+#else /* CONFIG_MMU */
+static int prctl_set_vma(unsigned long opt, unsigned long start,
+		unsigned long len_in, unsigned long arg)
+{
+	return -EINVAL;
+}
+#endif
+
 SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		unsigned long, arg4, unsigned long, arg5)
 {
@@ -2262,6 +2411,9 @@
 		if (arg2 || arg3 || arg4 || arg5)
 			return -EINVAL;
 		return current->no_new_privs ? 1 : 0;
+	case PR_SET_VMA:
+		error = prctl_set_vma(arg2, arg3, arg4, arg5);
+		break;
 	default:
 		error = -EINVAL;
 		break;
diff -ur ./kernel/sysctl.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sysctl.c
--- ./kernel/sysctl.c	2023-04-26 12:56:08.820118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/sysctl.c	2023-04-23 12:09:04.096196300 +0100
@@ -105,6 +105,8 @@
 extern unsigned int core_pipe_limit;
 #endif
 extern int pid_max;
+extern int extra_free_kbytes;
+extern int min_free_order_shift;
 extern int pid_max_min, pid_max_max;
 extern int percpu_pagelist_fraction;
 extern int compat_log;
@@ -1266,6 +1268,21 @@
 		.extra1		= &zero,
 	},
 	{
+		.procname	= "extra_free_kbytes",
+		.data		= &extra_free_kbytes,
+		.maxlen		= sizeof(extra_free_kbytes),
+		.mode		= 0644,
+		.proc_handler	= min_free_kbytes_sysctl_handler,
+		.extra1		= &zero,
+	},
+	{
+		.procname	= "min_free_order_shift",
+		.data		= &min_free_order_shift,
+		.maxlen		= sizeof(min_free_order_shift),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
 		.procname	= "percpu_pagelist_fraction",
 		.data		= &percpu_pagelist_fraction,
 		.maxlen		= sizeof(percpu_pagelist_fraction),
diff -ur ./kernel/time/alarmtimer.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/time/alarmtimer.c
--- ./kernel/time/alarmtimer.c	2023-04-26 12:56:08.830118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/time/alarmtimer.c	2023-04-23 12:09:04.337685700 +0100
@@ -199,6 +199,12 @@
 
 }
 
+ktime_t alarm_expires_remaining(const struct alarm *alarm)
+{
+	struct alarm_base *base = &alarm_bases[alarm->type];
+	return ktime_sub(alarm->node.expires, base->gettime());
+}
+
 #ifdef CONFIG_RTC_CLASS
 /**
  * alarmtimer_suspend - Suspend time callback
@@ -305,7 +311,7 @@
 }
 
 /**
- * alarm_start - Sets an alarm to fire
+ * alarm_start - Sets an absolute alarm to fire
  * @alarm: ptr to alarm to set
  * @start: time to run the alarm
  */
@@ -325,6 +331,31 @@
 }
 
 /**
+ * alarm_start_relative - Sets a relative alarm to fire
+ * @alarm: ptr to alarm to set
+ * @start: time relative to now to run the alarm
+ */
+int alarm_start_relative(struct alarm *alarm, ktime_t start)
+{
+	struct alarm_base *base = &alarm_bases[alarm->type];
+
+	start = ktime_add(start, base->gettime());
+	return alarm_start(alarm, start);
+}
+
+void alarm_restart(struct alarm *alarm)
+{
+	struct alarm_base *base = &alarm_bases[alarm->type];
+	unsigned long flags;
+
+	spin_lock_irqsave(&base->lock, flags);
+	hrtimer_set_expires(&alarm->timer, alarm->node.expires);
+	hrtimer_restart(&alarm->timer);
+	alarmtimer_enqueue(base, alarm);
+	spin_unlock_irqrestore(&base->lock, flags);
+}
+
+/**
  * alarm_try_to_cancel - Tries to cancel an alarm timer
  * @alarm: ptr to alarm to be canceled
  *
@@ -394,6 +425,12 @@
 	return overrun;
 }
 
+u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)
+{
+	struct alarm_base *base = &alarm_bases[alarm->type];
+
+	return alarm_forward(alarm, base->gettime(), interval);
+}
 
 
 
diff -ur ./kernel/trace/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/Kconfig
--- ./kernel/trace/Kconfig	2023-04-26 12:26:26.270131168 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/Kconfig	2023-04-23 12:09:04.824511300 +0100
@@ -82,6 +82,9 @@
 	select CONTEXT_SWITCH_TRACER
 	bool
 
+config GPU_TRACEPOINTS
+	bool
+
 config CONTEXT_SWITCH_TRACER
 	bool
 
diff -ur ./kernel/trace/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/Makefile
--- ./kernel/trace/Makefile	2023-04-26 12:26:26.270131168 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/Makefile	2023-04-23 12:09:04.823970500 +0100
@@ -60,5 +60,6 @@
 endif
 obj-$(CONFIG_PROBE_EVENTS) += trace_probe.o
 obj-$(CONFIG_UPROBE_EVENT) += trace_uprobe.o
+obj-$(CONFIG_GPU_TRACEPOINTS) += gpu-traces.o
 
 libftrace-y := ftrace.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace: gpu-traces.c
diff -ur ./kernel/trace/trace.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace.c
--- ./kernel/trace/trace.c	2023-04-26 12:56:08.840118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace.c	2023-04-23 12:09:04.977970500 +0100
@@ -716,6 +716,7 @@
 	"irq-info",
 	"markers",
 	"function-trace",
+	"print-tgid",
 	NULL
 };
 
@@ -1225,6 +1226,7 @@
 static unsigned map_pid_to_cmdline[PID_MAX_DEFAULT+1];
 static unsigned map_cmdline_to_pid[SAVED_CMDLINES];
 static char saved_cmdlines[SAVED_CMDLINES][TASK_COMM_LEN];
+static unsigned saved_tgids[SAVED_CMDLINES];
 static int cmdline_idx;
 static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;
 
@@ -1428,6 +1430,7 @@
 	}
 
 	memcpy(&saved_cmdlines[idx], tsk->comm, TASK_COMM_LEN);
+	saved_tgids[idx] = tsk->tgid;
 
 	arch_spin_unlock(&trace_cmdline_lock);
 }
@@ -1463,6 +1466,25 @@
 	preempt_enable();
 }
 
+int trace_find_tgid(int pid)
+{
+	unsigned map;
+	int tgid;
+
+	preempt_disable();
+	arch_spin_lock(&trace_cmdline_lock);
+	map = map_pid_to_cmdline[pid];
+	if (map != NO_CMDLINE_MAP)
+		tgid = saved_tgids[map];
+	else
+		tgid = -1;
+
+	arch_spin_unlock(&trace_cmdline_lock);
+	preempt_enable();
+
+	return tgid;
+}
+
 void tracing_record_cmdline(struct task_struct *tsk)
 {
 	if (atomic_read(&trace_record_cmdline_disabled) || !tracing_is_on())
@@ -2419,6 +2441,13 @@
 	seq_puts(m, "#              | |       |          |         |\n");
 }
 
+static void print_func_help_header_tgid(struct trace_buffer *buf, struct seq_file *m)
+{
+	print_event_info(buf, m);
+	seq_puts(m, "#           TASK-PID    TGID   CPU#      TIMESTAMP  FUNCTION\n");
+	seq_puts(m, "#              | |        |      |          |         |\n");
+}
+
 static void print_func_help_header_irq(struct trace_buffer *buf, struct seq_file *m)
 {
 	print_event_info(buf, m);
@@ -2431,6 +2460,18 @@
 	seq_puts(m, "#              | |       |   ||||       |         |\n");
 }
 
+static void print_func_help_header_irq_tgid(struct trace_buffer *buf, struct seq_file *m)
+{
+	print_event_info(buf, m);
+	seq_puts(m, "#                                      _-----=> irqs-off\n");
+	seq_puts(m, "#                                     / _----=> need-resched\n");
+	seq_puts(m, "#                                    | / _---=> hardirq/softirq\n");
+	seq_puts(m, "#                                    || / _--=> preempt-depth\n");
+	seq_puts(m, "#                                    ||| /     delay\n");
+	seq_puts(m, "#           TASK-PID    TGID   CPU#  ||||    TIMESTAMP  FUNCTION\n");
+	seq_puts(m, "#              | |        |      |   ||||       |         |\n");
+}
+
 void
 print_trace_header(struct seq_file *m, struct trace_iterator *iter)
 {
@@ -2731,9 +2772,15 @@
 	} else {
 		if (!(trace_flags & TRACE_ITER_VERBOSE)) {
 			if (trace_flags & TRACE_ITER_IRQ_INFO)
-				print_func_help_header_irq(iter->trace_buffer, m);
+				if (trace_flags & TRACE_ITER_TGID)
+					print_func_help_header_irq_tgid(iter->trace_buffer, m);
+				else
+					print_func_help_header_irq(iter->trace_buffer, m);
 			else
-				print_func_help_header(iter->trace_buffer, m);
+				if (trace_flags & TRACE_ITER_TGID)
+					print_func_help_header_tgid(iter->trace_buffer, m);
+				else
+					print_func_help_header(iter->trace_buffer, m);
 		}
 	}
 }
@@ -3585,9 +3632,53 @@
 }
 
 static const struct file_operations tracing_saved_cmdlines_fops = {
-    .open       = tracing_open_generic,
-    .read       = tracing_saved_cmdlines_read,
-    .llseek	= generic_file_llseek,
+	.open	= tracing_open_generic,
+	.read	= tracing_saved_cmdlines_read,
+	.llseek	= generic_file_llseek,
+};
+
+static ssize_t
+tracing_saved_tgids_read(struct file *file, char __user *ubuf,
+				size_t cnt, loff_t *ppos)
+{
+	char *file_buf;
+	char *buf;
+	int len = 0;
+	int pid;
+	int i;
+
+	file_buf = kmalloc(SAVED_CMDLINES*(16+1+16), GFP_KERNEL);
+	if (!file_buf)
+		return -ENOMEM;
+
+	buf = file_buf;
+
+	for (i = 0; i < SAVED_CMDLINES; i++) {
+		int tgid;
+		int r;
+
+		pid = map_cmdline_to_pid[i];
+		if (pid == -1 || pid == NO_CMDLINE_MAP)
+			continue;
+
+		tgid = trace_find_tgid(pid);
+		r = sprintf(buf, "%d %d\n", pid, tgid);
+		buf += r;
+		len += r;
+	}
+
+	len = simple_read_from_buffer(ubuf, cnt, ppos,
+				      file_buf, len);
+
+	kfree(file_buf);
+
+	return len;
+}
+
+static const struct file_operations tracing_saved_tgids_fops = {
+	.open	= tracing_open_generic,
+	.read	= tracing_saved_tgids_read,
+	.llseek	= generic_file_llseek,
 };
 
 static ssize_t
@@ -6128,6 +6219,9 @@
 	trace_create_file("trace_marker", 0220, d_tracer,
 			  tr, &tracing_mark_fops);
 
+	trace_create_file("saved_tgids", 0444, d_tracer,
+			  tr, &tracing_saved_tgids_fops);
+
 	trace_create_file("trace_clock", 0644, d_tracer, tr,
 			  &trace_clock_fops);
 
diff -ur ./kernel/trace/trace.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace.h
--- ./kernel/trace/trace.h	2023-04-26 12:56:08.840118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace.h	2023-04-23 12:09:04.990007600 +0100
@@ -653,6 +653,7 @@
 extern cycle_t ftrace_now(int cpu);
 
 extern void trace_find_cmdline(int pid, char comm[]);
+extern int trace_find_tgid(int pid);
 
 #ifdef CONFIG_DYNAMIC_FTRACE
 extern unsigned long ftrace_update_tot_cnt;
@@ -866,6 +867,7 @@
 	TRACE_ITER_IRQ_INFO		= 0x800000,
 	TRACE_ITER_MARKERS		= 0x1000000,
 	TRACE_ITER_FUNCTION		= 0x2000000,
+	TRACE_ITER_TGID 		= 0x4000000,
 };
 
 /*
diff -ur ./kernel/trace/trace_functions_graph.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace_functions_graph.c
--- ./kernel/trace/trace_functions_graph.c	2023-04-26 12:56:08.840118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace_functions_graph.c	2023-04-23 12:09:05.297079000 +0100
@@ -46,6 +46,8 @@
 #define TRACE_GRAPH_PRINT_DURATION	0x10
 #define TRACE_GRAPH_PRINT_ABS_TIME	0x20
 #define TRACE_GRAPH_PRINT_IRQS		0x40
+#define TRACE_GRAPH_PRINT_FLAT		0x80
+
 
 static unsigned int max_depth;
 
@@ -64,6 +66,8 @@
 	{ TRACER_OPT(funcgraph-abstime, TRACE_GRAPH_PRINT_ABS_TIME) },
 	/* Display interrupts */
 	{ TRACER_OPT(funcgraph-irqs, TRACE_GRAPH_PRINT_IRQS) },
+	/* Use standard trace formatting rather than hierarchical */
+	{ TRACER_OPT(funcgraph-flat, TRACE_GRAPH_PRINT_FLAT) },
 	{ } /* Empty entry */
 };
 
@@ -1234,6 +1238,9 @@
 	int cpu = iter->cpu;
 	int ret;
 
+	if (flags & TRACE_GRAPH_PRINT_FLAT)
+		return TRACE_TYPE_UNHANDLED;
+
 	if (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {
 		per_cpu_ptr(data->cpu_data, cpu)->ignore = 0;
 		return TRACE_TYPE_HANDLED;
@@ -1291,13 +1298,6 @@
 	return print_graph_function_flags(iter, tracer_flags.val);
 }
 
-static enum print_line_t
-print_graph_function_event(struct trace_iterator *iter, int flags,
-			   struct trace_event *event)
-{
-	return print_graph_function(iter);
-}
-
 static void print_lat_header(struct seq_file *s, u32 flags)
 {
 	static const char spaces[] = "                "	/* 16 spaces */
@@ -1364,6 +1364,11 @@
 {
 	struct trace_iterator *iter = s->private;
 
+	if (flags & TRACE_GRAPH_PRINT_FLAT) {
+		trace_default_header(s);
+		return;
+	}
+
 	if (!(trace_flags & TRACE_ITER_CONTEXT_INFO))
 		return;
 
@@ -1434,20 +1439,6 @@
 	return 0;
 }
 
-static struct trace_event_functions graph_functions = {
-	.trace		= print_graph_function_event,
-};
-
-static struct trace_event graph_trace_entry_event = {
-	.type		= TRACE_GRAPH_ENT,
-	.funcs		= &graph_functions,
-};
-
-static struct trace_event graph_trace_ret_event = {
-	.type		= TRACE_GRAPH_RET,
-	.funcs		= &graph_functions
-};
-
 static struct tracer graph_trace __read_mostly = {
 	.name		= "function_graph",
 	.open		= graph_trace_open,
@@ -1523,16 +1514,6 @@
 {
 	max_bytes_for_cpu = snprintf(NULL, 0, "%d", nr_cpu_ids - 1);
 
-	if (!register_ftrace_event(&graph_trace_entry_event)) {
-		pr_warning("Warning: could not register graph trace events\n");
-		return 1;
-	}
-
-	if (!register_ftrace_event(&graph_trace_ret_event)) {
-		pr_warning("Warning: could not register graph trace events\n");
-		return 1;
-	}
-
 	return register_tracer(&graph_trace);
 }
 
diff -ur ./kernel/trace/trace_output.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace_output.c
--- ./kernel/trace/trace_output.c	2023-04-26 12:56:08.850118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/trace/trace_output.c	2023-04-23 12:09:05.457444500 +0100
@@ -702,11 +702,25 @@
 	unsigned long secs, usec_rem;
 	char comm[TASK_COMM_LEN];
 	int ret;
+	int tgid;
 
 	trace_find_cmdline(entry->pid, comm);
 
-	ret = trace_seq_printf(s, "%16s-%-5d [%03d] ",
-			       comm, entry->pid, iter->cpu);
+	ret = trace_seq_printf(s, "%16s-%-5d ", comm, entry->pid);
+	if (!ret)
+		return 0;
+
+	if (trace_flags & TRACE_ITER_TGID) {
+		tgid = trace_find_tgid(entry->pid);
+		if (tgid < 0)
+			ret = trace_seq_puts(s, "(-----) ");
+		else
+			ret = trace_seq_printf(s, "(%5d) ", tgid);
+		if (!ret)
+			return 0;
+	}
+
+	ret = trace_seq_printf(s, "[%03d] ", iter->cpu);
 	if (!ret)
 		return 0;
 
@@ -1035,6 +1049,168 @@
 	.funcs		= &trace_fn_funcs,
 };
 
+/* TRACE_GRAPH_ENT */
+static enum print_line_t trace_graph_ent_trace(struct trace_iterator *iter, int flags,
+					struct trace_event *event)
+{
+	struct trace_seq *s = &iter->seq;
+	struct ftrace_graph_ent_entry *field;
+
+	trace_assign_type(field, iter->ent);
+
+	if (!trace_seq_puts(s, "graph_ent: func="))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	if (!seq_print_ip_sym(s, field->graph_ent.func, flags))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	if (!trace_seq_puts(s, "\n"))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ent_raw(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ent_entry *field;
+
+	trace_assign_type(field, iter->ent);
+
+	if (!trace_seq_printf(&iter->seq, "%lx %d\n",
+			      field->graph_ent.func,
+			      field->graph_ent.depth))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ent_hex(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ent_entry *field;
+	struct trace_seq *s = &iter->seq;
+
+	trace_assign_type(field, iter->ent);
+
+	SEQ_PUT_HEX_FIELD_RET(s, field->graph_ent.func);
+	SEQ_PUT_HEX_FIELD_RET(s, field->graph_ent.depth);
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ent_bin(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ent_entry *field;
+	struct trace_seq *s = &iter->seq;
+
+	trace_assign_type(field, iter->ent);
+
+	SEQ_PUT_FIELD_RET(s, field->graph_ent.func);
+	SEQ_PUT_FIELD_RET(s, field->graph_ent.depth);
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static struct trace_event_functions trace_graph_ent_funcs = {
+	.trace		= trace_graph_ent_trace,
+	.raw		= trace_graph_ent_raw,
+	.hex		= trace_graph_ent_hex,
+	.binary		= trace_graph_ent_bin,
+};
+
+static struct trace_event trace_graph_ent_event = {
+	.type		= TRACE_GRAPH_ENT,
+	.funcs		= &trace_graph_ent_funcs,
+};
+
+/* TRACE_GRAPH_RET */
+static enum print_line_t trace_graph_ret_trace(struct trace_iterator *iter, int flags,
+					struct trace_event *event)
+{
+	struct trace_seq *s = &iter->seq;
+	struct trace_entry *entry = iter->ent;
+	struct ftrace_graph_ret_entry *field;
+
+	trace_assign_type(field, entry);
+
+	if (!trace_seq_puts(s, "graph_ret: func="))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	if (!seq_print_ip_sym(s, field->ret.func, flags))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	if (!trace_seq_puts(s, "\n"))
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ret_raw(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ret_entry *field;
+
+	trace_assign_type(field, iter->ent);
+
+	if (!trace_seq_printf(&iter->seq, "%lx %lld %lld %ld %d\n",
+			      field->ret.func,
+			      field->ret.calltime,
+			      field->ret.rettime,
+			      field->ret.overrun,
+			      field->ret.depth));
+		return TRACE_TYPE_PARTIAL_LINE;
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ret_hex(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ret_entry *field;
+	struct trace_seq *s = &iter->seq;
+
+	trace_assign_type(field, iter->ent);
+
+	SEQ_PUT_HEX_FIELD_RET(s, field->ret.func);
+	SEQ_PUT_HEX_FIELD_RET(s, field->ret.calltime);
+	SEQ_PUT_HEX_FIELD_RET(s, field->ret.rettime);
+	SEQ_PUT_HEX_FIELD_RET(s, field->ret.overrun);
+	SEQ_PUT_HEX_FIELD_RET(s, field->ret.depth);
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static enum print_line_t trace_graph_ret_bin(struct trace_iterator *iter, int flags,
+				      struct trace_event *event)
+{
+	struct ftrace_graph_ret_entry *field;
+	struct trace_seq *s = &iter->seq;
+
+	trace_assign_type(field, iter->ent);
+
+	SEQ_PUT_FIELD_RET(s, field->ret.func);
+	SEQ_PUT_FIELD_RET(s, field->ret.calltime);
+	SEQ_PUT_FIELD_RET(s, field->ret.rettime);
+	SEQ_PUT_FIELD_RET(s, field->ret.overrun);
+	SEQ_PUT_FIELD_RET(s, field->ret.depth);
+
+	return TRACE_TYPE_HANDLED;
+}
+
+static struct trace_event_functions trace_graph_ret_funcs = {
+	.trace		= trace_graph_ret_trace,
+	.raw		= trace_graph_ret_raw,
+	.hex		= trace_graph_ret_hex,
+	.binary		= trace_graph_ret_bin,
+};
+
+static struct trace_event trace_graph_ret_event = {
+	.type		= TRACE_GRAPH_RET,
+	.funcs		= &trace_graph_ret_funcs,
+};
+
 /* TRACE_CTX an TRACE_WAKE */
 static enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,
 					     char *delim)
@@ -1425,6 +1601,8 @@
 
 static struct trace_event *events[] __initdata = {
 	&trace_fn_event,
+	&trace_graph_ent_event,
+	&trace_graph_ret_event,
 	&trace_ctx_event,
 	&trace_wake_event,
 	&trace_stack_event,
diff -ur ./kernel/watchdog.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/watchdog.c
--- ./kernel/watchdog.c	2023-04-26 12:56:08.850118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/kernel/watchdog.c	2023-04-23 12:09:05.855904600 +0100
@@ -45,6 +45,11 @@
 static DEFINE_PER_CPU(bool, hard_watchdog_warn);
 static DEFINE_PER_CPU(bool, watchdog_nmi_touch);
 static DEFINE_PER_CPU(unsigned long, hrtimer_interrupts_saved);
+#endif
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_OTHER_CPU
+static cpumask_t __read_mostly watchdog_cpus;
+#endif
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI
 static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);
 #endif
 
@@ -178,7 +183,7 @@
 	__raw_get_cpu_var(watchdog_touch_ts) = 0;
 }
 
-#ifdef CONFIG_HARDLOCKUP_DETECTOR
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI
 /* watchdog detector functions */
 static int is_hardlockup(void)
 {
@@ -192,6 +197,76 @@
 }
 #endif
 
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_OTHER_CPU
+static unsigned int watchdog_next_cpu(unsigned int cpu)
+{
+	cpumask_t cpus = watchdog_cpus;
+	unsigned int next_cpu;
+
+	next_cpu = cpumask_next(cpu, &cpus);
+	if (next_cpu >= nr_cpu_ids)
+		next_cpu = cpumask_first(&cpus);
+
+	if (next_cpu == cpu)
+		return nr_cpu_ids;
+
+	return next_cpu;
+}
+
+static int is_hardlockup_other_cpu(unsigned int cpu)
+{
+	unsigned long hrint = per_cpu(hrtimer_interrupts, cpu);
+
+	if (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)
+		return 1;
+
+	per_cpu(hrtimer_interrupts_saved, cpu) = hrint;
+	return 0;
+}
+
+static void watchdog_check_hardlockup_other_cpu(void)
+{
+	unsigned int next_cpu;
+
+	/*
+	 * Test for hardlockups every 3 samples.  The sample period is
+	 *  watchdog_thresh * 2 / 5, so 3 samples gets us back to slightly over
+	 *  watchdog_thresh (over by 20%).
+	 */
+	if (__this_cpu_read(hrtimer_interrupts) % 3 != 0)
+		return;
+
+	/* check for a hardlockup on the next cpu */
+	next_cpu = watchdog_next_cpu(smp_processor_id());
+	if (next_cpu >= nr_cpu_ids)
+		return;
+
+	smp_rmb();
+
+	if (per_cpu(watchdog_nmi_touch, next_cpu) == true) {
+		per_cpu(watchdog_nmi_touch, next_cpu) = false;
+		return;
+	}
+
+	if (is_hardlockup_other_cpu(next_cpu)) {
+		/* only warn once */
+		if (per_cpu(hard_watchdog_warn, next_cpu) == true)
+			return;
+
+		if (hardlockup_panic)
+			panic("Watchdog detected hard LOCKUP on cpu %u", next_cpu);
+		else
+			WARN(1, "Watchdog detected hard LOCKUP on cpu %u", next_cpu);
+
+		per_cpu(hard_watchdog_warn, next_cpu) = true;
+	} else {
+		per_cpu(hard_watchdog_warn, next_cpu) = false;
+	}
+}
+#else
+static inline void watchdog_check_hardlockup_other_cpu(void) { return; }
+#endif
+
 static int is_softlockup(unsigned long touch_ts)
 {
 	unsigned long now = get_timestamp();
@@ -203,7 +278,7 @@
 	return 0;
 }
 
-#ifdef CONFIG_HARDLOCKUP_DETECTOR
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI
 
 static struct perf_event_attr wd_hw_attr = {
 	.type		= PERF_TYPE_HARDWARE,
@@ -251,7 +326,7 @@
 	__this_cpu_write(hard_watchdog_warn, false);
 	return;
 }
-#endif /* CONFIG_HARDLOCKUP_DETECTOR */
+#endif /* CONFIG_HARDLOCKUP_DETECTOR_NMI */
 
 static void watchdog_interrupt_count(void)
 {
@@ -271,6 +346,9 @@
 	/* kick the hardlockup detector */
 	watchdog_interrupt_count();
 
+	/* test for hardlockups on the next cpu */
+	watchdog_check_hardlockup_other_cpu();
+
 	/* kick the softlockup detector */
 	wake_up_process(__this_cpu_read(softlockup_watchdog));
 
@@ -395,7 +473,7 @@
 	__touch_watchdog();
 }
 
-#ifdef CONFIG_HARDLOCKUP_DETECTOR
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI
 /*
  * People like the simple clean cpu node info on boot.
  * Reduce the watchdog noise by only printing messages
@@ -471,9 +549,44 @@
 	return;
 }
 #else
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_OTHER_CPU
+static int watchdog_nmi_enable(unsigned int cpu)
+{
+	/*
+	 * The new cpu will be marked online before the first hrtimer interrupt
+	 * runs on it.  If another cpu tests for a hardlockup on the new cpu
+	 * before it has run its first hrtimer, it will get a false positive.
+	 * Touch the watchdog on the new cpu to delay the first check for at
+	 * least 3 sampling periods to guarantee one hrtimer has run on the new
+	 * cpu.
+	 */
+	per_cpu(watchdog_nmi_touch, cpu) = true;
+	smp_wmb();
+	cpumask_set_cpu(cpu, &watchdog_cpus);
+	return 0;
+}
+
+static void watchdog_nmi_disable(unsigned int cpu)
+{
+	unsigned int next_cpu = watchdog_next_cpu(cpu);
+
+	/*
+	 * Offlining this cpu will cause the cpu before this one to start
+	 * checking the one after this one.  If this cpu just finished checking
+	 * the next cpu and updating hrtimer_interrupts_saved, and then the
+	 * previous cpu checks it within one sample period, it will trigger a
+	 * false positive.  Touch the watchdog on the next cpu to prevent it.
+	 */
+	if (next_cpu < nr_cpu_ids)
+		per_cpu(watchdog_nmi_touch, next_cpu) = true;
+	smp_wmb();
+	cpumask_clear_cpu(cpu, &watchdog_cpus);
+}
+#else
 static int watchdog_nmi_enable(unsigned int cpu) { return 0; }
 static void watchdog_nmi_disable(unsigned int cpu) { return; }
-#endif /* CONFIG_HARDLOCKUP_DETECTOR */
+#endif /* CONFIG_HARDLOCKUP_DETECTOR_OTHER_CPU */
+#endif /* CONFIG_HARDLOCKUP_DETECTOR_NMI */
 
 /* prepare/enable/disable routines */
 /* sysctl functions */
diff -ur ./lib/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Kconfig
--- ./lib/Kconfig	2023-04-26 12:56:08.850118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Kconfig	2023-04-23 12:09:06.019610800 +0100
@@ -189,6 +189,15 @@
 config LZO_DECOMPRESS
 	tristate
 
+config LZ4_COMPRESS
+	tristate
+
+config LZ4HC_COMPRESS
+	tristate
+
+config LZ4_DECOMPRESS
+	tristate
+
 source "lib/xz/Kconfig"
 
 #
@@ -213,6 +222,10 @@
 	select LZO_DECOMPRESS
 	tristate
 
+config DECOMPRESS_LZ4
+	select LZ4_DECOMPRESS
+	tristate
+
 #
 # Generic allocator support is selected if needed
 #
diff -ur ./lib/Kconfig.debug /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Kconfig.debug
--- ./lib/Kconfig.debug	2023-04-26 12:56:08.850118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Kconfig.debug	2023-04-23 12:09:06.104355900 +0100
@@ -191,15 +191,27 @@
 	  The overhead should be minimal.  A periodic hrtimer runs to
 	  generate interrupts and kick the watchdog task every 4 seconds.
 	  An NMI is generated every 10 seconds or so to check for hardlockups.
+	  If NMIs are not available on the platform, every 12 seconds the
+	  hrtimer interrupt on one cpu will be used to check for hardlockups
+	  on the next cpu.
 
 	  The frequency of hrtimer and NMI events and the soft and hard lockup
 	  thresholds can be controlled through the sysctl watchdog_thresh.
 
-config HARDLOCKUP_DETECTOR
+config HARDLOCKUP_DETECTOR_NMI
 	def_bool y
 	depends on LOCKUP_DETECTOR && !HAVE_NMI_WATCHDOG
 	depends on PERF_EVENTS && HAVE_PERF_EVENTS_NMI
 
+config HARDLOCKUP_DETECTOR_OTHER_CPU
+	def_bool y
+	depends on LOCKUP_DETECTOR && SMP
+	depends on !HARDLOCKUP_DETECTOR_NMI && !HAVE_NMI_WATCHDOG
+
+config HARDLOCKUP_DETECTOR
+	def_bool y
+	depends on HARDLOCKUP_DETECTOR_NMI || HARDLOCKUP_DETECTOR_OTHER_CPU
+
 config BOOTPARAM_HARDLOCKUP_PANIC
 	bool "Panic (Reboot) On Hard Lockups"
 	depends on HARDLOCKUP_DETECTOR
@@ -669,8 +681,9 @@
 	  mutexes and rwsems.
 
 config STACKTRACE
-	bool
+	bool "Stacktrace"
 	depends on STACKTRACE_SUPPORT
+	default y
 
 config DEBUG_STACK_USAGE
 	bool "Stack utilization instrumentation"
@@ -854,7 +867,7 @@
 config FRAME_POINTER
 	bool "Compile the kernel with frame pointers"
 	depends on DEBUG_KERNEL && \
-		(CRIS || M68K || FRV || UML || \
+		(CRIS || M68K || FRV || UML || MIPS || \
 		 AVR32 || SUPERH || BLACKFIN || MN10300 || METAG) || \
 		ARCH_WANT_FRAME_POINTERS
 	default y if (DEBUG_INFO && UML) || ARCH_WANT_FRAME_POINTERS
diff -ur ./lib/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Makefile
--- ./lib/Makefile	2023-04-26 12:56:08.850118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib/Makefile	2023-04-23 12:09:06.095984700 +0100
@@ -75,6 +75,9 @@
 obj-$(CONFIG_BCH) += bch.o
 obj-$(CONFIG_LZO_COMPRESS) += lzo/
 obj-$(CONFIG_LZO_DECOMPRESS) += lzo/
+obj-$(CONFIG_LZ4_COMPRESS) += lz4/
+obj-$(CONFIG_LZ4HC_COMPRESS) += lz4/
+obj-$(CONFIG_LZ4_DECOMPRESS) += lz4/
 obj-$(CONFIG_XZ_DEC) += xz/
 obj-$(CONFIG_RAID6_PQ) += raid6/
 
@@ -83,6 +86,7 @@
 lib-$(CONFIG_DECOMPRESS_LZMA) += decompress_unlzma.o
 lib-$(CONFIG_DECOMPRESS_XZ) += decompress_unxz.o
 lib-$(CONFIG_DECOMPRESS_LZO) += decompress_unlzo.o
+lib-$(CONFIG_DECOMPRESS_LZ4) += decompress_unlz4.o
 
 obj-$(CONFIG_TEXTSEARCH) += textsearch.o
 obj-$(CONFIG_TEXTSEARCH_KMP) += ts_kmp.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/lib: lz4
diff -ur ./mm/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/Kconfig
--- ./mm/Kconfig	2023-04-26 12:56:08.860118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/Kconfig	2023-04-23 12:09:12.098647100 +0100
@@ -477,3 +477,28 @@
 	  and swap data is stored as normal on the matching swap device.
 
 	  If unsure, say Y to enable frontswap.
+
+config ZSMALLOC
+	bool "Memory allocator for compressed pages"
+	depends on MMU
+	default n
+	help
+	  zsmalloc is a slab-based memory allocator designed to store
+	  compressed RAM pages.	 zsmalloc uses virtual memory mapping
+	  in order to reduce fragmentation.  However, this results in a
+	  non-standard allocator interface where a handle, not a pointer, is
+	  returned by an alloc().  This handle must be mapped in order to
+	  access the allocated space.
+
+config PGTABLE_MAPPING
+	bool "Use page table mapping to access object in zsmalloc"
+	depends on ZSMALLOC
+	help
+	  By default, zsmalloc uses a copy-based object mapping method to
+	  access allocations that span two pages. However, if a particular
+	  architecture (ex, ARM) performs VM mapping faster than copying,
+	  then you should select this. This causes zsmalloc to use page table
+	  mapping rather than copying for object mapping.
+
+	  You can check speed with zsmalloc benchmark[1].
+	  [1] https://github.com/spartacus06/zsmalloc
diff -ur ./mm/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/Makefile
--- ./mm/Makefile	2023-04-26 12:56:08.860118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/Makefile	2023-04-23 12:09:12.097800600 +0100
@@ -58,3 +58,4 @@
 obj-$(CONFIG_DEBUG_KMEMLEAK_TEST) += kmemleak-test.o
 obj-$(CONFIG_CLEANCACHE) += cleancache.o
 obj-$(CONFIG_MEMORY_ISOLATION) += page_isolation.o
+obj-$(CONFIG_ZSMALLOC)	+= zsmalloc.o
diff -ur ./mm/highmem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/highmem.c
--- ./mm/highmem.c	2023-04-26 12:26:26.590131013 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/highmem.c	2023-04-23 12:09:12.580054700 +0100
@@ -44,6 +44,14 @@
  */
 #ifdef CONFIG_HIGHMEM
 
+#ifndef ARCH_PKMAP_COLORING
+#define     set_pkmap_color(pg,cl)          /* */
+#define     get_last_pkmap_nr(p,cl)         (p)
+#define     get_next_pkmap_nr(p,cl)         ((p + 1) & LAST_PKMAP_MASK)
+#define     is_no_more_pkmaps(p,cl)         (!p)
+#define     get_next_pkmap_counter(c,cl)    (c - 1)
+#endif
+
 unsigned long totalhigh_pages __read_mostly;
 EXPORT_SYMBOL(totalhigh_pages);
 
@@ -161,19 +169,24 @@
 {
 	unsigned long vaddr;
 	int count;
+	int color;
+
+	set_pkmap_color(page,color);
+	last_pkmap_nr = get_last_pkmap_nr(last_pkmap_nr,color);
 
 start:
 	count = LAST_PKMAP;
 	/* Find an empty entry */
 	for (;;) {
-		last_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;
-		if (!last_pkmap_nr) {
+		last_pkmap_nr = get_next_pkmap_nr(last_pkmap_nr,color);
+		if (is_no_more_pkmaps(last_pkmap_nr,color)) {
 			flush_all_zero_pkmaps();
 			count = LAST_PKMAP;
 		}
 		if (!pkmap_count[last_pkmap_nr])
 			break;	/* Found a usable entry */
-		if (--count)
+		count = get_next_pkmap_counter(count,color);
+		if (count > 0)
 			continue;
 
 		/*
diff -ur ./mm/madvise.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/madvise.c
--- ./mm/madvise.c	2023-04-26 12:26:26.610131003 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/madvise.c	2023-04-23 12:09:12.821709100 +0100
@@ -102,7 +102,8 @@
 
 	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
 	*prev = vma_merge(mm, *prev, start, end, new_flags, vma->anon_vma,
-				vma->vm_file, pgoff, vma_policy(vma));
+				vma->vm_file, pgoff, vma_policy(vma),
+				vma_get_anon_name(vma));
 	if (*prev) {
 		vma = *prev;
 		goto success;
diff -ur ./mm/mempolicy.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mempolicy.c
--- ./mm/mempolicy.c	2023-04-26 12:36:35.210089068 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mempolicy.c	2023-04-23 12:09:13.008160400 +0100
@@ -728,7 +728,7 @@
 			((vmstart - vma->vm_start) >> PAGE_SHIFT);
 		prev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,
 				  vma->anon_vma, vma->vm_file, pgoff,
-				  new_pol);
+				  new_pol, vma_get_anon_name(vma));
 		if (prev) {
 			vma = prev;
 			next = vma->vm_next;
diff -ur ./mm/mlock.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mlock.c
--- ./mm/mlock.c	2023-04-26 12:26:26.640130989 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mlock.c	2023-04-23 12:09:13.060065200 +0100
@@ -287,7 +287,8 @@
 
 	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
 	*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,
-			  vma->vm_file, pgoff, vma_policy(vma));
+			  vma->vm_file, pgoff, vma_policy(vma),
+			  vma_get_anon_name(vma));
 	if (*prev) {
 		vma = *prev;
 		goto success;
diff -ur ./mm/mmap.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mmap.c
--- ./mm/mmap.c	2023-04-26 12:56:08.880118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mmap.c	2023-04-23 12:09:13.059668700 +0100
@@ -893,7 +893,8 @@
  * per-vma resources, so we don't attempt to merge those.
  */
 static inline int is_mergeable_vma(struct vm_area_struct *vma,
-			struct file *file, unsigned long vm_flags)
+			struct file *file, unsigned long vm_flags,
+			const char __user *anon_name)
 {
 	if (vma->vm_flags ^ vm_flags)
 		return 0;
@@ -901,6 +902,8 @@
 		return 0;
 	if (vma->vm_ops && vma->vm_ops->close)
 		return 0;
+	if (vma_get_anon_name(vma) != anon_name)
+		return 0;
 	return 1;
 }
 
@@ -931,9 +934,10 @@
  */
 static int
 can_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,
-	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff)
+	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff,
+	const char __user *anon_name)
 {
-	if (is_mergeable_vma(vma, file, vm_flags) &&
+	if (is_mergeable_vma(vma, file, vm_flags, anon_name) &&
 	    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {
 		if (vma->vm_pgoff == vm_pgoff)
 			return 1;
@@ -950,9 +954,10 @@
  */
 static int
 can_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,
-	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff)
+	struct anon_vma *anon_vma, struct file *file, pgoff_t vm_pgoff,
+	const char __user *anon_name)
 {
-	if (is_mergeable_vma(vma, file, vm_flags) &&
+	if (is_mergeable_vma(vma, file, vm_flags, anon_name) &&
 	    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {
 		pgoff_t vm_pglen;
 		vm_pglen = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
@@ -963,9 +968,9 @@
 }
 
 /*
- * Given a mapping request (addr,end,vm_flags,file,pgoff), figure out
- * whether that can be merged with its predecessor or its successor.
- * Or both (it neatly fills a hole).
+ * Given a mapping request (addr,end,vm_flags,file,pgoff,anon_name),
+ * figure out whether that can be merged with its predecessor or its
+ * successor.  Or both (it neatly fills a hole).
  *
  * In most cases - when called for mmap, brk or mremap - [addr,end) is
  * certain not to be mapped by the time vma_merge is called; but when
@@ -995,7 +1000,8 @@
 			struct vm_area_struct *prev, unsigned long addr,
 			unsigned long end, unsigned long vm_flags,
 		     	struct anon_vma *anon_vma, struct file *file,
-			pgoff_t pgoff, struct mempolicy *policy)
+			pgoff_t pgoff, struct mempolicy *policy,
+			const char __user *anon_name)
 {
 	pgoff_t pglen = (end - addr) >> PAGE_SHIFT;
 	struct vm_area_struct *area, *next;
@@ -1021,15 +1027,15 @@
 	 */
 	if (prev && prev->vm_end == addr &&
   			mpol_equal(vma_policy(prev), policy) &&
-			can_vma_merge_after(prev, vm_flags,
-						anon_vma, file, pgoff)) {
+			can_vma_merge_after(prev, vm_flags, anon_vma,
+						file, pgoff, anon_name)) {
 		/*
 		 * OK, it can.  Can we now merge in the successor as well?
 		 */
 		if (next && end == next->vm_start &&
 				mpol_equal(policy, vma_policy(next)) &&
-				can_vma_merge_before(next, vm_flags,
-					anon_vma, file, pgoff+pglen) &&
+				can_vma_merge_before(next, vm_flags, anon_vma,
+						file, pgoff+pglen, anon_name) &&
 				is_mergeable_anon_vma(prev->anon_vma,
 						      next->anon_vma, NULL)) {
 							/* cases 1, 6 */
@@ -1049,8 +1055,8 @@
 	 */
 	if (next && end == next->vm_start &&
  			mpol_equal(policy, vma_policy(next)) &&
-			can_vma_merge_before(next, vm_flags,
-					anon_vma, file, pgoff+pglen)) {
+			can_vma_merge_before(next, vm_flags, anon_vma,
+					file, pgoff+pglen, anon_name)) {
 		if (prev && addr < prev->vm_end)	/* case 4 */
 			err = vma_adjust(prev, prev->vm_start,
 				addr, prev->vm_pgoff, NULL);
@@ -1519,7 +1525,8 @@
 	/*
 	 * Can we just expand an old mapping?
 	 */
-	vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff, NULL);
+	vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff,
+			NULL, NULL);
 	if (vma)
 		goto out;
 
@@ -2663,7 +2670,7 @@
 
 	/* Can we just expand an old private anonymous mapping? */
 	vma = vma_merge(mm, prev, addr, addr + len, flags,
-					NULL, NULL, pgoff, NULL);
+					NULL, NULL, pgoff, NULL, NULL);
 	if (vma)
 		goto out;
 
@@ -2821,7 +2828,8 @@
 	if (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))
 		return NULL;	/* should never get here */
 	new_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,
-			vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma));
+			vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),
+			vma_get_anon_name(vma));
 	if (new_vma) {
 		/*
 		 * Source vma may have been merged into new_vma
diff -ur ./mm/mprotect.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mprotect.c
--- ./mm/mprotect.c	2023-04-26 12:26:26.650130984 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/mprotect.c	2023-04-23 12:09:13.138490400 +0100
@@ -271,7 +271,8 @@
 	 */
 	pgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);
 	*pprev = vma_merge(mm, *pprev, start, end, newflags,
-			vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma));
+			vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),
+			vma_get_anon_name(vma));
 	if (*pprev) {
 		vma = *pprev;
 		goto success;
diff -ur ./mm/page_alloc.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/page_alloc.c
--- ./mm/page_alloc.c	2023-04-26 12:56:08.880118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/page_alloc.c	2023-04-23 12:09:13.381538700 +0100
@@ -196,7 +196,20 @@
 	 "Movable",
 };
 
+/*
+ * Try to keep at least this much lowmem free.  Do not allow normal
+ * allocations below this point, only high priority ones. Automatically
+ * tuned according to the amount of memory in the system.
+ */
 int min_free_kbytes = 1024;
+int min_free_order_shift = 1;
+
+/*
+ * Extra memory for the system to try freeing. Used to temporarily
+ * free memory, to make space for new workloads. Anyone can allocate
+ * down to the min watermarks controlled by min_free_kbytes above.
+ */
+int extra_free_kbytes = 0;
 
 static unsigned long __meminitdata nr_kernel_pages;
 static unsigned long __meminitdata nr_all_pages;
@@ -1648,7 +1661,7 @@
 		free_pages -= z->free_area[o].nr_free << o;
 
 		/* Require fewer higher order pages to be free */
-		min >>= 1;
+		min >>= min_free_order_shift;
 
 		if (free_pages <= min)
 			return false;
@@ -5320,6 +5333,7 @@
 static void __setup_per_zone_wmarks(void)
 {
 	unsigned long pages_min = min_free_kbytes >> (PAGE_SHIFT - 10);
+	unsigned long pages_low = extra_free_kbytes >> (PAGE_SHIFT - 10);
 	unsigned long lowmem_pages = 0;
 	struct zone *zone;
 	unsigned long flags;
@@ -5331,11 +5345,14 @@
 	}
 
 	for_each_zone(zone) {
-		u64 tmp;
+		u64 min, low;
 
 		spin_lock_irqsave(&zone->lock, flags);
-		tmp = (u64)pages_min * zone->managed_pages;
-		do_div(tmp, lowmem_pages);
+		min = (u64)pages_min * zone->managed_pages;
+		do_div(min, lowmem_pages);
+		low = (u64)pages_low * zone->managed_pages;
+		do_div(low, vm_total_pages);
+
 		if (is_highmem(zone)) {
 			/*
 			 * __GFP_HIGH and PF_MEMALLOC allocations usually don't
@@ -5356,11 +5373,13 @@
 			 * If it's a lowmem zone, reserve a number of pages
 			 * proportionate to the zone's size.
 			 */
-			zone->watermark[WMARK_MIN] = tmp;
+			zone->watermark[WMARK_MIN] = min;
 		}
 
-		zone->watermark[WMARK_LOW]  = min_wmark_pages(zone) + (tmp >> 2);
-		zone->watermark[WMARK_HIGH] = min_wmark_pages(zone) + (tmp >> 1);
+		zone->watermark[WMARK_LOW]  = min_wmark_pages(zone) +
+					low + (min >> 2);
+		zone->watermark[WMARK_HIGH] = min_wmark_pages(zone) +
+					low + (min >> 1);
 
 		setup_zone_migrate_reserve(zone);
 		spin_unlock_irqrestore(&zone->lock, flags);
@@ -5473,7 +5492,7 @@
 /*
  * min_free_kbytes_sysctl_handler - just a wrapper around proc_dointvec() so 
  *	that we can call two helper functions whenever min_free_kbytes
- *	changes.
+ *	or extra_free_kbytes changes.
  */
 int min_free_kbytes_sysctl_handler(ctl_table *table, int write, 
 	void __user *buffer, size_t *length, loff_t *ppos)
diff -ur ./mm/page_io.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/page_io.c
--- ./mm/page_io.c	2023-04-26 12:56:08.880118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/page_io.c	2023-04-23 12:09:13.380744300 +0100
@@ -21,6 +21,7 @@
 #include <linux/writeback.h>
 #include <linux/frontswap.h>
 #include <linux/aio.h>
+#include <linux/blkdev.h>
 #include <asm/pgtable.h>
 
 static struct bio *get_swap_bio(gfp_t gfp_flags,
@@ -80,9 +81,54 @@
 				imajor(bio->bi_bdev->bd_inode),
 				iminor(bio->bi_bdev->bd_inode),
 				(unsigned long long)bio->bi_sector);
-	} else {
-		SetPageUptodate(page);
+		goto out;
 	}
+
+	SetPageUptodate(page);
+
+	/*
+	 * There is no guarantee that the page is in swap cache - the software
+	 * suspend code (at least) uses end_swap_bio_read() against a non-
+	 * swapcache page.  So we must check PG_swapcache before proceeding with
+	 * this optimization.
+	 */
+	if (likely(PageSwapCache(page))) {
+		struct swap_info_struct *sis;
+
+		sis = page_swap_info(page);
+		if (sis->flags & SWP_BLKDEV) {
+			/*
+			 * The swap subsystem performs lazy swap slot freeing,
+			 * expecting that the page will be swapped out again.
+			 * So we can avoid an unnecessary write if the page
+			 * isn't redirtied.
+			 * This is good for real swap storage because we can
+			 * reduce unnecessary I/O and enhance wear-leveling
+			 * if an SSD is used as the as swap device.
+			 * But if in-memory swap device (eg zram) is used,
+			 * this causes a duplicated copy between uncompressed
+			 * data in VM-owned memory and compressed data in
+			 * zram-owned memory.  So let's free zram-owned memory
+			 * and make the VM-owned decompressed page *dirty*,
+			 * so the page should be swapped out somewhere again if
+			 * we again wish to reclaim it.
+			 */
+			struct gendisk *disk = sis->bdev->bd_disk;
+			if (disk->fops->swap_slot_free_notify) {
+				swp_entry_t entry;
+				unsigned long offset;
+
+				entry.val = page_private(page);
+				offset = swp_offset(entry);
+
+				SetPageDirty(page);
+				disk->fops->swap_slot_free_notify(sis->bdev,
+						offset);
+			}
+		}
+	}
+
+out:
 	unlock_page(page);
 	bio_put(bio);
 }
diff -ur ./mm/shmem.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/shmem.c
--- ./mm/shmem.c	2023-04-26 12:56:08.890118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/shmem.c	2023-04-23 12:09:13.615756400 +0100
@@ -2950,6 +2950,14 @@
 }
 EXPORT_SYMBOL_GPL(shmem_file_setup);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+}
+
 /**
  * shmem_zero_setup - setup a shared anonymous mapping
  * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
@@ -2963,10 +2971,7 @@
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
+	shmem_set_file(vma, file);
 	return 0;
 }
 
diff -ur ./mm/vmscan.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/vmscan.c
--- ./mm/vmscan.c	2023-04-26 12:56:08.900118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm/vmscan.c	2023-04-23 12:09:14.025934400 +0100
@@ -43,6 +43,7 @@
 #include <linux/sysctl.h>
 #include <linux/oom.h>
 #include <linux/prefetch.h>
+#include <linux/debugfs.h>
 
 #include <asm/tlbflush.h>
 #include <asm/div64.h>
@@ -154,6 +155,40 @@
 	return zone_page_state(lruvec_zone(lruvec), NR_LRU_BASE + lru);
 }
 
+struct dentry *debug_file;
+
+static int debug_shrinker_show(struct seq_file *s, void *unused)
+{
+	struct shrinker *shrinker;
+	struct shrink_control sc;
+
+	sc.gfp_mask = -1;
+	sc.nr_to_scan = 0;
+
+	down_read(&shrinker_rwsem);
+	list_for_each_entry(shrinker, &shrinker_list, list) {
+		char name[64];
+		int num_objs;
+
+		num_objs = shrinker->shrink(shrinker, &sc);
+		seq_printf(s, "%pf %d\n", shrinker->shrink, num_objs);
+	}
+	up_read(&shrinker_rwsem);
+	return 0;
+}
+
+static int debug_shrinker_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, debug_shrinker_show, inode->i_private);
+}
+
+static const struct file_operations debug_shrinker_fops = {
+        .open = debug_shrinker_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release,
+};
+
 /*
  * Add a shrinker callback to be called from the vm
  */
@@ -166,6 +201,15 @@
 }
 EXPORT_SYMBOL(register_shrinker);
 
+static int __init add_shrinker_debug(void)
+{
+	debugfs_create_file("shrinker", 0644, NULL, NULL,
+			    &debug_shrinker_fops);
+	return 0;
+}
+
+late_initcall(add_shrinker_debug);
+
 /*
  * Remove one
  */
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/mm: zsmalloc.c
diff -ur ./net/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/Kconfig
--- ./net/Kconfig	2023-04-26 12:56:08.910118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/Kconfig	2023-04-23 12:09:15.299368700 +0100
@@ -81,6 +81,20 @@
 
 endif # if INET
 
+config ANDROID_PARANOID_NETWORK
+	bool "Only allow certain groups to create sockets"
+	default y
+	help
+		none
+
+config NET_ACTIVITY_STATS
+	bool "Network activity statistics tracking"
+	default y
+	help
+	 Network activity statistics are useful for tracking wireless
+	 modem activity on 2G, 3G, 4G wireless networks. Counts number of
+	 transmissions and groups them in specified time buckets.
+
 config NETWORK_SECMARK
 	bool "Security Marking"
 	help
@@ -220,7 +234,7 @@
 source "net/netlink/Kconfig"
 
 config RPS
-	boolean
+	boolean "RPS"
 	depends on SMP && SYSFS && USE_GENERIC_SMP_HELPERS
 	default y
 
diff -ur ./net/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/Makefile
--- ./net/Makefile	2023-04-26 12:56:08.910118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/Makefile	2023-04-23 12:09:15.298887400 +0100
@@ -70,3 +70,4 @@
 obj-$(CONFIG_NFC)		+= nfc/
 obj-$(CONFIG_OPENVSWITCH)	+= openvswitch/
 obj-$(CONFIG_VSOCKETS)	+= vmw_vsock/
+obj-$(CONFIG_NET_ACTIVITY_STATS)		+= activity_stats.o
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net: activity_stats.c
diff -ur ./net/bluetooth/af_bluetooth.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/af_bluetooth.c
--- ./net/bluetooth/af_bluetooth.c	2023-04-26 12:26:26.850130887 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/af_bluetooth.c	2023-04-23 12:09:17.457599100 +0100
@@ -30,6 +30,11 @@
 #include <net/bluetooth/bluetooth.h>
 #include <linux/proc_fs.h>
 
+#ifndef CONFIG_BT_SOCK_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
 #define VERSION "2.16"
 
 /* Bluetooth sockets */
@@ -103,11 +108,40 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
+#ifdef CONFIG_PARANOID_NETWORK
+static inline int current_has_bt_admin(void)
+{
+	return !current_euid();
+}
+
+static inline int current_has_bt(void)
+{
+	return current_has_bt_admin();
+}
+# else
+static inline int current_has_bt_admin(void)
+{
+	return 1;
+}
+
+static inline int current_has_bt(void)
+{
+	return 1;
+}
+#endif
+
 static int bt_sock_create(struct net *net, struct socket *sock, int proto,
 			  int kern)
 {
 	int err;
 
+	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
+			proto == BTPROTO_L2CAP) {
+		if (!current_has_bt())
+			return -EPERM;
+	} else if (!current_has_bt_admin())
+		return -EPERM;
+
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
diff -ur ./net/bluetooth/amp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/amp.c
--- ./net/bluetooth/amp.c	2023-04-26 12:26:26.850130887 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/amp.c	2023-04-23 12:09:17.456722800 +0100
@@ -113,7 +113,7 @@
 	bdaddr_t *dst = mgr->l2cap_conn->dst;
 	struct hci_conn *hcon;
 
-	hcon = hci_conn_add(hdev, AMP_LINK, dst);
+	hcon = hci_conn_add(hdev, AMP_LINK, 0, dst);
 	if (!hcon)
 		return NULL;
 
diff -ur ./net/bluetooth/hci_conn.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/hci_conn.c
--- ./net/bluetooth/hci_conn.c	2023-04-26 12:26:26.860130882 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/hci_conn.c	2023-04-23 12:09:17.775401500 +0100
@@ -354,7 +354,8 @@
 		     &conn->dst);
 }
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
 
@@ -382,14 +383,22 @@
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
 		break;
 	case SCO_LINK:
-		if (lmp_esco_capable(hdev))
-			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
-					(hdev->esco_type & EDR_ESCO_MASK);
-		else
-			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
-		break;
+		if (!pkt_type)
+			pkt_type = SCO_ESCO_MASK;
 	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
+		if (!pkt_type)
+			pkt_type = ALL_ESCO_MASK;
+		if (lmp_esco_capable(hdev)) {
+			/* HCI Setup Synchronous Connection Command uses
+			   reverse logic on the EDR_ESCO_MASK bits */
+			conn->pkt_type = (pkt_type ^ EDR_ESCO_MASK) &
+					hdev->esco_type;
+		} else {
+			/* Legacy HCI Add Sco Connection Command uses a
+			   shifted bitmask */
+			conn->pkt_type = (pkt_type << 5) & hdev->pkt_type &
+					SCO_PTYPE_MASK;
+		}
 		break;
 	}
 
@@ -520,7 +529,7 @@
 		if (le)
 			return ERR_PTR(-EBUSY);
 
-		le = hci_conn_add(hdev, LE_LINK, dst);
+		le = hci_conn_add(hdev, LE_LINK, 0, dst);
 		if (!le)
 			return ERR_PTR(-ENOMEM);
 
@@ -543,7 +552,7 @@
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
-		acl = hci_conn_add(hdev, ACL_LINK, dst);
+		acl = hci_conn_add(hdev, ACL_LINK, 0, dst);
 		if (!acl)
 			return ERR_PTR(-ENOMEM);
 	}
@@ -561,7 +570,8 @@
 }
 
 static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
-				bdaddr_t *dst, u8 sec_level, u8 auth_type)
+					__u16 pkt_type, bdaddr_t *dst,
+					u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -572,7 +582,7 @@
 
 	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
 	if (!sco) {
-		sco = hci_conn_add(hdev, type, dst);
+		sco = hci_conn_add(hdev, type, pkt_type, dst);
 		if (!sco) {
 			hci_conn_drop(acl);
 			return ERR_PTR(-ENOMEM);
@@ -602,7 +612,8 @@
 }
 
 /* Create SCO, ACL or LE connection. */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+			     __u16 pkt_type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("%s dst %pMR type 0x%x", hdev->name, dst, type);
@@ -614,7 +625,7 @@
 		return hci_connect_acl(hdev, dst, sec_level, auth_type);
 	case SCO_LINK:
 	case ESCO_LINK:
-		return hci_connect_sco(hdev, type, dst, sec_level, auth_type);
+		return hci_connect_sco(hdev, type, pkt_type, dst, sec_level, auth_type);
 	}
 
 	return ERR_PTR(-EINVAL);
@@ -880,6 +891,15 @@
 		(ci + n)->out   = c->out;
 		(ci + n)->state = c->state;
 		(ci + n)->link_mode = c->link_mode;
+		if (c->type == SCO_LINK) {
+			(ci + n)->mtu = hdev->sco_mtu;
+			(ci + n)->cnt = hdev->sco_cnt;
+			(ci + n)->pkts = hdev->sco_pkts;
+		} else {
+			(ci + n)->mtu = hdev->acl_mtu;
+			(ci + n)->cnt = hdev->acl_cnt;
+			(ci + n)->pkts = hdev->acl_pkts;
+		}
 		if (++n >= req.conn_num)
 			break;
 	}
@@ -916,6 +936,15 @@
 		ci.out   = conn->out;
 		ci.state = conn->state;
 		ci.link_mode = conn->link_mode;
+		if (req.type == SCO_LINK) {
+			ci.mtu = hdev->sco_mtu;
+			ci.cnt = hdev->sco_cnt;
+			ci.pkts = hdev->sco_pkts;
+		} else {
+			ci.mtu = hdev->acl_mtu;
+			ci.cnt = hdev->acl_cnt;
+			ci.pkts = hdev->acl_pkts;
+		}
 	}
 	hci_dev_unlock(hdev);
 
diff -ur ./net/bluetooth/hci_event.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/hci_event.c
--- ./net/bluetooth/hci_event.c	2023-04-26 12:56:08.930118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/hci_event.c	2023-04-23 12:09:17.856598200 +0100
@@ -1119,7 +1119,7 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr);
+			conn = hci_conn_add(hdev, ACL_LINK, 0, &cp->bdaddr);
 			if (conn) {
 				conn->out = true;
 				conn->link_mode |= HCI_LM_MASTER;
@@ -1748,6 +1748,15 @@
 	hci_conn_check_pending(hdev);
 }
 
+static inline bool is_sco_active(struct hci_dev *hdev)
+{
+	if (hci_conn_hash_lookup_state(hdev, SCO_LINK, BT_CONNECTED) ||
+			(hci_conn_hash_lookup_state(hdev, ESCO_LINK,
+						    BT_CONNECTED)))
+		return true;
+	return false;
+}
+
 static void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_conn_request *ev = (void *) skb->data;
@@ -1775,7 +1784,8 @@
 		conn = hci_conn_hash_lookup_ba(hdev, ev->link_type,
 					       &ev->bdaddr);
 		if (!conn) {
-			conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr);
+			/* pkt_type not yet used for incoming connections */
+			conn = hci_conn_add(hdev, ev->link_type, 0, &ev->bdaddr);
 			if (!conn) {
 				BT_ERR("No memory for new connection");
 				hci_dev_unlock(hdev);
@@ -1794,7 +1804,8 @@
 
 			bacpy(&cp.bdaddr, &ev->bdaddr);
 
-			if (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))
+			if (lmp_rswitch_capable(hdev) && ((mask & HCI_LM_MASTER)
+						|| is_sco_active(hdev)))
 				cp.role = 0x00; /* Become master */
 			else
 				cp.role = 0x01; /* Remain slave */
@@ -2963,6 +2974,7 @@
 		hci_conn_add_sysfs(conn);
 		break;
 
+	case 0x10:	/* Connection Accept Timeout */
 	case 0x11:	/* Unsupported Feature or Parameter Value */
 	case 0x1c:	/* SCO interval rejected */
 	case 0x1a:	/* Unsupported Remote Feature */
@@ -3531,7 +3543,7 @@
 
 	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
 	if (!conn) {
-		conn = hci_conn_add(hdev, LE_LINK, &ev->bdaddr);
+		conn = hci_conn_add(hdev, LE_LINK, 0, &ev->bdaddr);
 		if (!conn) {
 			BT_ERR("No memory for new connection");
 			goto unlock;
diff -ur ./net/bluetooth/l2cap_core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/l2cap_core.c
--- ./net/bluetooth/l2cap_core.c	2023-04-26 12:56:08.930118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/l2cap_core.c	2023-04-23 12:09:18.098526100 +0100
@@ -1793,10 +1793,10 @@
 	auth_type = l2cap_get_auth_type(chan);
 
 	if (chan->dcid == L2CAP_CID_LE_DATA)
-		hcon = hci_connect(hdev, LE_LINK, dst, dst_type,
+		hcon = hci_connect(hdev, LE_LINK, 0, dst, dst_type,
 				   chan->sec_level, auth_type);
 	else
-		hcon = hci_connect(hdev, ACL_LINK, dst, dst_type,
+		hcon = hci_connect(hdev, ACL_LINK, 0, dst, dst_type,
 				   chan->sec_level, auth_type);
 
 	if (IS_ERR(hcon)) {
diff -ur ./net/bluetooth/mgmt.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/mgmt.c
--- ./net/bluetooth/mgmt.c	2023-04-26 12:56:08.930118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/mgmt.c	2023-04-23 12:09:18.189062200 +0100
@@ -2205,10 +2205,10 @@
 		auth_type = HCI_AT_DEDICATED_BONDING_MITM;
 
 	if (cp->addr.type == BDADDR_BREDR)
-		conn = hci_connect(hdev, ACL_LINK, &cp->addr.bdaddr,
+		conn = hci_connect(hdev, ACL_LINK, 0, &cp->addr.bdaddr,
 				   cp->addr.type, sec_level, auth_type);
 	else
-		conn = hci_connect(hdev, LE_LINK, &cp->addr.bdaddr,
+		conn = hci_connect(hdev, LE_LINK, 0, &cp->addr.bdaddr,
 				   cp->addr.type, sec_level, auth_type);
 
 	if (IS_ERR(conn)) {
diff -ur ./net/bluetooth/rfcomm/core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/rfcomm/core.c
--- ./net/bluetooth/rfcomm/core.c	2023-04-26 12:26:26.890130868 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/rfcomm/core.c	2023-04-23 12:09:18.268663900 +0100
@@ -436,7 +436,6 @@
 
 	switch (d->state) {
 	case BT_CONNECT:
-	case BT_CONFIG:
 		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
 			rfcomm_schedule();
diff -ur ./net/bluetooth/sco.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/sco.c
--- ./net/bluetooth/sco.c	2023-04-26 12:26:26.900130863 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bluetooth/sco.c	2023-04-23 12:09:18.340180300 +0100
@@ -158,6 +158,7 @@
 {
 	bdaddr_t *src = &bt_sk(sk)->src;
 	bdaddr_t *dst = &bt_sk(sk)->dst;
+	__u16 pkt_type = sco_pi(sk)->pkt_type;
 	struct sco_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev  *hdev;
@@ -173,11 +174,13 @@
 
 	if (lmp_esco_capable(hdev) && !disable_esco)
 		type = ESCO_LINK;
-	else
+	else {
 		type = SCO_LINK;
+		pkt_type &= SCO_ESCO_MASK;
+	}
 
-	hcon = hci_connect(hdev, type, dst, BDADDR_BREDR, BT_SECURITY_LOW,
-			   HCI_AT_NO_BONDING);
+	hcon = hci_connect(hdev, type, pkt_type, dst, BDADDR_BREDR,
+			   BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (IS_ERR(hcon)) {
 		err = PTR_ERR(hcon);
 		goto done;
@@ -445,17 +448,21 @@
 	return 0;
 }
 
-static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
+static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
-	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
+	struct sockaddr_sco sa;
 	struct sock *sk = sock->sk;
-	int err = 0;
+	int len, err = 0;
 
-	BT_DBG("sk %p %pMR", sk, &sa->sco_bdaddr);
+	BT_DBG("sk %p %pMR", sk, &sa.sco_bdaddr);
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
+	memset(&sa, 0, sizeof(sa));
+	len = min_t(unsigned int, sizeof(sa), alen);
+	memcpy(&sa, addr, len);
+
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -468,7 +475,8 @@
 		goto done;
 	}
 
-	bacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);
+	bacpy(&bt_sk(sk)->src, &sa.sco_bdaddr);
+	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
 
 	sk->sk_state = BT_BOUND;
 
@@ -479,26 +487,34 @@
 
 static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
-	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	int err;
+	struct sockaddr_sco sa;
+	int len, err;
 
 	BT_DBG("sk %p", sk);
 
-	if (alen < sizeof(struct sockaddr_sco) ||
-	    addr->sa_family != AF_BLUETOOTH)
+	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)
-		return -EBADFD;
-
-	if (sk->sk_type != SOCK_SEQPACKET)
-		return -EINVAL;
+	memset(&sa, 0, sizeof(sa));
+	len = min_t(unsigned int, sizeof(sa), alen);
+	memcpy(&sa, addr, len);
 
 	lock_sock(sk);
 
+	if (sk->sk_type != SOCK_SEQPACKET) {
+		err = -EINVAL;
+		goto done;
+	}
+
+	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {
+		err = -EBADFD;
+		goto done;
+	}
+
 	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);
+	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
+	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
 
 	err = sco_connect(sk);
 	if (err)
@@ -622,6 +638,7 @@
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);
 	else
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);
+	sa->sco_pkt_type = sco_pi(sk)->pkt_type;
 
 	return 0;
 }
diff -ur ./net/bridge/br_device.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bridge/br_device.c
--- ./net/bridge/br_device.c	2023-04-26 12:56:08.930118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/bridge/br_device.c	2023-04-23 12:09:18.507517500 +0100
@@ -41,11 +41,6 @@
 	}
 #endif
 
-	u64_stats_update_begin(&brstats->syncp);
-	brstats->tx_packets++;
-	brstats->tx_bytes += skb->len;
-	u64_stats_update_end(&brstats->syncp);
-
 	if (!br_allowed_ingress(br, br_get_vlan_info(br), skb, &vid))
 		goto out;
 
@@ -54,6 +49,12 @@
 	skb_reset_mac_header(skb);
 	skb_pull(skb, ETH_HLEN);
 
+	u64_stats_update_begin(&brstats->syncp);
+	brstats->tx_packets++;
+	/* Exclude ETH_HLEN from byte stats for consistency with Rx chain */
+	brstats->tx_bytes += skb->len;
+	u64_stats_update_end(&brstats->syncp);
+
 	if (is_broadcast_ether_addr(dest))
 		br_flood_deliver(br, skb);
 	else if (is_multicast_ether_addr(dest)) {
diff -ur ./net/ipv4/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/Makefile
--- ./net/ipv4/Makefile	2023-04-26 12:56:08.970118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/Makefile	2023-04-23 12:09:23.136995200 +0100
@@ -15,6 +15,7 @@
 
 obj-$(CONFIG_NET_IP_TUNNEL) += ip_tunnel.o
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
+obj-$(CONFIG_SYSFS) += sysfs_net_ipv4.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
diff -ur ./net/ipv4/af_inet.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/af_inet.c
--- ./net/ipv4/af_inet.c	2023-04-26 12:56:08.970118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/af_inet.c	2023-04-23 12:09:23.217704700 +0100
@@ -119,6 +119,19 @@
 #include <linux/mroute.h>
 #endif
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
 
 /* The inetsw table contains everything that inet_create needs to
  * build a new socket.
@@ -286,6 +299,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (unlikely(!inet_ehash_secret))
 		if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 			build_ehash_secret();
@@ -338,8 +354,7 @@
 	}
 
 	err = -EPERM;
-	if (sock->type == SOCK_RAW && !kern &&
-	    !ns_capable(net->user_ns, CAP_NET_RAW))
+	if (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))
 		goto out_rcu_unlock;
 
 	sock->ops = answer->ops;
@@ -907,6 +922,7 @@
 	case SIOCSIFPFLAGS:
 	case SIOCGIFPFLAGS:
 	case SIOCSIFFLAGS:
+	case SIOCKILLADDR:
 		err = devinet_ioctl(net, cmd, (void __user *)arg);
 		break;
 	default:
diff -ur ./net/ipv4/devinet.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/devinet.c
--- ./net/ipv4/devinet.c	2023-04-26 12:56:08.970118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/devinet.c	2023-04-23 12:09:23.297302200 +0100
@@ -59,6 +59,7 @@
 
 #include <net/arp.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <net/route.h>
 #include <net/ip_fib.h>
 #include <net/rtnetlink.h>
@@ -918,6 +919,7 @@
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
 	case SIOCSIFDSTADDR:	/* Set the destination address */
 	case SIOCSIFNETMASK: 	/* Set the netmask for the interface */
+	case SIOCKILLADDR:	/* Nuke all sockets on this address */
 		ret = -EPERM;
 		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
 			goto out;
@@ -969,7 +971,8 @@
 	}
 
 	ret = -EADDRNOTAVAIL;
-	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
+	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS
+	    && cmd != SIOCKILLADDR)
 		goto done;
 
 	switch (cmd) {
@@ -1096,6 +1099,9 @@
 			inet_insert_ifa(ifa);
 		}
 		break;
+	case SIOCKILLADDR:	/* Nuke all connections on this address */
+		ret = tcp_nuke_addr(net, (struct sockaddr *) sin);
+		break;
 	}
 done:
 	rtnl_unlock();
diff -ur ./net/ipv4/icmp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/icmp.c
--- ./net/ipv4/icmp.c	2023-04-26 12:56:08.970118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/icmp.c	2023-04-23 12:09:23.460975200 +0100
@@ -939,7 +939,8 @@
 void icmp_err(struct sk_buff *skb, u32 info)
 {
 	struct iphdr *iph = (struct iphdr *)skb->data;
-	struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));
+	int offset = iph->ihl<<2;
+	struct icmphdr *icmph = (struct icmphdr *)(skb->data + offset);
 	int type = icmp_hdr(skb)->type;
 	int code = icmp_hdr(skb)->code;
 	struct net *net = dev_net(skb->dev);
@@ -949,7 +950,7 @@
 	 * triggered by ICMP_ECHOREPLY which sent from kernel.
 	 */
 	if (icmph->type != ICMP_ECHOREPLY) {
-		ping_err(skb, info);
+		ping_err(skb, offset, info);
 		return;
 	}
 
diff -ur ./net/ipv4/netfilter/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/netfilter/Kconfig
--- ./net/ipv4/netfilter/Kconfig	2023-04-26 12:56:08.980118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/netfilter/Kconfig	2023-04-23 12:09:24.018777500 +0100
@@ -110,6 +110,18 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_REJECT_SKERR
+	bool "Force socket error when rejecting with icmp*"
+	depends on IP_NF_TARGET_REJECT
+	default n
+	help
+          This option enables turning a "--reject-with icmp*" into a matching
+          socket error also.
+	  The REJECT target normally allows sending an ICMP message. But it
+          leaves the local socket unaware of any ingress rejects.
+
+	  If unsure, say N.
+
 config IP_NF_TARGET_ULOG
 	tristate "ULOG target support"
 	default m if NETFILTER_ADVANCED=n
diff -ur ./net/ipv4/netfilter/ipt_REJECT.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/netfilter/ipt_REJECT.c
--- ./net/ipv4/netfilter/ipt_REJECT.c	2023-04-26 12:26:27.130130751 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/netfilter/ipt_REJECT.c	2023-04-23 12:09:24.097076600 +0100
@@ -129,6 +129,14 @@
 static inline void send_unreach(struct sk_buff *skb_in, int code)
 {
 	icmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);
+#ifdef CONFIG_IP_NF_TARGET_REJECT_SKERR
+	if (skb_in->sk) {
+		skb_in->sk->sk_err = icmp_err_convert[code].errno;
+		skb_in->sk->sk_error_report(skb_in->sk);
+		pr_debug("ipt_REJECT: sk_err=%d for skb=%p sk=%p\n",
+			skb_in->sk->sk_err, skb_in, skb_in->sk);
+	}
+#endif
 }
 
 static unsigned int
diff -ur ./net/ipv4/ping.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/ping.c
--- ./net/ipv4/ping.c	2023-04-26 12:56:08.980118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/ping.c	2023-04-23 12:09:24.416040600 +0100
@@ -33,7 +33,6 @@
 #include <linux/netdevice.h>
 #include <net/snmp.h>
 #include <net/ip.h>
-#include <net/ipv6.h>
 #include <net/icmp.h>
 #include <net/protocol.h>
 #include <linux/skbuff.h>
@@ -46,8 +45,18 @@
 #include <net/inet_common.h>
 #include <net/checksum.h>
 
+#if IS_ENABLED(CONFIG_IPV6)
+#include <linux/in6.h>
+#include <linux/icmpv6.h>
+#include <net/addrconf.h>
+#include <net/ipv6.h>
+#include <net/transp_v6.h>
+#endif
+
 
-static struct ping_table ping_table;
+struct ping_table ping_table;
+struct pingv6_ops pingv6_ops;
+EXPORT_SYMBOL_GPL(pingv6_ops);
 
 static u16 ping_port_rover;
 
@@ -58,6 +67,7 @@
 	pr_debug("hash(%d) = %d\n", num, res);
 	return res;
 }
+EXPORT_SYMBOL_GPL(ping_hash);
 
 static inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,
 					     struct net *net, unsigned int num)
@@ -65,7 +75,7 @@
 	return &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];
 }
 
-static int ping_v4_get_port(struct sock *sk, unsigned short ident)
+int ping_get_port(struct sock *sk, unsigned short ident)
 {
 	struct hlist_nulls_node *node;
 	struct hlist_nulls_head *hlist;
@@ -103,6 +113,10 @@
 		ping_portaddr_for_each_entry(sk2, node, hlist) {
 			isk2 = inet_sk(sk2);
 
+			/* BUG? Why is this reuse and not reuseaddr? ping.c
+			 * doesn't turn off SO_REUSEADDR, and it doesn't expect
+			 * that other ping processes can steal its packets.
+			 */
 			if ((isk2->inet_num == ident) &&
 			    (sk2 != sk) &&
 			    (!sk2->sk_reuse || !sk->sk_reuse))
@@ -125,17 +139,18 @@
 	write_unlock_bh(&ping_table.lock);
 	return 1;
 }
+EXPORT_SYMBOL_GPL(ping_get_port);
 
-static void ping_v4_hash(struct sock *sk)
+void ping_hash(struct sock *sk)
 {
-	pr_debug("ping_v4_hash(sk->port=%u)\n", inet_sk(sk)->inet_num);
+	pr_debug("ping_hash(sk->port=%u)\n", inet_sk(sk)->inet_num);
 	BUG(); /* "Please do not press this button again." */
 }
 
-static void ping_v4_unhash(struct sock *sk)
+void ping_unhash(struct sock *sk)
 {
 	struct inet_sock *isk = inet_sk(sk);
-	pr_debug("ping_v4_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num);
+	pr_debug("ping_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num);
 	if (sk_hashed(sk)) {
 		write_lock_bh(&ping_table.lock);
 		hlist_nulls_del(&sk->sk_nulls_node);
@@ -146,31 +161,61 @@
 		write_unlock_bh(&ping_table.lock);
 	}
 }
+EXPORT_SYMBOL_GPL(ping_unhash);
 
-static struct sock *ping_v4_lookup(struct net *net, __be32 saddr, __be32 daddr,
-				   u16 ident, int dif)
+static struct sock *ping_lookup(struct net *net, struct sk_buff *skb, u16 ident)
 {
 	struct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);
 	struct sock *sk = NULL;
 	struct inet_sock *isk;
 	struct hlist_nulls_node *hnode;
+	int dif = skb->dev->ifindex;
+
+	if (skb->protocol == htons(ETH_P_IP)) {
+		pr_debug("try to find: num = %d, daddr = %pI4, dif = %d\n",
+			 (int)ident, &ip_hdr(skb)->daddr, dif);
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
+		pr_debug("try to find: num = %d, daddr = %pI6c, dif = %d\n",
+			 (int)ident, &ipv6_hdr(skb)->daddr, dif);
+#endif
+	}
 
-	pr_debug("try to find: num = %d, daddr = %pI4, dif = %d\n",
-		 (int)ident, &daddr, dif);
 	read_lock_bh(&ping_table.lock);
 
 	ping_portaddr_for_each_entry(sk, hnode, hslot) {
 		isk = inet_sk(sk);
 
-		pr_debug("found: %p: num = %d, daddr = %pI4, dif = %d\n", sk,
-			 (int)isk->inet_num, &isk->inet_rcv_saddr,
-			 sk->sk_bound_dev_if);
-
 		pr_debug("iterate\n");
 		if (isk->inet_num != ident)
 			continue;
-		if (isk->inet_rcv_saddr && isk->inet_rcv_saddr != daddr)
-			continue;
+
+		if (skb->protocol == htons(ETH_P_IP) &&
+		    sk->sk_family == AF_INET) {
+			pr_debug("found: %p: num=%d, daddr=%pI4, dif=%d\n", sk,
+				 (int) isk->inet_num, &isk->inet_rcv_saddr,
+				 sk->sk_bound_dev_if);
+
+			if (isk->inet_rcv_saddr &&
+			    isk->inet_rcv_saddr != ip_hdr(skb)->daddr)
+				continue;
+#if IS_ENABLED(CONFIG_IPV6)
+		} else if (skb->protocol == htons(ETH_P_IPV6) &&
+			   sk->sk_family == AF_INET6) {
+			struct ipv6_pinfo *np = inet6_sk(sk);
+
+			pr_debug("found: %p: num=%d, daddr=%pI6c, dif=%d\n", sk,
+				 (int) isk->inet_num,
+				 &inet6_sk(sk)->rcv_saddr,
+				 sk->sk_bound_dev_if);
+
+			if (!ipv6_addr_any(&np->rcv_saddr) &&
+			    !ipv6_addr_equal(&np->rcv_saddr,
+					     &ipv6_hdr(skb)->daddr))
+				continue;
+#endif
+		}
+
 		if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)
 			continue;
 
@@ -200,7 +245,7 @@
 }
 
 
-static int ping_init_sock(struct sock *sk)
+int ping_init_sock(struct sock *sk)
 {
 	struct net *net = sock_net(sk);
 	kgid_t group = current_egid();
@@ -225,8 +270,9 @@
 
 	return -EACCES;
 }
+EXPORT_SYMBOL_GPL(ping_init_sock);
 
-static void ping_close(struct sock *sk, long timeout)
+void ping_close(struct sock *sk, long timeout)
 {
 	pr_debug("ping_close(sk=%p,sk->num=%u)\n",
 		 inet_sk(sk), inet_sk(sk)->inet_num);
@@ -234,36 +280,122 @@
 
 	sk_common_release(sk);
 }
+EXPORT_SYMBOL_GPL(ping_close);
+
+/* Checks the bind address and possibly modifies sk->sk_bound_dev_if. */
+int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,
+			 struct sockaddr *uaddr, int addr_len) {
+	struct net *net = sock_net(sk);
+	if (sk->sk_family == AF_INET) {
+		struct sockaddr_in *addr = (struct sockaddr_in *) uaddr;
+		int chk_addr_ret;
+
+		if (addr_len < sizeof(*addr))
+			return -EINVAL;
+
+		pr_debug("ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\n",
+			 sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));
+
+		chk_addr_ret = inet_addr_type(net, addr->sin_addr.s_addr);
+
+		if (addr->sin_addr.s_addr == htonl(INADDR_ANY))
+			chk_addr_ret = RTN_LOCAL;
+
+		if ((sysctl_ip_nonlocal_bind == 0 &&
+		    isk->freebind == 0 && isk->transparent == 0 &&
+		     chk_addr_ret != RTN_LOCAL) ||
+		    chk_addr_ret == RTN_MULTICAST ||
+		    chk_addr_ret == RTN_BROADCAST)
+			return -EADDRNOTAVAIL;
+
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (sk->sk_family == AF_INET6) {
+		struct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;
+		int addr_type, scoped, has_addr;
+		struct net_device *dev = NULL;
+
+		if (addr_len < sizeof(*addr))
+			return -EINVAL;
+
+		pr_debug("ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\n",
+			 sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));
+
+		addr_type = ipv6_addr_type(&addr->sin6_addr);
+		scoped = __ipv6_addr_needs_scope_id(addr_type);
+		if ((addr_type != IPV6_ADDR_ANY &&
+		     !(addr_type & IPV6_ADDR_UNICAST)) ||
+		    (scoped && !addr->sin6_scope_id))
+			return -EINVAL;
+
+		rcu_read_lock();
+		if (addr->sin6_scope_id) {
+			dev = dev_get_by_index_rcu(net, addr->sin6_scope_id);
+			if (!dev) {
+				rcu_read_unlock();
+				return -ENODEV;
+			}
+		}
+		has_addr = pingv6_ops.ipv6_chk_addr(net, &addr->sin6_addr, dev,
+						    scoped);
+		rcu_read_unlock();
+
+		if (!(isk->freebind || isk->transparent || has_addr ||
+		      addr_type == IPV6_ADDR_ANY))
+			return -EADDRNOTAVAIL;
+
+		if (scoped)
+			sk->sk_bound_dev_if = addr->sin6_scope_id;
+#endif
+	} else {
+		return -EAFNOSUPPORT;
+	}
+	return 0;
+}
+
+void ping_set_saddr(struct sock *sk, struct sockaddr *saddr)
+{
+	if (saddr->sa_family == AF_INET) {
+		struct inet_sock *isk = inet_sk(sk);
+		struct sockaddr_in *addr = (struct sockaddr_in *) saddr;
+		isk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (saddr->sa_family == AF_INET6) {
+		struct sockaddr_in6 *addr = (struct sockaddr_in6 *) saddr;
+		struct ipv6_pinfo *np = inet6_sk(sk);
+		np->rcv_saddr = np->saddr = addr->sin6_addr;
+#endif
+	}
+}
 
+void ping_clear_saddr(struct sock *sk, int dif)
+{
+	sk->sk_bound_dev_if = dif;
+	if (sk->sk_family == AF_INET) {
+		struct inet_sock *isk = inet_sk(sk);
+		isk->inet_rcv_saddr = isk->inet_saddr = 0;
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (sk->sk_family == AF_INET6) {
+		struct ipv6_pinfo *np = inet6_sk(sk);
+		memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));
+		memset(&np->saddr, 0, sizeof(np->saddr));
+#endif
+	}
+}
 /*
  * We need our own bind because there are no privileged id's == local ports.
  * Moreover, we don't allow binding to multi- and broadcast addresses.
  */
 
-static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
-	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;
 	struct inet_sock *isk = inet_sk(sk);
 	unsigned short snum;
-	int chk_addr_ret;
 	int err;
+	int dif = sk->sk_bound_dev_if;
 
-	if (addr_len < sizeof(struct sockaddr_in))
-		return -EINVAL;
-
-	pr_debug("ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n",
-		 sk, addr->sin_addr.s_addr, ntohs(addr->sin_port));
-
-	chk_addr_ret = inet_addr_type(sock_net(sk), addr->sin_addr.s_addr);
-	if (addr->sin_addr.s_addr == htonl(INADDR_ANY))
-		chk_addr_ret = RTN_LOCAL;
-
-	if ((sysctl_ip_nonlocal_bind == 0 &&
-	    isk->freebind == 0 && isk->transparent == 0 &&
-	     chk_addr_ret != RTN_LOCAL) ||
-	    chk_addr_ret == RTN_MULTICAST ||
-	    chk_addr_ret == RTN_BROADCAST)
-		return -EADDRNOTAVAIL;
+	err = ping_check_bind_addr(sk, isk, uaddr, addr_len);
+	if (err)
+		return err;
 
 	lock_sock(sk);
 
@@ -272,42 +404,50 @@
 		goto out;
 
 	err = -EADDRINUSE;
-	isk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;
-	snum = ntohs(addr->sin_port);
-	if (ping_v4_get_port(sk, snum) != 0) {
-		isk->inet_saddr = isk->inet_rcv_saddr = 0;
+	ping_set_saddr(sk, uaddr);
+	snum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);
+	if (ping_get_port(sk, snum) != 0) {
+		ping_clear_saddr(sk, dif);
 		goto out;
 	}
 
-	pr_debug("after bind(): num = %d, daddr = %pI4, dif = %d\n",
+	pr_debug("after bind(): num = %d, dif = %d\n",
 		 (int)isk->inet_num,
-		 &isk->inet_rcv_saddr,
 		 (int)sk->sk_bound_dev_if);
 
 	err = 0;
-	if (isk->inet_rcv_saddr)
+	if ((sk->sk_family == AF_INET && isk->inet_rcv_saddr) ||
+	    (sk->sk_family == AF_INET6 &&
+	     !ipv6_addr_any(&inet6_sk(sk)->rcv_saddr)))
 		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+
 	if (snum)
 		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
 	isk->inet_sport = htons(isk->inet_num);
 	isk->inet_daddr = 0;
 	isk->inet_dport = 0;
+
+#if IS_ENABLED(CONFIG_IPV6)
+	if (sk->sk_family == AF_INET6)
+		memset(&inet6_sk(sk)->daddr, 0, sizeof(inet6_sk(sk)->daddr));
+#endif
+
 	sk_dst_reset(sk);
 out:
 	release_sock(sk);
 	pr_debug("ping_v4_bind -> %d\n", err);
 	return err;
 }
+EXPORT_SYMBOL_GPL(ping_bind);
 
 /*
  * Is this a supported type of ICMP message?
  */
 
-static inline int ping_supported(int type, int code)
+static inline int ping_supported(int family, int type, int code)
 {
-	if (type == ICMP_ECHO && code == 0)
-		return 1;
-	return 0;
+	return (family == AF_INET && type == ICMP_ECHO && code == 0) ||
+	       (family == AF_INET6 && type == ICMPV6_ECHO_REQUEST && code == 0);
 }
 
 /*
@@ -315,30 +455,42 @@
  * sort of error condition.
  */
 
-static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
-
-void ping_err(struct sk_buff *skb, u32 info)
+void ping_err(struct sk_buff *skb, int offset, u32 info)
 {
-	struct iphdr *iph = (struct iphdr *)skb->data;
-	struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));
+	int family;
+	struct icmphdr *icmph;
 	struct inet_sock *inet_sock;
-	int type = icmp_hdr(skb)->type;
-	int code = icmp_hdr(skb)->code;
+	int type;
+	int code;
 	struct net *net = dev_net(skb->dev);
 	struct sock *sk;
 	int harderr;
 	int err;
 
+	if (skb->protocol == htons(ETH_P_IP)) {
+		family = AF_INET;
+		type = icmp_hdr(skb)->type;
+		code = icmp_hdr(skb)->code;
+		icmph = (struct icmphdr *)(skb->data + offset);
+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
+		family = AF_INET6;
+		type = icmp6_hdr(skb)->icmp6_type;
+		code = icmp6_hdr(skb)->icmp6_code;
+		icmph = (struct icmphdr *) (skb->data + offset);
+	} else {
+		BUG();
+	}
+
 	/* We assume the packet has already been checked by icmp_unreach */
 
-	if (!ping_supported(icmph->type, icmph->code))
+	if (!ping_supported(family, icmph->type, icmph->code))
 		return;
 
-	pr_debug("ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\n", type,
-		 code, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+	pr_debug("ping_err(proto=0x%x,type=%d,code=%d,id=%04x,seq=%04x)\n",
+		 skb->protocol, type, code, ntohs(icmph->un.echo.id),
+		 ntohs(icmph->un.echo.sequence));
 
-	sk = ping_v4_lookup(net, iph->daddr, iph->saddr,
-			    ntohs(icmph->un.echo.id), skb->dev->ifindex);
+	sk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));
 	if (sk == NULL) {
 		pr_debug("no socket, dropping\n");
 		return;	/* No socket for error */
@@ -349,72 +501,83 @@
 	harderr = 0;
 	inet_sock = inet_sk(sk);
 
-	switch (type) {
-	default:
-	case ICMP_TIME_EXCEEDED:
-		err = EHOSTUNREACH;
-		break;
-	case ICMP_SOURCE_QUENCH:
-		/* This is not a real error but ping wants to see it.
-		 * Report it with some fake errno. */
-		err = EREMOTEIO;
-		break;
-	case ICMP_PARAMETERPROB:
-		err = EPROTO;
-		harderr = 1;
-		break;
-	case ICMP_DEST_UNREACH:
-		if (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */
-			ipv4_sk_update_pmtu(skb, sk, info);
-			if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {
-				err = EMSGSIZE;
-				harderr = 1;
-				break;
+	if (skb->protocol == htons(ETH_P_IP)) {
+		switch (type) {
+		default:
+		case ICMP_TIME_EXCEEDED:
+			err = EHOSTUNREACH;
+			break;
+		case ICMP_SOURCE_QUENCH:
+			/* This is not a real error but ping wants to see it.
+			 * Report it with some fake errno.
+			 */
+			err = EREMOTEIO;
+			break;
+		case ICMP_PARAMETERPROB:
+			err = EPROTO;
+			harderr = 1;
+			break;
+		case ICMP_DEST_UNREACH:
+			if (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */
+				ipv4_sk_update_pmtu(skb, sk, info);
+				if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {
+					err = EMSGSIZE;
+					harderr = 1;
+					break;
+				}
+				goto out;
 			}
-			goto out;
+			err = EHOSTUNREACH;
+			if (code <= NR_ICMP_UNREACH) {
+				harderr = icmp_err_convert[code].fatal;
+				err = icmp_err_convert[code].errno;
+			}
+			break;
+		case ICMP_REDIRECT:
+			/* See ICMP_SOURCE_QUENCH */
+			ipv4_sk_redirect(skb, sk);
+			err = EREMOTEIO;
+			break;
 		}
-		err = EHOSTUNREACH;
-		if (code <= NR_ICMP_UNREACH) {
-			harderr = icmp_err_convert[code].fatal;
-			err = icmp_err_convert[code].errno;
-		}
-		break;
-	case ICMP_REDIRECT:
-		/* See ICMP_SOURCE_QUENCH */
-		ipv4_sk_redirect(skb, sk);
-		err = EREMOTEIO;
-		break;
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
+		harderr = pingv6_ops.icmpv6_err_convert(type, code, &err);
+#endif
 	}
 
 	/*
 	 *      RFC1122: OK.  Passes ICMP errors back to application, as per
 	 *	4.1.3.3.
 	 */
-	if (!inet_sock->recverr) {
+	if ((family == AF_INET && !inet_sock->recverr) ||
+	    (family == AF_INET6 && !inet6_sk(sk)->recverr)) {
 		if (!harderr || sk->sk_state != TCP_ESTABLISHED)
 			goto out;
 	} else {
-		ip_icmp_error(sk, skb, err, 0 /* no remote port */,
-			 info, (u8 *)icmph);
+		if (family == AF_INET) {
+			ip_icmp_error(sk, skb, err, 0 /* no remote port */,
+				      info, (u8 *)icmph);
+#if IS_ENABLED(CONFIG_IPV6)
+		} else if (family == AF_INET6) {
+			pingv6_ops.ipv6_icmp_error(sk, skb, err, 0,
+						   info, (u8 *)icmph);
+#endif
+		}
 	}
 	sk->sk_err = err;
 	sk->sk_error_report(sk);
 out:
 	sock_put(sk);
 }
+EXPORT_SYMBOL_GPL(ping_err);
 
 /*
- *	Copy and checksum an ICMP Echo packet from user space into a buffer.
+ *	Copy and checksum an ICMP Echo packet from user space into a buffer
+ *	starting from the payload.
  */
 
-struct pingfakehdr {
-	struct icmphdr icmph;
-	struct iovec *iov;
-	__wsum wcheck;
-};
-
-static int ping_getfrag(void *from, char *to,
-			int offset, int fraglen, int odd, struct sk_buff *skb)
+int ping_getfrag(void *from, char *to,
+		 int offset, int fraglen, int odd, struct sk_buff *skb)
 {
 	struct pingfakehdr *pfh = (struct pingfakehdr *)from;
 
@@ -425,20 +588,33 @@
 			    pfh->iov, 0, fraglen - sizeof(struct icmphdr),
 			    &pfh->wcheck))
 			return -EFAULT;
+	} else if (offset < sizeof(struct icmphdr)) {
+			BUG();
+	} else {
+		if (csum_partial_copy_fromiovecend
+				(to, pfh->iov, offset - sizeof(struct icmphdr),
+				 fraglen, &pfh->wcheck))
+			return -EFAULT;
+	}
 
-		return 0;
+#if IS_ENABLED(CONFIG_IPV6)
+	/* For IPv6, checksum each skb as we go along, as expected by
+	 * icmpv6_push_pending_frames. For IPv4, accumulate the checksum in
+	 * wcheck, it will be finalized in ping_v4_push_pending_frames.
+	 */
+	if (pfh->family == AF_INET6) {
+		skb->csum = pfh->wcheck;
+		skb->ip_summed = CHECKSUM_NONE;
+		pfh->wcheck = 0;
 	}
-	if (offset < sizeof(struct icmphdr))
-		BUG();
-	if (csum_partial_copy_fromiovecend
-			(to, pfh->iov, offset - sizeof(struct icmphdr),
-			 fraglen, &pfh->wcheck))
-		return -EFAULT;
+#endif
+
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ping_getfrag);
 
-static int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,
-				    struct flowi4 *fl4)
+static int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,
+				       struct flowi4 *fl4)
 {
 	struct sk_buff *skb = skb_peek(&sk->sk_write_queue);
 
@@ -450,24 +626,9 @@
 	return ip_push_pending_frames(sk, fl4);
 }
 
-static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-			size_t len)
-{
-	struct net *net = sock_net(sk);
-	struct flowi4 fl4;
-	struct inet_sock *inet = inet_sk(sk);
-	struct ipcm_cookie ipc;
-	struct icmphdr user_icmph;
-	struct pingfakehdr pfh;
-	struct rtable *rt = NULL;
-	struct ip_options_data opt_copy;
-	int free = 0;
-	__be32 saddr, daddr, faddr;
-	u8  tos;
-	int err;
-
-	pr_debug("ping_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->inet_num);
-
+int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,
+			void *user_icmph, size_t icmph_len) {
+	u8 type, code;
 
 	if (len > 0xFFFF)
 		return -EMSGSIZE;
@@ -482,15 +643,53 @@
 
 	/*
 	 *	Fetch the ICMP header provided by the userland.
-	 *	iovec is modified!
+	 *	iovec is modified! The ICMP header is consumed.
 	 */
-
-	if (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,
-			     sizeof(struct icmphdr)))
+	if (memcpy_fromiovec(user_icmph, msg->msg_iov, icmph_len))
 		return -EFAULT;
-	if (!ping_supported(user_icmph.type, user_icmph.code))
+
+	if (family == AF_INET) {
+		type = ((struct icmphdr *) user_icmph)->type;
+		code = ((struct icmphdr *) user_icmph)->code;
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (family == AF_INET6) {
+		type = ((struct icmp6hdr *) user_icmph)->icmp6_type;
+		code = ((struct icmp6hdr *) user_icmph)->icmp6_code;
+#endif
+	} else {
+		BUG();
+	}
+
+	if (!ping_supported(family, type, code))
 		return -EINVAL;
 
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ping_common_sendmsg);
+
+int ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		    size_t len)
+{
+	struct net *net = sock_net(sk);
+	struct flowi4 fl4;
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipcm_cookie ipc;
+	struct icmphdr user_icmph;
+	struct pingfakehdr pfh;
+	struct rtable *rt = NULL;
+	struct ip_options_data opt_copy;
+	int free = 0;
+	__be32 saddr, daddr, faddr;
+	u8  tos;
+	int err;
+
+	pr_debug("ping_v4_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->inet_num);
+
+	err = ping_common_sendmsg(AF_INET, msg, len, &user_icmph,
+				  sizeof(user_icmph));
+	if (err)
+		return err;
+
 	/*
 	 *	Get and verify the address.
 	 */
@@ -595,13 +794,14 @@
 	pfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;
 	pfh.iov = msg->msg_iov;
 	pfh.wcheck = 0;
+	pfh.family = AF_INET;
 
 	err = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,
 			0, &ipc, &rt, msg->msg_flags);
 	if (err)
 		ip_flush_pending_frames(sk);
 	else
-		err = ping_push_pending_frames(sk, &pfh, &fl4);
+		err = ping_v4_push_pending_frames(sk, &pfh, &fl4);
 	release_sock(sk);
 
 out:
@@ -622,11 +822,13 @@
 	goto out;
 }
 
-static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-			size_t len, int noblock, int flags, int *addr_len)
+int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_sock *isk = inet_sk(sk);
-	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
+	int family = sk->sk_family;
+	struct sockaddr_in *sin;
+	struct sockaddr_in6 *sin6;
 	struct sk_buff *skb;
 	int copied, err;
 
@@ -636,11 +838,22 @@
 	if (flags & MSG_OOB)
 		goto out;
 
-	if (addr_len)
-		*addr_len = sizeof(*sin);
+	if (addr_len) {
+		if (family == AF_INET)
+			*addr_len = sizeof(*sin);
+		else if (family == AF_INET6 && addr_len)
+			*addr_len = sizeof(*sin6);
+	}
 
-	if (flags & MSG_ERRQUEUE)
-		return ip_recv_error(sk, msg, len);
+	if (flags & MSG_ERRQUEUE) {
+		if (family == AF_INET) {
+			return ip_recv_error(sk, msg, len);
+#if IS_ENABLED(CONFIG_IPV6)
+		} else if (family == AF_INET6) {
+			return pingv6_ops.ipv6_recv_error(sk, msg, len);
+#endif
+		}
+	}
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
@@ -659,15 +872,44 @@
 
 	sock_recv_timestamp(msg, sk, skb);
 
-	/* Copy the address. */
-	if (sin) {
-		sin->sin_family = AF_INET;
-		sin->sin_port = 0 /* skb->h.uh->source */;
-		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	/* Copy the address and add cmsg data. */
+	if (family == AF_INET) {
+		sin = (struct sockaddr_in *) msg->msg_name;
+		if (sin) {
+			sin->sin_family = AF_INET;
+			sin->sin_port = 0 /* skb->h.uh->source */;
+			sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		}
+
+		if (isk->cmsg_flags)
+			ip_cmsg_recv(msg, skb);
+
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (family == AF_INET6) {
+		struct ipv6_pinfo *np = inet6_sk(sk);
+		struct ipv6hdr *ip6 = ipv6_hdr(skb);
+		sin6 = (struct sockaddr_in6 *) msg->msg_name;
+
+		if (sin6) {
+			sin6->sin6_family = AF_INET6;
+			sin6->sin6_port = 0;
+			sin6->sin6_addr = ip6->saddr;
+			sin6->sin6_flowinfo = 0;
+			if (np->sndflow)
+				sin6->sin6_flowinfo = ip6_flowinfo(ip6);
+			sin6->sin6_scope_id =
+				ipv6_iface_scope_id(&sin6->sin6_addr,
+						    IP6CB(skb)->iif);
+		}
+
+		if (inet6_sk(sk)->rxopt.all)
+			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);
+#endif
+	} else {
+		BUG();
 	}
-	if (isk->cmsg_flags)
-		ip_cmsg_recv(msg, skb);
+
 	err = copied;
 
 done:
@@ -676,8 +918,9 @@
 	pr_debug("ping_recvmsg -> %d\n", err);
 	return err;
 }
+EXPORT_SYMBOL_GPL(ping_recvmsg);
 
-static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
+int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	pr_debug("ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\n",
 		 inet_sk(sk), inet_sk(sk)->inet_num, skb);
@@ -688,6 +931,7 @@
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ping_queue_rcv_skb);
 
 
 /*
@@ -698,10 +942,7 @@
 {
 	struct sock *sk;
 	struct net *net = dev_net(skb->dev);
-	struct iphdr *iph = ip_hdr(skb);
 	struct icmphdr *icmph = icmp_hdr(skb);
-	__be32 saddr = iph->saddr;
-	__be32 daddr = iph->daddr;
 
 	/* We assume the packet has already been checked by icmp_rcv */
 
@@ -711,8 +952,7 @@
 	/* Push ICMP header back */
 	skb_push(skb, skb->data - (u8 *)icmph);
 
-	sk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),
-			    skb->dev->ifindex);
+	sk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));
 	if (sk != NULL) {
 		pr_debug("rcv on socket %p\n", sk);
 		ping_queue_rcv_skb(sk, skb_get(skb));
@@ -723,6 +963,7 @@
 
 	/* We're called from icmp_rcv(). kfree_skb() is done there. */
 }
+EXPORT_SYMBOL_GPL(ping_rcv);
 
 struct proto ping_prot = {
 	.name =		"PING",
@@ -733,14 +974,14 @@
 	.disconnect =	udp_disconnect,
 	.setsockopt =	ip_setsockopt,
 	.getsockopt =	ip_getsockopt,
-	.sendmsg =	ping_sendmsg,
+	.sendmsg =	ping_v4_sendmsg,
 	.recvmsg =	ping_recvmsg,
 	.bind =		ping_bind,
 	.backlog_rcv =	ping_queue_rcv_skb,
 	.release_cb =	ip4_datagram_release_cb,
-	.hash =		ping_v4_hash,
-	.unhash =	ping_v4_unhash,
-	.get_port =	ping_v4_get_port,
+	.hash =		ping_hash,
+	.unhash =	ping_unhash,
+	.get_port =	ping_get_port,
 	.obj_size =	sizeof(struct inet_sock),
 };
 EXPORT_SYMBOL(ping_prot);
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4: sysfs_net_ipv4.c
diff -ur ./net/ipv4/tcp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/tcp.c
--- ./net/ipv4/tcp.c	2023-04-26 12:56:08.980118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv4/tcp.c	2023-04-23 12:09:24.587363700 +0100
@@ -268,12 +268,16 @@
 #include <linux/crypto.h>
 #include <linux/time.h>
 #include <linux/slab.h>
+#include <linux/uid_stat.h>
 
 #include <net/icmp.h>
 #include <net/inet_common.h>
 #include <net/tcp.h>
 #include <net/xfrm.h>
 #include <net/ip.h>
+#include <net/ip6_route.h>
+#include <net/ipv6.h>
+#include <net/transp_v6.h>
 #include <net/netdma.h>
 #include <net/sock.h>
 
@@ -1225,6 +1229,9 @@
 	if (copied)
 		tcp_push(sk, flags, mss_now, tp->nonagle);
 	release_sock(sk);
+
+	if (copied + copied_syn)
+		uid_stat_tcp_snd(current_uid(), copied + copied_syn);
 	return copied + copied_syn;
 
 do_fault:
@@ -1529,6 +1536,7 @@
 	if (copied > 0) {
 		tcp_recv_skb(sk, seq, &offset);
 		tcp_cleanup_rbuf(sk, copied);
+		uid_stat_tcp_rcv(current_uid(), copied);
 	}
 	return copied;
 }
@@ -1933,6 +1941,9 @@
 	tcp_cleanup_rbuf(sk, copied);
 
 	release_sock(sk);
+
+	if (copied > 0)
+		uid_stat_tcp_rcv(current_uid(), copied);
 	return copied;
 
 out:
@@ -1941,6 +1952,8 @@
 
 recv_urg:
 	err = tcp_recv_urg(sk, msg, len, flags);
+	if (err > 0)
+		uid_stat_tcp_rcv(current_uid(), err);
 	goto out;
 
 recv_sndq:
@@ -3455,3 +3468,107 @@
 
 	tcp_tasklet_init();
 }
+
+static int tcp_is_local(struct net *net, __be32 addr) {
+	struct rtable *rt;
+	struct flowi4 fl4 = { .daddr = addr };
+	rt = ip_route_output_key(net, &fl4);
+	if (IS_ERR_OR_NULL(rt))
+		return 0;
+	return rt->dst.dev && (rt->dst.dev->flags & IFF_LOOPBACK);
+}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+static int tcp_is_local6(struct net *net, struct in6_addr *addr) {
+	struct rt6_info *rt6 = rt6_lookup(net, addr, addr, 0, 0);
+	return rt6 && rt6->dst.dev && (rt6->dst.dev->flags & IFF_LOOPBACK);
+}
+#endif
+
+/*
+ * tcp_nuke_addr - destroy all sockets on the given local address
+ * if local address is the unspecified address (0.0.0.0 or ::), destroy all
+ * sockets with local addresses that are not configured.
+ */
+int tcp_nuke_addr(struct net *net, struct sockaddr *addr)
+{
+	int family = addr->sa_family;
+	unsigned int bucket;
+
+	struct in_addr *in;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	struct in6_addr *in6;
+#endif
+	if (family == AF_INET) {
+		in = &((struct sockaddr_in *)addr)->sin_addr;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	} else if (family == AF_INET6) {
+		in6 = &((struct sockaddr_in6 *)addr)->sin6_addr;
+#endif
+	} else {
+		return -EAFNOSUPPORT;
+	}
+
+	for (bucket = 0; bucket < tcp_hashinfo.ehash_mask; bucket++) {
+		struct hlist_nulls_node *node;
+		struct sock *sk;
+		spinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, bucket);
+
+restart:
+		spin_lock_bh(lock);
+		sk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[bucket].chain) {
+			struct inet_sock *inet = inet_sk(sk);
+
+			if (sysctl_ip_dynaddr && sk->sk_state == TCP_SYN_SENT)
+				continue;
+			if (sock_flag(sk, SOCK_DEAD))
+				continue;
+
+			if (family == AF_INET) {
+				__be32 s4 = inet->inet_rcv_saddr;
+				if (s4 == LOOPBACK4_IPV6)
+					continue;
+
+				if (in->s_addr != s4 &&
+				    !(in->s_addr == INADDR_ANY &&
+				      !tcp_is_local(net, s4)))
+					continue;
+			}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+			if (family == AF_INET6) {
+				struct in6_addr *s6;
+				if (!inet->pinet6)
+					continue;
+
+				s6 = &inet->pinet6->rcv_saddr;
+				if (ipv6_addr_type(s6) == IPV6_ADDR_MAPPED)
+					continue;
+
+				if (!ipv6_addr_equal(in6, s6) &&
+				    !(ipv6_addr_equal(in6, &in6addr_any) &&
+				      !tcp_is_local6(net, s6)))
+				continue;
+			}
+#endif
+
+			sock_hold(sk);
+			spin_unlock_bh(lock);
+
+			local_bh_disable();
+			bh_lock_sock(sk);
+			sk->sk_err = ETIMEDOUT;
+			sk->sk_error_report(sk);
+
+			tcp_done(sk);
+			bh_unlock_sock(sk);
+			local_bh_enable();
+			sock_put(sk);
+
+			goto restart;
+		}
+		spin_unlock_bh(lock);
+	}
+
+	return 0;
+}
diff -ur ./net/ipv6/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/Makefile
--- ./net/ipv6/Makefile	2023-04-26 12:56:08.990118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/Makefile	2023-04-23 12:09:25.300439900 +0100
@@ -7,7 +7,7 @@
 ipv6-objs :=	af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
 		addrlabel.o \
 		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o udplite.o \
-		raw.o icmp.o mcast.o reassembly.o tcp_ipv6.o \
+		raw.o icmp.o mcast.o reassembly.o tcp_ipv6.o ping.o \
 		exthdrs.o datagram.o ip6_flowlabel.o inet6_connection_sock.o
 
 ipv6-offload :=	ip6_offload.o tcpv6_offload.o udp_offload.o exthdrs_offload.o
diff -ur ./net/ipv6/af_inet6.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/af_inet6.c
--- ./net/ipv6/af_inet6.c	2023-04-26 12:56:08.990118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/af_inet6.c	2023-04-23 12:09:25.378060300 +0100
@@ -49,6 +49,7 @@
 #include <net/udp.h>
 #include <net/udplite.h>
 #include <net/tcp.h>
+#include <net/ping.h>
 #include <net/protocol.h>
 #include <net/inet_common.h>
 #include <net/route.h>
@@ -62,6 +63,20 @@
 #include <asm/uaccess.h>
 #include <linux/mroute6.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
+
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
 MODULE_LICENSE("GPL");
@@ -108,6 +123,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (sock->type != SOCK_RAW &&
 	    sock->type != SOCK_DGRAM &&
 	    !inet_ehash_secret)
@@ -159,8 +177,7 @@
 	}
 
 	err = -EPERM;
-	if (sock->type == SOCK_RAW && !kern &&
-	    !ns_capable(net->user_ns, CAP_NET_RAW))
+	if (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))
 		goto out_rcu_unlock;
 
 	sock->ops = answer->ops;
@@ -477,6 +494,21 @@
 }
 EXPORT_SYMBOL(inet6_getname);
 
+int inet6_killaddr_ioctl(struct net *net, void __user *arg) {
+	struct in6_ifreq ireq;
+	struct sockaddr_in6 sin6;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EACCES;
+
+	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
+		return -EFAULT;
+
+	sin6.sin6_family = AF_INET6;
+	sin6.sin6_addr = ireq.ifr6_addr;
+	return tcp_nuke_addr(net, (struct sockaddr *) &sin6);
+}
+
 int inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
 {
 	struct sock *sk = sock->sk;
@@ -500,6 +532,8 @@
 		return addrconf_del_ifaddr(net, (void __user *) arg);
 	case SIOCSIFDSTADDR:
 		return addrconf_set_dstaddr(net, (void __user *) arg);
+	case SIOCKILLADDR:
+		return inet6_killaddr_ioctl(net, (void __user *) arg);
 	default:
 		if (!sk->sk_prot->ioctl)
 			return -ENOIOCTLCMD;
@@ -840,6 +874,9 @@
 	if (err)
 		goto out_unregister_udplite_proto;
 
+	err = proto_register(&pingv6_prot, 1);
+	if (err)
+		goto out_unregister_ping_proto;
 
 	/* We MUST register RAW sockets before we create the ICMP6,
 	 * IGMP6, or NDISC control sockets.
@@ -930,6 +967,10 @@
 	if (err)
 		goto ipv6_packet_fail;
 
+	err = pingv6_init();
+	if (err)
+		goto pingv6_fail;
+
 #ifdef CONFIG_SYSCTL
 	err = ipv6_sysctl_register();
 	if (err)
@@ -942,6 +983,8 @@
 sysctl_fail:
 	ipv6_packet_cleanup();
 #endif
+pingv6_fail:
+	pingv6_exit();
 ipv6_packet_fail:
 	tcpv6_exit();
 tcpv6_fail:
@@ -985,6 +1028,8 @@
 	rtnl_unregister_all(PF_INET6);
 out_sock_register_fail:
 	rawv6_exit();
+out_unregister_ping_proto:
+	proto_unregister(&pingv6_prot);
 out_unregister_raw_proto:
 	proto_unregister(&rawv6_prot);
 out_unregister_udplite_proto:
diff -ur ./net/ipv6/exthdrs_core.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/exthdrs_core.c
--- ./net/ipv6/exthdrs_core.c	2023-04-26 12:56:08.990118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/exthdrs_core.c	2023-04-23 12:09:25.460570300 +0100
@@ -166,15 +166,15 @@
  * to explore inner IPv6 header, eg. ICMPv6 error messages.
  *
  * If target header is found, its offset is set in *offset and return protocol
- * number. Otherwise, return -1.
+ * number. Otherwise, return -ENOENT or -EBADMSG.
  *
  * If the first fragment doesn't contain the final protocol header or
  * NEXTHDR_NONE it is considered invalid.
  *
  * Note that non-1st fragment is special case that "the protocol number
  * of last header" is "next header" field in Fragment header. In this case,
- * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
- * isn't NULL.
+ * *offset is meaningless. If fragoff is not NULL, the fragment offset is
+ * stored in *fragoff; if it is NULL, return -EINVAL.
  *
  * if flags is not NULL and it's a fragment, then the frag flag
  * IP6_FH_F_FRAG will be set. If it's an AH header, the
@@ -253,9 +253,12 @@
 				if (target < 0 &&
 				    ((!ipv6_ext_hdr(hp->nexthdr)) ||
 				     hp->nexthdr == NEXTHDR_NONE)) {
-					if (fragoff)
+					if (fragoff) {
 						*fragoff = _frag_off;
-					return hp->nexthdr;
+						return hp->nexthdr;
+					} else {
+						return -EINVAL;
+					}
 				}
 				return -ENOENT;
 			}
diff -ur ./net/ipv6/icmp.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/icmp.c
--- ./net/ipv6/icmp.c	2023-04-26 12:56:08.990118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/icmp.c	2023-04-23 12:09:25.536740700 +0100
@@ -57,6 +57,7 @@
 
 #include <net/ipv6.h>
 #include <net/ip6_checksum.h>
+#include <net/ping.h>
 #include <net/protocol.h>
 #include <net/raw.h>
 #include <net/rawv6.h>
@@ -84,12 +85,18 @@
 static void icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		       u8 type, u8 code, int offset, __be32 info)
 {
+	/* icmpv6_notify checks 8 bytes can be pulled, icmp6hdr is 8 bytes */
+	struct icmp6hdr *icmp6 = (struct icmp6hdr *) (skb->data + offset);
 	struct net *net = dev_net(skb->dev);
 
 	if (type == ICMPV6_PKT_TOOBIG)
 		ip6_update_pmtu(skb, net, info, 0, 0);
 	else if (type == NDISC_REDIRECT)
 		ip6_redirect(skb, net, 0, 0);
+
+	if (!(type & ICMPV6_INFOMSG_MASK))
+		if (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)
+			ping_err(skb, offset, info);
 }
 
 static int icmpv6_rcv(struct sk_buff *skb);
@@ -224,7 +231,8 @@
 	return (*op & 0xC0) == 0x80;
 }
 
-static int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6, struct icmp6hdr *thdr, int len)
+int icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
+			       struct icmp6hdr *thdr, int len)
 {
 	struct sk_buff *skb;
 	struct icmp6hdr *icmp6h;
@@ -307,8 +315,8 @@
 static inline void mip6_addr_swap(struct sk_buff *skb) {}
 #endif
 
-static struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,
-					     struct sock *sk, struct flowi6 *fl6)
+struct dst_entry *icmpv6_route_lookup(struct net *net, struct sk_buff *skb,
+				      struct sock *sk, struct flowi6 *fl6)
 {
 	struct dst_entry *dst, *dst2;
 	struct flowi6 fl2;
@@ -697,7 +705,8 @@
 		skb->csum = ~csum_unfold(csum_ipv6_magic(saddr, daddr, skb->len,
 					     IPPROTO_ICMPV6, 0));
 		if (__skb_checksum_complete(skb)) {
-			LIMIT_NETDEBUG(KERN_DEBUG "ICMPv6 checksum failed [%pI6 > %pI6]\n",
+			LIMIT_NETDEBUG(KERN_DEBUG
+				       "ICMPv6 checksum failed [%pI6c > %pI6c]\n",
 				       saddr, daddr);
 			goto csum_error;
 		}
@@ -718,7 +727,7 @@
 		break;
 
 	case ICMPV6_ECHO_REPLY:
-		/* we couldn't care less */
+		ping_rcv(skb);
 		break;
 
 	case ICMPV6_PKT_TOOBIG:
diff -ur ./net/ipv6/netfilter/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/netfilter/Kconfig
--- ./net/ipv6/netfilter/Kconfig	2023-04-26 12:26:27.260130688 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/netfilter/Kconfig	2023-04-23 12:09:25.938775900 +0100
@@ -153,6 +153,18 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP6_NF_TARGET_REJECT_SKERR
+	bool "Force socket error when rejecting with icmp*"
+	depends on IP6_NF_TARGET_REJECT
+	default n
+	help
+          This option enables turning a "--reject-with icmp*" into a matching
+          socket error also.
+	  The REJECT target normally allows sending an ICMP message. But it
+          leaves the local socket unaware of any ingress rejects.
+
+	  If unsure, say N.
+
 config IP6_NF_MANGLE
 	tristate "Packet mangling"
 	default m if NETFILTER_ADVANCED=n
diff -ur ./net/ipv6/netfilter/ip6t_REJECT.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/netfilter/ip6t_REJECT.c
--- ./net/ipv6/netfilter/ip6t_REJECT.c	2023-04-26 12:26:27.260130688 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6/netfilter/ip6t_REJECT.c	2023-04-23 12:09:26.017896500 +0100
@@ -180,6 +180,15 @@
 		skb_in->dev = net->loopback_dev;
 
 	icmpv6_send(skb_in, ICMPV6_DEST_UNREACH, code, 0);
+#ifdef CONFIG_IP6_NF_TARGET_REJECT_SKERR
+	if (skb_in->sk) {
+		icmpv6_err_convert(ICMPV6_DEST_UNREACH, code,
+				   &skb_in->sk->sk_err);
+		skb_in->sk->sk_error_report(skb_in->sk);
+		pr_debug("ip6t_REJECT: sk_err=%d for skb=%p sk=%p\n",
+			skb_in->sk->sk_err, skb_in, skb_in->sk);
+	}
+#endif
 }
 
 static unsigned int
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/ipv6: ping.c
diff -ur ./net/netfilter/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/Kconfig
--- ./net/netfilter/Kconfig	2023-04-26 12:26:27.540130553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/Kconfig	2023-04-23 12:09:30.502161400 +0100
@@ -1089,6 +1089,8 @@
 	based on who created the socket: the user or group. It is also
 	possible to check whether a socket actually exists.
 
+	Conflicts with '"quota, tag, uid" match'
+
 config NETFILTER_XT_MATCH_POLICY
 	tristate 'IPsec "policy" match support'
 	depends on XFRM
@@ -1122,6 +1124,22 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_QTAGUID
+	bool '"quota, tag, owner" match and stats support'
+        depends on NETFILTER_XT_MATCH_SOCKET
+	depends on NETFILTER_XT_MATCH_OWNER=n
+	help
+	  This option replaces the `owner' match. In addition to matching
+	  on uid, it keeps stats based on a tag assigned to a socket.
+	  The full tag is comprised of a UID and an accounting tag.
+	  The tags are assignable to sockets from user space (e.g. a download
+	  manager can assign the socket to another UID for accounting).
+	  Stats and control are done via /proc/net/xt_qtaguid/.
+	  It replaces owner as it takes the same arguments, but should
+	  really be recognized by the iptables tool.
+
+	  If unsure, say `N'.
+
 config NETFILTER_XT_MATCH_QUOTA
 	tristate '"quota" match support'
 	depends on NETFILTER_ADVANCED
@@ -1132,6 +1150,30 @@
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"quota2" match support'
+	depends on NETFILTER_ADVANCED
+	help
+	  This option adds a `quota2' match, which allows to match on a
+	  byte counter correctly and not per CPU.
+	  It allows naming the quotas.
+	  This is based on http://xtables-addons.git.sourceforge.net
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
+
+config NETFILTER_XT_MATCH_QUOTA2_LOG
+	bool '"quota2" Netfilter LOG support'
+	depends on NETFILTER_XT_MATCH_QUOTA2
+	depends on IP_NF_TARGET_ULOG=n    # not yes, not module, just no
+	default n
+	help
+	  This option allows `quota2' to log ONCE when a quota limit
+	  is passed. It logs via NETLINK using the NETLINK_NFLOG family.
+	  It logs similarly to how ipt_ULOG would without data.
+
+	  If unsure, say `N'.
+
 config NETFILTER_XT_MATCH_RATEEST
 	tristate '"rateest" match support'
 	depends on NETFILTER_ADVANCED
diff -ur ./net/netfilter/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/Makefile
--- ./net/netfilter/Makefile	2023-04-26 12:26:27.540130553 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/Makefile	2023-04-23 12:09:30.501504000 +0100
@@ -127,7 +127,9 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_PHYSDEV) += xt_physdev.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_PKTTYPE) += xt_pkttype.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_POLICY) += xt_policy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QTAGUID) += xt_qtaguid_print.o xt_qtaguid.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA) += xt_quota.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_RATEEST) += xt_rateest.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_REALM) += xt_realm.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_RECENT) += xt_recent.o
Only in ./net/netfilter: xt_DSCP.c
Only in ./net/netfilter: xt_HL.c
diff -ur ./net/netfilter/xt_IDLETIMER.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/xt_IDLETIMER.c
--- ./net/netfilter/xt_IDLETIMER.c	2023-04-26 12:26:27.690130480 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/xt_IDLETIMER.c	2023-04-23 12:09:32.661359800 +0100
@@ -5,6 +5,7 @@
  * After timer expires a kevent will be sent.
  *
  * Copyright (C) 2004, 2010 Nokia Corporation
+ *
  * Written by Timo Teras <ext-timo.teras@nokia.com>
  *
  * Converted to x_tables and reworked for upstream inclusion
@@ -38,8 +39,10 @@
 #include <linux/netfilter/xt_IDLETIMER.h>
 #include <linux/kdev_t.h>
 #include <linux/kobject.h>
+#include <linux/skbuff.h>
 #include <linux/workqueue.h>
 #include <linux/sysfs.h>
+#include <net/net_namespace.h>
 
 struct idletimer_tg_attr {
 	struct attribute attr;
@@ -56,6 +59,8 @@
 	struct idletimer_tg_attr attr;
 
 	unsigned int refcnt;
+	bool send_nl_msg;
+	bool active;
 };
 
 static LIST_HEAD(idletimer_tg_list);
@@ -63,6 +68,32 @@
 
 static struct kobject *idletimer_tg_kobj;
 
+static void notify_netlink_uevent(const char *label, struct idletimer_tg *timer)
+{
+	char label_msg[NLMSG_MAX_SIZE];
+	char state_msg[NLMSG_MAX_SIZE];
+	char *envp[] = { label_msg, state_msg, NULL };
+	int res;
+
+	res = snprintf(label_msg, NLMSG_MAX_SIZE, "LABEL=%s",
+		       label);
+	if (NLMSG_MAX_SIZE <= res) {
+		pr_err("message too long (%d)", res);
+		return;
+	}
+	res = snprintf(state_msg, NLMSG_MAX_SIZE, "STATE=%s",
+		       timer->active ? "active" : "inactive");
+	if (NLMSG_MAX_SIZE <= res) {
+		pr_err("message too long (%d)", res);
+		return;
+	}
+	pr_debug("putting nlmsg: <%s> <%s>\n", label_msg, state_msg);
+	kobject_uevent_env(idletimer_tg_kobj, KOBJ_CHANGE, envp);
+	return;
+
+
+}
+
 static
 struct idletimer_tg *__idletimer_tg_find_by_label(const char *label)
 {
@@ -83,6 +114,7 @@
 {
 	struct idletimer_tg *timer;
 	unsigned long expires = 0;
+	unsigned long now = jiffies;
 
 	mutex_lock(&list_mutex);
 
@@ -92,11 +124,15 @@
 
 	mutex_unlock(&list_mutex);
 
-	if (time_after(expires, jiffies))
+	if (time_after(expires, now))
 		return sprintf(buf, "%u\n",
-			       jiffies_to_msecs(expires - jiffies) / 1000);
+			       jiffies_to_msecs(expires - now) / 1000);
 
-	return sprintf(buf, "0\n");
+	if (timer->send_nl_msg)
+		return sprintf(buf, "0 %d\n",
+			jiffies_to_msecs(now - expires) / 1000);
+	else
+		return sprintf(buf, "0\n");
 }
 
 static void idletimer_tg_work(struct work_struct *work)
@@ -105,6 +141,9 @@
 						  work);
 
 	sysfs_notify(idletimer_tg_kobj, NULL, timer->attr.attr.name);
+
+	if (timer->send_nl_msg)
+		notify_netlink_uevent(timer->attr.attr.name, timer);
 }
 
 static void idletimer_tg_expired(unsigned long data)
@@ -113,6 +152,7 @@
 
 	pr_debug("timer %s expired\n", timer->attr.attr.name);
 
+	timer->active = false;
 	schedule_work(&timer->work);
 }
 
@@ -145,6 +185,8 @@
 	setup_timer(&info->timer->timer, idletimer_tg_expired,
 		    (unsigned long) info->timer);
 	info->timer->refcnt = 1;
+	info->timer->send_nl_msg = (info->send_nl_msg == 0) ? false : true;
+	info->timer->active = true;
 
 	mod_timer(&info->timer->timer,
 		  msecs_to_jiffies(info->timeout * 1000) + jiffies);
@@ -168,14 +210,24 @@
 					 const struct xt_action_param *par)
 {
 	const struct idletimer_tg_info *info = par->targinfo;
+	unsigned long now = jiffies;
 
 	pr_debug("resetting timer %s, timeout period %u\n",
 		 info->label, info->timeout);
 
 	BUG_ON(!info->timer);
 
+	info->timer->active = true;
+
+	if (time_before(info->timer->timer.expires, now)) {
+		schedule_work(&info->timer->work);
+		pr_debug("Starting timer %s (Expired, Jiffies): %lu, %lu\n",
+			 info->label, info->timer->timer.expires, now);
+	}
+
+	/* TODO: Avoid modifying timers on each packet */
 	mod_timer(&info->timer->timer,
-		  msecs_to_jiffies(info->timeout * 1000) + jiffies);
+		  msecs_to_jiffies(info->timeout * 1000) + now);
 
 	return XT_CONTINUE;
 }
@@ -184,8 +236,9 @@
 {
 	struct idletimer_tg_info *info = par->targinfo;
 	int ret;
+	unsigned long now = jiffies;
 
-	pr_debug("checkentry targinfo%s\n", info->label);
+	pr_debug("checkentry targinfo %s\n", info->label);
 
 	if (info->timeout == 0) {
 		pr_debug("timeout value is zero\n");
@@ -204,8 +257,16 @@
 	info->timer = __idletimer_tg_find_by_label(info->label);
 	if (info->timer) {
 		info->timer->refcnt++;
+		info->timer->active = true;
+
+		if (time_before(info->timer->timer.expires, now)) {
+			schedule_work(&info->timer->work);
+			pr_debug("Starting Checkentry timer (Expired, Jiffies): %lu, %lu\n",
+				info->timer->timer.expires, now);
+		}
+
 		mod_timer(&info->timer->timer,
-			  msecs_to_jiffies(info->timeout * 1000) + jiffies);
+			  msecs_to_jiffies(info->timeout * 1000) + now);
 
 		pr_debug("increased refcnt of timer %s to %u\n",
 			 info->label, info->timer->refcnt);
@@ -219,6 +280,7 @@
 	}
 
 	mutex_unlock(&list_mutex);
+
 	return 0;
 }
 
@@ -240,7 +302,7 @@
 		kfree(info->timer);
 	} else {
 		pr_debug("decreased refcnt of timer %s to %u\n",
-			 info->label, info->timer->refcnt);
+		info->label, info->timer->refcnt);
 	}
 
 	mutex_unlock(&list_mutex);
@@ -248,6 +310,7 @@
 
 static struct xt_target idletimer_tg __read_mostly = {
 	.name		= "IDLETIMER",
+	.revision	= 1,
 	.family		= NFPROTO_UNSPEC,
 	.target		= idletimer_tg_target,
 	.targetsize     = sizeof(struct idletimer_tg_info),
@@ -313,3 +376,4 @@
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("ipt_IDLETIMER");
 MODULE_ALIAS("ip6t_IDLETIMER");
+MODULE_ALIAS("arpt_IDLETIMER");
Only in ./net/netfilter: xt_RATEEST.c
Only in ./net/netfilter: xt_TCPMSS.c
Only in ./net/netfilter: xt_dscp.c
Only in ./net/netfilter: xt_hl.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter: xt_qtaguid.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter: xt_qtaguid_internal.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter: xt_qtaguid_print.c
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter: xt_qtaguid_print.h
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter: xt_quota2.c
Only in ./net/netfilter: xt_rateest.c
diff -ur ./net/netfilter/xt_socket.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/xt_socket.c
--- ./net/netfilter/xt_socket.c	2023-04-26 12:56:09.050118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/netfilter/xt_socket.c	2023-04-23 12:09:33.779027900 +0100
@@ -35,7 +35,7 @@
 #include <net/netfilter/nf_conntrack.h>
 #endif
 
-static void
+void
 xt_socket_put_sk(struct sock *sk)
 {
 	if (sk->sk_state == TCP_TIME_WAIT)
@@ -43,6 +43,7 @@
 	else
 		sock_put(sk);
 }
+EXPORT_SYMBOL(xt_socket_put_sk);
 
 static int
 extract_icmp4_fields(const struct sk_buff *skb,
@@ -101,9 +102,8 @@
 	return 0;
 }
 
-static bool
-socket_match(const struct sk_buff *skb, struct xt_action_param *par,
-	     const struct xt_socket_mtinfo1 *info)
+struct sock*
+xt_socket_get4_sk(const struct sk_buff *skb, struct xt_action_param *par)
 {
 	const struct iphdr *iph = ip_hdr(skb);
 	struct udphdr _hdr, *hp = NULL;
@@ -120,7 +120,7 @@
 		hp = skb_header_pointer(skb, ip_hdrlen(skb),
 					sizeof(_hdr), &_hdr);
 		if (hp == NULL)
-			return false;
+			return NULL;
 
 		protocol = iph->protocol;
 		saddr = iph->saddr;
@@ -131,9 +131,9 @@
 	} else if (iph->protocol == IPPROTO_ICMP) {
 		if (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,
 					&sport, &dport))
-			return false;
+			return NULL;
 	} else {
-		return false;
+		return NULL;
 	}
 
 #ifdef XT_SOCKET_HAVE_CONNTRACK
@@ -157,6 +157,23 @@
 
 	sk = nf_tproxy_get_sock_v4(dev_net(skb->dev), protocol,
 				   saddr, daddr, sport, dport, par->in, NFT_LOOKUP_ANY);
+
+	pr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",
+		 protocol, &saddr, ntohs(sport),
+		 &daddr, ntohs(dport),
+		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
+
+	return sk;
+}
+EXPORT_SYMBOL(xt_socket_get4_sk);
+
+static bool
+socket_match(const struct sk_buff *skb, struct xt_action_param *par,
+	     const struct xt_socket_mtinfo1 *info)
+{
+	struct sock *sk;
+
+	sk = xt_socket_get4_sk(skb, par);
 	if (sk != NULL) {
 		bool wildcard;
 		bool transparent = true;
@@ -179,11 +196,6 @@
 			sk = NULL;
 	}
 
-	pr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",
-		 protocol, &saddr, ntohs(sport),
-		 &daddr, ntohs(dport),
-		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
-
 	return (sk != NULL);
 }
 
@@ -255,8 +267,8 @@
 	return 0;
 }
 
-static bool
-socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
+struct sock*
+xt_socket_get6_sk(const struct sk_buff *skb, struct xt_action_param *par)
 {
 	struct ipv6hdr *iph = ipv6_hdr(skb);
 	struct udphdr _hdr, *hp = NULL;
@@ -264,7 +276,6 @@
 	struct in6_addr *daddr = NULL, *saddr = NULL;
 	__be16 uninitialized_var(dport), uninitialized_var(sport);
 	int thoff = 0, uninitialized_var(tproto);
-	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;
 
 	tproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);
 	if (tproto < 0) {
@@ -276,7 +287,7 @@
 		hp = skb_header_pointer(skb, thoff,
 					sizeof(_hdr), &_hdr);
 		if (hp == NULL)
-			return false;
+			return NULL;
 
 		saddr = &iph->saddr;
 		sport = hp->source;
@@ -286,13 +297,30 @@
 	} else if (tproto == IPPROTO_ICMPV6) {
 		if (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,
 					 &sport, &dport))
-			return false;
+			return NULL;
 	} else {
-		return false;
+		return NULL;
 	}
 
 	sk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,
 				   saddr, daddr, sport, dport, par->in, NFT_LOOKUP_ANY);
+	pr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "
+		 "(orig %pI6:%hu) sock %p\n",
+		 tproto, saddr, ntohs(sport),
+		 daddr, ntohs(dport),
+		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
+	return sk;
+}
+EXPORT_SYMBOL(xt_socket_get6_sk);
+
+static bool
+socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct sock *sk;
+	const struct xt_socket_mtinfo1 *info;
+
+	info = (struct xt_socket_mtinfo1 *) par->matchinfo;
+	sk = xt_socket_get6_sk(skb, par);
 	if (sk != NULL) {
 		bool wildcard;
 		bool transparent = true;
@@ -315,12 +343,6 @@
 			sk = NULL;
 	}
 
-	pr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "
-		 "(orig %pI6:%hu) sock %p\n",
-		 tproto, saddr, ntohs(sport),
-		 daddr, ntohs(dport),
-		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
-
 	return (sk != NULL);
 }
 #endif
diff -ur ./net/rfkill/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/rfkill/Kconfig
--- ./net/rfkill/Kconfig	2023-04-26 12:26:27.850130403 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/rfkill/Kconfig	2023-04-23 12:09:36.576514700 +0100
@@ -10,6 +10,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rfkill.
 
+config RFKILL_PM
+	bool "Power off on suspend"
+	depends on RFKILL && PM
+	default y
+
 # LED trigger support
 config RFKILL_LEDS
 	bool
diff -ur ./net/sunrpc/sched.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/sunrpc/sched.c
--- ./net/sunrpc/sched.c	2023-04-26 12:56:09.110118952 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/sunrpc/sched.c	2023-04-23 12:09:39.778573700 +0100
@@ -254,7 +254,7 @@
 {
 	if (fatal_signal_pending(current))
 		return -ERESTARTSYS;
-	freezable_schedule();
+	freezable_schedule_unsafe();
 	return 0;
 }
 
diff -ur ./net/unix/af_unix.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/unix/af_unix.c
--- ./net/unix/af_unix.c	2023-04-26 12:56:09.120118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/unix/af_unix.c	2023-04-23 12:09:41.138443700 +0100
@@ -114,6 +114,7 @@
 #include <linux/mount.h>
 #include <net/checksum.h>
 #include <linux/security.h>
+#include <linux/freezer.h>
 
 struct hlist_head unix_socket_table[2 * UNIX_HASH_SIZE];
 EXPORT_SYMBOL_GPL(unix_socket_table);
@@ -1879,7 +1880,7 @@
 
 		set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 		unix_state_unlock(sk);
-		timeo = schedule_timeout(timeo);
+		timeo = freezable_schedule_timeout(timeo);
 		unix_state_lock(sk);
 		clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 	}
diff -ur ./net/wireless/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/Kconfig
--- ./net/wireless/Kconfig	2023-04-26 12:26:28.140130262 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/Kconfig	2023-04-23 12:09:41.779999300 +0100
@@ -166,3 +166,14 @@
 	  from lib80211.
 
 	  If unsure, say N.
+
+config CFG80211_ALLOW_RECONNECT
+	bool "Allow reconnect while already connected"
+	depends on CFG80211
+	default n
+	help
+	  cfg80211 stack doesn't allow to connect if you are already
+	  connected. This option allows to make a connection in this case.
+
+	  Select this option ONLY for wlan drivers that are specifically
+	  built for such purposes.
diff -ur ./net/wireless/scan.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/scan.c
--- ./net/wireless/scan.c	2023-04-26 12:56:09.130118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/scan.c	2023-04-23 12:09:42.338398600 +0100
@@ -55,7 +55,7 @@
  * also linked into the probe response struct.
  */
 
-#define IEEE80211_SCAN_RESULT_EXPIRE	(30 * HZ)
+#define IEEE80211_SCAN_RESULT_EXPIRE	(3 * HZ)
 
 static void bss_free(struct cfg80211_internal_bss *bss)
 {
diff -ur ./net/wireless/sme.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/sme.c
--- ./net/wireless/sme.c	2023-04-26 12:56:09.130118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/net/wireless/sme.c	2023-04-23 12:09:42.337902900 +0100
@@ -707,8 +707,10 @@
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
 		return;
 
+#ifndef CONFIG_CFG80211_ALLOW_RECONNECT
 	if (wdev->sme_state != CFG80211_SME_CONNECTED)
 		return;
+#endif
 
 	if (wdev->current_bss) {
 		cfg80211_unhold_bss(wdev->current_bss);
@@ -785,10 +787,14 @@
 
 	ASSERT_WDEV_LOCK(wdev);
 
+#ifndef CONFIG_CFG80211_ALLOW_RECONNECT
 	if (wdev->sme_state != CFG80211_SME_IDLE)
 		return -EALREADY;
 
 	if (WARN_ON(wdev->connect_keys)) {
+#else
+	if (wdev->connect_keys) {
+#endif
 		kfree(wdev->connect_keys);
 		wdev->connect_keys = NULL;
 	}
diff -ur ./scripts/Makefile.lib /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/Makefile.lib
--- ./scripts/Makefile.lib	2023-04-26 12:56:09.140118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/Makefile.lib	2023-04-23 12:09:44.258637200 +0100
@@ -273,6 +273,12 @@
 
 dtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)
 
+# cat
+# ---------------------------------------------------------------------------
+# Concatentate multiple files together
+quiet_cmd_cat = CAT     $@
+cmd_cat = (cat $(filter-out FORCE,$^) > $@) || (rm -f $@; false)
+
 # Bzip2
 # ---------------------------------------------------------------------------
 
diff -ur ./scripts/kconfig/confdata.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/confdata.c
--- ./scripts/kconfig/confdata.c	2023-04-26 12:56:09.150118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/confdata.c	2023-04-23 12:09:47.223491800 +0100
@@ -1083,7 +1083,7 @@
 	csym->flags &= ~(SYMBOL_VALID);
 }
 
-static void set_all_choice_values(struct symbol *csym)
+void set_all_choice_values(struct symbol *csym)
 {
 	struct property *prop;
 	struct symbol *sym;
@@ -1100,7 +1100,7 @@
 	}
 	csym->flags |= SYMBOL_DEF_USER;
 	/* clear VALID to get value calculated */
-	csym->flags &= ~(SYMBOL_VALID);
+	csym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);
 }
 
 void conf_set_all_new_symbols(enum conf_def_mode mode)
@@ -1202,6 +1202,14 @@
 	 * selected in a choice block and we set it to yes,
 	 * and the rest to no.
 	 */
+	if (mode != def_random) {
+		for_all_symbols(i, csym) {
+			if ((sym_is_choice(csym) && !sym_has_value(csym)) ||
+			    sym_is_choice_value(csym))
+				csym->flags |= SYMBOL_NEED_SET_CHOICE_VALUES;
+		}
+	}
+
 	for_all_symbols(i, csym) {
 		if (sym_has_value(csym) || !sym_is_choice(csym))
 			continue;
@@ -1209,7 +1217,5 @@
 		sym_calc_value(csym);
 		if (mode == def_random)
 			randomize_choice_values(csym);
-		else
-			set_all_choice_values(csym);
 	}
 }
diff -ur ./scripts/kconfig/expr.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/expr.h
--- ./scripts/kconfig/expr.h	2023-04-26 12:56:09.150118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/expr.h	2023-04-23 12:09:47.222388800 +0100
@@ -106,6 +106,9 @@
 #define SYMBOL_DEF3       0x40000  /* symbol.def[S_DEF_3] is valid */
 #define SYMBOL_DEF4       0x80000  /* symbol.def[S_DEF_4] is valid */
 
+/* choice values need to be set before calculating this symbol value */
+#define SYMBOL_NEED_SET_CHOICE_VALUES  0x100000
+
 #define SYMBOL_MAXLENGTH	256
 #define SYMBOL_HASHSIZE		9973
 
diff -ur ./scripts/kconfig/lkc.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/lkc.h
--- ./scripts/kconfig/lkc.h	2023-04-26 12:56:09.160118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/lkc.h	2023-04-23 12:09:47.377254100 +0100
@@ -87,6 +87,7 @@
 void sym_set_change_count(int count);
 void sym_add_change_count(int count);
 void conf_set_all_new_symbols(enum conf_def_mode mode);
+void set_all_choice_values(struct symbol *csym);
 
 struct conf_printer {
 	void (*print_symbol)(FILE *, struct symbol *, const char *, void *);
diff -ur ./scripts/kconfig/symbol.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/symbol.c
--- ./scripts/kconfig/symbol.c	2023-04-26 12:56:09.160118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/kconfig/symbol.c	2023-04-23 12:09:47.779002700 +0100
@@ -300,6 +300,14 @@
 
 	if (sym->flags & SYMBOL_VALID)
 		return;
+
+	if (sym_is_choice_value(sym) &&
+	    sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES) {
+		sym->flags &= ~SYMBOL_NEED_SET_CHOICE_VALUES;
+		prop = sym_get_choice_prop(sym);
+		sym_calc_value(prop_get_symbol(prop));
+	}
+
 	sym->flags |= SYMBOL_VALID;
 
 	oldval = sym->curr;
@@ -425,6 +433,9 @@
 
 	if (sym->flags & SYMBOL_AUTO)
 		sym->flags &= ~SYMBOL_WRITE;
+
+	if (sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES)
+		set_all_choice_values(sym);
 }
 
 void sym_clear_all_valid(void)
diff -ur ./scripts/setlocalversion /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/setlocalversion
--- ./scripts/setlocalversion	2023-04-26 12:56:09.170118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/scripts/setlocalversion	2023-04-23 12:09:49.064323700 +0100
@@ -52,7 +52,6 @@
 			# If only the short version is requested, don't bother
 			# running further git commands
 			if $short; then
-				echo "+"
 				return
 			fi
 			# If we are past a tagged commit (like
diff -ur ./security/capability.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/capability.c
--- ./security/capability.c	2023-04-26 12:56:09.180118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/capability.c	2023-04-23 12:09:50.017677900 +0100
@@ -12,6 +12,26 @@
 
 #include <linux/security.h>
 
+static int cap_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static int cap_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static int cap_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static int cap_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return 0;
+}
+
 static int cap_syslog(int type)
 {
 	return 0;
@@ -903,6 +923,10 @@
 
 void __init security_fixup_ops(struct security_operations *ops)
 {
+	set_to_cap_if_null(ops, binder_set_context_mgr);
+	set_to_cap_if_null(ops, binder_transaction);
+	set_to_cap_if_null(ops, binder_transfer_binder);
+	set_to_cap_if_null(ops, binder_transfer_file);
 	set_to_cap_if_null(ops, ptrace_access_check);
 	set_to_cap_if_null(ops, ptrace_traceme);
 	set_to_cap_if_null(ops, capget);
diff -ur ./security/commoncap.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/commoncap.c
--- ./security/commoncap.c	2023-04-26 12:26:28.470130102 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/commoncap.c	2023-04-23 12:09:50.017198600 +0100
@@ -31,6 +31,10 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -78,6 +82,13 @@
 {
 	struct user_namespace *ns = targ_ns;
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
+		return 0;
+	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
+		return 0;
+#endif
+
 	/* See if cred has the capability in the target user namespace
 	 * by examining the target user namespace and all of the target
 	 * user namespace's parents.
diff -ur ./security/security.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/security.c
--- ./security/security.c	2023-04-26 12:56:09.180118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/security.c	2023-04-23 12:09:51.300963300 +0100
@@ -134,6 +134,26 @@
 
 /* Security operations */
 
+int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return security_ops->binder_set_context_mgr(mgr);
+}
+
+int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return security_ops->binder_transaction(from, to);
+}
+
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return security_ops->binder_transfer_binder(from, to);
+}
+
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return security_ops->binder_transfer_file(from, to, file);
+}
+
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
 #ifdef CONFIG_SECURITY_YAMA_STACKED
diff -ur ./security/selinux/hooks.c /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/selinux/hooks.c
--- ./security/selinux/hooks.c	2023-04-26 12:56:09.180118951 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/selinux/hooks.c	2023-04-23 12:09:51.455678900 +0100
@@ -1821,6 +1821,67 @@
 
 /* Hook functions begin here. */
 
+static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+{
+	u32 mysid = current_sid();
+	u32 mgrsid = task_sid(mgr);
+
+	return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER, BINDER__SET_CONTEXT_MGR, NULL);
+}
+
+static int selinux_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	u32 mysid = current_sid();
+	u32 fromsid = task_sid(from);
+	u32 tosid = task_sid(to);
+	int rc;
+
+	if (mysid != fromsid) {
+		rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER, BINDER__IMPERSONATE, NULL);
+		if (rc)
+			return rc;
+	}
+
+	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL, NULL);
+}
+
+static int selinux_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	u32 fromsid = task_sid(from);
+	u32 tosid = task_sid(to);
+	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER, NULL);
+}
+
+static int selinux_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	u32 sid = task_sid(to);
+	struct file_security_struct *fsec = file->f_security;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	struct common_audit_data ad;
+	struct selinux_audit_data sad = {0,};
+	int rc;
+
+	ad.type = LSM_AUDIT_DATA_PATH;
+	ad.u.path = file->f_path;
+	ad.selinux_audit_data = &sad;
+
+	if (sid != fsec->sid) {
+		rc = avc_has_perm(sid, fsec->sid,
+				  SECCLASS_FD,
+				  FD__USE,
+				  &ad);
+		if (rc)
+			return rc;
+	}
+
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+
+	return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+			    &ad);
+}
+
 static int selinux_ptrace_access_check(struct task_struct *child,
 				     unsigned int mode)
 {
@@ -5532,6 +5593,11 @@
 static struct security_operations selinux_ops = {
 	.name =				"selinux",
 
+	.binder_set_context_mgr =	selinux_binder_set_context_mgr,
+	.binder_transaction =		selinux_binder_transaction,
+	.binder_transfer_binder =	selinux_binder_transfer_binder,
+	.binder_transfer_file =		selinux_binder_transfer_file,
+
 	.ptrace_access_check =		selinux_ptrace_access_check,
 	.ptrace_traceme =		selinux_ptrace_traceme,
 	.capget =			selinux_capget,
diff -ur ./security/selinux/include/classmap.h /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/selinux/include/classmap.h
--- ./security/selinux/include/classmap.h	2023-04-26 12:26:28.520130078 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/security/selinux/include/classmap.h	2023-04-23 12:09:51.539039700 +0100
@@ -151,5 +151,6 @@
 	{ "kernel_service", { "use_as_override", "create_files_as", NULL } },
 	{ "tun_socket",
 	  { COMMON_SOCK_PERMS, "attach_queue", NULL } },
+	{ "binder", { "impersonate", "call", "set_context_mgr", "transfer", NULL } },
 	{ NULL }
   };
diff -ur ./sound/oss/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/oss/Kconfig
--- ./sound/oss/Kconfig	2023-04-26 12:26:28.800129942 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/oss/Kconfig	2023-04-23 12:09:59.935958300 +0100
@@ -247,6 +247,8 @@
 	  and Pinnacle). Larger values reduce the chance of data overruns at
 	  the expense of overall latency. If unsure, use the default.
 
+source "sound/oss/jzsound/Kconfig"
+
 menuconfig SOUND_OSS
 	tristate "OSS sound modules"
 	depends on ISA_DMA_API && VIRT_TO_BUS
diff -ur ./sound/oss/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/oss/Makefile
--- ./sound/oss/Makefile	2023-04-26 12:26:28.800129942 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/oss/Makefile	2023-04-23 12:09:59.935353600 +0100
@@ -26,6 +26,7 @@
 obj-$(CONFIG_SOUND_MSNDPIN)	+= msnd.o msnd_pinnacle.o
 obj-$(CONFIG_SOUND_VWSND)	+= vwsnd.o
 obj-$(CONFIG_SOUND_BCM_CS4297A)	+= swarm_cs4297a.o
+obj-$(CONFIG_SOUND_OSS_XBURST)  += jzsound/
 
 obj-$(CONFIG_DMASOUND)		+= dmasound/
 
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/oss: jzsound
diff -ur ./sound/soc/Kconfig /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/soc/Kconfig
--- ./sound/soc/Kconfig	2023-04-26 12:56:09.300118997 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/soc/Kconfig	2023-04-23 12:10:11.475430100 +0100
@@ -54,6 +54,7 @@
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
+source "sound/soc/ingenic/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/sound/soc: ingenic
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools: dmic-test
diff -ur ./tools/lib/lk/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools/lib/lk/Makefile
--- ./tools/lib/lk/Makefile	2023-04-26 12:56:09.380119028 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools/lib/lk/Makefile	2023-04-23 12:10:25.616825500 +0100
@@ -13,7 +13,7 @@
 CFLAGS = -ggdb3 -Wall -Wextra -std=gnu99 -Werror -O6 -D_FORTIFY_SOURCE=2 $(EXTRA_WARNINGS) $(EXTRA_CFLAGS) -fPIC
 EXTLIBS = -lpthread -lrt -lelf -lm
 ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS) -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
-ALL_LDFLAGS = $(LDFLAGS)
+ALL_LDFLAGS = $(LDFLAGS) -static
 
 RM = rm -f
 
diff -ur ./tools/perf/Makefile /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools/perf/Makefile
--- ./tools/perf/Makefile	2023-04-26 12:56:09.390119032 +0100
+++ /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools/perf/Makefile	2023-04-23 12:10:26.733690100 +0100
@@ -149,7 +149,7 @@
 endif
 lib = lib
 
-export prefix bindir sharedir sysconfdir
+export AR CC prefix bindir sharedir sysconfdir
 
 RM = rm -f
 MKDIR = mkdir
@@ -224,7 +224,7 @@
 	-I../lib/ \
 	-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE
 
-BASIC_LDFLAGS =
+BASIC_LDFLAGS = -static
 
 ifeq ($(call try-cc,$(SOURCE_BIONIC),$(CFLAGS),bionic),y)
 	BIONIC := 1
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools/perf: mk_mips_static_binaray
Only in /mnt/shared/projects/teacup/Ingenic-SDK-T31-1.1.1-20200508/opensource/kernel/tools: wakeup-test
